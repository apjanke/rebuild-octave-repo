# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1223341565 14400
#      Mon Oct 06 21:06:05 2008 -0400
# Node ID 73d6b71788c066dcf57a810fee00b467ec1d0a60
# Parent  8e8afefe9466b9fe0b75a394888029be293d3020
use case-insensitive comparison for graphics properties; misc style fixes

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,21 @@
+2008-10-06  John W. Eaton  <jwe@octave.org>
+
+	* plot/__add_datasource__.m, plot/__axes_limits__.m,
+	plot/__bar__.m, plot/__bars__.m, plot/__contour__.m,
+	plot/__go_draw_axes__.m, plot/__go_draw_figure__.m,
+	plot/__patch__.m, plot/__quiver__.m, plot/__scatter__.m,
+	plot/__stem__.m, plot/ancestor.m, plot/axis.m, plot/box.m,
+	plot/caxis.m, plot/close.m, plot/colorbar.m, plot/fill.m,
+	plot/findobj.m, plot/grid.m, plot/hidden.m, plot/hold.m,
+	plot/ishold.m, plot/legend.m, plot/linkprop.m, plot/orient.m,
+	plot/plotmatrix.m, plot/shading.m: Use case-insensitive comparison
+	for properties.  Misc style fixes.
+
 2008-10-06  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/orient.m: Figure handle must be scalar.
 	* plot/hold.m: Axis handle must be scalar.
 	* plot/axes.m: Axis handle must be scalar.
 	* plot/__plt_get_axis_arg__.m: Handle must be scalar.
 
 	* miscellaneous/delete.m: Permit a vector of handles to be deleted.
diff --git a/scripts/plot/__add_datasource__.m b/scripts/plot/__add_datasource__.m
--- a/scripts/plot/__add_datasource__.m
+++ b/scripts/plot/__add_datasource__.m
@@ -31,22 +31,22 @@ function newargs = __add_datasource__ (f
   for i = 1 : numel (data)
     addproperty (strcat (data{i}, "datasource"), h, "string", "");
   endfor
 
   i = 0;
   newargs = {};
   while (i < numel (varargin))
     arg = varargin{++i};
-    if (i != numel(varargin) && ischar (arg) &&
-    length (arg > 1) && strcmpi (arg(2:end), "datasource"))
+    if (i != numel(varargin) && ischar (arg)
+	&& length (arg) > 1 && strcmpi (arg(2:end), "datasource"))
       arg = tolower (arg);
       val = varargin{++i};
       if (ischar (val))
-    set (h, arg, val);
+	set (h, arg, val);
       else
-    error ("%s: expecting data source to be a string", fcn);
+	error ("%s: expecting data source to be a string", fcn);
       endif
     else
       newargs{end + 1} = arg;
     endif
   endwhile
 endfunction
diff --git a/scripts/plot/__axes_limits__.m b/scripts/plot/__axes_limits__.m
--- a/scripts/plot/__axes_limits__.m
+++ b/scripts/plot/__axes_limits__.m
@@ -27,25 +27,23 @@ function retval = __axes_limits__ (fcn, 
   [h, varargin, nargin] = __plt_get_axis_arg__ (fcn, varargin{:});
 
   if (nargin == 0)
     retval = get (h, fcn);
   else
     arg = varargin{1};
 
     if (ischar (arg))
-      arg = tolower (arg);
-      if (strcmp ("mode", arg))
-
+      if (strcmpi (arg, "mode"))
 	retval = get (h, fcnmode);
-      elseif (strcmp ("auto", arg) ||  strcmp ("manual", arg))  
+      elseif (strcmpi (arg, "auto") ||  strcmpi (arg, "manual"))
 	set (h, fcnmode, arg);
       endif
     else
       if (!isnumeric (arg) && any (size(arg(:)) != [2, 1]))
 	error ("%s: argument must be a 2 element vector", fcn);
       else
-	set (h, fcn, arg (:));
+	set (h, fcn, arg(:));
       endif
     endif
   endif
 
 endfunction
diff --git a/scripts/plot/__bar__.m b/scripts/plot/__bar__.m
--- a/scripts/plot/__bar__.m
+++ b/scripts/plot/__bar__.m
@@ -62,20 +62,20 @@ function varargout = __bar__ (vertical, 
     endif
     x = [1:size(y,1)]';
     idx = 2;
   endif
       
   newargs = {};
   have_line_spec = false;
   while (idx <= nargin - 2)
-    if (ischar (varargin{idx}) && strcmp (varargin{idx}, "grouped"))
+    if (ischar (varargin{idx}) && strcmpi (varargin{idx}, "grouped"))
       group = true;
       idx++;
-    elseif (ischar (varargin{idx}) && strcmp (varargin{idx}, "stacked"))
+    elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "stacked"))
       group = false;
       idx++;
     else
       if ((ischar (varargin{idx}) || iscell (varargin{idx}))
 	  && ! have_line_spec)
 	[linespec, valid] = __pltopt__ (func, varargin{idx}, false);
 	if (valid)
 	  have_line_spec = true;
@@ -83,18 +83,19 @@ function varargout = __bar__ (vertical, 
 	  idx++;
 	  continue;
 	endif
       endif
       if (isscalar(varargin{idx}))
 	width = varargin{idx++};
       elseif (idx == nargin - 2)
 	newargs = [newargs,varargin(idx++)];
-      elseif (ischar (varargin{idx}) && strcmp (tolower (varargin{idx}), "basevalue") &&
-          isscalar (varargin{idx+1}))
+      elseif (ischar (varargin{idx})
+	      && strcmpi (varargin{idx}, "basevalue")
+	      && isscalar (varargin{idx+1}))
         bv = varargin{idx+1};
         idx += 2;
       else
 	newargs = [newargs,varargin(idx:idx+1)];
 	idx += 2;
       endif
     endif
   endwhile
diff --git a/scripts/plot/__bars__.m b/scripts/plot/__bars__.m
--- a/scripts/plot/__bars__.m
+++ b/scripts/plot/__bars__.m
@@ -143,20 +143,20 @@ function update_baseline (h, d)
   ydata = get (h, "ydata")(1);
 
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
     obj = get (kids (i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline") 
 	&& obj.baseline == h)
       ## Only alter if changed to avoid recursion of the listener functions
-      if (! strcmp (get (kids(i), "showbaseline"), visible))
+      if (! strcmpi (get (kids(i), "showbaseline"), visible))
 	set (kids (i), "showbaseline", visible);
       endif
-      if (! strcmp (get (kids(i), "basevalue"), visible))
+      if (! strcmpi (get (kids(i), "basevalue"), visible))
 	set (kids (i), "basevalue", ydata);
       endif
     endif
   endfor
 endfunction
 
 function show_baseline (h, d)
   persistent recursion = false;
@@ -182,17 +182,17 @@ endfunction
 function move_baseline (h, d)
   b0 = get (h, "basevalue");
   bl = get (h, "baseline");
 
   if (get (bl, "ydata") != [b0, b0])
     set (bl, "ydata", [b0, b0]);
   endif
 
-  if (strcmp (get (h, "barlayout"), "grouped"))
+  if (strcmpi (get (h, "barlayout"), "grouped"))
     update_data (h, d);
   endif
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
   set (kids, "edgecolor", get (h, "edgecolor"), 
        "linewidth", get (h, "linewidth"),
@@ -216,17 +216,17 @@ function update_data (h, d)
       for hh = hlist(:)'
 	ytmp = get (hh, "ydata");
 	y = [y ytmp(:)];
       endfor
 
       [xb, yb] = bar (x, y, get (h, "barwidth"), get (h, "barlayout"),
 		      "basevalue", get (h, "basevalue"));
       ny = columns (y);
-      vert = strcmp (get (h, "horizontal"), "off");
+      vert = strcmpi (get (h, "horizontal"), "off");
 
       for i = 1:ny
 	hp = get (hlist(i), "children");
 	if (vert)
 	  set (hp, "xdata", xb(:,:,i), "ydata", yb(:,:,i));
 	else
 	  set (hp, "xdata", yb(:,:,i), "ydata", xb(:,:,i));
 	endif
@@ -250,20 +250,20 @@ function update_group (h, d)
       horizontal = get (h, "horizontal");
 
       ## To prevent recursion, only change if modified
       for hh = hlist(:)'
 	if (hh != h)
 	  if (get (hh, "barwidth") != barwidth)
 	    set (hh, "barwidth", barwidth);
 	  endif
-	  if (! strcmp (get (hh, "barlayout"), barlayout))
+	  if (! strcmpi (get (hh, "barlayout"), barlayout))
 	    set (hh, "barlayout", barlayout);
 	  endif
-	  if (! strcmp (get (hh, "horizontal"), horizontal))
+	  if (! strcmpi (get (hh, "horizontal"), horizontal))
 	    set (hh, "horizontal", horizontal);
 	  endif
 	endif
       endfor
       update_data (h, d);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
diff --git a/scripts/plot/__contour__.m b/scripts/plot/__contour__.m
--- a/scripts/plot/__contour__.m
+++ b/scripts/plot/__contour__.m
@@ -49,22 +49,22 @@ function [c, h] = __contour__ (varargin)
       opts{end+1} = varargin{i};
       varargin(i) = [];
     else
       i++;
     endif
   endwhile
 
   if (ischar (z))
-    if (strcmp (z, "none"))
+    if (strcmpi (z, "none"))
       z = NaN;
-    elseif (strcmp (z, "base"))
+    elseif (strcmpi (z, "base"))
       z = varargin{3};
       z = 2 * (min (z(:)) - max (z(:)));
-    elseif (! strcmp (z, "level"))
+    elseif (! strcmpi (z, "level"))
       error ("unrecognized z argument");
     endif
   endif
 
   [c, lev] = contourc (varargin{3:end});
 
   ## Decode contourc output format.
   i1 = 1;
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -306,17 +306,17 @@ function __go_draw_axes__ (h, plot_strea
     ximg_data = {};
     ximg_data_idx = 0;
 
     while (! isempty (kids))
 
       obj = get (kids(1));
       kids = kids(2:end);
 
-      if (strcmp (obj.visible, "off"))
+      if (strcmpi (obj.visible, "off"))
 	continue;
       endif
 
       ## Check for facecolor interpolation for surfaces.
       doing_interp_color = ...
          isfield (obj, "facecolor") && strncmp (obj.facecolor, "interp", 6);
 
       switch (obj.type)
@@ -1553,19 +1553,19 @@ function [str, f, s] = __maybe_munge_tex
     s = 10;
     fnt = f;
     it = false;
     bld = false;
   endif
 
   str = getfield (obj, fld);
   if (enhanced)
-    if (strcmp (obj.interpreter, "tex"))
+    if (strcmpi (obj.interpreter, "tex"))
       str = __tex2enhanced__ (str, fnt, it, bld);
-    elseif (strcmp (obj.interpreter, "latex"))
+    elseif (strcmpi (obj.interpreter, "latex"))
       if (! warned_latex)
 	warning ("latex text objects not supported");
 	warned_latex = true;
       endif
     endif
   endif
 endfunction
 
@@ -1611,35 +1611,35 @@ function str = __tex2enhanced__ (str, fn
 	bld = true;
 	if (it)
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
 			str(2(i) + 3:end));
         else
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bold ', 
 			str(s(i) + 3:end));
         endif
-      elseif (strcmp (f, "color"))
+      elseif (strcmpi (f, "color"))
 	## FIXME Ignore \color but remove trailing {} block as well
 	d = strfind(str(e(i) + 1:end),'}');
         if (isempty (d))
 	  warning ('syntax error in \color argument');
 	else
 	  str = cstrcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
         endif
-      elseif(strcmp (f, "fontname"))
+      elseif(strcmpi (f, "fontname"))
 	b1 = strfind(str(e(i) + 1:end),'{');
 	b2 = strfind(str(e(i) + 1:end),'}');
         if (isempty(b1) || isempty(b2))
 	  warning ('syntax error in \fontname argument');
 	else
           str = cstrcat (str(1:s(i) - 1), '/', 
 			str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
 			str(e(i) + b2(1) + 1:end));
         endif
-      elseif(strcmp (f, "fontsize"))
+      elseif(strcmpi (f, "fontsize"))
 	b1 = strfind(str(e(i) + 1:end),'{');
 	b2 = strfind(str(e(i) + 1:end),'}');
         if (isempty(b1) || isempty(b2))
 	  warning ('syntax error in \fontname argument');
 	else
           str = cstrcat (str(1:s(i) - 1), '/=', 
 			str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
 			str(e(i) + b2(1) + 1:end));
diff --git a/scripts/plot/__go_draw_figure__.m b/scripts/plot/__go_draw_figure__.m
--- a/scripts/plot/__go_draw_figure__.m
+++ b/scripts/plot/__go_draw_figure__.m
@@ -33,17 +33,17 @@ function __go_draw_figure__ (f, plot_str
       if (nkids > 0)
 	axes_count = 0;
 	for i = 1:nkids
 	  obj = __get__ (kids(i));
 	  switch (obj.type)
 	    case "axes"
 	      axes_count++;
 	      ## Force multiplot with a colorbar to ensure colorbar on the page
-	      if (!strcmp (obj.__colorbar__, "none"))
+	      if (!strcmpi (obj.__colorbar__, "none"))
 		axes_count++;
 	      endif
 	  endswitch
 	endfor
 
 	fputs (plot_stream, "\nreset;\n");
 	fputs (plot_stream, "set autoscale fix;\n");
 
diff --git a/scripts/plot/__patch__.m b/scripts/plot/__patch__.m
--- a/scripts/plot/__patch__.m
+++ b/scripts/plot/__patch__.m
@@ -48,32 +48,32 @@ function [h, fail] = __patch__ (p, varar
 
     if (nargin > 3 && ndims (varargin{3}) == 2 && ndims (x) == 2
 	&& size_equal(x, varargin{3}) && !ischar(varargin{3}))
       z = varargin{3};
       have_z = true;
       iarg++;
     endif
   elseif (ischar (varargin{1})
-	  && (strcmp (tolower (varargin{1}), "faces")
-	      || strcmp (tolower (varargin{1}), "vertices")))
+	  && (strcmpi (varargin{1}, "faces")
+	      || strcmpi (varargin{1}, "vertices")))
     if (! isnumeric (varargin{2}))
       fail = true;
       return;
     endif
     
-    if (strcmp (tolower (varargin{1}), "faces"))
+    if (strcmpi (varargin{1}, "faces"))
       faces = varargin{2};
-      if (strcmp (tolower (varargin{3}), "vertices"))
+      if (strcmpi (varargin{3}, "vertices"))
 	vert = varargin{4};
 	have_faces = true;
       endif
-    elseif (strcmp (tolower (varargin{3}), "vertices"))
+    elseif (strcmpi (varargin{3}, "vertices"))
       vert = varargin{2};
-      if (strcmp (tolower (varargin{3}), "faces"))
+      if (strcmpi (varargin{3}, "faces"))
 	faces = varargin{4};
 	have_faces = true;
       endif
     endif
     if (!have_faces)
       fail = true;
       return;
     else
diff --git a/scripts/plot/__quiver__.m b/scripts/plot/__quiver__.m
--- a/scripts/plot/__quiver__.m
+++ b/scripts/plot/__quiver__.m
@@ -73,17 +73,17 @@ function hg = __quiver__ (varargin)
     endif
   endif
 
   have_filled = false;
   have_line_spec = false;
   args = {};
   while (ioff <= nargin)
     arg = varargin{ioff++};
-    if (ischar (arg) && strncmp (tolower (arg), "filled", 6))
+    if (ischar (arg) && strncmpi (arg, "filled", 6))
       have_filled = true;
     elseif ((ischar (arg) || iscell (arg))
 	    && ! have_line_spec)
       [linespec, valid] = __pltopt__ ("quiver", arg, false);
       if (valid)
 	have_line_spec = true;
 	if (strncmp (linespec.linestyle, "none", 4))
 	  linespec.linestyle = "-";
@@ -319,17 +319,17 @@ function update_data (h, d)
   kids = get (h, "children");
 
   if (isempty (z) || isempty (w))
     is3d = false;
   else
     is3d = true;
   endif
 
-  if (strcmp (get (h, "autoscale"), "on") && s != 0)
+  if (strcmpi (get (h, "autoscale"), "on") && s != 0)
     ## Scale the arrows to fit in the grid
     dx = (max(x(:)) - min(x(:))) ./ size (x, 2);
     dy = (max(y(:)) - min(y(:))) ./ size (y, 1);
     if (is3d)
       ## What should this be divided by? The below seems right
       dz = (max(z(:)) - min(z(:))) ./ max (size (z));
       len = max (sqrt (u(:).^2 + dy(:).^2) + dz(:).^2);
     else
@@ -395,17 +395,17 @@ function update_props (h, d)
   kids = get (h, "children");
 
   set (kids(1), "color", get (h, "color"), 
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"));
   set (kids(2), "color", get (h, "color"), 
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"));
-  if (strcmp (get (h, "showarrowhead"), "on"))
+  if (strcmpi (get (h, "showarrowhead"), "on"))
     set (kids (2), "visible", "on");
   else
     set (kids (2), "visible", "off");
   endif
   set (kids(3), "color", get (h, "color"), 
        "marker", get (h, "marker"),
        "markerfacecolor", get (h, "markerfacecolor"),
        "markersize", get (h, "markersize"));
diff --git a/scripts/plot/__scatter__.m b/scripts/plot/__scatter__.m
--- a/scripts/plot/__scatter__.m
+++ b/scripts/plot/__scatter__.m
@@ -72,17 +72,17 @@ function h = __scatter__ (varargin)
 
   newargs = {};
   filled = false;
   have_marker = false;
   marker = "o";
   iarg = firstnonnumeric;
   while (iarg <= nargin)
     arg = varargin{iarg++};
-    if (ischar (arg) && strncmp (tolower (arg), "filled", 6))
+    if (ischar (arg) && strncmpi (arg, "filled", 6))
       filled = true;
     elseif ((ischar (arg) || iscell (arg)) && ! have_marker)
       [linespec, valid] = __pltopt__ ("scatter", arg, false);
       if (valid)
 	have_marker = true;
 	marker = linespec.marker;
 	if (strncmp (marker, "none", 4))
 	  marker = "o";
@@ -94,26 +94,26 @@ function h = __scatter__ (varargin)
       newargs{end+1} = arg;
       if (iarg <= nargin)
 	newargs{end+1} = varagin{iarg++};
       endif
     endif
   endwhile
 
   if (ischar (c))
-    h = patch("faces", [1:length(x)].', "vertices", [x, y, z], "facecolor",
-	      "none", "edgecolor", c, "marker", marker, 
-	      "markersize", s, "linestyle", "none");
+    h = patch ("faces", [1:length(x)].', "vertices", [x, y, z], "facecolor",
+	       "none", "edgecolor", c, "marker", marker, 
+	       "markersize", s, "linestyle", "none");
     if (filled)
       set(h, "markerfacecolor", c); 
     endif
   else
-    h = patch("faces", [1:length(x)].', "vertices", [x, y, z], "facecolor",
-	      "none", "edgecolor", "flat", "cdata", c, "marker", marker, 
-	      "markersize", s, "linestyle", "none");
+    h = patch ("faces", [1:length(x)].', "vertices", [x, y, z], "facecolor",
+	       "none", "edgecolor", "flat", "cdata", c, "marker", marker, 
+	       "markersize", s, "linestyle", "none");
     if (filled)
       set(h, "markerfacecolor", "flat"); 
     endif
     ax = get (h, "parent");
     clim = get (ax, "clim");
     if (min(c(:)) < clim(1))
       clim(1) = min(c(:));
       set (ax, "clim", clim);
diff --git a/scripts/plot/__stem__.m b/scripts/plot/__stem__.m
--- a/scripts/plot/__stem__.m
+++ b/scripts/plot/__stem__.m
@@ -164,18 +164,18 @@ function [x, y, z, dofill, lc, ls, mc, m
   else
     caller = "stem";
   endif
 
   ## Remove prop/val pairs from data to consider
   i = 2;
   newargs = {};
   while (i < length (varargin))
-    if (ischar (varargin{i}) && !(strcmpi ("fill", varargin{i}) || 
-				 strcmpi ("filled", varargin{i})))
+    if (ischar (varargin{i}) && !(strcmpi ("fill", varargin{i})
+				  || strcmpi ("filled", varargin{i})))
       newargs{end + 1} = varargin{i};
       newargs{end + 1} = varargin{i + 1};
       nargin = nargin - 2;
       varargin(i:i+1) = [];
     else
       i++;
     endif
   endwhile
@@ -287,24 +287,24 @@ function [x, y, z, dofill, lc, ls, mc, m
 	if (! (ismatrix (x) && ismatrix (y)))
 	  error ("stem: X and Y must be matrices");
 	endif
       endif
     endif # if ischar(varargin{2})
     if (! have_z)
       ## varargin{3} must be char
       ## check for "fill
-      if ((strcmpi ("fill", varargin{3}) || strcmpi ("filled", varargin{3}))
+      if ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
 	  && fill_2)
 	error ("stem: duplicate fill argument");
-      elseif (strcmp("fill", varargin{3}) && linespec_2)
+      elseif (strcmpi ("fill", varargin{3}) && linespec_2)
 	## must be "fill"
 	dofill = 1;
 	fill_2 = 1;
-      elseif ((strcmpi ("fill", varargin{3}) || strcmpi ("filled", varargin{3}))
+      elseif ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
 	  && !linespec_2)
 	## must be "fill"
 	dofill = 1;
 	fill_2 = 1;
       elseif (! linespec_2)
 	## must be linespec
 	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
 	linespec_2 = 1;
@@ -322,69 +322,69 @@ function [x, y, z, dofill, lc, ls, mc, m
       x = varargin{1};
       y = varargin{2};
       if (! (ismatrix (x) && ismatrix (y)))
 	error ("stem: X and Y must be matrices");
       endif
     endif
 
     if (! have_z)
-      if (strcmpi ("fill", varargin{3}) || strcmpi ("filled", varargin{3}))
+      if (strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
 	dofill = 1;
 	fill_2 = 1; # be sure, no second "fill" is in the arguments
       else
 	## must be a linespec
 	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
 	linespec_2 = 1;
       endif
     endif
 
     ## check for "fill" ..
-    if ((strcmpi ("fill", varargin{4}) || strcmpi ("filled", varargin{4}))
+    if ((strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
 	&& fill_2)
       error ("%s: duplicate fill argument", caller);
-    elseif ((strcmpi ("fill", varargin{4}) || strcmpi ("filled", varargin{4}))
+    elseif ((strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
 	&& linespec_2)
       ## must be "fill"
       dofill = 1;
       fill_2 = 1;
-    elseif (!strcmpi ("fill", varargin{4}) && !strcmpi ("filled", varargin{4})
+    elseif (!strcmpi (varargin{4}, "fill") && !strcmpi (varargin{4}, "filled")
 	&& !linespec_2)
       ## must be linespec
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{4});
       linespec_2 = 1;
     endif
   elseif (nargin == 6 && have_z)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
       error ("stem3: X, Y and Z must be matrices");
     endif
 
-    if (strcmpi ("fill", varargin{4}) || strcmpi ("filled", varargin{4}))
+    if (strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
       dofill = 1;
       fill_2 = 1; # be sure, no second "fill" is in the arguments
     else
       ## must be a linespec
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{4});
       linespec_2 = 1;
     endif
 
     ## check for "fill" ..
-    if ((strcmpi ("fill", varargin{5}) || strcmpi ("filled", varargin{5}))
+    if ((strcmpi (varargin{5}, "fill") || strcmpi (varargin{5}, "filled"))
 	&& fill_2)
       error ("stem3: duplicate fill argument");
-    elseif ((strcmpi ("fill", varargin{5}) || strcmpi ("filled", varargin{5}))
+    elseif ((strcmpi (varargin{5}, "fill") || strcmpi (varargin{5}, "filled"))
 	&& linespec_2)
       ## must be "fill"
       dofill = 1;
       fill_2 = 1;
-    elseif (!strcmpi ("fill", varargin{5}) && !strcmpi ("filled", varargin{5})
-	&& !linespec_2)
+    elseif (!strcmpi (varargin{5}, "fill") && !strcmpi (varargin{5}, "filled")
+	    && !linespec_2)
       ## must be linespec
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{5});
       linespec_2 = 1;
     endif
   else
     error ("%s: incorrect number of arguments", caller);
   endif
 
@@ -428,17 +428,17 @@ function [lc, ls, mc, ms] = stem_line_sp
   [lc, ls, mc, ms] = set_default_values ();
   ## Parse the line specifier string.
   cur_props = __pltopt__ ("stem", str, false);
   for i = 1:length(cur_props)
     if (isfield (cur_props(i), "color") && ! isempty (cur_props(i).color)); # means line color
       mc = lc = cur_props(i).color;
     elseif (isfield (cur_props(i), "linestyle"))
       ls = cur_props(i).linestyle;
-    elseif (isfield (cur_props(i), "marker") && ! strcmp (cur_props(i).marker, "none"))
+    elseif (isfield (cur_props(i), "marker") && ! strcmpi (cur_props(i).marker, "none"))
       ms = cur_props(i).marker;
     endif
   endfor
 endfunction
 
 function [lc, ls, mc, ms] = set_default_values ()
   ## set default values
   mc = [];
@@ -466,20 +466,20 @@ function update_baseline (h, d)
   ydata = get (h, "ydata")(1);
 
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
     obj = get (kids (i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline") 
 	&& obj.baseline == h)
       ## Only alter if changed to avoid recursion of the listener functions
-      if (! strcmp (get (kids(i), "showbaseline"), visible))
+      if (! strcmpi (get (kids(i), "showbaseline"), visible))
 	set (kids (i), "showbaseline", visible);
       endif
-      if (! strcmp (get (kids(i), "basevalue"), visible))
+      if (! strcmpi (get (kids(i), "basevalue"), visible))
 	set (kids (i), "basevalue", ydata);
       endif
     endif
   endfor
 endfunction
 
 function show_baseline (h, d)
   set (get (h, "baseline"), "visible", get (h, "showbaseline"));
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -37,17 +37,17 @@ function p = ancestor (h, type, toplevel
   if (nargin == 2 || nargin == 3)
     p = [];
     if (ischar (type))
       type = { type };
     endif
     if (iscellstr (type))
       look_first = true;
       if (nargin == 3)
-        if (ischar (toplevel) && strcmp (toplevel, "toplevel"))
+        if (ischar (toplevel) && strcmpi (toplevel, "toplevel"))
           look_first = false;
         else
           error ("ancestor: third argument must be \"toplevel\"");
         endif
       endif
       while (true)
         if (isempty (h) || ! ishandle (h))
           break;
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -143,87 +143,86 @@ function curr_axis = __axis__ (ca, ax, v
     else
       xlim = get (ca, "xlim");
       ylim = get (ca, "ylim");
       zlim = get (ca, "zlim");
       curr_axis = [xlim, ylim, zlim];
     endif
 
   elseif (ischar (ax))
-    ax = tolower (ax);
     len = length (ax);
 
     ## 'matrix mode' to reverse the y-axis
-    if (strcmp (ax, "ij"))
+    if (strcmpi (ax, "ij"))
       set (ca, "ydir", "reverse");
-    elseif (strcmp (ax, "xy"))
+    elseif (strcmpi (ax, "xy"))
       set (ca, "ydir", "normal");
 
       ## aspect ratio
-    elseif (strcmp (ax, "image"))
+    elseif (strcmpi (ax, "image"))
       set (ca, "dataaspectratio", [1, 1, 1]);
       __do_tight_option__ (ca);
-    elseif (strcmp (ax, "equal") || strcmp (ax, "square"))
+    elseif (strcmpi (ax, "equal") || strcmpi (ax, "square"))
       set (ca, "dataaspectratio", [1, 1, 1]);
-    elseif (strcmp (ax, "normal"))
+    elseif (strcmpi (ax, "normal"))
       set (ca, "dataaspectratiomode", "auto");
 
       ## axis limits
-    elseif (len >= 4 && strcmp (ax(1:4), "auto"))
+    elseif (len >= 4 && strcmpi (ax(1:4), "auto"))
       if (len > 4)
 	if (any (ax == "x"))
 	  set (ca, "xlimmode", "auto");
 	endif
 	if (any (ax == "y"))
 	  set (ca, "ylimmode", "auto");
 	endif
 	if (any (ax == "z"))
 	  set (ca, "zlimmode", "auto");
 	endif
       else
 	set (ca, "xlimmode", "auto", "ylimmode", "auto", "zlimmode", "auto");
       endif
-    elseif (strcmp (ax, "manual"))
+    elseif (strcmpi (ax, "manual"))
       ## fixes the axis limits, like axis(axis) should;
       set (ca, "xlimmode", "manual", "ylimmode", "manual", "zlimmode", "manual");
-    elseif (strcmp (ax, "tight"))
+    elseif (strcmpi (ax, "tight"))
       ## sets the axis limits to the min and max of all data.
       __do_tight_option__ (ca);
 
       ## tic marks
-    elseif (strcmp (ax, "on") || strcmp (ax, "tic"))
+    elseif (strcmpi (ax, "on") || strcmpi (ax, "tic"))
       set (ca, "xtickmode", "auto", "ytickmode", "auto", "ztickmode", "auto");
       set (ca, "xticklabelmode", "auto", "yticklabelmode", "auto",
 	   "zticklabelmode", "auto");
       set (ca, "visible", "on");
-    elseif (strcmp (ax, "off"))
+    elseif (strcmpi (ax, "off"))
       set (ca, "xtick", [], "ytick", [], "ztick", []);
       set (ca, "visible", "off");
-    elseif (len > 3 && strcmp (ax(1:3), "tic"))
+    elseif (len > 3 && strcmpi (ax(1:3), "tic"))
       if (any (ax == "x"))
 	set (ca, "xtickmode", "auto");
       else
 	set (ca, "xtick", []);
       endif
       if (any (ax == "y"))
 	set (ca, "ytickmode", "auto");
       else
 	set (ca, "ytick", []);
       endif
       if (any (ax == "z"))
 	set (ca, "ztickmode", "auto");
       else
 	set (ca, "ztick", []);
       endif
-    elseif (strcmp (ax, "label"))
+    elseif (strcmpi (ax, "label"))
       set (ca, "xticklabelmode", "auto", "yticklabelmode", "auto",
 	   "zticklabelmode", "auto");
-    elseif (strcmp (ax, "nolabel"))
+    elseif (strcmpi (ax, "nolabel"))
       set (ca, "xticklabel", "", "yticklabel", "", "zticklabel", "");
-    elseif (len > 5 && strcmp (ax(1:5), "label"))
+    elseif (len > 5 && strcmpi (ax(1:5), "label"))
       if (any (ax == "x"))
 	set (ca, "xticklabelmode", "auto");
       else
 	set (ca, "xticklabel", "");
       endif
       if (any (ax == "y"))
 	set (ca, "yticklabelmode", "auto");
       else
diff --git a/scripts/plot/box.m b/scripts/plot/box.m
--- a/scripts/plot/box.m
+++ b/scripts/plot/box.m
@@ -33,27 +33,27 @@ function box (varargin)
 
   h = gca ();
 
   box_state = get (h, "box");
 
   nargs = numel (varargin);
 
   if (nargs == 0)
-    if (strcmp (box_state, "on"))
+    if (strcmpi (box_state, "on"))
       box_state = "off";
     else
       box_state = "on";
     endif
   elseif (nargs == 1)
     state = varargin{1};
     if (ischar (state))
-      if (strcmp ("off", state))
+      if (strcmpi (state, "off"))
 	box_state = "off";
-      elseif (strcmp ("on", state))
+      elseif (strcmpi (state, "on"))
 	box_state = "on";
       else
 	print_usage ();
       endif
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -60,20 +60,19 @@ function [cmin, cmax] = __caxis__ (ca, a
 
   if (nargin == 1)
     cmin = get (ca, "clim");
     if (nargout > 1)
       cmax = cmin(2);
       cmin = cmin(1);
     endif
   elseif (ischar (ax))
-    ax = tolower (ax);
-    if (strcmp (ax, "auto"))
+    if (strcmpi (ax, "auto"))
       set (ca, "climmode", "auto");
-    elseif (strcmp (ax, "manual"))
+    elseif (strcmpi (ax, "manual"))
       set (ca, "climmode", "manual");
     endif
   elseif (isvector (ax))
     len = length (ax);
 
     if (len != 2)
       error ("caxis: expecting vector with 2 elements");
     endif
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -38,26 +38,26 @@ function retval = close (arg1, arg2)
   if (nargin == 0)
     ## Close current figure.  Don't use gcf because that will open a new
     ## plot window if one doesn't exist.
     figs = get (0, "currentfigure");
     if (! isempty (figs) && figs == 0)
       figs = [];
     endif
   elseif (nargin == 1)
-    if (ischar (arg1) && strcmp (arg1, "all"))
+    if (ischar (arg1) && strcmpi (arg1, "all"))
       close_all_figures (false);
     elseif (isfigure (arg1))
       figs = arg1;
     else
       error ("close: expecting argument to be \"all\" or a figure handle");
     endif
   elseif (nargin == 2
-	  && ischar (arg1) && strcmp (arg1, "all")
-	  && ischar (arg2) && strcmp (arg2, "hidden"))
+	  && ischar (arg1) && strcmpi (arg1, "all")
+	  && ischar (arg2) && strcmpi (arg2, "hidden"))
     close_all_figures (true);
   else
     print_usage ();
   endif
 
   for h = figs
     __go_execute_callback__ (h, "closerequestfcn");
   endfor
@@ -67,14 +67,14 @@ function retval = close (arg1, arg2)
   endif
 
 endfunction
 
 function close_all_figures (close_hidden_figs)
 
   while (! isempty (fig = get (0, "currentfigure")))
     ## handlevisibility = get (fig, "handlevisibility")
-    ## if (close_hidden_figs || ! strcmp (handlevisibility, "off"))
+    ## if (close_hidden_figs || ! strcmpi (handlevisibility, "off"))
     close (fig);
     ## endif
   endwhile
 
 endfunction
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -46,17 +46,17 @@
 ## as the axes handle on which to add the colorbar.
 ## @end deftypefn
 
 
 ## PKG_ADD: mark_as_command colorbar
 
 function colorbar (varargin)
   
-  if (nargin > 0 && strcmpi(varargin{1}, "peer"))
+  if (nargin > 0 && strcmpi (varargin{1}, "peer"))
     if (nargin > 1)
       ax = varargin{2};
       if (!isscalar (ax) || ! ishandle (ax)
 	  || strcmp (get (ax, "type"), "axes"))
 	error ("colorbar: expecting an axes handle following 'peer'");
       endif
     else
       error ("colorbar: misisng axes handle after 'peer'");
@@ -66,23 +66,22 @@ function colorbar (varargin)
   endif
 
   pos = "eastoutside";
   for i = 1 : length (varargin)
     arg = varargin{i};
     if (length(arg) < 1)
       pos = "eastoutside";
     elseif (ischar (arg))
-      arg = tolower (arg);
-      if (strcmp (arg, "off") || strcmp (arg, "none"))
+      if (strcmpi (arg, "off") || strcmpi (arg, "none"))
 	pos = "none";
-      elseif (strcmp (arg, "north") || strcmp (arg, "south")
-	      || strcmp (arg, "east") || strcmp (arg, "west")
-	      || strcmp (arg, "northoutside") || strcmp (arg, "southoutside")
-	      || strcmp (arg, "eastoutside") || strcmp (arg, "westoutside"))
+      elseif (strcmpi (arg, "north") || strcmpi (arg, "south")
+	      || strcmpi (arg, "east") || strcmpi (arg, "west")
+	      || strcmpi (arg, "northoutside") || strcmpi (arg, "southoutside")
+	      || strcmpi (arg, "eastoutside") || strcmpi (arg, "westoutside"))
 	pos = arg;
       else
 	error ("colorbar: unrecognized position argument");
       endif
     else
       error ("colorbar: expecting string arguments");
     endif
   endfor
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -59,47 +59,48 @@ function retval = fill (varargin)
 
 endfunction
 
 function iargs = __find_patches__ (varargin)
   iargs = [];
   i = 1;
   while (i < nargin)
     iargs (end + 1) = i;
-    if (ischar (varargin{i}) && (strcmp (tolower (varargin{i}), "faces") || 
-				  strcmp (tolower (varargin{i}), "vertices")))
+    if (ischar (varargin{i})
+	&& (strcmpi (varargin{i}, "faces")
+	    || strcmpi (varargin{i}, "vertices")))
       i += 4;
     elseif (isnumeric (varargin{i}))
       i += 2;
     endif
 
     if (i <= nargin)
       while (true);
 	if (ischar (varargin{i}) && 
-	    (strcmp (tolower (varargin{i}), "faces") || 
-	     strcmp (tolower (varargin{i}), "vertices")))
+	    (strcmpi (varargin{i}, "faces")
+	     || strcmpi (varargin{i}, "vertices")))
 	  break;
 	elseif (isnumeric (varargin{i}))
 	  ## Assume its the colorspec
 	  i++;
 	  break;
 	elseif (ischar (varargin{i}))
 	  colspec = tolower (varargin{i});
 	  collen = length (colspec);
 
-	  if (strncmp (colspec, "blue", collen) ||
-	      strncmp (colspec, "black", collen) ||
-	      strncmp (colspec, "k", collen) ||
-	      strncmp (colspec, "black", collen) ||
-	      strncmp (colspec, "red", collen) ||
-	      strncmp (colspec, "green", collen) ||
-	      strncmp (colspec, "yellow", collen) ||
-	      strncmp (colspec, "magenta", collen) ||
-	      strncmp (colspec, "cyan", collen) ||
-	      strncmp (colspec, "white", collen))
+	  if (strncmp (colspec, "blue", collen)
+	      || strncmp (colspec, "black", collen)
+	      || strncmp (colspec, "k", collen)
+	      || strncmp (colspec, "black", collen)
+	      || strncmp (colspec, "red", collen)
+	      || strncmp (colspec, "green", collen)
+	      || strncmp (colspec, "yellow", collen)
+	      || strncmp (colspec, "magenta", collen)
+	      || strncmp (colspec, "cyan", collen)
+	      || strncmp (colspec, "white", collen))
 	    i++;
 	    break;
 	  endif
 	else
 	  i += 2;
 	endif
       endwhile
     endif
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -73,20 +73,20 @@ function h = findobj (varargin)
       handles = varargin{1};
       n1 = 2;
     else
       handles = 0;
       n1 = 1;
     endif
     if (n1 <= nargin)
       if (ischar (varargin{n1}))
-	if (strcmpi (varargin{n1}, 'flat'))
+	if (strcmpi (varargin{n1}, "flat"))
 	  depth = 0;
 	  n1 = n1 + 1;
-	elseif (strcmpi(varargin{n1}, '-depth'))
+	elseif (strcmpi (varargin{n1}, "-depth"))
 	  depth = varargin{n1+1};
 	  n1 = n1 + 2;
 	endif
       else
 	error ("findobj: properties and options must be strings");
       endif
     endif
   endif
@@ -103,75 +103,75 @@ function h = findobj (varargin)
   pname             = {};
   pvalue            = {};
   np = 1;
   na = 1;
 
   while (na <= numel (args))
     regularexpression(np) = 0;
     property(np) = 0;
-    logicaloperator{np} = 'and';
+    logicaloperator{np} = "and";
     if (ischar (args{na}))
-      if (strcmpi(args{na}, '-regexp'))
+      if (strcmpi (args{na}, "-regexp"))
 	if (na + 2 <= numel (args))
 	  regularexpression(np) = 1;
 	  na = na + 1;
 	  pname{np} = args{na};
 	  na = na + 1;
 	  pvalue{np} = args{na};
 	  na = na + 1;
 	  np = np + 1;
 	else
 	  error ("findobj: inconsistent number of arguments");
 	endif
-      elseif (strcmpi(args{na}, '-property'))
+      elseif (strcmpi (args{na}, "-property"))
 	if (na + 1 <= numel (args))
 	  na = na + 1;
 	  property(np) = 1;
 	  pname{np} = args{na};
 	  na = na + 1;
 	  pvalue{np} = [];
 	  np = np + 1;
 	else
 	  error ("findobj: inconsistent number of arguments");
 	endif
-      elseif (! strcmp (args{na}(1), '-')) # parameter/value pairs
+      elseif (! strcmp (args{na}(1), "-")) # parameter/value pairs
 	if (na + 1 <= numel (args))
 	  pname{np} = args{na};
 	  na = na + 1;
 	  pvalue{np} = args{na};
 	  na = na + 1;
 	  if (na <= numel(args))
 	    if (ischar (args{na}))
-	      if strcmpi(args{na}, '-and')
-		logicaloperator{np} = 'and';
+	      if strcmpi(args{na}, "-and")
+		logicaloperator{np} = "and";
 		na = na+1;
-	      elseif strcmpi(args{na}, '-or')
-		logicaloperator{np} = 'or';
+	      elseif strcmpi(args{na}, "-or")
+		logicaloperator{np} = "or";
 		na = na+1;
-	      elseif strcmpi(args{na}, '-xor')
-		logicaloperator{np} = 'xor';
+	      elseif strcmpi(args{na}, "-xor")
+		logicaloperator{np} = "xor";
 		na = na+1;
-	      elseif strcmpi(args{na}, '-not')
-		logicaloperator{np} = 'not';
+	      elseif strcmpi(args{na}, "-not")
+		logicaloperator{np} = "not";
 		na = na+1;
 	      endif
 	    else
 	      error ("findobj: properties and options must be strings");
 	    endif
 	  else
-	    logicaloperator{np} = 'and';
+	    logicaloperator{np} = "and";
 	  endif
 	  np = np + 1;
 	else
 	  error ("findobj: inconsistent number of arguments");
 	endif
       else
 	## this is sloppy ... but works like matlab
-	if strcmpi(args{na}, '-not')
+	if strcmpi(args{na}, "-not")
 	  h = [];
 	  return
 	endif
 	na = na + 1;
       endif
     else
       error ("findobj: properties and options must be strings");
     endif
@@ -180,17 +180,17 @@ function h = findobj (varargin)
   numpairs = np - 1;
   
   ## load all objects which qualify for being searched
   idepth = 0;
   h = handles;
   while (numel (handles) && ! (idepth >= depth))
     children = [];
     for n = 1 : numel (handles)
-      children = union (children, get(handles(n), 'children'));
+      children = union (children, get(handles(n), "children"));
     endfor 
     handles = children;
     h = union (h, children);
     idepth = idepth + 1;
   endwhile
 
   keepers = ones (size (h));
   if (numpairs > 0)
@@ -215,17 +215,17 @@ function h = findobj (varargin)
 	      else
 		match = (pvalue{np} == p.(pname{np}));
 	      endif
             else
 	      match = 0;
             endif
             match = all (match);
           endif
-          if (strcmpi (logicaloperator{np}, 'not'))
+          if (strcmpi (logicaloperator{np}, "not"))
             keepers(nh) = ! keepers(nh) & ! match;
           else
             keepers(nh) = feval (logicaloperator{np}, keepers(nh), match);
           endif
 	else
 	  keepers(nh) = 0;
 	endif
       endfor
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -44,21 +44,21 @@ function grid (varargin)
 
   if (nargs > 1)
     print_usage ();
   elseif (nargs == 0)
     grid_on = ! grid_on;
   else
     x = varargin{1};
     if (ischar (x))
-      if (strcmp ("off", x))
+      if (strcmpi (x, "off"))
 	grid_on = false;
-      elseif (strcmp ("on", x))
+      elseif (strcmpi (x, "on"))
 	grid_on = true;
-      elseif (strcmp ("minor", x))
+      elseif (strcmpi (x, "minor"))
 	minor_on = ! minor_on;
 	if (minor_on)
 	  grid_on = true;
 	endif
       else
 	print_usage ();
       endif
     else
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -44,17 +44,17 @@ function retval = hidden (mode)
     print_usage ();
   endif
 
   for h = get (gca (), "children");
     htype = lower (get (h, "type"));
     if (strcmp (htype, "surface"))
       fc = get (h, "facecolor");
       if ((! ischar (fc) && is_white (fc))
-	  || (ischar (fc) && strcmp (fc, "none")))
+	  || (ischar (fc) && strcmpi (fc, "none")))
         switch (mode)
         case "on"
           set (h, "facecolor", "w");
         case "off"
           set (h, "facecolor", "none");
         case "swap"
           if (ischar (fc))
             set (h, "facecolor", "w");
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -51,27 +51,27 @@ function hold (varargin)
   else
     h = gcf ();
     nargs = numel (varargin);
   endif
 
   hold_state = get (h, "nextplot");
 
   if (nargs == 0)
-    if (strcmp (hold_state, "add"))
+    if (strcmpi (hold_state, "add"))
       hold_state = "replace";
     else
       hold_state = "add";
     endif
   elseif (nargs == 1)
     state = varargin{1};
     if (ischar (state))
-      if (strcmp ("off", state))
+      if (strcmpi (state, "off"))
 	hold_state = "replace";
-      elseif (strcmp ("on", state))
+      elseif (strcmpi (state, "on"))
 	hold_state = "add";
       else
 	print_usage ();
       endif
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/plot/ishold.m b/scripts/plot/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/ishold.m
@@ -20,14 +20,14 @@
 ## @deftypefn {Function File} {} ishold
 ## Return true if the next line will be added to the current plot, or
 ## false if the plot device will be cleared before drawing the next line.
 ## @end deftypefn
 
 function retval = ishold ()
 
   if (nargin == 0)
-    retval = strcmp (get (gca (), "nextplot"), "add");
+    retval = strcmpi (get (gca (), "nextplot"), "add");
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -117,17 +117,17 @@ function legend (varargin)
 	str = tolower (deblank (arg));
 	switch (str)
 	  case {"off", "hide"}
 	    set (ca, "key", "off");
 	  case "show"
 	    set (ca, "key", "on");
 	  case "toggle"
 	    val = get (ca, "key");
-	    if (strcmp (val, "on"))
+	    if (strcmpi (val, "on"))
 	      set (ca, "key", "off");
 	    else
 	      set (ca, "key", "on");
 	    endif
 	  case "boxon"
 	    set (ca, "key", "on", "keybox", "on");
 	  case "boxoff"
 	    set (ca, "keybox", "off");
diff --git a/scripts/plot/linkprop.m b/scripts/plot/linkprop.m
--- a/scripts/plot/linkprop.m
+++ b/scripts/plot/linkprop.m
@@ -82,17 +82,17 @@ function update_prop (h, d, hlist, prop)
   endif
 endfunction
 
 function delete_prop (h, d, hlist, prop)
   ## FIXME. Actually need to delete the linked properties.
   ## However, only warn if the graphics objects aren't being deleted.
   warn = false;
   for h = hlist(:)'
-    if (ishandle (h) && !strcmp (get (h, "beingdeleted"), "on"))
+    if (ishandle (h) && !strcmpi (get (h, "beingdeleted"), "on"))
       warn = true;
       break;
     endif
   endfor
   if (warn)
     warning ("linkprop: can not remove linked properties");
   endif
 endfunction
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -39,17 +39,17 @@ function retval = orient (varargin)
   else
     cf = gcf ();
   endif
 
   if (nargs == 0)
     retval = get (cf, "paperorientation");
   elseif (nargin == 1)
     orientation = varargin{1};
-    if (strcmp (orientation, "landscape") || strcmp (orientation, "portrait"))
+    if (strcmpi (orientation, "landscape") || strcmpi (orientation, "portrait"))
       set (cf, "paperorientation", orientation)
     else
       error ("orient: unknown orientation");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -97,20 +97,20 @@ endfunction
 
 %!demo
 %! plotmatrix (randn (100, 3), 'g+')
 
 function plotmatrixdelete (h, d, ax)
   for i = 1 : numel (ax)
     hc = ax(i);
     if (ishandle (hc) && strcmp (get (hc, "type"), "axes") && 
-	strcmp (get (hc, "beingdeleted"), "off"))
+	strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
       ## If the parent is invalid or being deleted, then do nothing
-      if (ishandle (parent) && strcmp (get (parent, "beingdeleted"), "off"))
+      if (ishandle (parent) && strcmpi (get (parent, "beingdeleted"), "off"))
 	delete (hc);
       endif
     endif
   endfor
 endfunction
 
 function [h, ax, p, pax, need_usage] = __plotmatrix__ (bigax, varargin)
   need_usage = false;
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -54,23 +54,23 @@ function shading (varargin)
 
   h1 = findobj (ax, "type", "patch");
   h2 = findobj (ax, "type", "surface");
 
   obj = [h1(:); h2(:)];
 
   for n = 1:numel(obj)
     h = obj(n); 
-    if (strcmp (mode, "flat"))
+    if (strcmpi (mode, "flat"))
       set (h, "facecolor", "flat");
       set (h, "edgecolor", "none");
-    elseif (strcmp (mode, "interp"))
+    elseif (strcmpi (mode, "interp"))
       set (h, "facecolor", "interp");
       set (h, "edgecolor", "none");
-    elseif (strcmp (mode, "faceted"))
+    elseif (strcmpi (mode, "faceted"))
       set (h, "facecolor", "flat");
       set (h, "edgecolor", [0 0 0]);
     else
       error ("unknown argument");
     endif
   endfor
 
 endfunction
