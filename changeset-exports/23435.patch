# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1492812460 14400
#      Fri Apr 21 18:07:40 2017 -0400
# Node ID c452180ab6721f2f21fdc9ea5784e38328020cb3
# Parent  f4d4d83f15c5f18badad165f0a7563d2ac1314d9
begin refactoring parse tree evaluator

* libinterp/parse-tree/pt-tm-const.cc,
libinterp/parse-tree/pt-tm-const.h:
New files, extracted from pt-mat.h and pt-mat.cc.
* libinterp/parse-tree/module.mk: Update.

* interpreter.cc, ov-class.cc, ov-classdef.cc, ov-classdef.h,
ov-fcn-handle.cc, ov-fcn-handle.h, ov-usr-fcn.cc, oct-parse.in.yy,
pt-arg-list.cc, pt-arg-list.h, pt-array-list.h, pt-assign.cc,
pt-assign.h, pt-binop.cc, pt-binop.h, pt-cbinop.cc, pt-cbinop.h,
pt-cell.cc, pt-cell.h, pt-classdef.cc, pt-classdef.h, pt-cmd.cc,
pt-cmd.h, pt-colon.cc, pt-colon.h, pt-const.cc, pt-const.h,
pt-decl.cc, pt-decl.h, pt-eval.cc, pt-eval.h, pt-except.cc,
pt-except.h, pt-exp.cc, pt-exp.h, pt-fcn-handle.cc, pt-fcn-handle.h,
pt-funcall.cc, pt-funcall.h, pt-id.cc, pt-id.h, pt-idx.cc, pt-idx.h,
pt-jit.cc, pt-jump.cc, pt-jump.h, pt-loop.cc, pt-loop.h, pt-mat.cc,
pt-mat.h, pt-misc.cc, pt-misc.h, pt-select.cc, pt-select.h,
pt-stmt.cc, pt-stmt.h, pt-unop.cc, pt-unop.h:

Use tree_evaluator class to walk the parse tree instead of rvalue
methods in the parse tree classes.  Maintain a stack in the evaluator
class to accumulate results.

Pass pointer to evaluator to function objects and other classes as
needed for evaluation.

This is a work in progress that is not yet complete.  The ultimate
goal is to move all evaluation into the tree_evaluator class instead
of spreading that work among many different classes.  The global
pointer to the current evaluator should also be eliminated.

diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -421,17 +421,17 @@ namespace octave
     initialize_file_io ();
 
     install_types ();
 
     install_ops ();
 
     install_builtins ();
 
-    install_classdef ();
+    install_classdef (m_evaluator);
 
     bool line_editing = false;
     bool traditional = false;
 
     if (m_app_context)
       {
         // Embedded interpeters don't execute command line options or
         const cmdline_options& options = m_app_context->options ();
diff --git a/libinterp/corefcn/profiler.h b/libinterp/corefcn/profiler.h
--- a/libinterp/corefcn/profiler.h
+++ b/libinterp/corefcn/profiler.h
@@ -214,11 +214,11 @@ extern OCTINTERP_API profile_data_accumu
 
 // Helper macro to profile a block of code.
 
 #define BEGIN_PROFILER_BLOCK(classname)                                 \
   {                                                                     \
     profile_data_accumulator::enter<classname> pe (profiler, *this);
 
 #define END_PROFILER_BLOCK                      \
-    }  // end of block => call pe's destructor
+  }  // end of block => call pe's destructor
 
 #endif
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -451,17 +451,17 @@ octave_class::subsref (const std::string
               if (type[0] != '.') tmp = idx.front ();
               true_nargout = numel (tmp);
             }
 
           retval = octave::feval (meth.function_value (), args, true_nargout);
 
           // Since we're handling subsref, if the list has more than one
           // element, return it as a comma-separated list so that we can
-          // pass it to rvalue1.
+          // pass it to the evaluator
           if (retval.length () > 1)
             retval = octave_value (retval);
         }
       else
         {
           if (type.length () == 1 && type[0] == '(')
             retval(0) = octave_value (map.index (idx.front ()), c_name,
                                       parent_list);
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "load-path.h"
 #include "ov-builtin.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-typeinfo.h"
 #include "ov-usr-fcn.h"
 #include "pt-assign.h"
 #include "pt-classdef.h"
+#include "pt-eval.h"
 #include "pt-funcall.h"
 #include "pt-idx.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "singleton-cleanup.h"
 #include "symtab.h"
 
@@ -415,19 +416,21 @@ is_dummy_method (const octave_value& fcn
         }
     }
   else
     retval = true;
 
   return retval;
 }
 
-bool
+static bool
 is_method_executing (const octave_value& ov, const cdef_object& obj)
 {
+  octave::tree_evaluator *tw = octave::current_evaluator;
+
   octave_function* stack_fcn = octave::call_stack::current ();
 
   octave_function* method_fcn = ov.function_value (true);
 
   // Does the top of the call stack match our target function?
 
   if (stack_fcn && stack_fcn == method_fcn)
     {
@@ -445,17 +448,21 @@ is_method_executing (const octave_value&
           // methods, it's the first argument of the function; for ctors, it
           // is the first return value.
 
           octave::tree_parameter_list* pl = uf->is_classdef_constructor ()
             ? uf->return_list () : uf->parameter_list ();
 
           if (pl && pl->size () > 0)
             {
-              octave_value arg0 = pl->front ()->lvalue ().value ();
+              octave::tree_decl_elt *elt = pl->front ();
+
+              octave_lvalue ref = elt->lvalue (tw);
+
+              octave_value arg0 = ref.value ();
 
               if (arg0.is_defined () && arg0.type_name () == "object")
                 {
                   cdef_object arg0_obj = to_cdef (arg0);
 
                   return obj.is (arg0_obj);
                 }
             }
@@ -635,20 +642,20 @@ handle_delete (const octave_value_list& 
   octave_value_list retval;
 
   // FIXME: implement this
 
   return retval;
 }
 
 static cdef_class
-make_class (const std::string& name,
+make_class (octave::tree_evaluator *tw, const std::string& name,
             const std::list<cdef_class>& super_list = std::list<cdef_class> ())
 {
-  cdef_class cls (name, super_list);
+  cdef_class cls (tw, name, super_list);
 
   cls.set_class (cdef_class::meta_class ());
   cls.put ("Abstract", false);
   cls.put ("ConstructOnLoad", false);
   cls.put ("ContainingPackage", Matrix ());
   cls.put ("Description", "");
   cls.put ("DetailedDescription", "");
   cls.put ("Events", Cell ());
@@ -690,25 +697,27 @@ make_class (const std::string& name,
 
   if (! name.empty ())
     cdef_manager::register_class (cls);
 
   return cls;
 }
 
 static cdef_class
-make_class (const std::string& name, const cdef_class& super)
+make_class (octave::tree_evaluator *tw, const std::string& name,
+            const cdef_class& super)
 {
-  return make_class (name, std::list<cdef_class> (1, super));
+  return make_class (tw, name, std::list<cdef_class> (1, super));
 }
 
 static cdef_class
-make_meta_class (const std::string& name, const cdef_class& super)
+make_meta_class (octave::tree_evaluator *tw, const std::string& name,
+                 const cdef_class& super)
 {
-  cdef_class cls = make_class (name, super);
+  cdef_class cls = make_class (tw, name, super);
 
   cls.put ("Sealed", true);
   cls.mark_as_meta_class ();
 
   return cls;
 }
 
 static cdef_property
@@ -1781,20 +1790,20 @@ handle_cdef_object::~handle_cdef_object 
 value_cdef_object::~value_cdef_object (void)
 {
 #if DEBUG_TRACE
   std::cerr << "deleting " << get_class ().get_name ()
             << " object (value)" << std::endl;
 #endif
 }
 
-cdef_class::cdef_class_rep::cdef_class_rep (const std::list<cdef_class>&
-                                            superclasses)
-  : cdef_meta_object_rep (), member_count (0), handle_class (false),
-    object_count (0), meta (false)
+cdef_class::cdef_class_rep::cdef_class_rep (octave::tree_evaluator *tw,
+                                            const std::list<cdef_class>& superclasses)
+  : cdef_meta_object_rep (), m_evaluator (tw), member_count (0),
+    handle_class (false), object_count (0), meta (false)
 {
   put ("SuperClasses", to_ov (superclasses));
   implicit_ctor_list = superclasses;
 }
 
 cdef_method
 cdef_class::cdef_class_rep::find_method (const std::string& nm, bool local)
 {
@@ -2440,35 +2449,38 @@ cdef_class::cdef_class_rep::construct_ob
 
       cdef_class this_cls = wrap ();
 
       static cdef_object empty_class;
 
       if (this_cls == cdef_class::meta_class ())
         {
           if (! empty_class.ok ())
-            empty_class = make_class ("", std::list<cdef_class> ());
+            empty_class = make_class (m_evaluator, "",
+                                      std::list<cdef_class> ());
           obj = empty_class;
         }
       else if (this_cls == cdef_class::meta_property ())
         {
           static cdef_property empty_property;
 
           if (! empty_class.ok ())
-            empty_class = make_class ("", std::list<cdef_class> ());
+            empty_class = make_class (m_evaluator, "",
+                                      std::list<cdef_class> ());
           if (! empty_property.ok ())
             empty_property = make_property (empty_class, "");
           obj = empty_property;
         }
       else if (this_cls == cdef_class::meta_method ())
         {
           static cdef_method empty_method;
 
           if (! empty_class.ok ())
-            empty_class = make_class ("", std::list<cdef_class> ());
+            empty_class = make_class (m_evaluator, "",
+                                      std::list<cdef_class> ());
           if (! empty_method.ok ())
             empty_method = make_method (empty_class, "", octave_value ());
           obj = empty_method;
         }
       else if (this_cls == cdef_class::meta_package ())
         {
           static cdef_package empty_package;
 
@@ -2495,33 +2507,36 @@ cdef_class::cdef_class_rep::construct_ob
 
       return obj;
     }
 
   return cdef_object ();
 }
 
 static octave_value
-compute_attribute_value (octave::tree_classdef_attribute* t)
+compute_attribute_value (octave::tree_evaluator *tw,
+                         octave::tree_classdef_attribute* t)
 {
-  if (t->expression ())
+  octave::tree_expression *expr = t->expression ();
+
+  if (expr)
     {
-      if (t->expression ()->is_identifier ())
+      if (expr->is_identifier ())
         {
-          std::string s = t->expression ()->name ();
+          std::string s = expr->name ();
 
           if (s == "public")
             return std::string ("public");
           else if (s == "protected")
             return std::string ("protected");
           else if (s == "private")
             return std::string ("private");
         }
 
-      return t->expression ()->rvalue1 ();
+      return tw->evaluate (expr);
     }
   else
     return octave_value (true);
 }
 
 template <typename T>
 static std::string
 attribute_value_to_string (T* t, octave_value v)
@@ -2530,17 +2545,18 @@ attribute_value_to_string (T* t, octave_
     return v.string_value ();
   else if (t->expression ())
     return t->expression ()->original_text ();
   else
     return std::string ("true");
 }
 
 cdef_class
-cdef_class::make_meta_class (octave::tree_classdef* t, bool is_at_folder)
+cdef_class::make_meta_class (octave::tree_evaluator *tw,
+                             octave::tree_classdef* t, bool is_at_folder)
 {
   cdef_class retval;
   std::string class_name, full_class_name;
 
   // Class creation
 
   class_name = full_class_name = t->ident ()->name ();
   if (! t->package_name ().empty ())
@@ -2567,17 +2583,17 @@ cdef_class::make_meta_class (octave::tre
           if (sclass.get ("Sealed").bool_value ())
             error ("`%s' cannot inherit from `%s', because it is sealed",
                    full_class_name.c_str (), sclass_name.c_str ());
 
           slist.push_back (sclass);
         }
     }
 
-  retval = ::make_class (full_class_name, slist);
+  retval = ::make_class (tw, full_class_name, slist);
 
   // Package owning this class
 
   if (! t->package_name ().empty ())
     {
       cdef_package pack = cdef_manager::find_package (t->package_name ());
 
       if (pack.ok ())
@@ -2586,17 +2602,17 @@ cdef_class::make_meta_class (octave::tre
 
   // Class attributes
 
   if (t->attribute_list ())
     {
       for (const auto& attr : (*t->attribute_list ()))
         {
           std::string aname = attr->ident ()->name ();
-          octave_value avalue = compute_attribute_value (attr);
+          octave_value avalue = compute_attribute_value (tw, attr);
 
 #if DEBUG_TRACE
           std::cerr << "class attribute: " << aname << " = "
                     << attribute_value_to_string (attr, avalue) << std::endl;
 #endif
 
           retval.put (aname, avalue);
         }
@@ -2626,17 +2642,17 @@ cdef_class::make_meta_class (octave::tre
 
           // Method attributes
 
           if (mb_p->attribute_list ())
             {
               for (auto& attr_p : *mb_p->attribute_list ())
                 {
                   std::string aname = attr_p->ident ()->name ();
-                  octave_value avalue = compute_attribute_value (attr_p);
+                  octave_value avalue = compute_attribute_value (tw, attr_p);
 
 #if DEBUG_TRACE
                   std::cerr << "method attribute: " << aname << " = "
                             << attribute_value_to_string (attr_p, avalue)
                             << std::endl;
 #endif
 
                   amap[aname] = avalue;
@@ -2731,17 +2747,17 @@ cdef_class::make_meta_class (octave::tre
 
           // Property attributes
 
           if (pb_p->attribute_list ())
             {
               for (auto& attr_p : *pb_p->attribute_list ())
                 {
                   std::string aname = attr_p->ident ()->name ();
-                  octave_value avalue = compute_attribute_value (attr_p);
+                  octave_value avalue = compute_attribute_value (tw, attr_p);
 
 #if DEBUG_TRACE
                   std::cerr << "property attribute: " << aname << " = "
                             << attribute_value_to_string (attr_p, avalue)
                             << std::endl;
 #endif
 
                   if (aname == "Access")
@@ -2764,19 +2780,20 @@ cdef_class::make_meta_class (octave::tre
 
                   cdef_property prop = ::make_property (retval, prop_name);
 
 #if DEBUG_TRACE
                   std::cerr << "property: " << prop_p->ident ()->name ()
                             << std::endl;
 #endif
 
-                  if (prop_p->expression ())
+                  octave::tree_expression *expr = prop_p->expression ();
+                  if (expr)
                     {
-                      octave_value pvalue = prop_p->expression ()->rvalue1 ();
+                      octave_value pvalue = tw->evaluate (expr);
 
 #if DEBUG_TRACE
                       std::cerr << "property default: "
                                 << attribute_value_to_string (*pit, pvalue)
                                 << std::endl;
 #endif
 
                       prop.put ("DefaultValue", pvalue);
@@ -3333,33 +3350,33 @@ cdef_package::cdef_package_rep::meta_rel
 cdef_class cdef_class::_meta_class = cdef_class ();
 cdef_class cdef_class::_meta_property = cdef_class ();
 cdef_class cdef_class::_meta_method = cdef_class ();
 cdef_class cdef_class::_meta_package = cdef_class ();
 
 cdef_package cdef_package::_meta = cdef_package ();
 
 void
-install_classdef (void)
+install_classdef (octave::tree_evaluator *tw)
 {
   octave_classdef::register_type ();
 
   // bootstrap
-  cdef_class handle = make_class ("handle");
-  cdef_class meta_class = cdef_class::_meta_class = make_meta_class ("meta.class", handle);
+  cdef_class handle = make_class (tw, "handle");
+  cdef_class meta_class = cdef_class::_meta_class = make_meta_class (tw, "meta.class", handle);
   handle.set_class (meta_class);
   meta_class.set_class (meta_class);
 
   // meta classes
-  cdef_class meta_property = cdef_class::_meta_property = make_meta_class ("meta.property", handle);
-  cdef_class meta_method = cdef_class::_meta_method = make_meta_class ("meta.method", handle);
-  cdef_class meta_package = cdef_class::_meta_package = make_meta_class ("meta.package", handle);
-
-  cdef_class meta_event = make_meta_class ("meta.event", handle);
-  cdef_class meta_dynproperty = make_meta_class ("meta.dynamicproperty", handle);
+  cdef_class meta_property = cdef_class::_meta_property = make_meta_class (tw, "meta.property", handle);
+  cdef_class meta_method = cdef_class::_meta_method = make_meta_class (tw, "meta.method", handle);
+  cdef_class meta_package = cdef_class::_meta_package = make_meta_class (tw, "meta.package", handle);
+
+  cdef_class meta_event = make_meta_class (tw, "meta.event", handle);
+  cdef_class meta_dynproperty = make_meta_class (tw, "meta.dynamicproperty", handle);
 
   // meta.class properties
   meta_class.install_property (make_attribute (meta_class, "Abstract"));
   meta_class.install_property (make_attribute (meta_class, "ConstructOnLoad"));
   meta_class.install_property (make_property  (meta_class, "ContainingPackage"));
   meta_class.install_property (make_property  (meta_class, "Description"));
   meta_class.install_property (make_property  (meta_class, "DetailedDescription"));
   meta_class.install_property (make_property  (meta_class, "Events"));
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -38,16 +38,17 @@ class cdef_object;
 class cdef_class;
 class cdef_property;
 class cdef_method;
 class cdef_package;
 
 namespace octave
 {
   class tree_classdef;
+  class tree_evaluator;
 }
 
 // This is mainly a boostrap class to declare the expected interface.
 // The actual base class is cdef_class_base, which is declared after
 // cdef_object, such that it can contain cdef_object objects.
 class
 cdef_object_rep
 {
@@ -611,20 +612,22 @@ cdef_class : public cdef_meta_object
 {
 private:
 
   class
   cdef_class_rep : public cdef_meta_object_rep
   {
   public:
     cdef_class_rep (void)
-      : cdef_meta_object_rep (), member_count (0), handle_class (false),
-        object_count (0), meta (false) { }
+      : cdef_meta_object_rep (), m_evaluator (0), member_count (0),
+        handle_class (false), object_count (0), meta (false)
+    { }
 
-    cdef_class_rep (const std::list<cdef_class>& superclasses);
+    cdef_class_rep (octave::tree_evaluator *tw,
+                    const std::list<cdef_class>& superclasses);
 
     cdef_object_rep* copy (void) const { return new cdef_class_rep (*this); }
 
     bool is_class (void) const { return true; }
 
     std::string get_name (void) const
     { return get ("Name").string_value (); }
 
@@ -697,16 +700,18 @@ private:
       else
         delete this;
     }
 
     void mark_as_meta_class (void) { meta = true; }
 
     bool is_meta_class (void) const { return meta; }
 
+    octave::tree_evaluator *evaluator (void) const { return m_evaluator; }
+
   private:
     void load_all_methods (void);
 
     void find_names (std::set<std::string>& names, bool all);
 
     void find_properties (std::map<std::string,cdef_property>& props,
                           int mode = 0);
 
@@ -715,16 +720,19 @@ private:
 
     cdef_class wrap (void)
     {
       refcount++;
       return cdef_class (this);
     }
 
   private:
+
+    octave::tree_evaluator *m_evaluator;
+
     // The @-directory were this class is loaded from.
     // (not used yet)
     std::string directory;
 
     // The methods defined by this class.
     std::map<std::string,cdef_method> method_map;
 
     // The properties defined by this class.
@@ -751,31 +759,32 @@ private:
     // Utility iterator typedef's.
     typedef std::map<std::string,cdef_method>::iterator method_iterator;
     typedef std::map<std::string,cdef_method>::const_iterator method_const_iterator;
     typedef std::map<std::string,cdef_property>::iterator property_iterator;
     typedef std::map<std::string,cdef_property>::const_iterator property_const_iterator;
 
   private:
     cdef_class_rep (const cdef_class_rep& c)
-      : cdef_meta_object_rep (c), directory (c.directory),
+      : cdef_meta_object_rep (c), m_evaluator (c.m_evaluator),
+        directory (c.directory),
         method_map (c.method_map), property_map (c.property_map),
         member_count (c.member_count), handle_class (c.handle_class),
         implicit_ctor_list (c.implicit_ctor_list),
         object_count (c.object_count), meta (c.meta) { }
   };
 
 public:
   // Create and invalid class object
   cdef_class (void)
     : cdef_meta_object () { }
 
-  cdef_class (const std::string& nm,
+  cdef_class (octave::tree_evaluator *tw, const std::string& nm,
               const std::list<cdef_class>& superclasses)
-    : cdef_meta_object (new cdef_class_rep (superclasses))
+    : cdef_meta_object (new cdef_class_rep (tw, superclasses))
   { get_rep ()->set_name (nm); }
 
   cdef_class (const cdef_class& cls)
     : cdef_meta_object (cls) { }
 
   cdef_class (const cdef_object& obj)
     : cdef_meta_object (obj)
   {
@@ -827,17 +836,18 @@ public:
   { return get_rep ()->get_name (); }
 
   bool is_builtin (void) const
   { return get_directory ().empty (); }
 
   void delete_object (cdef_object obj)
   { get_rep ()->delete_object (obj); }
 
-  static cdef_class make_meta_class (octave::tree_classdef* t,
+  static cdef_class make_meta_class (octave::tree_evaluator *tw,
+                                     octave::tree_classdef* t,
                                      bool is_at_folder = false);
 
   octave_function* get_method_function (const std::string& nm);
 
   octave_function* get_constructor_function (void)
   { return get_method_function (get_name ()); }
 
   octave_value construct (const octave_value_list& args)
@@ -881,27 +891,30 @@ public:
 
 private:
   cdef_class_rep* get_rep (void)
   { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
 
   const cdef_class_rep* get_rep (void) const
   { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
+  octave::tree_evaluator *evaluator (void) const
+  { return get_rep ()->evaluator (); }
+
   friend bool operator == (const cdef_class&, const cdef_class&);
   friend bool operator != (const cdef_class&, const cdef_class&);
   friend bool operator < (const cdef_class&, const cdef_class&);
 
 private:
   static cdef_class _meta_class;
   static cdef_class _meta_property;
   static cdef_class _meta_method;
   static cdef_class _meta_package;
 
-  friend void install_classdef (void);
+  friend void install_classdef (octave::tree_evaluator *);
 };
 
 inline bool
 operator == (const cdef_class& clsa, const cdef_class& clsb)
 // FIXME: is this really the right way to check class equality?
 { return (clsa.get_rep () == clsb.get_rep ()); }
 
 inline bool
@@ -1388,17 +1401,17 @@ private:
   { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
 
   const cdef_package_rep* get_rep (void) const
   { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
 
 private:
   static cdef_package _meta;
 
-  friend void install_classdef (void);
+  friend void install_classdef (octave::tree_evaluator *);
 };
 
 class
 octave_classdef : public octave_base_value
 {
 public:
   octave_classdef (void)
     : octave_base_value (), object () { }
@@ -1519,17 +1532,17 @@ to_cdef_ref (const octave_value& val)
 
   return dynamic_cast<octave_classdef *> (val.internal_rep ())->get_object_ref ();
 }
 
 inline cdef_object
 to_cdef (const cdef_object& obj)
 { return obj; }
 
-OCTINTERP_API void install_classdef (void);
+OCTINTERP_API void install_classdef (octave::tree_evaluator *);
 
 class
 cdef_manager
 {
 public:
 
   static cdef_class find_class (const std::string& name,
                                 bool error_if_not_found = true,
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -49,16 +49,17 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "pt-arg-list.h"
 #include "pt-assign.h"
 #include "pt-cmd.h"
+#include "pt-eval.h"
 #include "pt-exp.h"
 #include "pt-idx.h"
 #include "pt-misc.h"
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
@@ -1912,17 +1913,18 @@ octave_fcn_binder::octave_fcn_binder (co
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
   : octave_fcn_handle (f), root_handle (root), arg_template (templ),
     arg_mask (mask), expected_nargin (exp_nargin)
 { }
 
 octave_fcn_handle *
-octave_fcn_binder::maybe_binder (const octave_value& f)
+octave_fcn_binder::maybe_binder (const octave_value& f,
+                                 octave::tree_evaluator *tw)
 {
   octave_fcn_handle *retval = 0;
 
   octave_user_function *usr_fcn = f.user_function_value (false);
   octave::tree_parameter_list *param_list = usr_fcn ? usr_fcn->parameter_list () : 0;
 
   octave::tree_statement_list *cmd_list = 0;
   octave::tree_expression *body_expr = 0;
@@ -1984,30 +1986,30 @@ octave_fcn_binder::maybe_binder (const o
               // or a defined identifier.
               int iarg = 0;
               for (octave::tree_argument_list::iterator it = arg_list->begin ();
                    it != arg_list->end (); ++it, ++iarg)
                 {
                   octave::tree_expression *elt = *it;
                   if (elt && elt->is_constant ())
                     {
-                      arg_template(iarg) = elt->rvalue1 ();
+                      arg_template(iarg) = tw->evaluate (elt);
                       arg_mask[iarg] = -1;
                     }
                   else if (elt && elt->is_identifier ())
                     {
                       octave::tree_identifier *elt_id =
                         dynamic_cast<octave::tree_identifier *> (elt);
                       if (arginmap.find (elt_id->name ()) != arginmap.end ())
                         {
                           arg_mask[iarg] = arginmap[elt_id->name ()];
                         }
                       else if (elt_id->is_defined ())
                         {
-                          arg_template(iarg) = elt_id->rvalue1 ();
+                          arg_template(iarg) = tw->evaluate (elt_id);
                           arg_mask[iarg] = -1;
                         }
                       else
                         {
                           bad = true;
                           break;
                         }
                     }
@@ -2019,17 +2021,17 @@ octave_fcn_binder::maybe_binder (const o
                 }
 
               octave_value root_val;
 
               if (! bad)
                 {
                   // If the head is a value, use it as root.
                   if (head_id->is_defined ())
-                    root_val = head_id->rvalue1 ();
+                    root_val = tw->evaluate (head_id);
                   else
                     {
                       // It's a name.
                       std::string head_name = head_id->name ();
 
                       if (head_name == "eval" || head_name == "feval")
                         bad = true;
                       else
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -30,16 +30,21 @@ along with Octave; see the file COPYING.
 #include <string>
 #include <memory>
 
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 
+namespace octave
+{
+  class tree_evaluator;
+}
+
 // Function handles.
 
 class
 OCTINTERP_API
 octave_fcn_handle : public octave_base_value
 {
 private:
 
@@ -195,17 +200,18 @@ private:
   // Private ctor.
   octave_fcn_binder (const octave_value& f, const octave_value& root,
                      const octave_value_list& templ,
                      const std::vector<int>& mask, int exp_nargin);
 
 public:
 
   // Factory method.
-  static octave_fcn_handle *maybe_binder (const octave_value& f);
+  static octave_fcn_handle *maybe_binder (const octave_value& f,
+                                          octave::tree_evaluator *tw);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -145,17 +145,19 @@ octave_user_script::do_multi_index_op (i
       frame.protect_var (Vtrack_line_num);
       Vtrack_line_num = true;
 
       frame.protect_var (octave::tree_evaluator::statement_context);
       octave::tree_evaluator::statement_context = octave::tree_evaluator::script;
 
       BEGIN_PROFILER_BLOCK (octave_user_script)
 
-        cmd_list->accept (*octave::current_evaluator);
+      octave::tree_evaluator *tw = octave::current_evaluator;
+
+      cmd_list->accept (*tw);
 
       END_PROFILER_BLOCK
 
       if (octave::tree_return_command::returning)
         octave::tree_return_command::returning = 0;
 
       if (octave::tree_break_command::breaking)
         octave::tree_break_command::breaking--;
@@ -516,44 +518,48 @@ octave_user_function::do_multi_index_op 
     {
       symbol_table::push_context ();
 
       frame.add_fcn (symbol_table::pop_context);
     }
 
   string_vector arg_names = args.name_tags ();
 
+  octave::tree_evaluator *tw = octave::current_evaluator;
+
   if (param_list && ! param_list->varargs_only ())
-    param_list->define_from_arg_vector (args);
+    tw->define_parameter_list_from_arg_vector (param_list, args);
 
   // For classdef constructor, pre-populate the output arguments
   // with the pre-initialized object instance, extracted above.
 
   if (is_classdef_constructor ())
     {
       if (! ret_list)
         error ("%s: invalid classdef constructor, no output argument defined",
                dispatch_class ().c_str ());
 
-      ret_list->define_from_arg_vector (ret_args);
+      tw->define_parameter_list_from_arg_vector (ret_list, ret_args);
     }
 
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
   if (param_list)
-    frame.add_method (param_list, &octave::tree_parameter_list::undefine);
+    frame.add_method (tw, &octave::tree_evaluator::undefine_parameter_list,
+                      param_list);
 
   // Force return list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named values returned by this function.
 
   if (ret_list)
-    frame.add_method (ret_list, &octave::tree_parameter_list::undefine);
+    frame.add_method (tw, &octave::tree_evaluator::undefine_parameter_list,
+                      ret_list);
 
   if (call_depth == 0)
     {
       // Force symbols to be undefined again when this function
       // exits.
       //
       // This cleanup function is added to the unwind_protect stack
       // after the calls to clear the parameter lists so that local
@@ -595,52 +601,51 @@ octave_user_function::do_multi_index_op 
       octave::tree_statement *stmt = cmd_list->front ();
 
       octave::tree_expression *expr = stmt->expression ();
 
       if (expr)
         {
           octave::call_stack::set_location (stmt->line (), stmt->column ());
 
-          retval = (lvalue_list
-                    ? expr->rvalue (nargout, lvalue_list)
-                    : expr->rvalue (nargout));
+          retval = tw->evaluate_n (expr, nargout, lvalue_list);
         }
     }
   else
-    cmd_list->accept (*octave::current_evaluator);
+    cmd_list->accept (*tw);
 
   END_PROFILER_BLOCK
 
   if (echo_commands)
     print_code_function_trailer ();
 
   if (octave::tree_return_command::returning)
     octave::tree_return_command::returning = 0;
 
   if (octave::tree_break_command::breaking)
     octave::tree_break_command::breaking--;
 
   // Copy return values out.
 
   if (ret_list && ! is_special_expr ())
     {
-      ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
+      tw->initialize_undefined_parameter_list_elements (ret_list, my_name,
+                                                        nargout, Matrix ());
 
       Cell varargout;
 
       if (ret_list->takes_varargs ())
         {
           octave_value varargout_varval = symbol_table::varval ("varargout");
 
           if (varargout_varval.is_defined ())
             varargout = varargout_varval.xcell_value ("varargout must be a cell array object");
         }
 
-      retval = ret_list->convert_to_const_vector (nargout, varargout);
+      retval = tw->convert_parameter_list_to_const_vector (ret_list, nargout, varargout);
     }
 
   return retval;
 }
 
 void
 octave_user_function::accept (octave::tree_walker& tw)
 {
diff --git a/libinterp/parse-tree/module.mk b/libinterp/parse-tree/module.mk
--- a/libinterp/parse-tree/module.mk
+++ b/libinterp/parse-tree/module.mk
@@ -29,16 +29,17 @@ PARSE_TREE_INC = \
   libinterp/parse-tree/pt-jit.h \
   libinterp/parse-tree/pt-jump.h \
   libinterp/parse-tree/pt-loop.h \
   libinterp/parse-tree/pt-mat.h \
   libinterp/parse-tree/pt-misc.h \
   libinterp/parse-tree/pt-pr-code.h \
   libinterp/parse-tree/pt-select.h \
   libinterp/parse-tree/pt-stmt.h \
+  libinterp/parse-tree/pt-tm-const.h \
   libinterp/parse-tree/pt-unop.h \
   libinterp/parse-tree/pt-walk.h \
   libinterp/parse-tree/pt.h \
   libinterp/parse-tree/token.h
 
 
 ## oct-gperf.h and oct-parse.h are in the SRC list so that they will
 ## be distributed but not installed.
@@ -75,16 +76,17 @@ PARSE_TREE_SRC = \
   libinterp/parse-tree/pt-jit.cc \
   libinterp/parse-tree/pt-jump.cc \
   libinterp/parse-tree/pt-loop.cc \
   libinterp/parse-tree/pt-mat.cc \
   libinterp/parse-tree/pt-misc.cc \
   libinterp/parse-tree/pt-pr-code.cc \
   libinterp/parse-tree/pt-select.cc \
   libinterp/parse-tree/pt-stmt.cc \
+  libinterp/parse-tree/pt-tm-const.cc \
   libinterp/parse-tree/pt-unop.cc \
   libinterp/parse-tree/pt-walk.cc \
   libinterp/parse-tree/pt.cc \
   libinterp/parse-tree/token.cc
 
 ## Special rules for sources which must be built before rest of compilation.
 
 ## Don't use a pipeline to process gperf output since if gperf
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -2351,17 +2351,17 @@ namespace octave
       {
         if (limit)
           {
             if (base->is_constant () && limit->is_constant ()
                 && (! incr || (incr && incr->is_constant ())))
               {
                 try
                   {
-                    octave_value tmp = e->rvalue1 ();
+                    octave_value tmp = octave::current_evaluator->evaluate (e);
 
                     tree_constant *tc_retval
                       = new tree_constant (tmp, base->line (), base->column ());
 
                     std::ostringstream buf;
 
                     tree_print_code tpc (buf);
 
@@ -3908,17 +3908,17 @@ namespace octave
 
   tree_argument_list *
   base_parser::validate_matrix_for_assignment (tree_expression *e)
   {
     tree_argument_list *retval = 0;
 
     if (e->is_constant ())
       {
-        octave_value ov = e->rvalue1 ();
+        octave_value ov = octave::current_evaluator->evaluate (e);
 
         delete e;
 
         if (ov.is_empty ())
           bison_error ("invalid empty left hand side of assignment");
         else
           bison_error ("invalid constant left hand side of assignment");
       }
@@ -3976,17 +3976,17 @@ namespace octave
 
     discard_error_messages = true;
     discard_warning_messages = true;
 
     if (array_list->all_elements_are_constant ())
       {
         try
           {
-            octave_value tmp = array_list->rvalue1 ();
+            octave_value tmp = octave::current_evaluator->evaluate (array_list);
 
             tree_constant *tc_retval
               = new tree_constant (tmp, array_list->line (),
                                    array_list->column ());
 
             std::ostringstream buf;
 
             tree_print_code tpc (buf);
@@ -4332,17 +4332,17 @@ parse_fcn_file (const std::string& full_
               // table?).  Return pointer to constructor?
 
               if (fcn_ptr)
                 panic_impossible ();
 
               bool is_at_folder = ! dispatch_type.empty ();
 
               fcn_ptr =
-                parser.classdef_object->make_meta_class (is_at_folder);
+                parser.classdef_object->make_meta_class (octave::current_evaluator, is_at_folder);
 
               delete (parser.classdef_object);
 
               parser.classdef_object = 0;
             }
           else if (fcn_ptr)
             {
               fcn_ptr->maybe_relocate_end ();
@@ -5126,17 +5126,17 @@ namespace octave
                         tree_identifier *id
                           = dynamic_cast<tree_identifier *> (expr);
 
                         do_bind_ans = (! id->is_variable ());
                       }
                     else
                       do_bind_ans = (! expr->is_assignment_expression ());
 
-                    retval = expr->rvalue (nargout);
+                    retval = octave::current_evaluator->evaluate_n (expr, nargout);
 
                     if (do_bind_ans && ! retval.empty ())
                       bind_ans (retval(0), expr->print_result ());
 
                     if (nargout == 0)
                       retval = octave_value_list ();
                   }
                 else if (nargout == 0)
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "oct-lvalue.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-usr-fcn.h"
 #include "parse.h"
 #include "pt-arg-list.h"
+#include "pt-eval.h"
 #include "pt-exp.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-pr-code.h"
 #include "pt-walk.h"
 #include "interpreter.h"
 #include "unwind-prot.h"
 
@@ -199,17 +200,18 @@ DEFCONSTFUN (end, , ,
     retval = 1;
 
   return retval;
 }
 
 namespace octave
 {
   octave_value_list
-  tree_argument_list::convert_to_const_vector (const octave_value *object)
+  tree_argument_list::convert_to_const_vector (tree_evaluator *tw,
+                                               const octave_value *object)
   {
     // END doesn't make sense for functions.  Maybe we need a different
     // way of asking an octave_value object this question?
 
     bool stash_object = (list_includes_magic_end
                          && object
                          && ! (object->is_function ()
                                || object->is_function_handle ()));
@@ -238,17 +240,17 @@ namespace octave
             index_position = k;
             num_indices = len;
           }
 
         tree_expression *elt = *p++;
 
         if (elt)
           {
-            octave_value tmp = elt->rvalue1 ();
+            octave_value tmp = tw->evaluate (elt);
 
             if (tmp.is_cs_list ())
               args.push_back (tmp.list_value ());
             else if (tmp.is_defined ())
               args.push_back (tmp);
           }
         else
           {
@@ -256,22 +258,22 @@ namespace octave
             break;
           }
       }
 
     return args;
   }
 
   std::list<octave_lvalue>
-  tree_argument_list::lvalue_list (void)
+  tree_argument_list::lvalue_list (tree_evaluator *tw)
   {
     std::list<octave_lvalue> retval;
 
     for (tree_expression* elt : *this)
-      retval.push_back (elt->lvalue ());
+      retval.push_back (elt->lvalue (tw));
 
     return retval;
   }
 
   string_vector
   tree_argument_list::get_arg_names (void) const
   {
     int len = length ();
@@ -320,15 +322,9 @@ namespace octave
     new_list->list_includes_magic_end = list_includes_magic_end;
     new_list->simple_assign_lhs = simple_assign_lhs;
 
     for (const tree_expression* elt : *this)
       new_list->append (elt ? elt->dup (scope, context) : 0);
 
     return new_list;
   }
-
-  void
-  tree_argument_list::accept (tree_walker& tw)
-  {
-    tw.visit_argument_list (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -28,24 +28,24 @@ along with Octave; see the file COPYING.
 #include <list>
 
 class octave_value_list;
 class octave_lvalue;
 
 #include "str-vec.h"
 
 #include "base-list.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
+  class tree_evaluator;
   class tree_expression;
 
-  class tree_walker;
-
   // Argument lists.  Used to hold the list of expressions that are the
   // arguments in a function call or index expression.
 
   class tree_argument_list : public octave::base_list<tree_expression *>
   {
   public:
 
     typedef tree_expression* element_type;
@@ -85,28 +85,32 @@ namespace octave
     void mark_as_simple_assign_lhs (void) { simple_assign_lhs = true; }
 
     bool is_simple_assign_lhs (void) { return simple_assign_lhs; }
 
     bool all_elements_are_constant (void) const;
 
     bool is_valid_lvalue_list (void) const;
 
-    octave_value_list convert_to_const_vector (const octave_value *object = 0);
+    octave_value_list convert_to_const_vector (tree_evaluator *tw,
+                                               const octave_value *object = 0);
 
-    std::list<octave_lvalue> lvalue_list (void);
+    std::list<octave_lvalue> lvalue_list (tree_evaluator *tw);
 
     string_vector get_arg_names (void) const;
 
     std::list<std::string> variable_names (void) const;
 
     tree_argument_list *dup (symbol_table::scope_id scope,
                              symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_argument_list (*this);
+    }
 
   private:
 
     bool list_includes_magic_end;
 
     bool list_includes_magic_tilde;
 
     bool simple_assign_lhs;
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -27,16 +27,18 @@ along with Octave; see the file COPYING.
 
 #include "base-list.h"
 #include "pt-arg-list.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
 namespace octave
 {
+  class tree_walker;
+
   // Base class for cell arrays and matrices.
 
   class tree_array_list : public tree_expression,
                           public octave::base_list<tree_argument_list *>
   {
   public:
 
     typedef octave::base_list<tree_argument_list *>::iterator iterator;
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -34,17 +34,16 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-assign.h"
-#include "pt-eval.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
 namespace octave
 {
   // Simple assignment expressions.
 
@@ -57,90 +56,16 @@ namespace octave
   tree_simple_assignment::~tree_simple_assignment (void)
   {
     if (! preserve)
       delete lhs;
 
     delete rhs;
   }
 
-  octave_value_list
-  tree_simple_assignment::rvalue (int nargout)
-  {
-    if (nargout > 1)
-      error ("invalid number of output arguments for expression X = RHS");
-
-    return rvalue1 (nargout);
-  }
-
-  octave_value
-  tree_simple_assignment::rvalue1 (int)
-  {
-    octave_value retval;
-
-    if (rhs)
-      {
-        octave_value rhs_val = rhs->rvalue1 ();
-
-        if (rhs_val.is_undefined ())
-          error ("value on right hand side of assignment is undefined");
-
-        if (rhs_val.is_cs_list ())
-          {
-            const octave_value_list lst = rhs_val.list_value ();
-
-            if (lst.empty ())
-              error ("invalid number of elements on RHS of assignment");
-
-            rhs_val = lst(0);
-          }
-
-        try
-          {
-            octave_lvalue ult = lhs->lvalue ();
-
-            if (ult.numel () != 1)
-              err_nonbraced_cs_list_assignment ();
-
-            ult.assign (etype, rhs_val);
-
-            if (etype == octave_value::op_asn_eq)
-              retval = rhs_val;
-            else
-              retval = ult.value ();
-
-            if (print_result ()
-                && octave::tree_evaluator::statement_printing_enabled ())
-              {
-                // We clear any index here so that we can
-                // get the new value of the referenced
-                // object below, instead of the indexed
-                // value (which should be the same as the
-                // right hand side value).
-
-                ult.clear_index ();
-
-                octave_value lhs_val = ult.value ();
-
-                octave_value_list args = ovl (lhs_val);
-                args.stash_name_tags (string_vector (lhs->name ()));
-                octave::feval ("display", args);
-              }
-          }
-        catch (octave::index_exception& e)
-          {
-            e.set_var (lhs->name ());
-            std::string msg = e.message ();
-            error_with_id (e.err_id (), msg.c_str ());
-          }
-      }
-
-    return retval;
-  }
-
   std::string
   tree_simple_assignment::oper (void) const
   {
     return octave_value::assign_op_as_string (etype);
   }
 
   tree_expression *
   tree_simple_assignment::dup (symbol_table::scope_id scope,
@@ -151,203 +76,32 @@ namespace octave
                                     rhs ? rhs->dup (scope, context) : 0,
                                     preserve, etype);
 
     new_sa->copy_base (*this);
 
     return new_sa;
   }
 
-  void
-  tree_simple_assignment::accept (tree_walker& tw)
-  {
-    tw.visit_simple_assignment (*this);
-  }
-
   // Multi-valued assignment expressions.
 
   tree_multi_assignment::tree_multi_assignment
   (tree_argument_list *lst, tree_expression *r,
    bool plhs, int l, int c)
     : tree_expression (l, c), lhs (lst), rhs (r), preserve (plhs)
   { }
 
   tree_multi_assignment::~tree_multi_assignment (void)
   {
     if (! preserve)
       delete lhs;
 
     delete rhs;
   }
 
-  octave_value
-  tree_multi_assignment::rvalue1 (int nargout)
-  {
-    octave_value retval;
-
-    const octave_value_list tmp = rvalue (nargout);
-
-    if (! tmp.empty ())
-      retval = tmp(0);
-
-    return retval;
-  }
-
-  // FIXME: this works, but it would look a little better if
-  // it were broken up into a couple of separate functions.
-
-  octave_value_list
-  tree_multi_assignment::rvalue (int)
-  {
-    octave_value_list retval;
-
-    if (rhs)
-      {
-        std::list<octave_lvalue> lvalue_list = lhs->lvalue_list ();
-
-        octave_idx_type n_out = 0;
-
-        for (const auto& lval : lvalue_list)
-          n_out += lval.numel ();
-
-        // The following trick is used to keep rhs_val constant.
-        const octave_value_list rhs_val1 = rhs->rvalue (n_out, &lvalue_list);
-        const octave_value_list rhs_val = (rhs_val1.length () == 1
-                                           && rhs_val1(0).is_cs_list ()
-                                           ? rhs_val1(0).list_value ()
-                                           : rhs_val1);
-
-        octave_idx_type k = 0;
-
-        octave_idx_type n = rhs_val.length ();
-
-        // To avoid copying per elements and possible optimizations, we
-        // postpone joining the final values.
-        std::list<octave_value_list> retval_list;
-
-        tree_argument_list::iterator q = lhs->begin ();
-
-        for (octave_lvalue ult : lvalue_list)
-          {
-            tree_expression *lhs_elt = *q++;
-
-            octave_idx_type nel = ult.numel ();
-
-            if (nel != 1)
-              {
-                // Huge kluge so that wrapper scripts with lines like
-                //
-                //   [varargout{1:nargout}] = fcn (args);
-                //
-                // Will work the same as calling fcn directly when nargout
-                // is 0 and fcn produces more than one output even when
-                // nargout is 0.  This only works if varargout has not yet
-                // been defined.  See also bug #43813.
-
-                if (lvalue_list.size () == 1 && nel == 0 && n > 0
-                    && ! ult.is_black_hole () && ult.is_undefined ()
-                    && ult.index_type () == "{" && ult.index_is_empty ())
-                  {
-                    // Convert undefined lvalue with empty index to a cell
-                    // array with a single value and indexed by 1 to
-                    // handle a single output.
-
-                    nel = 1;
-
-                    ult.define (Cell (1, 1));
-
-                    ult.clear_index ();
-                    std::list<octave_value_list> idx;
-                    idx.push_back (octave_value_list (octave_value (1)));
-                    ult.set_index ("{", idx);
-                  }
-
-                if (k + nel > n)
-                  error ("some elements undefined in return list");
-
-                // This element of the return list expects a
-                // comma-separated list of values.  Slicing avoids
-                // copying.
-
-                octave_value_list ovl = rhs_val.slice (k, nel);
-
-                ult.assign (octave_value::op_asn_eq, octave_value (ovl));
-
-                retval_list.push_back (ovl);
-
-                k += nel;
-              }
-            else
-              {
-                if (k < n)
-                  {
-                    ult.assign (octave_value::op_asn_eq, rhs_val(k));
-
-                    if (ult.is_black_hole ())
-                      {
-                        k++;
-                        continue;
-                      }
-                    else
-                      {
-                        retval_list.push_back (rhs_val(k));
-
-                        k++;
-                      }
-                  }
-                else
-                  {
-                    // This can happen for a function like
-                    //
-                    //   function varargout = f ()
-                    //     varargout{1} = nargout;
-                    //   endfunction
-                    //
-                    // called with
-                    //
-                    //    [a, ~] = f ();
-                    //
-                    // Then the list of of RHS values will contain one
-                    // element but we are iterating over the list of all
-                    // RHS values.  We shouldn't complain that a value we
-                    // don't need is missing from the list.
-
-                    if (! ult.is_black_hole ())
-                      error ("element number %d undefined in return list", k+1);
-
-                    k++;
-                    continue;
-                  }
-              }
-
-            if (print_result ()
-                && octave::tree_evaluator::statement_printing_enabled ())
-              {
-                // We clear any index here so that we can get
-                // the new value of the referenced object below,
-                // instead of the indexed value (which should be
-                // the same as the right hand side value).
-
-                ult.clear_index ();
-
-                octave_value lhs_val = ult.value ();
-
-                octave_value_list args = ovl (lhs_val);
-                args.stash_name_tags (string_vector (lhs_elt->name ()));
-                octave::feval ("display", args);
-              }
-          }
-
-        // Concatenate return values.
-        retval = retval_list;
-      }
-
-    return retval;
-  }
-
   std::string
   tree_multi_assignment::oper (void) const
   {
     return octave_value::assign_op_as_string (op_type ());
   }
 
   tree_expression *
   tree_multi_assignment::dup (symbol_table::scope_id scope,
@@ -357,22 +111,16 @@ namespace octave
       = new tree_multi_assignment (lhs ? lhs->dup (scope, context) : 0,
                                    rhs ? rhs->dup (scope, context) : 0,
                                    preserve);
 
     new_ma->copy_base (*this);
 
     return new_ma;
   }
-
-  void
-  tree_multi_assignment::accept (tree_walker& tw)
-  {
-    tw.visit_multi_assignment (*this);
-  }
 }
 
 /*
 %!function varargout = f ()
 %!  varargout{1} = nargout;
 %!endfunction
 %!
 %!test
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -29,24 +29,23 @@ along with Octave; see the file COPYING.
 #include <string>
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov.h"
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
   class tree_argument_list;
 
-  class tree_walker;
-
   // Simple assignment expressions.
 
   class tree_simple_assignment : public tree_expression
   {
   public:
 
     tree_simple_assignment (bool plhs = false, int l = -1, int c = -1,
                             octave_value::assign_op t = octave_value::op_asn_eq)
@@ -64,33 +63,32 @@ namespace octave
     tree_simple_assignment& operator = (const tree_simple_assignment&) = delete;
 
     ~tree_simple_assignment (void);
 
     bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     bool is_assignment_expression (void) const { return true; }
 
     std::string oper (void) const;
 
     tree_expression *left_hand_side (void) { return lhs; }
 
     tree_expression *right_hand_side (void) { return rhs; }
 
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
-
+    void accept (tree_walker& tw)
+    {
+      tw.visit_simple_assignment (*this);
+    }
+    
     octave_value::assign_op op_type (void) const { return etype; }
 
   private:
 
     void do_assign (octave_lvalue& ult, const octave_value_list& args,
                     const octave_value& rhs_val);
 
     void do_assign (octave_lvalue& ult, const octave_value& rhs_val);
@@ -132,30 +130,29 @@ namespace octave
     ~tree_multi_assignment (void);
 
     bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
     bool is_assignment_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     std::string oper (void) const;
 
     tree_argument_list *left_hand_side (void) { return lhs; }
 
     tree_expression *right_hand_side (void) { return rhs; }
 
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_multi_assignment (*this);
+    }
 
     octave_value::assign_op op_type (void) const
     { return octave_value::op_asn_eq; }
 
   private:
 
     // The left hand side of the assignment.
     tree_argument_list *lhs;
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -33,114 +33,26 @@ along with Octave; see the file COPYING.
 #include "pt-bp.h"
 #include "pt-walk.h"
 #include "variables.h"
 
 namespace octave
 {
   // Binary expressions.
 
-  octave_value_list
-  tree_binary_expression::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    if (nargout > 1)
-      error ("binary operator '%s': invalid number of output arguments",
-             oper ().c_str ());
-
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
-
   void
   tree_binary_expression::matlab_style_short_circuit_warning (const char *op)
   {
     warning_with_id ("Octave:possible-matlab-short-circuit-operator",
                      "Matlab-style short-circuit operation performed for operator %s",
                      op);
 
     braindead_shortcircuit_warning_issued = true;
   }
 
-  octave_value
-  tree_binary_expression::rvalue1 (int)
-  {
-    octave_value retval;
-
-    if (eligible_for_braindead_shortcircuit)
-      {
-        if (op_lhs)
-          {
-            octave_value a = op_lhs->rvalue1 ();
-
-            if (a.ndims () == 2 && a.rows () == 1 && a.columns () == 1)
-              {
-                bool result = false;
-
-                bool a_true = a.is_true ();
-
-                if (a_true)
-                  {
-                    if (etype == octave_value::op_el_or)
-                      {
-                        matlab_style_short_circuit_warning ("|");
-                        return octave_value (true);
-                      }
-                  }
-                else
-                  {
-                    if (etype == octave_value::op_el_and)
-                      {
-                        matlab_style_short_circuit_warning ("&");
-                        return octave_value (false);
-                      }
-                  }
-
-                if (op_rhs)
-                  {
-                    octave_value b = op_rhs->rvalue1 ();
-
-                    result = b.is_true ();
-                  }
-
-                return octave_value (result);
-              }
-          }
-      }
-
-    if (op_lhs)
-      {
-        octave_value a = op_lhs->rvalue1 ();
-
-        if (a.is_defined () && op_rhs)
-          {
-            octave_value b = op_rhs->rvalue1 ();
-
-            if (b.is_defined ())
-              {
-                BEGIN_PROFILER_BLOCK (tree_binary_expression)
-
-                  // Note: The profiler does not catch the braindead
-                  // short-circuit evaluation code above, but that should be
-                  // ok.  The evaluation of operands and the operator itself
-                  // is entangled and it's not clear where to start/stop
-                  // timing the operator to make it reasonable.
-
-                  retval = ::do_binary_op (etype, a, b);
-
-                END_PROFILER_BLOCK
-                  }
-          }
-      }
-
-    return retval;
-  }
-
   std::string
   tree_binary_expression::oper (void) const
   {
     return octave_value::binary_op_as_string (etype);
   }
 
   tree_expression *
   tree_binary_expression::dup (symbol_table::scope_id scope,
@@ -151,80 +63,18 @@ namespace octave
                                     op_rhs ? op_rhs->dup (scope, context) : 0,
                                     line (), column (), etype);
 
     new_be->copy_base (*this);
 
     return new_be;
   }
 
-  void
-  tree_binary_expression::accept (tree_walker& tw)
-  {
-    tw.visit_binary_expression (*this);
-  }
-
   // Boolean expressions.
 
-  octave_value_list
-  tree_boolean_expression::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    if (nargout > 1)
-      error ("binary operator '%s': invalid number of output arguments",
-             oper ().c_str ());
-
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
-
-  octave_value
-  tree_boolean_expression::rvalue1 (int)
-  {
-    octave_value retval;
-
-    bool result = false;
-
-    // This evaluation is not caught by the profiler, since we can't find
-    // a reasonable place where to time.  Note that we don't want to
-    // include evaluation of LHS or RHS into the timing, but this is
-    // entangled together with short-circuit evaluation here.
-
-    if (op_lhs)
-      {
-        octave_value a = op_lhs->rvalue1 ();
-
-        bool a_true = a.is_true ();
-
-        if (a_true)
-          {
-            if (etype == bool_or)
-              return octave_value (true);
-          }
-        else
-          {
-            if (etype == bool_and)
-              return octave_value (false);
-          }
-
-        if (op_rhs)
-          {
-            octave_value b = op_rhs->rvalue1 ();
-
-            result = b.is_true ();
-          }
-
-        retval = octave_value (result);
-      }
-
-    return retval;
-  }
-
   std::string
   tree_boolean_expression::oper (void) const
   {
     std::string retval = "<unknown>";
 
     switch (etype)
       {
       case bool_and:
@@ -250,15 +100,9 @@ namespace octave
       = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
                                      op_rhs ? op_rhs->dup (scope, context) : 0,
                                      line (), column (), etype);
 
     new_be->copy_base (*this);
 
     return new_be;
   }
-
-  void
-  tree_boolean_expression::accept (tree_walker& tw)
-  {
-    tw.visit_boolean_expression (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -28,22 +28,21 @@ along with Octave; see the file COPYING.
 #include <string>
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov.h"
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
-
   // Binary expressions.
 
   class tree_binary_expression : public tree_expression
   {
   public:
 
     tree_binary_expression (int l = -1, int c = -1,
                             octave_value::binary_op t
@@ -88,34 +87,40 @@ namespace octave
       return ((op_lhs && op_lhs->has_magic_end ())
               || (op_rhs && op_rhs->has_magic_end ()));
     }
 
     bool is_binary_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     std::string oper (void) const;
 
     octave_value::binary_op op_type (void) const { return etype; }
 
     tree_expression *lhs (void) { return op_lhs; }
     tree_expression *rhs (void) { return op_rhs; }
 
+    bool is_eligible_for_braindead_shortcircuit (void) const
+    {
+      return eligible_for_braindead_shortcircuit;
+    }
+
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_binary_expression (*this);
+    }
 
     std::string profiler_name (void) const { return "binary " + oper (); }
 
+    void matlab_style_short_circuit_warning (const char *op);
+
   protected:
 
     // The operands for the expression.
     tree_expression *op_lhs;
     tree_expression *op_rhs;
 
   private:
 
@@ -124,18 +129,16 @@ namespace octave
 
     // TRUE if this is an | or & expression in the condition of an IF
     // or WHILE statement.
     bool eligible_for_braindead_shortcircuit;
 
     // TRUE if we have already issued a warning about short circuiting
     // for this operator.
     bool braindead_shortcircuit_warning_issued;
-
-    void matlab_style_short_circuit_warning (const char *op);
   };
 
   // Boolean expressions.
 
   class tree_boolean_expression : public tree_binary_expression
   {
   public:
 
@@ -160,28 +163,27 @@ namespace octave
     tree_boolean_expression& operator = (const tree_boolean_expression&) = delete;
 
     ~tree_boolean_expression (void) = default;
 
     bool is_boolean_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     std::string oper (void) const;
 
     type op_type (void) const { return etype; }
 
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_boolean_expression (*this);
+    }
 
   private:
 
     // The type of the expression.
     type etype;
   };
 }
 
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -30,51 +30,16 @@ along with Octave; see the file COPYING.
 #include "pt-cbinop.h"
 #include "pt-bp.h"
 #include "pt-unop.h"
 #include "pt-walk.h"
 
 namespace octave
 {
   typedef tree_expression* tree_expression_ptr_t;
-
-  octave_value_list
-  tree_compound_binary_expression::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    if (nargout > 1)
-      error ("binary operator '%s': invalid number of output arguments",
-             oper ().c_str ());
-
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
-
-  octave_value
-  tree_compound_binary_expression::rvalue1 (int)
-  {
-    octave_value retval;
-
-    if (op_lhs)
-      {
-        octave_value a = op_lhs->rvalue1 ();
-
-        if (a.is_defined () && op_rhs)
-          {
-            octave_value b = op_rhs->rvalue1 ();
-
-            if (b.is_defined ())
-              retval = ::do_binary_op (etype, a, b);
-          }
-      }
-
-    return retval;
-  }
 }
 
 // If a tree expression is a transpose or hermitian transpose, return
 // the argument and corresponding operator.
 
 static octave_value::unary_op
 strip_trans_herm (octave::tree_expression_ptr_t& exp)
 {
@@ -234,15 +199,9 @@ namespace octave
     tree_binary_expression *ret = (ct == octave_value::unknown_compound_binary_op)
       ? new tree_binary_expression (a, b, l, c, t)
       : new tree_compound_binary_expression (a, b, l,
                                              c, t, ca,
                                              cb, ct);
 
     return ret;
   }
-
-  void
-  tree_compound_binary_expression::accept (tree_walker& tw)
-  {
-    tw.visit_compound_binary_expression (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-cbinop.h b/libinterp/parse-tree/pt-cbinop.h
--- a/libinterp/parse-tree/pt-cbinop.h
+++ b/libinterp/parse-tree/pt-cbinop.h
@@ -28,22 +28,21 @@ along with Octave; see the file COPYING.
 #include <string>
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov.h"
 #include "pt-binop.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
-
   // Binary expressions that can be reduced to compound operations
 
   class tree_compound_binary_expression : public tree_binary_expression
   {
   public:
 
     tree_compound_binary_expression (tree_expression *a, tree_expression *b,
                                      int l, int c,
@@ -52,21 +51,20 @@ namespace octave
                                      octave_value::compound_binary_op ct)
       : tree_binary_expression (a, b, l, c, t), op_lhs (ca), op_rhs (cb),
         etype (ct) { }
 
     octave_value::compound_binary_op cop_type (void) const { return etype; }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_compound_binary_expression (*this);
+    }
 
   private:
 
     tree_expression *op_lhs;
     tree_expression *op_rhs;
     octave_value::compound_binary_op etype;
 
     // No copying!
diff --git a/libinterp/parse-tree/pt-cell.cc b/libinterp/parse-tree/pt-cell.cc
--- a/libinterp/parse-tree/pt-cell.cc
+++ b/libinterp/parse-tree/pt-cell.cc
@@ -31,85 +31,19 @@ along with Octave; see the file COPYING.
 #include "pt-arg-list.h"
 #include "pt-exp.h"
 #include "pt-cell.h"
 #include "pt-walk.h"
 #include "ov.h"
 
 namespace octave
 {
-  octave_value
-  tree_cell::rvalue1 (int)
-  {
-    octave_value retval;
-
-    octave_idx_type nr = length ();
-    octave_idx_type nc = -1;
-
-    Cell val;
-
-    octave_idx_type i = 0;
-
-    for (tree_argument_list* elt : *this)
-      {
-        octave_value_list row = elt->convert_to_const_vector ();
-
-        if (nr == 1)
-          // Optimize the single row case.
-          val = row.cell_value ();
-        else if (nc < 0)
-          {
-            nc = row.length ();
-
-            val = Cell (nr, nc);
-          }
-        else
-          {
-            octave_idx_type this_nc = row.length ();
-
-            if (this_nc != nc)
-              {
-                if (this_nc == 0)
-                  continue;  // blank line
-                else
-                  error ("number of columns must match");
-              }
-          }
-
-        for (octave_idx_type j = 0; j < nc; j++)
-          val(i,j) = row(j);
-
-        i++;
-      }
-
-    if (i < nr)
-      val.resize (dim_vector (i, nc));  // there were blank rows
-    retval = val;
-
-    return retval;
-  }
-
-  octave_value_list
-  tree_cell::rvalue (int nargout)
-  {
-    if (nargout > 1)
-      error ("invalid number of output arguments for cell array");
-
-    return rvalue1 (nargout);
-  }
-
   tree_expression *
   tree_cell::dup (symbol_table::scope_id scope,
                   symbol_table::context_id context) const
   {
     tree_cell *new_cell = new tree_cell (0, line (), column ());
 
     new_cell->copy_base (*this, scope, context);
 
     return new_cell;
   }
-
-  void
-  tree_cell::accept (tree_walker& tw)
-  {
-    tw.visit_cell (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -26,24 +26,23 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <iosfwd>
 
 class octave_value;
 class octave_value_list;
 
 #include "pt-mat.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
   class tree_argument_list;
 
-  class tree_walker;
-
   // General cells.
 
   class tree_cell : public tree_array_list
   {
   public:
 
     tree_cell (tree_argument_list *row = 0, int l = -1, int c = -1)
       : tree_array_list (row, l, c)
@@ -56,24 +55,23 @@ namespace octave
     tree_cell& operator = (const tree_cell&) = delete;
 
     ~tree_cell (void) = default;
 
     bool is_cell (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int);
-
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_cell (*this);
+    }
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::tree_cell' instead")
 typedef octave::tree_cell tree_cell;
 
diff --git a/libinterp/parse-tree/pt-classdef.cc b/libinterp/parse-tree/pt-classdef.cc
--- a/libinterp/parse-tree/pt-classdef.cc
+++ b/libinterp/parse-tree/pt-classdef.cc
@@ -26,184 +26,94 @@ along with Octave; see the file COPYING.
 
 #include "ov-classdef.h"
 #include "pt-classdef.h"
 
 namespace octave
 {
   // Classdef attribute
 
-  void
-  tree_classdef_attribute::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_attribute (*this);
-  }
-
   // Classdef attribute_list
 
   tree_classdef_attribute_list::~tree_classdef_attribute_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
   }
 
-  void
-  tree_classdef_attribute_list::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_attribute_list (*this);
-  }
-
   // Classdef superclass
 
-  void
-  tree_classdef_superclass::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_superclass (*this);
-  }
-
   // Classdef superclass_list
 
   tree_classdef_superclass_list::~tree_classdef_superclass_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
   }
 
-  void
-  tree_classdef_superclass_list::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_superclass_list (*this);
-  }
-
   // Classdef property
 
-  void
-  tree_classdef_property::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_property (*this);
-  }
-
   // Classdef property_list
 
   tree_classdef_property_list::~tree_classdef_property_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
   }
 
-  void
-  tree_classdef_property_list::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_property_list (*this);
-  }
-
   // Classdef properties_block
 
-  void
-  tree_classdef_properties_block::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_properties_block (*this);
-  }
-
   // Classdef methods_list
 
-  void
-  tree_classdef_methods_list::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_methods_list (*this);
-  }
-
   // Classdef methods_block
 
-  void
-  tree_classdef_methods_block::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_methods_block (*this);
-  }
-
   // Classdef event
 
-  void
-  tree_classdef_event::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_event (*this);
-  }
-
   // Classdef events_list
 
   tree_classdef_events_list::~tree_classdef_events_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
   }
 
-  void
-  tree_classdef_events_list::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_events_list (*this);
-  }
-
   // Classdef events_block
 
-  void
-  tree_classdef_events_block::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_events_block (*this);
-  }
-
   // Classdef enum
 
-  void
-  tree_classdef_enum::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_enum (*this);
-  }
-
   // Classdef enum_list
 
   tree_classdef_enum_list::~tree_classdef_enum_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
   }
 
-  void
-  tree_classdef_enum_list::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_enum_list (*this);
-  }
-
   // Classdef enum_block
 
-  void
-  tree_classdef_enum_block::accept (tree_walker& tw)
-  {
-    tw.visit_classdef_enum_block (*this);
-  }
-
   // Classdef body
 
   tree_classdef_body::~tree_classdef_body (void)
   {
     while (! properties_lst.empty ())
       {
         properties_list_iterator p = properties_lst.begin ();
         delete *p;
@@ -230,32 +140,26 @@ namespace octave
         delete *p;
         enum_lst.erase (p);
       }
   }
 
   // Classdef
 
   octave_function*
-  tree_classdef::make_meta_class (bool is_at_folder)
+  tree_classdef::make_meta_class (tree_evaluator *tw, bool is_at_folder)
   {
-    cdef_class cls = cdef_class::make_meta_class (this, is_at_folder);
+    cdef_class cls = cdef_class::make_meta_class (tw, this, is_at_folder);
 
     if (cls.ok ())
       return cls.get_constructor_function ();
 
     return 0;
   }
 
   tree_classdef *
   tree_classdef::dup (symbol_table::scope_id,
                       symbol_table::context_id) const
   {
     // FIXME
     return 0;
   }
-
-  void
-  tree_classdef::accept (tree_walker& tw)
-  {
-    tw.visit_classdef (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -24,26 +24,25 @@ along with Octave; see the file COPYING.
 #define octave_tree_classdef_h 1
 
 #include "octave-config.h"
 
 class octave_value;
 
 #include "pt-cmd.h"
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "pt-id.h"
 
 #include "base-list.h"
 
 #include <list>
 
 namespace octave
 {
-  class tree_walker;
-
   class tree_classdef_attribute
   {
   public:
 
     tree_classdef_attribute (tree_identifier *i = 0, tree_expression *e = 0)
       : id (i), expr (e), neg (false) { }
 
     tree_classdef_attribute (tree_identifier *i, bool b)
@@ -62,17 +61,20 @@ namespace octave
     }
 
     tree_identifier *ident (void) { return id; }
 
     tree_expression *expression (void) { return expr; }
 
     bool negate (void) { return neg; }
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_attribute (*this);
+    }
 
   private:
 
     tree_identifier *id;
     tree_expression *expr;
     bool neg;
   };
 
@@ -91,17 +93,20 @@ namespace octave
 
     tree_classdef_attribute_list (const tree_classdef_attribute_list&) = delete;
 
     tree_classdef_attribute_list&
     operator = (const tree_classdef_attribute_list&) = delete;
 
     ~tree_classdef_attribute_list (void);
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_attribute_list (*this);
+    }
   };
 
   class tree_classdef_superclass
   {
   public:
 
     tree_classdef_superclass (const std::string& cname)
       : cls_name (cname) { }
@@ -112,17 +117,20 @@ namespace octave
 
     tree_classdef_superclass&
     operator = (const tree_classdef_superclass&) = delete;
 
     ~tree_classdef_superclass (void) = default;
 
     std::string class_name (void) { return cls_name; }
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_superclass (*this);
+    }
 
   private:
 
     std::string cls_name;
   };
 
   class tree_classdef_superclass_list : public octave::base_list<tree_classdef_superclass *>
   {
@@ -139,17 +147,20 @@ namespace octave
 
     tree_classdef_superclass_list (const tree_classdef_superclass_list&) = delete;
 
     tree_classdef_superclass_list&
     operator = (const tree_classdef_superclass_list&) = delete;
 
     ~tree_classdef_superclass_list (void);
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_superclass_list (*this);
+    }
   };
 
   template <typename T>
   class tree_classdef_element : public tree
   {
   public:
 
     tree_classdef_element (tree_classdef_attribute_list *a,
@@ -217,17 +228,20 @@ namespace octave
       delete id;
       delete expr;
     }
 
     tree_identifier *ident (void) { return id; }
 
     tree_expression *expression (void) { return expr; }
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_property (*this);
+    }
 
   private:
 
     tree_identifier *id;
     tree_expression *expr;
   };
 
   class tree_classdef_property_list : public octave::base_list<tree_classdef_property *>
@@ -245,17 +259,20 @@ namespace octave
 
     tree_classdef_property_list (const tree_classdef_property_list&) = delete;
 
     tree_classdef_property_list&
     operator = (const tree_classdef_property_list&) = delete;
 
     ~tree_classdef_property_list (void);
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_property_list (*this);
+    }
   };
 
   class tree_classdef_properties_block
     : public tree_classdef_element<tree_classdef_property *>
   {
   public:
 
     tree_classdef_properties_block (tree_classdef_attribute_list *a,
@@ -269,17 +286,20 @@ namespace octave
 
     tree_classdef_properties_block (const tree_classdef_properties_block&) = delete;
 
     tree_classdef_properties_block&
     operator = (const tree_classdef_properties_block&) = delete;
 
     ~tree_classdef_properties_block (void) = default;
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_properties_block (*this);
+    }
   };
 
   class tree_classdef_methods_list : public octave::base_list<octave_value>
   {
   public:
 
     tree_classdef_methods_list (void) { }
 
@@ -292,17 +312,20 @@ namespace octave
 
     tree_classdef_methods_list (const tree_classdef_methods_list&) = delete;
 
     tree_classdef_methods_list&
     operator = (const tree_classdef_methods_list&) = delete;
 
     ~tree_classdef_methods_list (void) = default;
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_methods_list (*this);
+    }
   };
 
   class tree_classdef_methods_block : public tree_classdef_element<octave_value>
   {
   public:
 
     tree_classdef_methods_block (tree_classdef_attribute_list *a,
                                  tree_classdef_methods_list *mlist,
@@ -314,17 +337,20 @@ namespace octave
 
     tree_classdef_methods_block (const tree_classdef_methods_block&) = delete;
 
     tree_classdef_methods_block&
     operator = (const tree_classdef_methods_block&) = delete;
 
     ~tree_classdef_methods_block (void) = default;
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_methods_block (*this);
+    }
   };
 
   class tree_classdef_event
   {
   public:
 
     tree_classdef_event (tree_identifier *i = 0) : id (i) { }
 
@@ -336,17 +362,20 @@ namespace octave
 
     ~tree_classdef_event (void)
     {
       delete id;
     }
 
     tree_identifier *ident (void) { return id; }
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_event (*this);
+    }
 
   private:
 
     tree_identifier *id;
   };
 
   class tree_classdef_events_list : public octave::base_list<tree_classdef_event *>
   {
@@ -363,17 +392,20 @@ namespace octave
 
     tree_classdef_events_list (const tree_classdef_events_list&) = delete;
 
     tree_classdef_events_list&
     operator = (const tree_classdef_events_list&) = delete;
 
     ~tree_classdef_events_list (void);
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_events_list (*this);
+    }
   };
 
   class tree_classdef_events_block
     : public tree_classdef_element<tree_classdef_event *>
   {
   public:
 
     tree_classdef_events_block (tree_classdef_attribute_list *a,
@@ -386,17 +418,20 @@ namespace octave
 
     tree_classdef_events_block (const tree_classdef_events_block&) = delete;
 
     tree_classdef_events_block&
     operator = (const tree_classdef_events_block&) = delete;
 
     ~tree_classdef_events_block (void) = default;
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_events_block (*this);
+    }
   };
 
   class tree_classdef_enum
   {
   public:
 
     tree_classdef_enum (void) : id (0), expr (0) { }
 
@@ -414,17 +449,20 @@ namespace octave
       delete id;
       delete expr;
     }
 
     tree_identifier *ident (void) { return id; }
 
     tree_expression *expression (void) { return expr; }
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_enum (*this);
+    }
 
   private:
 
     tree_identifier *id;
     tree_expression *expr;
   };
 
   class tree_classdef_enum_list : public octave::base_list<tree_classdef_enum *>
@@ -441,17 +479,20 @@ namespace octave
     // No copying!
 
     tree_classdef_enum_list (const tree_classdef_enum_list&) = delete;
 
     tree_classdef_enum_list& operator = (const tree_classdef_enum_list&) = delete;
 
     ~tree_classdef_enum_list (void);
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_enum_list (*this);
+    }
   };
 
   class tree_classdef_enum_block
     : public tree_classdef_element<tree_classdef_enum *>
   {
   public:
 
     tree_classdef_enum_block (tree_classdef_attribute_list *a,
@@ -464,17 +505,20 @@ namespace octave
 
     tree_classdef_enum_block (const tree_classdef_enum_block&) = delete;
 
     tree_classdef_enum_block&
     operator = (const tree_classdef_enum_block&) = delete;
 
     ~tree_classdef_enum_block (void) = default;
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_enum_block (*this);
+    }
   };
 
   class tree_classdef_body
   {
   public:
 
     typedef std::list<tree_classdef_properties_block *>::iterator properties_list_iterator;
     typedef std::list<tree_classdef_properties_block *>::const_iterator properties_list_const_iterator;
@@ -558,17 +602,20 @@ namespace octave
       return events_lst;
     }
 
     std::list<tree_classdef_enum_block *> enum_list (void)
     {
       return enum_lst;
     }
 
-    void accept (tree_walker&);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef_body (*this);
+    }
 
   private:
 
     std::list<tree_classdef_properties_block *> properties_lst;
 
     std::list<tree_classdef_methods_block *> methods_lst;
 
     std::list<tree_classdef_events_block *> events_lst;
@@ -616,22 +663,26 @@ namespace octave
 
     tree_classdef_body *body (void) { return element_list; }
 
     octave_comment_list *leading_comment (void) { return lead_comm; }
     octave_comment_list *trailing_comment (void) { return trail_comm; }
 
     const std::string& package_name (void) const { return pack_name; }
 
-    octave_function* make_meta_class (bool is_at_folder = false);
+    octave_function* make_meta_class (tree_evaluator *tw,
+                                      bool is_at_folder = false);
 
     tree_classdef *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_classdef (*this);
+    }
 
   private:
 
     tree_classdef_attribute_list *attr_list;
 
     tree_identifier *id;
 
     tree_classdef_superclass_list *supclass_list;
diff --git a/libinterp/parse-tree/pt-cmd.cc b/libinterp/parse-tree/pt-cmd.cc
--- a/libinterp/parse-tree/pt-cmd.cc
+++ b/libinterp/parse-tree/pt-cmd.cc
@@ -34,29 +34,17 @@ namespace octave
   tree_command *
   tree_no_op_command::dup (symbol_table::scope_id,
                            symbol_table::context_id) const
   {
     return new tree_no_op_command (orig_cmd, is_end_of_file (),
                                    line (), column ());
   }
 
-  void
-  tree_no_op_command::accept (tree_walker& tw)
-  {
-    tw.visit_no_op_command (*this);
-  }
-
   // Function definition.
 
   tree_command *
   tree_function_def::dup (symbol_table::scope_id,
                           symbol_table::context_id) const
   {
     return new tree_function_def (fcn, line (), column ());
   }
-
-  void
-  tree_function_def::accept (tree_walker& tw)
-  {
-    tw.visit_function_def (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-cmd.h b/libinterp/parse-tree/pt-cmd.h
--- a/libinterp/parse-tree/pt-cmd.h
+++ b/libinterp/parse-tree/pt-cmd.h
@@ -25,22 +25,21 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "ov-fcn.h"
 #include "pt.h"
 #include "pt-bp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
-
   // A base class for commands.
 
   class tree_command : public tree
   {
   public:
 
     tree_command (int l = -1, int c = -1)
       : tree (l, c) { }
@@ -73,17 +72,20 @@ namespace octave
 
     tree_no_op_command& operator = (const tree_no_op_command&) = delete;
 
     ~tree_no_op_command (void) = default;
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_no_op_command (*this);
+    }
 
     bool is_end_of_fcn_or_script (void) const
     {
       return (orig_cmd == "endfunction" || orig_cmd == "endscript");
     }
 
     bool is_end_of_file (void) const { return eof; }
 
@@ -111,17 +113,20 @@ namespace octave
 
     tree_function_def& operator = (const tree_function_def&) = delete;
 
     ~tree_function_def (void) = default;
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_function_def (*this);
+    }
 
     octave_value function (void) { return fcn; }
 
   private:
 
     octave_value fcn;
 
     tree_function_def (const octave_value& v, int l = -1, int c = -1)
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -60,78 +60,16 @@ namespace octave
     else
       op_limit = t;
 
     retval = this;
 
     return retval;
   }
 
-  octave_value_list
-  tree_colon_expression::rvalue (int nargout)
-  {
-    if (nargout > 1)
-      error ("invalid number of output arguments for colon expression");
-
-    return rvalue1 (nargout);
-  }
-
-  octave_value
-  tree_colon_expression::rvalue1 (int)
-  {
-    octave_value retval;
-
-    if (! op_base || ! op_limit)
-      return retval;
-
-    octave_value ov_base = op_base->rvalue1 ();
-
-    octave_value ov_limit = op_limit->rvalue1 ();
-
-    if (ov_base.is_object () || ov_limit.is_object ())
-      {
-        octave_value_list tmp1;
-
-        if (op_increment)
-          {
-            octave_value ov_increment = op_increment->rvalue1 ();
-
-            tmp1(2) = ov_limit;
-            tmp1(1) = ov_increment;
-            tmp1(0) = ov_base;
-          }
-        else
-          {
-            tmp1(1) = ov_limit;
-            tmp1(0) = ov_base;
-          }
-
-        octave_value fcn = symbol_table::find_function ("colon", tmp1);
-
-        if (! fcn.is_defined ())
-          error ("can not find overloaded colon function");
-
-        octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
-
-        retval = tmp2 (0);
-      }
-    else
-      {
-        octave_value ov_increment = 1.0;
-
-        if (op_increment)
-          ov_increment = op_increment->rvalue1 ();
-
-        retval = do_colon_op (ov_base, ov_increment, ov_limit,
-                              is_for_cmd_expr ());
-      }
-
-    return retval;
-  }
-
   void
   tree_colon_expression::eval_error (const std::string& s) const
   {
     error ("%s", s.c_str ());
   }
 
   int
   tree_colon_expression::line (void) const
@@ -161,15 +99,9 @@ namespace octave
                              op_increment ? op_increment->dup (scope, context)
                              : 0,
                              line (), column ());
 
     new_ce->copy_base (*new_ce);
 
     return new_ce;
   }
-
-  void
-  tree_colon_expression::accept (tree_walker& tw)
-  {
-    tw.visit_colon_expression (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -27,22 +27,21 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
-
   // Colon expressions.
 
   class tree_colon_expression : public tree_expression
   {
   public:
 
     tree_colon_expression (int l = -1, int c = -1)
       : tree_expression (l, c), op_base (0), op_limit (0),
@@ -80,35 +79,34 @@ namespace octave
     }
 
     void preserve_base (void) { save_base = true; }
 
     tree_colon_expression *append (tree_expression *t);
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     void eval_error (const std::string& s) const;
 
     tree_expression *base (void) { return op_base; }
 
     tree_expression *limit (void) { return op_limit; }
 
     tree_expression *increment (void) { return op_increment; }
 
     int line (void) const;
     int column (void) const;
 
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_colon_expression (*this);
+    }
 
   private:
 
     // The components of the expression.
     tree_expression *op_base;
     tree_expression *op_limit;
     tree_expression *op_increment;
 
diff --git a/libinterp/parse-tree/pt-const.cc b/libinterp/parse-tree/pt-const.cc
--- a/libinterp/parse-tree/pt-const.cc
+++ b/libinterp/parse-tree/pt-const.cc
@@ -52,39 +52,20 @@ namespace octave
                             bool pr_orig_text)
   {
     if (pr_orig_text && ! orig_text.empty ())
       os << orig_text;
     else
       val.print_raw (os, pr_as_read_syntax);
   }
 
-  octave_value_list
-  tree_constant::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    if (nargout > 1)
-      error ("invalid number of output arguments for constant expression");
-
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
-
   tree_expression *
   tree_constant::dup (symbol_table::scope_id,
                       symbol_table::context_id) const
   {
     tree_constant *new_tc
       = new tree_constant (val, orig_text, line (), column ());
 
     new_tc->copy_base (*this);
 
     return new_tc;
   }
-
-  void
-  tree_constant::accept (tree_walker& tw)
-  {
-    tw.visit_constant (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-const.h b/libinterp/parse-tree/pt-const.h
--- a/libinterp/parse-tree/pt-const.h
+++ b/libinterp/parse-tree/pt-const.h
@@ -28,22 +28,21 @@ along with Octave; see the file COPYING.
 #include <iosfwd>
 #include <string>
 
 class octave_value_list;
 
 #include "ov.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
-
   class tree_constant : public tree_expression
   {
   public:
 
     tree_constant (int l = -1, int c = -1)
       : tree_expression (l, c), val (), orig_text () { }
 
     tree_constant (const octave_value& v, int l = -1, int c = -1)
@@ -72,24 +71,25 @@ namespace octave
     void print (std::ostream& os, bool pr_as_read_syntax = false,
                 bool pr_orig_txt = true);
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int = 1) { return val; }
-
-    octave_value_list rvalue (int nargout);
+    octave_value value (void) { return val; }
 
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_constant (*this);
+    }
 
     // Store the original text corresponding to this constant for later
     // pretty printing.
 
     void stash_original_text (const std::string& s) { orig_text = s; }
 
     std::string original_text (void) const { return orig_text; }
 
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -42,69 +42,38 @@ namespace octave
   // Declarations (global, static, etc.).
 
   tree_decl_elt::~tree_decl_elt (void)
   {
     delete id;
     delete expr;
   }
 
-  bool
-  tree_decl_elt::eval (void)
-  {
-    bool retval = false;
-
-    if (id && expr)
-      {
-        octave_lvalue ult = id->lvalue ();
-
-        octave_value init_val = expr->rvalue1 ();
-
-        ult.assign (octave_value::op_asn_eq, init_val);
-
-        retval = true;
-      }
-
-    return retval;
-  }
-
   tree_decl_elt *
   tree_decl_elt::dup (symbol_table::scope_id scope,
                       symbol_table::context_id context) const
   {
     return new tree_decl_elt (id ? id->dup (scope, context) : 0,
                               expr ? expr->dup (scope, context) : 0);
   }
 
-  void
-  tree_decl_elt::accept (tree_walker& tw)
-  {
-    tw.visit_decl_elt (*this);
-  }
-
   // Initializer lists for declaration statements.
 
   tree_decl_init_list *
   tree_decl_init_list::dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const
   {
     tree_decl_init_list *new_dil = new tree_decl_init_list ();
 
     for (const tree_decl_elt* elt : *this)
       new_dil->append (elt ? elt->dup (scope, context) : 0);
 
     return new_dil;
   }
 
-  void
-  tree_decl_init_list::accept (tree_walker& tw)
-  {
-    tw.visit_decl_init_list (*this);
-  }
-
   // Base class for declaration commands (global, static).
 
   tree_decl_command::~tree_decl_command (void)
   {
     delete init_list;
   }
 
   // Global.
@@ -113,32 +82,20 @@ namespace octave
   tree_global_command::dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const
   {
     return
       new tree_global_command (init_list ? init_list->dup (scope, context) : 0,
                                line (), column ());
   }
 
-  void
-  tree_global_command::accept (tree_walker& tw)
-  {
-    tw.visit_global_command (*this);
-  }
-
   // Static.
 
   tree_command *
   tree_persistent_command::dup (symbol_table::scope_id scope,
                                 symbol_table::context_id context) const
   {
     return
       new tree_persistent_command (init_list ? init_list->dup (scope, context)
                                    : 0,
                                    line (), column ());
   }
-
-  void
-  tree_persistent_command::accept (tree_walker& tw)
-  {
-    tw.visit_persistent_command (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -26,25 +26,25 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <string>
 
 #include "base-list.h"
 #include "oct-lvalue.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
+  class tree_evaluator;
   class tree_expression;
   class tree_identifier;
 
-  class tree_walker;
-
   // List of expressions that make up a declaration statement.
 
   class tree_decl_elt
   {
   public:
 
     tree_decl_elt (tree_identifier *i = 0, tree_expression *e = 0)
       : id (i), expr (e) { }
@@ -52,60 +52,46 @@ namespace octave
     // No copying!
 
     tree_decl_elt (const tree_decl_elt&) = delete;
 
     tree_decl_elt& operator = (const tree_decl_elt&) = delete;
 
     ~tree_decl_elt (void);
 
-    bool eval (void);
-
     bool is_defined (void) { return id ? id->is_defined () : false; }
 
     bool is_variable (void) { return id ? id->is_variable () : false; }
 
     void mark_as_formal_parameter (void)
     {
       if (id)
         id->mark_as_formal_parameter ();
     }
 
     bool lvalue_ok (void) { return id ? id->lvalue_ok () : false; }
 
-    // Do not allow functions to return null values.
-    octave_value rvalue1 (int nargout = 1)
-    {
-      return id ? id->rvalue1 (nargout).storable_value () : octave_value ();
-    }
-
-    octave_value_list rvalue (int nargout)
+    octave_lvalue lvalue (tree_evaluator *tw)
     {
-      octave_value_list retval;
-
-      if (nargout > 1)
-        error ("invalid number of output arguments in declaration list");
-
-      retval = rvalue1 (nargout);
-
-      return retval;
+      return id ? id->lvalue (tw) : octave_lvalue ();
     }
 
-    octave_lvalue lvalue (void) { return id ? id->lvalue () : octave_lvalue (); }
-
     tree_identifier *ident (void) { return id; }
 
     std::string name (void) { return id ? id->name () : ""; }
 
     tree_expression *expression (void) { return expr; }
 
     tree_decl_elt *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_decl_elt (*this);
+    }
 
   private:
 
     // An identifier to tag with the declared property.
     tree_identifier *id;
 
     // An initializer expression (may be zero);
     tree_expression *expr;
@@ -133,17 +119,20 @@ namespace octave
           delete *p;
           erase (p);
         }
     }
 
     tree_decl_init_list *dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_decl_init_list (*this);
+    }
   };
 
   // Base class for declaration commands -- global, static, etc.
 
   class tree_decl_command : public tree_command
   {
   public:
 
@@ -193,17 +182,20 @@ namespace octave
 
     tree_global_command& operator = (const tree_global_command&) = delete;
 
     ~tree_global_command (void) = default;
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_global_command (*this);
+    }
 
   private:
 
     static void do_init (tree_decl_elt& elt);
   };
 
   // Persistent.
 
@@ -223,17 +215,20 @@ namespace octave
 
     tree_persistent_command& operator = (const tree_persistent_command&) = delete;
 
     ~tree_persistent_command (void) = default;
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_persistent_command (*this);
+    }
 
   private:
 
     static void do_init (tree_decl_elt& elt);
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -35,21 +35,25 @@ along with Octave; see the file COPYING.
 #include "call-stack.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
 #include "interpreter.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
-#include "variables.h"
+#include "ov-re-sparse.h"
+#include "ov-cx-sparse.h"
+#include "profiler.h"
 #include "pt-all.h"
 #include "pt-eval.h"
+#include "pt-tm-const.h"
 #include "symtab.h"
 #include "unwind-prot.h"
+#include "variables.h"
 
 //FIXME: This should be part of tree_evaluator
 #include "pt-jit.h"
 
 // Maximum nesting level for functions, scripts, or sourced files called
 // recursively.
 int Vmax_recursion_depth = 256;
 
@@ -70,49 +74,318 @@ namespace octave
   tree_evaluator::stmt_list_type tree_evaluator::statement_context
     = tree_evaluator::other;
 
   bool tree_evaluator::in_loop_command = false;
 
   // Normal evaluator.
 
   void
-  tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle&)
+  tree_evaluator::reset (void)
+  {
+    m_value_stack.clear ();
+    m_lvalue_list_stack.pop ();
+    m_nargout_stack.pop ();
+  }
+
+  void
+  tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle& expr)
   {
-    panic_impossible ();
+    // FIXME: should CMD_LIST be limited to a single expression?
+    // I think that is what Matlab does.
+
+    tree_parameter_list *param_list = expr.parameter_list ();
+    tree_parameter_list *ret_list = expr.return_list ();
+    tree_statement_list *cmd_list = expr.body ();
+    symbol_table::scope_id this_scope = expr.scope ();
+
+    symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
+
+    if (new_scope > 0)
+      symbol_table::inherit (new_scope, symbol_table::current_scope (),
+                             symbol_table::current_context ());
+
+    octave_user_function *uf
+      = new octave_user_function (new_scope,
+                                  param_list ? param_list->dup (new_scope, 0) : 0,
+                                  ret_list ? ret_list->dup (new_scope, 0) : 0,
+                                  cmd_list ? cmd_list->dup (new_scope, 0) : 0);
+
+    octave_function *curr_fcn = octave::call_stack::current ();
+
+    if (curr_fcn)
+      {
+        // FIXME: maybe it would be better to just stash curr_fcn
+        // instead of individual bits of info about it?
+
+        uf->stash_parent_fcn_name (curr_fcn->name ());
+        uf->stash_dir_name (curr_fcn->dir_name ());
+
+        symbol_table::scope_id parent_scope = curr_fcn->parent_fcn_scope ();
+
+        if (parent_scope < 0)
+          parent_scope = curr_fcn->scope ();
+
+        uf->stash_parent_fcn_scope (parent_scope);
+
+        if (curr_fcn->is_class_method () || curr_fcn->is_class_constructor ())
+          uf->stash_dispatch_class (curr_fcn->dispatch_class ());
+      }
+
+    uf->mark_as_anonymous_function ();
+    uf->stash_fcn_file_name (expr.file_name ());
+    uf->stash_fcn_location (expr.line (), expr.column ());
+
+    octave_value ov_fcn (uf);
+
+    octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn, this));
+
+    m_value_stack.push (ovl (fh));
   }
 
   void
   tree_evaluator::visit_argument_list (tree_argument_list&)
   {
     panic_impossible ();
   }
 
   void
-  tree_evaluator::visit_binary_expression (tree_binary_expression&)
+  tree_evaluator::visit_binary_expression (tree_binary_expression& expr)
   {
-    panic_impossible ();
+    octave_value val;
+
+    tree_expression *op_lhs = expr.lhs ();
+    tree_expression *op_rhs = expr.rhs ();
+    octave_value::binary_op etype = expr.op_type ();
+
+    if (expr.is_eligible_for_braindead_shortcircuit ())
+      {
+        if (op_lhs)
+          {
+            octave_value a = evaluate (op_lhs);
+
+            if (a.ndims () == 2 && a.rows () == 1 && a.columns () == 1)
+              {
+                bool result = false;
+
+                bool a_true = a.is_true ();
+
+                if (a_true)
+                  {
+                    if (etype == octave_value::op_el_or)
+                      {
+                        expr.matlab_style_short_circuit_warning ("|");
+                        m_value_stack.push (ovl (octave_value (true)));
+                        return;
+                      }
+                  }
+                else
+                  {
+                    if (etype == octave_value::op_el_and)
+                      {
+                        expr.matlab_style_short_circuit_warning ("&");
+                        m_value_stack.push (ovl (octave_value (false)));
+                        return;
+                      }
+                  }
+
+                if (op_rhs)
+                  {
+                    octave_value b = evaluate (op_rhs);
+
+                    result = b.is_true ();
+                  }
+
+                m_value_stack.push (ovl (octave_value (result)));
+                return;
+              }
+          }
+      }
+
+    if (op_lhs)
+      {
+        octave_value a = evaluate (op_lhs);
+
+        if (a.is_defined () && op_rhs)
+          {
+            octave_value b = evaluate (op_rhs);
+
+            if (b.is_defined ())
+              {
+                profile_data_accumulator::enter<tree_binary_expression>
+                  block (profiler, expr);
+
+                // Note: The profiler does not catch the braindead
+                // short-circuit evaluation code above, but that should be
+                // ok.  The evaluation of operands and the operator itself
+                // is entangled and it's not clear where to start/stop
+                // timing the operator to make it reasonable.
+
+                val = ::do_binary_op (etype, a, b);
+              }
+          }
+      }
+
+    m_value_stack.push (ovl (val));
+  }
+
+  void
+  tree_evaluator::visit_boolean_expression (tree_boolean_expression& expr)
+  {
+    octave_value val;
+
+    bool result = false;
+
+    // This evaluation is not caught by the profiler, since we can't find
+    // a reasonable place where to time.  Note that we don't want to
+    // include evaluation of LHS or RHS into the timing, but this is
+    // entangled together with short-circuit evaluation here.
+
+    tree_expression *op_lhs = expr.lhs ();
+
+    if (op_lhs)
+      {
+        octave_value a = evaluate (op_lhs);
+
+        bool a_true = a.is_true ();
+
+        tree_boolean_expression::type etype = expr.op_type ();
+
+        if (a_true)
+          {
+            if (etype == tree_boolean_expression::bool_or)
+              {
+                m_value_stack.push (ovl (octave_value (true)));
+                return;
+              }
+          }
+        else
+          {
+            if (etype == tree_boolean_expression::bool_and)
+              {
+                m_value_stack.push (ovl (octave_value (false)));
+                return;
+              }
+          }
+
+        tree_expression *op_rhs = expr.rhs ();
+
+        if (op_rhs)
+          {
+            octave_value b = evaluate (op_rhs);
+
+            result = b.is_true ();
+          }
+
+        val = octave_value (result);
+      }
+
+    m_value_stack.push (ovl (val));
+  }
+
+  void
+  tree_evaluator::visit_compound_binary_expression (tree_compound_binary_expression& expr)
+  {
+    octave_value val;
+
+    tree_expression *op_lhs = expr.lhs ();
+
+    if (op_lhs)
+      {
+        octave_value a = evaluate (op_lhs);
+
+        tree_expression *op_rhs = expr.rhs ();
+
+        if (a.is_defined () && op_rhs)
+          {
+            octave_value b = evaluate (op_rhs);
+
+            if (b.is_defined ())
+              {
+                octave_value::binary_op etype = expr.op_type ();                
+
+                val = ::do_binary_op (etype, a, b);
+              }
+          }
+      }
+
+    m_value_stack.push (ovl (val));
   }
 
   void
   tree_evaluator::visit_break_command (tree_break_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     if (in_loop_command)
       tree_break_command::breaking = 1;
     else
       error ("break must appear in a loop in the same file as loop command");
   }
 
   void
-  tree_evaluator::visit_colon_expression (tree_colon_expression&)
+  tree_evaluator::visit_colon_expression (tree_colon_expression& expr)
   {
-    panic_impossible ();
+    octave_value val;
+
+    tree_expression *op_base = expr.base ();
+    tree_expression *op_limit = expr.limit ();
+
+    if (! op_base || ! op_limit)
+      {
+        m_value_stack.push (ovl (octave_value (val)));
+        return;
+      }
+
+    octave_value ov_base = evaluate (op_base);
+
+    octave_value ov_limit = evaluate (op_limit);
+
+    tree_expression *op_increment = expr.increment ();
+
+    if (ov_base.is_object () || ov_limit.is_object ())
+      {
+        octave_value_list tmp1;
+
+        if (op_increment)
+          {
+            octave_value ov_increment = evaluate (op_increment);
+
+            tmp1(2) = ov_limit;
+            tmp1(1) = ov_increment;
+            tmp1(0) = ov_base;
+          }
+        else
+          {
+            tmp1(1) = ov_limit;
+            tmp1(0) = ov_base;
+          }
+
+        octave_value fcn = symbol_table::find_function ("colon", tmp1);
+
+        if (! fcn.is_defined ())
+          error ("can not find overloaded colon function");
+
+        octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
+
+        val = tmp2 (0);
+      }
+    else
+      {
+        octave_value ov_increment = 1.0;
+
+        if (op_increment)
+          ov_increment = evaluate (op_increment);
+
+        val = do_colon_op (ov_base, ov_increment, ov_limit,
+                           expr.is_for_cmd_expr ());
+      }
+
+    m_value_stack.push (ovl (val));
   }
 
   void
   tree_evaluator::visit_continue_command (tree_continue_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
@@ -129,101 +402,306 @@ namespace octave
   }
 
   bool
   tree_evaluator::statement_printing_enabled (void)
   {
     return ! (Vsilent_functions && (statement_context == function
                                     || statement_context == script));
   }
-}
-
-static inline void
-do_global_init (octave::tree_decl_elt& elt)
-{
-  octave::tree_identifier *id = elt.ident ();
-
-  if (id)
-    {
-      id->mark_global ();
-
-      octave_lvalue ult = id->lvalue ();
-
-      if (ult.is_undefined ())
-        {
-          octave::tree_expression *expr = elt.expression ();
-
-          octave_value init_val;
-
-          if (expr)
-            init_val = expr->rvalue1 ();
-          else
-            init_val = Matrix ();
-
-          ult.assign (octave_value::op_asn_eq, init_val);
-        }
-    }
-}
-
-static inline void
-do_static_init (octave::tree_decl_elt& elt)
-{
-  octave::tree_identifier *id = elt.ident ();
-
-  if (id)
-    {
-      id->mark_as_static ();
-
-      octave_lvalue ult = id->lvalue ();
-
-      if (ult.is_undefined ())
-        {
-          octave::tree_expression *expr = elt.expression ();
-
-          octave_value init_val;
-
-          if (expr)
-            init_val = expr->rvalue1 ();
-          else
-            init_val = Matrix ();
-
-          ult.assign (octave_value::op_asn_eq, init_val);
-        }
-    }
-}
-
-namespace octave
-{
+
+  octave_value
+  tree_evaluator::evaluate (tree_decl_elt *elt)
+  {
+    // Do not allow functions to return null values.
+
+    tree_identifier *id = elt->ident ();
+
+    return id ? evaluate (id).storable_value () : octave_value ();
+  }
+
+  void
+  tree_evaluator::initialize_undefined_parameter_list_elements
+    (tree_parameter_list *param_list, const std::string& warnfor,
+     int nargout, const octave_value& val)
+  {
+    bool warned = false;
+
+    int count = 0;
+
+    octave_value tmp = symbol_table::varval (".ignored.");
+    const Matrix ignored = tmp.is_defined () ? tmp.matrix_value () : Matrix ();
+
+    octave_idx_type k = 0;
+
+    for (tree_decl_elt* elt : *param_list)
+      {
+        if (++count > nargout)
+          break;
+
+        if (! elt->is_variable ())
+          {
+            if (! warned)
+              {
+                warned = true;
+
+                while (k < ignored.numel ())
+                  {
+                    octave_idx_type l = ignored (k);
+                    if (l == count)
+                      {
+                        warned = false;
+                        break;
+                      }
+                    else if (l > count)
+                      break;
+                    else
+                      k++;
+                  }
+
+                if (warned)
+                  {
+                    warning_with_id
+                      ("Octave:undefined-return-values",
+                       "%s: some elements in list of return values are undefined",
+                       warnfor.c_str ());
+                  }
+              }
+
+            octave_lvalue lval = elt->lvalue (this);
+
+            lval.assign (octave_value::op_asn_eq, val);
+          }
+      }
+  }
+
+  void
+  tree_evaluator::define_parameter_list_from_arg_vector
+    (tree_parameter_list *param_list, const octave_value_list& args)
+  {
+    int i = -1;
+
+    for (tree_decl_elt* elt : *param_list)
+      {
+        i++;
+
+        octave_lvalue ref = elt->lvalue (this);
+
+        if (i < args.length ())
+          {
+            if (args(i).is_defined () && args(i).is_magic_colon ())
+              {
+                if (! eval_decl_elt (elt))
+                  error ("no default value for argument %d", i+1);
+              }
+            else
+              ref.define (args(i));
+          }
+        else
+          eval_decl_elt (elt);
+      }
+  }
+
   void
-  tree_evaluator::do_decl_init_list (decl_elt_init_fcn fcn,
-                                     tree_decl_init_list *init_list)
+  tree_evaluator::undefine_parameter_list (tree_parameter_list *param_list)
+  {
+    for (tree_decl_elt* elt : *param_list)
+      {
+        octave_lvalue ref = elt->lvalue (this);
+
+        ref.assign (octave_value::op_asn_eq, octave_value ());
+      }
+  }
+
+  octave_value_list
+  tree_evaluator::convert_parameter_list_to_const_vector
+    (tree_parameter_list *param_list, int nargout, const Cell& varargout)
+  {
+    octave_idx_type vlen = varargout.numel ();
+    int len = param_list->length ();
+
+    // Special case.  Will do a shallow copy.
+    if (len == 0)
+      return varargout;
+    else if (nargout <= len)
+      {
+        octave_value_list retval (nargout);
+
+        int i = 0;
+
+        for (tree_decl_elt* elt : *param_list)
+          {
+            if (elt->is_defined ())
+              retval(i++) = evaluate (elt);
+            else
+              break;
+          }
+
+        return retval;
+      }
+    else
+      {
+        octave_value_list retval (len + vlen);
+
+        int i = 0;
+
+        for (tree_decl_elt* elt : *param_list)
+          retval(i++) = evaluate (elt);
+
+        for (octave_idx_type j = 0; j < vlen; j++)
+          retval(i++) = varargout(j);
+
+        return retval;
+      }
+  }
+
+  bool
+  tree_evaluator::eval_decl_elt (tree_decl_elt *elt)
+  {
+    bool retval = false;
+
+    tree_identifier *id = elt->ident ();
+    tree_expression *expr = elt->expression ();
+
+    if (id && expr)
+      {
+        octave_lvalue ult = id->lvalue (this);
+
+        octave_value init_val = evaluate (expr);
+
+        ult.assign (octave_value::op_asn_eq, init_val);
+
+        retval = true;
+      }
+
+    return retval;
+  }
+
+  bool
+  tree_evaluator::switch_case_label_matches (tree_switch_case *expr,
+                                             const octave_value& val)
   {
-    if (init_list)
+    tree_expression *label = expr->case_label ();
+
+    octave_value label_value = evaluate (label);
+
+    if (label_value.is_defined ())
+      {
+        if (label_value.is_cell ())
+          {
+            Cell cell (label_value.cell_value ());
+
+            for (octave_idx_type i = 0; i < cell.rows (); i++)
+              {
+                for (octave_idx_type j = 0; j < cell.columns (); j++)
+                  {
+                    bool match = val.is_equal (cell(i,j));
+
+                    if (match)
+                      return true;
+                  }
+              }
+          }
+        else
+          return val.is_equal (label_value);
+      }
+
+    return false;
+  }
+
+  void
+  tree_evaluator::do_global_init (octave::tree_decl_elt& elt)
+  {
+    octave::tree_identifier *id = elt.ident ();
+
+    if (id)
       {
-        for (tree_decl_elt* elt : *init_list)
-          fcn (*elt);
+        id->mark_global ();
+
+        octave_lvalue ult = id->lvalue (this);
+
+        if (ult.is_undefined ())
+          {
+            octave::tree_expression *expr = elt.expression ();
+
+            octave_value init_val;
+
+            if (expr)
+              init_val = evaluate (expr);
+            else
+              init_val = Matrix ();
+
+            ult.assign (octave_value::op_asn_eq, init_val);
+          }
+      }
+  }
+
+  void
+  tree_evaluator::do_static_init (octave::tree_decl_elt& elt)
+  {
+    octave::tree_identifier *id = elt.ident ();
+
+    if (id)
+      {
+        id->mark_as_static ();
+
+        octave_lvalue ult = id->lvalue (this);
+
+        if (ult.is_undefined ())
+          {
+            octave::tree_expression *expr = elt.expression ();
+
+            octave_value init_val;
+
+            if (expr)
+              init_val = evaluate (expr);
+            else
+              init_val = Matrix ();
+
+            ult.assign (octave_value::op_asn_eq, init_val);
+          }
       }
   }
 
   void
   tree_evaluator::visit_global_command (tree_global_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
-    do_decl_init_list (do_global_init, cmd.initializer_list ());
+    tree_decl_init_list *init_list = cmd.initializer_list ();
+
+    if (init_list)
+      {
+        // If we called init_list->accept (*this), we would need a way
+        // to tell tree_evaluator::visit_decl_init_list that we are
+        // evaluating a global init list.
+
+        for (tree_decl_elt* elt : *init_list)
+          do_global_init (*elt);
+      }
   }
 
   void
   tree_evaluator::visit_persistent_command (tree_persistent_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
-    do_decl_init_list (do_static_init, cmd.initializer_list ());
+    tree_decl_init_list *init_list = cmd.initializer_list ();
+
+    if (init_list)
+      {
+        // If we called init_list->accept (*this), we would need a way
+        // to tell tree_evaluator::visit_decl_init_list that we are
+        // evaluating a static init list.
+
+        for (tree_decl_elt* elt : *init_list)
+          do_static_init (*elt);
+      }
   }
 
   void
   tree_evaluator::visit_decl_elt (tree_decl_elt&)
   {
     panic_impossible ();
   }
 
@@ -269,29 +747,29 @@ namespace octave
     octave::unwind_protect frame;
 
     frame.protect_var (in_loop_command);
 
     in_loop_command = true;
 
     tree_expression *expr = cmd.control_expr ();
 
-    octave_value rhs = expr->rvalue1 ();
+    octave_value rhs = evaluate (expr);
 
 #if defined (HAVE_LLVM)
     if (tree_jit::execute (cmd, rhs))
       return;
 #endif
 
     if (rhs.is_undefined ())
       return;
 
     tree_expression *lhs = cmd.left_hand_side ();
 
-    octave_lvalue ult = lhs->lvalue ();
+    octave_lvalue ult = lhs->lvalue (this);
 
     tree_statement_list *loop_body = cmd.body ();
 
     if (rhs.is_range ())
       {
         Range rng = rhs.range_value ();
 
         octave_idx_type steps = rng.numel ();
@@ -381,17 +859,17 @@ namespace octave
     octave::unwind_protect frame;
 
     frame.protect_var (in_loop_command);
 
     in_loop_command = true;
 
     tree_expression *expr = cmd.control_expr ();
 
-    octave_value rhs = expr->rvalue1 ();
+    octave_value rhs = evaluate (expr);
 
     if (rhs.is_undefined ())
       return;
 
     if (! rhs.is_map ())
       error ("in statement 'for [X, Y] = VAL', VAL must be a structure");
 
     // Cycle through structure elements.  First element of id_list
@@ -399,21 +877,21 @@ namespace octave
     // structure element.
 
     tree_argument_list *lhs = cmd.left_hand_side ();
 
     tree_argument_list::iterator p = lhs->begin ();
 
     tree_expression *elt = *p++;
 
-    octave_lvalue val_ref = elt->lvalue ();
+    octave_lvalue val_ref = elt->lvalue (this);
 
     elt = *p;
 
-    octave_lvalue key_ref = elt->lvalue ();
+    octave_lvalue key_ref = elt->lvalue (this);
 
     const octave_map tmp_val = rhs.map_value ();
 
     tree_statement_list *loop_body = cmd.body ();
 
     string_vector keys = tmp_val.keys ();
 
     octave_idx_type nel = keys.numel ();
@@ -437,22 +915,24 @@ namespace octave
         if (quit_loop_now ())
           break;
       }
   }
 
   void
   tree_evaluator::visit_octave_user_script (octave_user_script&)
   {
+    // ??
     panic_impossible ();
   }
 
   void
   tree_evaluator::visit_octave_user_function (octave_user_function&)
   {
+    // ??
     panic_impossible ();
   }
 
   void
   tree_evaluator::visit_octave_user_function_header (octave_user_function&)
   {
     panic_impossible ();
   }
@@ -479,19 +959,75 @@ namespace octave
         // Make sure that any variable with the same name as the new
         // function is cleared.
 
         symbol_table::assign (nm);
       }
   }
 
   void
-  tree_evaluator::visit_identifier (tree_identifier&)
+  tree_evaluator::visit_identifier (tree_identifier& expr)
   {
-    panic_impossible ();
+    octave_value_list retval;
+
+    symbol_table::symbol_reference sym = expr.symbol ();
+
+    octave_value val = sym->find ();
+
+    if (val.is_defined ())
+      {
+        // GAGME -- this would be cleaner if we required
+        // parens to indicate function calls.
+        //
+        // If this identifier refers to a function, we need to know
+        // whether it is indexed so that we can do the same thing
+        // for 'f' and 'f()'.  If the index is present and the function
+        // object declares it can handle it, return the function object
+        // and let tree_index_expression::rvalue handle indexing.
+        // Otherwise, arrange to call the function here, so that we don't
+        // return the function definition as a value.
+
+        octave_function *fcn = 0;
+
+        if (val.is_function ())
+          fcn = val.function_value (true);
+
+        int nargout = m_nargout_stack.top ();
+
+        if (fcn && ! (expr.is_postfix_indexed ()
+                      && fcn->is_postfix_index_handled (expr.postfix_index ())))
+          {
+            octave_value_list tmp_args;
+
+            const std::list<octave_lvalue> *lvalue_list
+              = m_lvalue_list_stack.top ();
+
+            retval = (lvalue_list
+                      ? val.do_multi_index_op (nargout, tmp_args, lvalue_list)
+                      : val.do_multi_index_op (nargout, tmp_args));
+          }
+        else
+          {
+            if (expr.print_result () && nargout == 0
+                && octave::tree_evaluator::statement_printing_enabled ())
+              {
+                octave_value_list args = ovl (val);
+                args.stash_name_tags (string_vector (expr.name ()));
+                octave::feval ("display", args);
+              }
+
+            retval = val;
+          }
+      }
+    else if (sym->is_added_static ())
+      expr.static_workspace_error ();
+    else
+      expr.eval_undefined_error ();
+
+    m_value_stack.push (retval);
   }
 
   void
   tree_evaluator::visit_if_clause (tree_if_clause&)
   {
     panic_impossible ();
   }
 
@@ -512,93 +1048,829 @@ namespace octave
         tree_expression *expr = tic->condition ();
 
         if (statement_context == function || statement_context == script)
           octave::call_stack::set_location (tic->line (), tic->column ());
 
         if (debug_mode && ! tic->is_else_clause ())
           do_breakpoint (tic->is_breakpoint (true));
 
-        if (tic->is_else_clause () || expr->is_logically_true ("if"))
+        if (tic->is_else_clause () || is_logically_true (expr, "if"))
           {
             tree_statement_list *stmt_lst = tic->commands ();
 
             if (stmt_lst)
               stmt_lst->accept (*this);
 
             break;
           }
       }
   }
-
+}
+
+static inline octave_value_list
+make_value_list (octave::tree_evaluator *tw, octave::tree_argument_list *args,
+                 const string_vector& arg_nm,
+                 const octave_value *object, bool rvalue = true)
+{
+  octave_value_list retval;
+
+  if (args)
+    {
+      if (rvalue && object && args->has_magic_end () && object->is_undefined ())
+        err_invalid_inquiry_subscript ();
+
+      retval = args->convert_to_const_vector (tw, object);
+    }
+
+  octave_idx_type n = retval.length ();
+
+  if (n > 0)
+    retval.stash_name_tags (arg_nm);
+
+  return retval;
+}
+
+// Final step of processing an indexing error.  Add the name of the
+// variable being indexed, if any, then issue an error.  (Will this also
+// be needed by pt-lvalue, which calls subsref?)
+
+static void
+final_index_error (octave::index_exception& e,
+                   const octave::tree_expression *expr)
+{
+  std::string extra_message;
+
+  if (expr->is_identifier ()
+      && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable ())
+    {
+      std::string var = expr->name ();
+
+      e.set_var (var);
+
+      octave_value fcn = symbol_table::find_function (var);
+
+      if (fcn.is_function ())
+        {
+          octave_function *fp = fcn.function_value ();
+
+          if (fp && fp->name () == var)
+            extra_message = " (note: variable '" + var + "' shadows function)";
+        }
+    }
+
+  std::string msg = e.message () + extra_message;
+
+  error_with_id (e.err_id (), msg.c_str ());
+}
+
+namespace octave
+{
   void
-  tree_evaluator::visit_index_expression (tree_index_expression&)
+  tree_evaluator::visit_index_expression (tree_index_expression& idx_expr)
+  {
+    octave_value_list retval;
+
+    int nargout = m_nargout_stack.top ();
+    
+    octave_value first_expr_val;
+
+    octave_value_list first_args;
+
+    bool have_args = false;
+
+    tree_expression *expr = idx_expr.expression ();
+    std::list<tree_argument_list *> args = idx_expr.arg_lists ();
+    std::string type = idx_expr.type_tags ();
+    std::list<string_vector> arg_nm = idx_expr.arg_names ();
+    std::list<tree_expression *> dyn_field = idx_expr.dyn_fields ();
+
+    if (expr->is_identifier () && type[0] == '(')
+      {
+        tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
+
+        if (! (id->is_variable () || args.empty ()))
+          {
+            tree_argument_list *al = *(args.begin ());
+
+            size_t n = al ? al->length () : 0;
+
+            if (n > 0)
+              {
+                string_vector anm = *(arg_nm.begin ());
+                have_args = true;
+                first_args = al -> convert_to_const_vector (this);
+                first_args.stash_name_tags (anm);
+
+                first_expr_val = id->do_lookup  (first_args);
+              }
+          }
+      }
+
+    if (first_expr_val.is_undefined ())
+      first_expr_val = evaluate (expr);
+
+    octave_value tmp = first_expr_val;
+    octave_idx_type tmpi = 0;
+
+    std::list<octave_value_list> idx;
+
+    int n = args.size ();
+
+    std::list<tree_argument_list *>::iterator p_args = args.begin ();
+    std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
+    std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
+
+    for (int i = 0; i < n; i++)
+      {
+        if (i > 0)
+          {
+            tree_argument_list *al = *p_args;
+
+            // In Matlab, () can only be followed by '.'.  In Octave, we
+            // do not enforce this for rvalue expressions, but we'll
+            // split the evaluation at this point.  This will,
+            // hopefully, allow Octave's looser rules apply smoothly for
+            // Matlab overloaded subsref codes.
+
+            // We might have an expression like
+            //
+            //   x{end}.a(end)
+            //
+            // and we are looking at the argument list that contains the
+            // second (or third, etc.) "end" token, so we must evaluate
+            // everything up to the point of that argument list so we
+            // can pass the appropriate value to the built-in end
+            // function.
+
+            // An expression like
+            //
+            //    s.a (f (1:end))
+            //
+            // can mean a lot of different things depending on the types
+            // of s, a, and f.  Let's just say it's complicated and that
+            // the following code is definitely not correct in all
+            // cases.  That it is already so complex makes me think that
+            // there must be a better way.
+
+            bool split = ((type[i-1] == '(' && type[i] != '.')
+                          || (al && al->has_magic_end ()
+                              && ! tmp.is_classdef_object ()));
+
+            if (split)
+              {
+                try
+                  {
+                    octave_value_list tmp_list
+                      =tmp.subsref (type.substr (tmpi, i-tmpi), idx, nargout);
+
+                    tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
+                    tmpi = i;
+                    idx.clear ();
+
+                    if (tmp.is_cs_list ())
+                      err_indexed_cs_list ();
+
+                    if (tmp.is_function ())
+                      {
+                        octave_function *fcn = tmp.function_value (true);
+
+                        if (fcn && ! fcn->is_postfix_index_handled (type[i]))
+                          {
+                            octave_value_list empty_args;
+
+                            tmp_list = tmp.do_multi_index_op (1, empty_args);
+                            tmp = (tmp_list.length ()
+                                   ? tmp_list(0) : octave_value ());
+
+                            if (tmp.is_cs_list ())
+                              err_indexed_cs_list ();
+                          }
+                      }
+                  }
+                catch (octave::index_exception& e)  // problems with index range, type etc.
+                  {
+                    final_index_error (e, expr);
+                  }
+              }
+          }
+
+        switch (type[i])
+          {
+          case '(':
+            if (have_args)
+              {
+                idx.push_back (first_args);
+                have_args = false;
+              }
+            else
+              idx.push_back (make_value_list (this, *p_args, *p_arg_nm, &tmp));
+            break;
+
+          case '{':
+            idx.push_back (make_value_list (this, *p_args, *p_arg_nm, &tmp));
+            break;
+
+          case '.':
+            idx.push_back (octave_value
+                           (idx_expr.get_struct_index (this, p_arg_nm, p_dyn_field)));
+            break;
+
+          default:
+            panic_impossible ();
+          }
+
+        p_args++;
+        p_arg_nm++;
+        p_dyn_field++;
+      }
+
+    const std::list<octave_lvalue> *lvalue_list = m_lvalue_list_stack.top ();
+
+    try
+      {
+        retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
+                              lvalue_list);
+      }
+    catch (octave::index_exception& e)  // range problems, bad index type, etc.
+      {
+        final_index_error (e, expr);
+      }
+
+    octave_value val = retval.length () ? retval(0) : octave_value ();
+
+    if (val.is_function ())
+      {
+        octave_function *fcn = val.function_value (true);
+
+        if (fcn)
+          {
+            octave_value_list empty_args;
+
+            retval = (lvalue_list
+                      ? val.do_multi_index_op (nargout, empty_args,
+                                               lvalue_list)
+                      : val.do_multi_index_op (nargout, empty_args));
+          }
+      }
+
+    m_value_stack.push (retval);
+  }
+  
+  void
+  tree_evaluator::visit_matrix (tree_matrix& expr)
   {
-    panic_impossible ();
+    octave_value retval = Matrix ();
+
+    bool all_strings_p = false;
+    bool all_sq_strings_p = false;
+    bool all_dq_strings_p = false;
+    bool all_empty_p = false;
+    bool all_real_p = false;
+    bool any_sparse_p = false;
+    bool any_class_p = false;
+    bool frc_str_conv = false;
+
+    tm_const tmp (expr, this);
+
+    if (tmp && ! tmp.empty ())
+      {
+        dim_vector dv = tmp.dims ();
+        all_strings_p = tmp.all_strings_p ();
+        all_sq_strings_p = tmp.all_sq_strings_p ();
+        all_dq_strings_p = tmp.all_dq_strings_p ();
+        all_empty_p = tmp.all_empty_p ();
+        all_real_p = tmp.all_real_p ();
+        any_sparse_p = tmp.any_sparse_p ();
+        any_class_p = tmp.any_class_p ();
+        frc_str_conv = tmp.some_strings_p ();
+
+        // Try to speed up the common cases.
+
+        std::string result_type = tmp.class_name ();
+
+        if (any_class_p)
+          {
+            retval = do_class_concat (tmp);
+          }
+        else if (result_type == "double")
+          {
+            if (any_sparse_p)
+              {
+                if (all_real_p)
+                  retval = do_single_type_concat<SparseMatrix> (dv, tmp);
+                else
+                  retval = do_single_type_concat<SparseComplexMatrix> (dv, tmp);
+              }
+            else
+              {
+                if (all_real_p)
+                  retval = do_single_type_concat<NDArray> (dv, tmp);
+                else
+                  retval = do_single_type_concat<ComplexNDArray> (dv, tmp);
+              }
+          }
+        else if (result_type == "single")
+          {
+            if (all_real_p)
+              retval = do_single_type_concat<FloatNDArray> (dv, tmp);
+            else
+              retval = do_single_type_concat<FloatComplexNDArray> (dv, tmp);
+          }
+        else if (result_type == "char")
+          {
+            char type = all_dq_strings_p ? '"' : '\'';
+
+            if (! all_strings_p)
+              warn_implicit_conversion ("Octave:num-to-str",
+                                        "numeric", result_type);
+            else
+              maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
+
+            charNDArray result (dv, Vstring_fill_char);
+
+            single_type_concat<charNDArray> (result, tmp);
+
+            retval = octave_value (result, type);
+          }
+        else if (result_type == "logical")
+          {
+            if (any_sparse_p)
+              retval = do_single_type_concat<SparseBoolMatrix> (dv, tmp);
+            else
+              retval = do_single_type_concat<boolNDArray> (dv, tmp);
+          }
+        else if (result_type == "int8")
+          retval = do_single_type_concat<int8NDArray> (dv, tmp);
+        else if (result_type == "int16")
+          retval = do_single_type_concat<int16NDArray> (dv, tmp);
+        else if (result_type == "int32")
+          retval = do_single_type_concat<int32NDArray> (dv, tmp);
+        else if (result_type == "int64")
+          retval = do_single_type_concat<int64NDArray> (dv, tmp);
+        else if (result_type == "uint8")
+          retval = do_single_type_concat<uint8NDArray> (dv, tmp);
+        else if (result_type == "uint16")
+          retval = do_single_type_concat<uint16NDArray> (dv, tmp);
+        else if (result_type == "uint32")
+          retval = do_single_type_concat<uint32NDArray> (dv, tmp);
+        else if (result_type == "uint64")
+          retval = do_single_type_concat<uint64NDArray> (dv, tmp);
+        else if (result_type == "cell")
+          retval = do_single_type_concat<Cell> (dv, tmp);
+        else if (result_type == "struct")
+          retval = do_single_type_concat<octave_map> (dv, tmp);
+        else
+          {
+            // The line below might seem crazy, since we take a copy of
+            // the first argument, resize it to be empty and then resize
+            // it to be full.  This is done since it means that there is
+            // no recopying of data, as would happen if we used a single
+            // resize.  It should be noted that resize operation is also
+            // significantly slower than the do_cat_op function, so it
+            // makes sense to have an empty matrix and copy all data.
+            //
+            // We might also start with a empty octave_value using
+            //
+            //    ctmp = octave_value_typeinfo::lookup_type
+            //          (tmp.begin() -> begin() -> type_name());
+            //
+            // and then directly resize.  However, for some types there
+            // might be some additional setup needed, and so this should
+            // be avoided.
+
+            octave_value ctmp;
+
+            // Find the first non-empty object
+
+            if (any_sparse_p)
+              {
+                // Start with sparse matrix to avoid issues memory issues
+                // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
+                if (all_real_p)
+                  ctmp = octave_sparse_matrix ().resize (dv);
+                else
+                  ctmp = octave_sparse_complex_matrix ().resize (dv);
+              }
+            else
+              {
+                for (tm_row_const& row : tmp)
+                  {
+                    octave_quit ();
+
+                    for (auto& elt : row)
+                      {
+                        octave_quit ();
+
+                        ctmp = elt;
+
+                        if (! ctmp.all_zero_dims ())
+                          goto found_non_empty;
+                      }
+                  }
+
+                ctmp = (*(tmp.begin () -> begin ()));
+
+              found_non_empty:
+
+                if (! all_empty_p)
+                  ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
+              }
+
+            // Now, extract the values from the individual elements and
+            // insert them in the result matrix.
+
+            int dv_len = dv.ndims ();
+            octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
+            Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
+
+            for (tm_row_const& row : tmp)
+              {
+                octave_quit ();
+
+                for (auto& elt : row)
+                  {
+                    octave_quit ();
+
+                    if (elt.is_empty ())
+                      continue;
+
+                    ctmp = do_cat_op (ctmp, elt, ra_idx);
+
+                    ra_idx (1) += elt.columns ();
+                  }
+
+                ra_idx (0) += row.rows ();
+                ra_idx (1) = 0;
+              }
+
+            retval = ctmp;
+
+            if (frc_str_conv && ! retval.is_string ())
+              retval = retval.convert_to_str ();
+          }
+      }
+
+    m_value_stack.push (retval);
   }
 
   void
-  tree_evaluator::visit_matrix (tree_matrix&)
+  tree_evaluator::visit_cell (tree_cell& expr)
   {
-    panic_impossible ();
+    octave_value retval;
+
+    octave_idx_type nr = expr.length ();
+    octave_idx_type nc = -1;
+
+    Cell val;
+
+    octave_idx_type i = 0;
+
+    for (tree_argument_list* elt : expr)
+      {
+        octave_value_list row = elt->convert_to_const_vector (this);
+
+        if (nr == 1)
+          // Optimize the single row case.
+          val = row.cell_value ();
+        else if (nc < 0)
+          {
+            nc = row.length ();
+
+            val = Cell (nr, nc);
+          }
+        else
+          {
+            octave_idx_type this_nc = row.length ();
+
+            if (this_nc != nc)
+              {
+                if (this_nc == 0)
+                  continue;  // blank line
+                else
+                  error ("number of columns must match");
+              }
+          }
+
+        for (octave_idx_type j = 0; j < nc; j++)
+          val(i,j) = row(j);
+
+        i++;
+      }
+
+    if (i < nr)
+      val.resize (dim_vector (i, nc));  // there were blank rows
+
+    retval = val;
+
+    m_value_stack.push (retval);
   }
 
   void
-  tree_evaluator::visit_cell (tree_cell&)
+  tree_evaluator::visit_multi_assignment (tree_multi_assignment& expr)
   {
-    panic_impossible ();
-  }
-
-  void
-  tree_evaluator::visit_multi_assignment (tree_multi_assignment&)
-  {
-    panic_impossible ();
+    octave_value_list val;
+
+    tree_expression *rhs = expr.right_hand_side ();
+
+    if (rhs)
+      {
+        tree_argument_list *lhs = expr.left_hand_side ();
+
+        std::list<octave_lvalue> lvalue_list = lhs->lvalue_list (this);
+
+        octave_idx_type n_out = 0;
+
+        for (const auto& lval : lvalue_list)
+          n_out += lval.numel ();
+
+        // The following trick is used to keep rhs_val constant.
+        const octave_value_list rhs_val1 = evaluate_n (rhs, n_out, &lvalue_list);
+        const octave_value_list rhs_val = (rhs_val1.length () == 1
+                                           && rhs_val1(0).is_cs_list ()
+                                           ? rhs_val1(0).list_value ()
+                                           : rhs_val1);
+
+        octave_idx_type k = 0;
+
+        octave_idx_type n = rhs_val.length ();
+
+        // To avoid copying per elements and possible optimizations, we
+        // postpone joining the final values.
+        std::list<octave_value_list> retval_list;
+
+        tree_argument_list::iterator q = lhs->begin ();
+
+        for (octave_lvalue ult : lvalue_list)
+          {
+            tree_expression *lhs_elt = *q++;
+
+            octave_idx_type nel = ult.numel ();
+
+            if (nel != 1)
+              {
+                // Huge kluge so that wrapper scripts with lines like
+                //
+                //   [varargout{1:nargout}] = fcn (args);
+                //
+                // Will work the same as calling fcn directly when nargout
+                // is 0 and fcn produces more than one output even when
+                // nargout is 0.  This only works if varargout has not yet
+                // been defined.  See also bug #43813.
+
+                if (lvalue_list.size () == 1 && nel == 0 && n > 0
+                    && ! ult.is_black_hole () && ult.is_undefined ()
+                    && ult.index_type () == "{" && ult.index_is_empty ())
+                  {
+                    // Convert undefined lvalue with empty index to a cell
+                    // array with a single value and indexed by 1 to
+                    // handle a single output.
+
+                    nel = 1;
+
+                    ult.define (Cell (1, 1));
+
+                    ult.clear_index ();
+                    std::list<octave_value_list> idx;
+                    idx.push_back (octave_value_list (octave_value (1)));
+                    ult.set_index ("{", idx);
+                  }
+
+                if (k + nel > n)
+                  error ("some elements undefined in return list");
+
+                // This element of the return list expects a
+                // comma-separated list of values.  Slicing avoids
+                // copying.
+
+                octave_value_list ovl = rhs_val.slice (k, nel);
+
+                ult.assign (octave_value::op_asn_eq, octave_value (ovl));
+
+                retval_list.push_back (ovl);
+
+                k += nel;
+              }
+            else
+              {
+                if (k < n)
+                  {
+                    ult.assign (octave_value::op_asn_eq, rhs_val(k));
+
+                    if (ult.is_black_hole ())
+                      {
+                        k++;
+                        continue;
+                      }
+                    else
+                      {
+                        retval_list.push_back (rhs_val(k));
+
+                        k++;
+                      }
+                  }
+                else
+                  {
+                    // This can happen for a function like
+                    //
+                    //   function varargout = f ()
+                    //     varargout{1} = nargout;
+                    //   endfunction
+                    //
+                    // called with
+                    //
+                    //    [a, ~] = f ();
+                    //
+                    // Then the list of of RHS values will contain one
+                    // element but we are iterating over the list of all
+                    // RHS values.  We shouldn't complain that a value we
+                    // don't need is missing from the list.
+
+                    if (! ult.is_black_hole ())
+                      error ("element number %d undefined in return list", k+1);
+
+                    k++;
+                    continue;
+                  }
+              }
+
+            if (expr.print_result ()
+                && octave::tree_evaluator::statement_printing_enabled ())
+              {
+                // We clear any index here so that we can get
+                // the new value of the referenced object below,
+                // instead of the indexed value (which should be
+                // the same as the right hand side value).
+
+                ult.clear_index ();
+
+                octave_value lhs_val = ult.value ();
+
+                octave_value_list args = ovl (lhs_val);
+                args.stash_name_tags (string_vector (lhs_elt->name ()));
+                octave::feval ("display", args);
+              }
+          }
+
+        // Concatenate return values.
+        val = retval_list;
+      }
+
+    m_value_stack.push (val);
   }
 
   void
   tree_evaluator::visit_no_op_command (tree_no_op_command& cmd)
   {
     if (debug_mode && cmd.is_end_of_fcn_or_script ())
       do_breakpoint (cmd.is_breakpoint (true), true);
   }
 
   void
-  tree_evaluator::visit_constant (tree_constant&)
+  tree_evaluator::visit_constant (tree_constant& expr)
   {
-    panic_impossible ();
+    int nargout = m_nargout_stack.top ();
+
+    if (nargout > 1)
+      error ("invalid number of output arguments for constant expression");
+
+    m_value_stack.push (ovl (expr.value ()));
+  }
+
+  void
+  tree_evaluator::visit_fcn_handle (tree_fcn_handle& expr)
+  {
+    std::string nm = expr.name ();
+
+    octave_value fh = make_fcn_handle (nm);
+
+    m_value_stack.push (ovl (fh));
   }
 
   void
-  tree_evaluator::visit_fcn_handle (tree_fcn_handle&)
+  tree_evaluator::visit_funcall (tree_funcall& expr)
   {
-    panic_impossible ();
-  }
-
-  void
-  tree_evaluator::visit_funcall (tree_funcall&)
-  {
-    panic_impossible ();
+    octave_value_list retval;
+
+    octave_value fcn = expr.function ();
+
+    octave_value_list args = expr.arguments ();
+
+    int nargout = m_nargout_stack.top ();
+
+    retval = octave::feval (fcn.function_value (), args, nargout);
+
+    if (retval.length () == 1 && retval(0).is_function ())
+      {
+        // The return object is a function.  We may need to re-index it
+        // using the same logic as for identifier.  This is primarily
+        // used for superclass references in classdef.
+
+        octave_value val = retval(0);
+        octave_function *f = val.function_value (true);
+
+        if (f && ! (expr.is_postfix_indexed ()
+                    && f->is_postfix_index_handled (expr.postfix_index ())))
+          {
+            octave_value_list tmp_args;
+
+            retval = val.do_multi_index_op (nargout, tmp_args);
+          }
+      }
+
+    m_value_stack.push (retval);
   }
 
   void
   tree_evaluator::visit_parameter_list (tree_parameter_list&)
   {
     panic_impossible ();
   }
 
   void
-  tree_evaluator::visit_postfix_expression (tree_postfix_expression&)
+  tree_evaluator::visit_postfix_expression (tree_postfix_expression& expr)
   {
-    panic_impossible ();
+    octave_value val;
+
+    tree_expression *op = expr.operand ();
+
+    if (op)
+      {
+        octave_value::unary_op etype = expr.op_type ();
+
+        if (etype == octave_value::op_incr || etype == octave_value::op_decr)
+          {
+            octave_lvalue ref = op->lvalue (this);
+
+            val = ref.value ();
+
+            profile_data_accumulator::enter<tree_postfix_expression>
+              block (profiler, expr);
+
+            ref.do_unary_op (etype);
+          }
+        else
+          {
+            octave_value op_val = evaluate (op);
+
+            if (op_val.is_defined ())
+              {
+                profile_data_accumulator::enter<tree_postfix_expression>
+                  block (profiler, expr);
+
+                val = ::do_unary_op (etype, op_val);
+              }
+          }
+      }
+
+    m_value_stack.push (ovl (val));
   }
 
   void
-  tree_evaluator::visit_prefix_expression (tree_prefix_expression&)
+  tree_evaluator::visit_prefix_expression (tree_prefix_expression& expr)
   {
-    panic_impossible ();
+    octave_value val;
+
+    tree_expression *op = expr.operand ();
+
+    if (op)
+      {
+        octave_value::unary_op etype = expr.op_type ();
+
+        if (etype == octave_value::op_incr || etype == octave_value::op_decr)
+          {
+            octave_lvalue op_ref = op->lvalue (this);
+
+            profile_data_accumulator::enter<tree_prefix_expression>
+              block (profiler, expr);
+
+            op_ref.do_unary_op (etype);
+
+            val = op_ref.value ();
+          }
+        else
+          {
+            octave_value op_val = evaluate (op);
+
+            if (op_val.is_defined ())
+              {
+                profile_data_accumulator::enter<tree_prefix_expression>
+                  block (profiler, expr);
+
+                // Attempt to do the operation in-place if it is unshared
+                // (a temporary expression).
+                if (op_val.get_count () == 1)
+                  val = op_val.do_non_const_unary_op (etype);
+                else
+                  val = ::do_unary_op (etype, op_val);
+              }
+          }
+      }
+
+    m_value_stack.push (ovl (val));
   }
 
   void
   tree_evaluator::visit_return_command (tree_return_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
@@ -618,19 +1890,84 @@ namespace octave
 
   void
   tree_evaluator::visit_return_list (tree_return_list&)
   {
     panic_impossible ();
   }
 
   void
-  tree_evaluator::visit_simple_assignment (tree_simple_assignment&)
+  tree_evaluator::visit_simple_assignment (tree_simple_assignment& expr)
   {
-    panic_impossible ();
+    octave_value val;
+
+    tree_expression *rhs = expr.right_hand_side ();
+
+    if (rhs)
+      {
+        octave_value rhs_val = evaluate (rhs);
+
+        if (rhs_val.is_undefined ())
+          error ("value on right hand side of assignment is undefined");
+
+        if (rhs_val.is_cs_list ())
+          {
+            const octave_value_list lst = rhs_val.list_value ();
+
+            if (lst.empty ())
+              error ("invalid number of elements on RHS of assignment");
+
+            rhs_val = lst(0);
+          }
+
+        tree_expression *lhs = expr.left_hand_side ();
+
+        try
+          {
+            octave_lvalue ult = lhs->lvalue (this);
+
+            if (ult.numel () != 1)
+              err_nonbraced_cs_list_assignment ();
+
+            octave_value::assign_op etype = expr.op_type ();
+
+            ult.assign (etype, rhs_val);
+
+            if (etype == octave_value::op_asn_eq)
+              val = rhs_val;
+            else
+              val = ult.value ();
+
+            if (expr.print_result ()
+                && octave::tree_evaluator::statement_printing_enabled ())
+              {
+                // We clear any index here so that we can
+                // get the new value of the referenced
+                // object below, instead of the indexed
+                // value (which should be the same as the
+                // right hand side value).
+
+                ult.clear_index ();
+
+                octave_value lhs_val = ult.value ();
+
+                octave_value_list args = ovl (lhs_val);
+                args.stash_name_tags (string_vector (lhs->name ()));
+                octave::feval ("display", args);
+              }
+          }
+        catch (octave::index_exception& e)
+          {
+            e.set_var (lhs->name ());
+            std::string msg = e.message ();
+            error_with_id (e.err_id (), msg.c_str ());
+          }
+      }
+
+    m_value_stack.push (ovl (val));
   }
 
   void
   tree_evaluator::visit_statement (tree_statement& stmt)
   {
     tree_command *cmd = stmt.command ();
     tree_expression *expr = stmt.expression ();
 
@@ -663,31 +2000,31 @@ namespace octave
                   do_breakpoint (expr->is_breakpoint (true));
 
                 // FIXME: maybe all of this should be packaged in
                 // one virtual function that returns a flag saying whether
                 // or not the expression will take care of binding ans and
                 // printing the result.
 
                 // FIXME: it seems that we should just have to
-                // call expr->rvalue1 () and that should take care of
+                // evaluate the expression and that should take care of
                 // everything, binding ans as necessary?
 
                 bool do_bind_ans = false;
 
                 if (expr->is_identifier ())
                   {
                     tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
                     do_bind_ans = (! id->is_variable ());
                   }
                 else
                   do_bind_ans = (! expr->is_assignment_expression ());
 
-                octave_value tmp_result = expr->rvalue1 (0);
+                octave_value tmp_result = evaluate (expr, 0);
 
                 if (do_bind_ans && tmp_result.is_defined ())
                   bind_ans (tmp_result, expr->print_result ()
                             && statement_printing_enabled ());
 
                 //              if (tmp_result.is_defined ())
                 //                result_values(0) = tmp_result;
               }
@@ -775,25 +2112,25 @@ namespace octave
       do_breakpoint (cmd.is_breakpoint (true));
 
     tree_expression *expr = cmd.switch_value ();
 
     if (! expr)
       error ("missing value in switch command near line %d, column %d",
              cmd.line (), cmd.column ());
 
-    octave_value val = expr->rvalue1 ();
+    octave_value val = evaluate (expr);
 
     tree_switch_case_list *lst = cmd.case_list ();
 
     if (lst)
       {
         for (tree_switch_case* t : *lst)
           {
-            if (t->is_default_case () || t->label_matches (val))
+            if (t->is_default_case () || switch_case_label_matches (t, val))
               {
                 tree_statement_list *stmt_lst = t->commands ();
 
                 if (stmt_lst)
                   stmt_lst->accept (*this);
 
                 break;
               }
@@ -849,17 +2186,17 @@ namespace octave
         tree_statement_list *catch_code = cmd.cleanup ();
         if (catch_code)
           {
             tree_identifier *expr_id = cmd.identifier ();
             octave_lvalue ult;
 
             if (expr_id)
               {
-                ult = expr_id->lvalue ();
+                ult = expr_id->lvalue (this);
 
                 octave_scalar_map err;
 
                 err.assign ("message", last_error_message ());
                 err.assign ("identifier", last_error_id ());
                 err.assign ("stack", last_error_stack ());
 
                 ult.assign (octave_value::op_asn_eq, err);
@@ -1005,17 +2342,17 @@ namespace octave
     if (! expr)
       panic_impossible ();
 
     for (;;)
       {
         if (debug_mode)
           do_breakpoint (cmd.is_breakpoint (true));
 
-        if (expr->is_logically_true ("while"))
+        if (is_logically_true (expr, "while"))
           {
             tree_statement_list *loop_body = cmd.body ();
 
             if (loop_body)
               loop_body->accept (*this);
 
             if (quit_loop_now ())
               break;
@@ -1056,17 +2393,17 @@ namespace octave
         if (quit_loop_now ())
           break;
 
         if (debug_mode)
           do_breakpoint (cmd.is_breakpoint (true));
 
         octave::call_stack::set_location (until_line, until_column);
 
-        if (expr->is_logically_true ("do-until"))
+        if (is_logically_true (expr, "do-until"))
           break;
       }
   }
 
   void
   tree_evaluator::do_breakpoint (tree_statement& stmt) const
   {
     do_breakpoint (stmt.is_breakpoint (true), stmt.is_end_of_fcn_or_script ());
@@ -1162,16 +2499,32 @@ namespace octave
   // input.cc accepts an argument list, we preserve it here so that the
   // interface won't have to change if we decide to use it in the future.
 
   octave_value
   tree_evaluator::do_keyboard (const octave_value_list& args) const
   {
     return ::do_keyboard (args);
   }
+
+  bool
+  tree_evaluator::is_logically_true (tree_expression *expr,
+                                     const char *warn_for)
+  {
+    bool expr_value = false;
+
+    octave_value t1 = evaluate (expr);
+
+    if (t1.is_defined ())
+      return t1.is_true ();
+    else
+      error ("%s: undefined value used in conditional expression", warn_for);
+
+    return expr_value;
+  }
 }
 
 DEFUN (max_recursion_depth, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} max_recursion_depth ()
 @deftypefnx {} {@var{old_val} =} max_recursion_depth (@var{new_val})
 @deftypefnx {} {} max_recursion_depth (@var{new_val}, "local")
 Query or set the internal limit on the number of times a function may
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -20,55 +20,103 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_pt_eval_h)
 #define octave_pt_eval_h 1
 
 #include "octave-config.h"
 
+#include <list>
 #include <stack>
 #include <string>
 
 #include "comment-list.h"
 #include "ovl.h"
+#include "pt-exp.h"
 #include "pt-walk.h"
 
 namespace octave
 {
+  class tree_decl_elt;
   class tree_expression;
 
   class interpreter;
 
   // How to evaluate the code that the parse trees represent.
 
   class OCTINTERP_API tree_evaluator : public tree_walker
   {
   public:
 
+    template <typename T>
+    class value_stack
+    {
+    public:
+
+      value_stack (void) = default;
+
+      value_stack (const value_stack&) = default;
+
+      value_stack& operator = (const value_stack&) = default;
+
+      ~value_stack (void) = default;
+
+      void push (const T& val) { m_stack.push (val); }
+
+      T pop (void)
+      {
+        T retval = m_stack.top ();
+        m_stack.pop ();
+        return retval;
+      }
+
+      T top (void) const
+      {
+        return m_stack.top ();
+      }
+
+      void clear (void)
+      {
+        while (! m_stack.empty ())
+          m_stack.pop ();
+      }
+      
+    private:
+
+      std::stack<T> m_stack;
+    };
+
     typedef void (*decl_elt_init_fcn) (tree_decl_elt&);
 
     tree_evaluator (interpreter *interp_context)
-      : m_interp_context (interp_context)
-      { }
+      : m_value_stack (), m_lvalue_list_stack (), m_nargout_stack (),
+        m_interp_context (interp_context)
+    { }
 
     // No copying!
 
     tree_evaluator (const tree_evaluator&) = delete;
 
     tree_evaluator& operator = (const tree_evaluator&) = delete;
 
     ~tree_evaluator (void) = default;
 
+    void reset (void);
+
     void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
     void visit_argument_list (tree_argument_list&);
 
     void visit_binary_expression (tree_binary_expression&);
 
+    void visit_boolean_expression (tree_boolean_expression&);
+
+    void visit_compound_binary_expression (tree_compound_binary_expression&);
+
     void visit_break_command (tree_break_command&);
 
     void visit_colon_expression (tree_colon_expression&);
 
     void visit_continue_command (tree_continue_command&);
 
     void visit_global_command (tree_global_command&);
 
@@ -174,28 +222,89 @@ namespace octave
     };
 
     // The context for the current evaluation.
     static stmt_list_type statement_context;
 
     // TRUE means we are evaluating some kind of looping construct.
     static bool in_loop_command;
 
+    octave_value evaluate (tree_expression *expr, int nargout = 1,
+                           const std::list<octave_lvalue> *lvalue_list = 0)
+    {
+      m_nargout_stack.push (nargout);
+      m_lvalue_list_stack.push (lvalue_list);
+
+      expr->accept (*this);
+
+      m_nargout_stack.pop ();
+      m_lvalue_list_stack.pop ();
+
+      octave_value_list tmp = m_value_stack.pop ();
+
+      return tmp.empty () ? octave_value () : tmp(0);
+    }
+
+    octave_value_list
+    evaluate_n (tree_expression *expr, int nargout = 1,
+                const std::list<octave_lvalue> *lvalue_list = 0)
+    {
+      m_nargout_stack.push (nargout);
+      m_lvalue_list_stack.push (lvalue_list);
+
+      expr->accept (*this);
+
+      m_nargout_stack.pop ();
+      m_lvalue_list_stack.pop ();
+
+      return m_value_stack.pop ();
+    }
+
+    octave_value evaluate (tree_decl_elt *);
+
+    void
+    initialize_undefined_parameter_list_elements
+      (tree_parameter_list *param_list, const std::string& warnfor,
+       int nargout, const octave_value& val);
+
+    void define_parameter_list_from_arg_vector
+      (tree_parameter_list *param_list, const octave_value_list& args);
+
+    void undefine_parameter_list (tree_parameter_list *param_list);
+
+    octave_value_list
+    convert_parameter_list_to_const_vector
+      (tree_parameter_list *param_list, int nargout, const Cell& varargout);
+
+    bool eval_decl_elt (tree_decl_elt *elt);
+
+    bool switch_case_label_matches (tree_switch_case *expr,
+                                    const octave_value& val);
+
   private:
 
-    void do_decl_init_list (decl_elt_init_fcn fcn,
-                            tree_decl_init_list *init_list);
+    void do_global_init (octave::tree_decl_elt& elt);
+
+    void do_static_init (octave::tree_decl_elt& elt);
 
     void do_breakpoint (tree_statement& stmt) const;
 
     void do_breakpoint (bool is_breakpoint,
                         bool is_end_of_fcn_or_script = false) const;
 
     virtual octave_value
-      do_keyboard (const octave_value_list& args = octave_value_list ()) const;
+    do_keyboard (const octave_value_list& args = octave_value_list ()) const;
+
+    bool is_logically_true (tree_expression *expr, const char *warn_for);
+
+    value_stack<octave_value_list> m_value_stack;
+
+    value_stack<const std::list<octave_lvalue>*> m_lvalue_list_stack;
+
+    value_stack<int> m_nargout_stack;
 
     interpreter *m_interp_context;
   };
 }
 
 // Maximum nesting level for functions, scripts, or sourced files called
 // recursively.
 extern int Vmax_recursion_depth;
diff --git a/libinterp/parse-tree/pt-except.cc b/libinterp/parse-tree/pt-except.cc
--- a/libinterp/parse-tree/pt-except.cc
+++ b/libinterp/parse-tree/pt-except.cc
@@ -63,22 +63,16 @@ namespace octave
                               catch_code ? catch_code->dup (scope, context) : 0,
                               expr_id ? expr_id->dup (scope, context) : 0,
                               lead_comm ? lead_comm->dup () : 0,
                               mid_comm ? mid_comm->dup () : 0,
                               trail_comm ? trail_comm->dup () : 0,
                               line (), column ());
   }
 
-  void
-  tree_try_catch_command::accept (tree_walker& tw)
-  {
-    tw.visit_try_catch_command (*this);
-  }
-
   // Simple exception handling.
 
   tree_unwind_protect_command::~tree_unwind_protect_command (void)
   {
     delete unwind_protect_code;
     delete cleanup_code;
     delete lead_comm;
     delete mid_comm;
@@ -92,15 +86,9 @@ namespace octave
     return new tree_unwind_protect_command
       (unwind_protect_code ? unwind_protect_code->dup (scope, context) : 0,
        cleanup_code ? cleanup_code->dup (scope, context) : 0,
        lead_comm ? lead_comm->dup () : 0,
        mid_comm ? mid_comm->dup () : 0,
        trail_comm ? trail_comm->dup () : 0,
        line (), column ());
   }
-
-  void
-  tree_unwind_protect_command::accept (tree_walker& tw)
-  {
-    tw.visit_unwind_protect_command (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -23,24 +23,23 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_pt_except_h)
 #define octave_pt_except_h 1
 
 #include "octave-config.h"
 
 #include "comment-list.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
   class tree_statement_list;
 
-  class tree_walker;
-
   // Simple exception handling.
 
   class tree_try_catch_command : public tree_command
   {
   public:
 
     tree_try_catch_command (int l = -1, int c = -1)
       : tree_command (l, c), try_code (0), catch_code (0), expr_id (0),
@@ -73,17 +72,20 @@ namespace octave
 
     octave_comment_list *middle_comment (void) { return mid_comm; }
 
     octave_comment_list *trailing_comment (void) { return trail_comm; }
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_try_catch_command (*this);
+    }
 
   private:
 
     // The first block of code to attempt to execute.
     tree_statement_list *try_code;
 
     // The code to execute if an error occurs in the first block.
     tree_statement_list *catch_code;
@@ -137,17 +139,20 @@ namespace octave
 
     octave_comment_list *middle_comment (void) { return mid_comm; }
 
     octave_comment_list *trailing_comment (void) { return trail_comm; }
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_unwind_protect_command (*this);
+    }
 
   private:
 
     // The first body of code to attempt to execute.
     tree_statement_list *unwind_protect_code;
 
     // The body of code to execute no matter what happens in the first
     // body of code.
diff --git a/libinterp/parse-tree/pt-exp.cc b/libinterp/parse-tree/pt-exp.cc
--- a/libinterp/parse-tree/pt-exp.cc
+++ b/libinterp/parse-tree/pt-exp.cc
@@ -32,51 +32,18 @@ along with Octave; see the file COPYING.
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-exp.h"
 
 namespace octave
 {
   // Expressions.
 
-  bool
-  tree_expression::is_logically_true (const char *warn_for)
-  {
-    bool expr_value = false;
-
-    octave_value t1 = rvalue1 ();
-
-    if (t1.is_defined ())
-      return t1.is_true ();
-    else
-      error ("%s: undefined value used in conditional expression", warn_for);
-
-    return expr_value;
-  }
-
-  octave_value
-  tree_expression::rvalue1 (int)
-  {
-    error ("invalid rvalue function called in expression");
-  }
-
-  octave_value_list
-  tree_expression::rvalue (int)
-  {
-    error ("invalid rvalue function called in expression");
-  }
-
-  octave_value_list
-  tree_expression::rvalue (int nargout, const std::list<octave_lvalue> *)
-  {
-    return rvalue (nargout);
-  }
-
   octave_lvalue
-  tree_expression::lvalue (void)
+  tree_expression::lvalue (tree_evaluator *)
   {
     error ("invalid lvalue function called in expression");
   }
 
   std::string
   tree_expression::original_text (void) const
   {
     return "";
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -31,16 +31,18 @@ along with Octave; see the file COPYING.
 class octave_value;
 class octave_lvalue;
 
 #include "pt.h"
 #include "symtab.h"
 
 namespace octave
 {
+  class tree_evaluator;
+
   // A base class for expressions.
 
   class tree_expression : public tree
   {
   public:
 
     tree_expression (int l = -1, int c = -1)
       : tree (l, c), num_parens (0), postfix_index_type ('\0'),
@@ -74,30 +76,21 @@ namespace octave
     virtual bool is_prefix_expression (void) const { return false; }
 
     virtual bool is_unary_expression (void) const { return false; }
 
     virtual bool is_binary_expression (void) const { return false; }
 
     virtual bool is_boolean_expression (void) const { return false; }
 
-    virtual bool is_logically_true (const char *);
-
     virtual bool lvalue_ok (void) const { return false; }
 
     virtual bool rvalue_ok (void) const { return false; }
 
-    virtual octave_value rvalue1 (int nargout = 1);
-
-    virtual octave_value_list rvalue (int nargout);
-
-    virtual octave_value_list
-    rvalue (int nargout, const std::list<octave_lvalue> *lvalue_list);
-
-    virtual octave_lvalue lvalue (void);
+    virtual octave_lvalue lvalue (tree_evaluator *);
 
     int paren_count (void) const { return num_parens; }
 
     bool is_postfix_indexed (void) const { return (postfix_index_type != '\0'); }
 
     char postfix_index (void) const { return postfix_index_type; }
 
     // Check if the result of the expression should be printed.
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -47,120 +47,27 @@ namespace octave
 
   void
   tree_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax,
                               bool pr_orig_text)
   {
     os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << nm;
   }
 
-  octave_value
-  tree_fcn_handle::rvalue1 (int)
-  {
-    return make_fcn_handle (nm);
-  }
-
-  octave_value_list
-  tree_fcn_handle::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    if (nargout > 1)
-      error ("invalid number of output arguments for function handle expression");
-
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
-
   tree_expression *
   tree_fcn_handle::dup (symbol_table::scope_id,
                         symbol_table::context_id) const
   {
     tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
 
     new_fh->copy_base (*this);
 
     return new_fh;
   }
 
-  void
-  tree_fcn_handle::accept (tree_walker& tw)
-  {
-    tw.visit_fcn_handle (*this);
-  }
-
-  octave_value
-  tree_anon_fcn_handle::rvalue1 (int)
-  {
-    // FIXME: should CMD_LIST be limited to a single expression?
-    // I think that is what Matlab does.
-
-    tree_parameter_list *param_list = parameter_list ();
-    tree_parameter_list *ret_list = return_list ();
-    tree_statement_list *cmd_list = body ();
-    symbol_table::scope_id this_scope = scope ();
-
-    symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
-
-    if (new_scope > 0)
-      symbol_table::inherit (new_scope, symbol_table::current_scope (),
-                             symbol_table::current_context ());
-
-    octave_user_function *uf
-      = new octave_user_function (new_scope,
-                                  param_list ? param_list->dup (new_scope, 0) : 0,
-                                  ret_list ? ret_list->dup (new_scope, 0) : 0,
-                                  cmd_list ? cmd_list->dup (new_scope, 0) : 0);
-
-    octave_function *curr_fcn = octave::call_stack::current ();
-
-    if (curr_fcn)
-      {
-        // FIXME: maybe it would be better to just stash curr_fcn
-        // instead of individual bits of info about it?
-
-        uf->stash_parent_fcn_name (curr_fcn->name ());
-        uf->stash_dir_name (curr_fcn->dir_name ());
-
-        symbol_table::scope_id parent_scope = curr_fcn->parent_fcn_scope ();
-
-        if (parent_scope < 0)
-          parent_scope = curr_fcn->scope ();
-
-        uf->stash_parent_fcn_scope (parent_scope);
-
-        if (curr_fcn->is_class_method () || curr_fcn->is_class_constructor ())
-          uf->stash_dispatch_class (curr_fcn->dispatch_class ());
-      }
-
-    uf->mark_as_anonymous_function ();
-    uf->stash_fcn_file_name (file_name);
-    uf->stash_fcn_location (line (), column ());
-
-    octave_value ov_fcn (uf);
-
-    octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn));
-
-    return fh;
-  }
-
-  octave_value_list
-  tree_anon_fcn_handle::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    if (nargout > 1)
-      error ("invalid number of output arguments for anonymous function handle expression");
-
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
-
   tree_expression *
   tree_anon_fcn_handle::dup (symbol_table::scope_id,
                              symbol_table::context_id) const
   {
     tree_parameter_list *param_list = parameter_list ();
     tree_parameter_list *ret_list = return_list ();
     tree_statement_list *cmd_list = body ();
     symbol_table::scope_id this_scope = scope ();
@@ -176,22 +83,16 @@ namespace octave
                             ret_list ? ret_list->dup (new_scope, 0) : 0,
                             cmd_list ? cmd_list->dup (new_scope, 0) : 0,
                             new_scope, line (), column ());
 
     new_afh->copy_base (*this);
 
     return new_afh;
   }
-
-  void
-  tree_anon_fcn_handle::accept (tree_walker& tw)
-  {
-    tw.visit_anon_fcn_handle (*this);
-  }
 }
 
 /*
 %!function r = __f2 (f, x)
 %!  r = f (x);
 %!endfunction
 %!function f = __f1 (k)
 %!  f = @(x) __f2 (@(y) y-k, x);
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -27,28 +27,27 @@ along with Octave; see the file COPYING.
 
 #include <iosfwd>
 #include <string>
 
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 class octave_value_list;
 
 #include "ov.h"
 #include "ov-usr-fcn.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
-
   class tree_fcn_handle : public tree_expression
   {
   public:
 
     tree_fcn_handle (int l = -1, int c = -1)
       : tree_expression (l, c), nm () { }
 
     tree_fcn_handle (const std::string& n, int l = -1, int c = -1)
@@ -69,61 +68,56 @@ namespace octave
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     std::string name (void) const { return nm; }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_fcn_handle (*this);
+    }
 
   private:
 
     // The name of this function handle.
     std::string nm;
   };
 
   class tree_anon_fcn_handle : public tree_expression
   {
   public:
 
     tree_anon_fcn_handle (int l = -1, int c = -1)
-      : tree_expression (l, c), fcn (0), file_name () { }
+      : tree_expression (l, c), fcn (0), m_file_name () { }
 
     tree_anon_fcn_handle (tree_parameter_list *pl, tree_parameter_list *rl,
                           tree_statement_list *cl, symbol_table::scope_id sid,
                           int l = -1, int c = -1)
       : tree_expression (l, c),
         fcn (new octave_user_function (sid, pl, rl, cl)),
-        file_name () { }
+        m_file_name () { }
 
     // No copying!
 
     tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
 
     tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&) = delete;
 
     ~tree_anon_fcn_handle (void) { delete fcn; }
 
     bool has_magic_end (void) const { return false; }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     tree_parameter_list *parameter_list (void) const
     {
       return fcn ? fcn->parameter_list () : 0;
     }
 
     tree_parameter_list *return_list (void) const
     {
       return fcn ? fcn->return_list () : 0;
@@ -137,27 +131,32 @@ namespace octave
     symbol_table::scope_id scope (void) const
     {
       return fcn ? fcn->scope () : -1;
     }
 
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_anon_fcn_handle (*this);
+    }
 
-    void stash_file_name (const std::string& file) { file_name = file; }
+    void stash_file_name (const std::string& file) { m_file_name = file; }
+
+    std::string file_name (void) const { return m_file_name; }
 
   private:
 
     // The function.
     octave_user_function *fcn;
 
     // Filename where the handle was defined.
-    std::string file_name;
+    std::string m_file_name;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::tree_fcn_handle' instead")
 typedef octave::tree_fcn_handle tree_fcn_handle;
 
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -71,43 +71,9 @@ namespace octave
   tree_funcall::dup (symbol_table::scope_id, symbol_table::context_id) const
   {
     tree_funcall *new_fc = new tree_funcall (fcn, args, line (), column ());
 
     new_fc->copy_base (*new_fc);
 
     return new_fc;
   }
-
-  void
-  tree_funcall::accept (tree_walker& tw)
-  {
-    tw.visit_funcall (*this);
-  }
-
-  octave_value_list
-  tree_funcall::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    retval = octave::feval (fcn.function_value (), args, nargout);
-
-    if (retval.length () == 1 && retval(0).is_function ())
-      {
-        // The return object is a function.  We may need to re-index it using the
-        // same logic as for identifier.  This is primarily used for superclass
-        // references in classdef.
-
-        octave_value val = retval(0);
-        octave_function *f = val.function_value (true);
-
-        if (f && ! (is_postfix_indexed ()
-                    && f->is_postfix_index_handled (postfix_index ())))
-          {
-            octave_value_list tmp_args;
-
-            retval = val.do_multi_index_op (nargout, tmp_args);
-          }
-      }
-
-    return retval;
-  }
 }
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
--- a/libinterp/parse-tree/pt-funcall.h
+++ b/libinterp/parse-tree/pt-funcall.h
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #define octave_tree_funcall_h 1
 
 #include "octave-config.h"
 
 #include "ov.h"
 #include "ovl.h"
 #include "parse.h"
 #include "pt-exp.h"
+#include "pt-walk.h"
 
 namespace octave
 {
   // Function call.  This class only represents function calls that have
   // known functions (most useful for calls to built-in functions that
   // are generated by the parser) and fixed argument lists, known at
   // compile time.
 
@@ -63,35 +64,24 @@ namespace octave
                 bool pr_orig_txt = true);
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     tree_funcall *dup (symbol_table::scope_id,
                        symbol_table::context_id context) const;
 
-    octave_value rvalue1 (int nargout)
-    {
-      octave_value retval;
-
-      const octave_value_list tmp = rvalue (nargout);
-
-      if (! tmp.empty ())
-        retval = tmp(0);
-
-      return retval;
-    }
-
-    octave_value_list rvalue (int nargout);
-
     octave_value function (void) const { return fcn; }
 
     octave_value_list arguments (void) const { return args; }
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_funcall (*this);
+    }
 
   private:
 
     // Function to call.  Error if not a valid function at time of
     // construction.
     octave_value fcn;
 
     // Argument list.
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -54,87 +54,18 @@ namespace octave
       error_with_id ("Octave:undefined-function",
                      "'%s' undefined", name ().c_str ());
     else
       error_with_id ("Octave:undefined-function",
                      "'%s' undefined near line %d column %d",
                      name ().c_str (), l, c);
   }
 
-  octave_value_list
-  tree_identifier::rvalue (int nargout,
-                           const std::list<octave_lvalue> *lvalue_list)
-  {
-    octave_value_list retval;
-
-    octave_value val = sym->find ();
-
-    if (val.is_defined ())
-      {
-        // GAGME -- this would be cleaner if we required
-        // parens to indicate function calls.
-        //
-        // If this identifier refers to a function, we need to know
-        // whether it is indexed so that we can do the same thing
-        // for 'f' and 'f()'.  If the index is present and the function
-        // object declares it can handle it, return the function object
-        // and let tree_index_expression::rvalue handle indexing.
-        // Otherwise, arrange to call the function here, so that we don't
-        // return the function definition as a value.
-
-        octave_function *fcn = 0;
-
-        if (val.is_function ())
-          fcn = val.function_value (true);
-
-        if (fcn && ! (is_postfix_indexed ()
-                      && fcn->is_postfix_index_handled (postfix_index ())))
-          {
-            octave_value_list tmp_args;
-
-            retval = (lvalue_list
-                      ? val.do_multi_index_op (nargout, tmp_args, lvalue_list)
-                      : val.do_multi_index_op (nargout, tmp_args));
-          }
-        else
-          {
-            if (print_result () && nargout == 0
-                && octave::tree_evaluator::statement_printing_enabled ())
-              {
-                octave_value_list args = ovl (val);
-                args.stash_name_tags (string_vector (name ()));
-                octave::feval ("display", args);
-              }
-
-            retval = val;
-          }
-      }
-    else if (sym->is_added_static ())
-      static_workspace_error ();
-    else
-      eval_undefined_error ();
-
-    return retval;
-  }
-
-  octave_value
-  tree_identifier::rvalue1 (int nargout)
-  {
-    octave_value retval;
-
-    octave_value_list tmp = rvalue (nargout);
-
-    if (! tmp.empty ())
-      retval = tmp(0);
-
-    return retval;
-  }
-
   octave_lvalue
-  tree_identifier::lvalue (void)
+  tree_identifier::lvalue (tree_evaluator *)
   {
     if (sym->is_added_static ())
       static_workspace_error ();
 
     return octave_lvalue (sym);
   }
 
   tree_identifier *
@@ -150,15 +81,9 @@ namespace octave
 
     tree_identifier *new_id
       = new tree_identifier (new_sym, line (), column ());
 
     new_id->copy_base (*this);
 
     return new_id;
   }
-
-  void
-  tree_identifier::accept (tree_walker& tw)
-  {
-    tw.visit_identifier (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -30,21 +30,22 @@ along with Octave; see the file COPYING.
 
 class octave_value;
 class octave_value_list;
 class octave_function;
 
 #include "oct-lvalue.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
+  class tree_evaluator;
 
   // Symbols from the symbol table.
 
   class tree_identifier : public tree_expression
   {
     friend class tree_index_expression;
 
   public:
@@ -106,40 +107,33 @@ namespace octave
 
     void mark_as_formal_parameter (void) { sym->mark_formal (); }
 
     // We really need to know whether this symbol referst to a variable
     // or a function, but we may not know that yet.
 
     bool lvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout)
-    {
-      return rvalue (nargout, 0);
-    }
-
-    octave_value_list rvalue (int nargout,
-                              const std::list<octave_lvalue> *lvalue_list);
-
-    octave_lvalue lvalue (void);
+    octave_lvalue lvalue (tree_evaluator *);
 
     void eval_undefined_error (void);
 
     void static_workspace_error (void)
     {
       error ("can not add variable \"%s\" to a static workspace",
              name ().c_str ());
     }
 
     tree_identifier *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_identifier (*this);
+    }
 
     symbol_table::symbol_reference symbol (void) const
     {
       return sym;
     }
   private:
 
     // The symbol record that this identifier references.
@@ -160,17 +154,17 @@ namespace octave
     bool is_black_hole (void) { return true; }
 
     tree_black_hole *dup (symbol_table::scope_id,
                           symbol_table::context_id) const
     {
       return new tree_black_hole;
     }
 
-    octave_lvalue lvalue (void)
+    octave_lvalue lvalue (tree_evaluator *)
     {
       return octave_lvalue (); // black hole lvalue
     }
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pager.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
+#include "pt-eval.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 #include "errwarn.h"
 
 namespace octave
@@ -141,139 +142,65 @@ namespace octave
 
   std::string
   tree_index_expression::name (void) const
   {
     return expr->name ();
   }
 }
 
-static Cell
-make_subs_cell (octave::tree_argument_list *args, const string_vector& arg_nm)
-{
-  Cell retval;
-
-  octave_value_list arg_values;
-
-  if (args)
-    arg_values = args->convert_to_const_vector ();
-
-  int n = arg_values.length ();
-
-  if (n > 0)
-    {
-      arg_values.stash_name_tags (arg_nm);
-
-      retval.resize (dim_vector (1, n));
-
-      for (int i = 0; i < n; i++)
-        retval(0,i) = arg_values(i);
-    }
-
-  return retval;
-}
-
 static inline octave_value_list
-make_value_list (octave::tree_argument_list *args, const string_vector& arg_nm,
-                 const octave_value *object, bool rvalue = true)
+make_value_list (octave::tree_evaluator *tw, octave::tree_argument_list *args,
+                 const string_vector& arg_nm, const octave_value *object,
+                 bool rvalue = true)
 {
   octave_value_list retval;
 
   if (args)
     {
       if (rvalue && object && args->has_magic_end () && object->is_undefined ())
         err_invalid_inquiry_subscript ();
 
-      retval = args->convert_to_const_vector (object);
+      retval = args->convert_to_const_vector (tw, object);
     }
 
   octave_idx_type n = retval.length ();
 
   if (n > 0)
     retval.stash_name_tags (arg_nm);
 
   return retval;
 }
 
 namespace octave
 {
   std::string
   tree_index_expression::get_struct_index
-  (std::list<string_vector>::const_iterator p_arg_nm,
+  (tree_evaluator *tw,
+   std::list<string_vector>::const_iterator p_arg_nm,
    std::list<tree_expression *>::const_iterator p_dyn_field) const
   {
     std::string fn = (*p_arg_nm)(0);
 
     if (fn.empty ())
       {
         tree_expression *df = *p_dyn_field;
 
         if (df)
           {
-            octave_value t = df->rvalue1 ();
+            octave_value t = tw->evaluate (df);
 
             fn = t.xstring_value ("dynamic structure field names must be strings");
           }
         else
           panic_impossible ();
       }
 
     return fn;
   }
-
-  octave_map
-  tree_index_expression::make_arg_struct (void) const
-  {
-    int n = args.size ();
-
-    Cell type_field (n, 1);
-    Cell subs_field (n, 1);
-
-    std::list<tree_argument_list *>::const_iterator p_args = args.begin ();
-    std::list<string_vector>::const_iterator p_arg_nm = arg_nm.begin ();
-    std::list<tree_expression *>::const_iterator p_dyn_field = dyn_field.begin ();
-
-    octave_map m;
-
-    for (int i = 0; i < n; i++)
-      {
-        switch (type[i])
-          {
-          case '(':
-            subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
-            break;
-
-          case '{':
-            subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
-            break;
-
-          case '.':
-            subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
-            break;
-
-          default:
-            panic_impossible ();
-          }
-
-        p_args++;
-        p_arg_nm++;
-        p_dyn_field++;
-      }
-
-    m.assign ("type", type_field);
-    m.assign ("subs", subs_field);
-
-    return m;
-  }
-
-  octave_value_list
-  tree_index_expression::rvalue (int nargout)
-  {
-    return tree_index_expression::rvalue (nargout, 0);
-  }
 }
 
 // Final step of processing an indexing error.  Add the name of the
 // variable being indexed, if any, then issue an error.  (Will this also
 // be needed by pt-lvalue, which calls subsref?)
 
 static void
 final_index_error (octave::index_exception& e,
@@ -301,226 +228,31 @@ final_index_error (octave::index_excepti
 
   std::string msg = e.message () + extra_message;
 
   error_with_id (e.err_id (), msg.c_str ());
 }
 
 namespace octave
 {
-  octave_value_list
-  tree_index_expression::rvalue (int nargout,
-                                 const std::list<octave_lvalue> *lvalue_list)
-  {
-    octave_value_list retval;
-
-    octave_value first_expr_val;
-
-    octave_value_list first_args;
-
-    bool have_args = false;
-
-    if (expr->is_identifier () && type[0] == '(')
-      {
-        tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
-
-        if (! (id->is_variable () || args.empty ()))
-          {
-            tree_argument_list *al = *(args.begin ());
-
-            size_t n = al ? al->length () : 0;
-
-            if (n > 0)
-              {
-                string_vector anm = *(arg_nm.begin ());
-                have_args = true;
-                first_args = al -> convert_to_const_vector ();
-                first_args.stash_name_tags (anm);
-
-                first_expr_val = id->do_lookup  (first_args);
-              }
-          }
-      }
-
-    if (first_expr_val.is_undefined ())
-      first_expr_val = expr->rvalue1 ();
-
-    octave_value tmp = first_expr_val;
-    octave_idx_type tmpi = 0;
-
-    std::list<octave_value_list> idx;
-
-    int n = args.size ();
-
-    std::list<tree_argument_list *>::iterator p_args = args.begin ();
-    std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
-    std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
-
-    for (int i = 0; i < n; i++)
-      {
-        if (i > 0)
-          {
-            tree_argument_list *al = *p_args;
-
-            // In Matlab, () can only be followed by '.'.  In Octave, we
-            // do not enforce this for rvalue expressions, but we'll
-            // split the evaluation at this point.  This will,
-            // hopefully, allow Octave's looser rules apply smoothly for
-            // Matlab overloaded subsref codes.
-
-            // We might have an expression like
-            //
-            //   x{end}.a(end)
-            //
-            // and we are looking at the argument list that contains the
-            // second (or third, etc.) "end" token, so we must evaluate
-            // everything up to the point of that argument list so we
-            // can pass the appropriate value to the built-in end
-            // function.
-
-            // An expression like
-            //
-            //    s.a (f (1:end))
-            //
-            // can mean a lot of different things depending on the types
-            // of s, a, and f.  Let's just say it's complicated and that
-            // the following code is definitely not correct in all
-            // cases.  That it is already so complex makes me think that
-            // there must be a better way.
-
-            bool split = ((type[i-1] == '(' && type[i] != '.')
-                          || (al && al->has_magic_end ()
-                              && ! tmp.is_classdef_object ()));
-
-            if (split)
-              {
-                try
-                  {
-                    octave_value_list tmp_list
-                      =tmp.subsref (type.substr (tmpi, i-tmpi), idx, nargout);
-
-                    tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
-                    tmpi = i;
-                    idx.clear ();
-
-                    if (tmp.is_cs_list ())
-                      err_indexed_cs_list ();
-
-                    if (tmp.is_function ())
-                      {
-                        octave_function *fcn = tmp.function_value (true);
-
-                        if (fcn && ! fcn->is_postfix_index_handled (type[i]))
-                          {
-                            octave_value_list empty_args;
-
-                            tmp_list = tmp.do_multi_index_op (1, empty_args);
-                            tmp = (tmp_list.length ()
-                                   ? tmp_list(0) : octave_value ());
-
-                            if (tmp.is_cs_list ())
-                              err_indexed_cs_list ();
-                          }
-                      }
-                  }
-                catch (octave::index_exception& e)  // problems with index range, type etc.
-                  {
-                    final_index_error (e, expr);
-                  }
-              }
-          }
-
-        switch (type[i])
-          {
-          case '(':
-            if (have_args)
-              {
-                idx.push_back (first_args);
-                have_args = false;
-              }
-            else
-              idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
-            break;
-
-          case '{':
-            idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
-            break;
-
-          case '.':
-            idx.push_back (octave_value (get_struct_index (p_arg_nm,
-                                                           p_dyn_field)));
-            break;
-
-          default:
-            panic_impossible ();
-          }
-
-        p_args++;
-        p_arg_nm++;
-        p_dyn_field++;
-      }
-
-    try
-      {
-        retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
-                              lvalue_list);
-      }
-    catch (octave::index_exception& e)  // range problems, bad index type, etc.
-      {
-        final_index_error (e, expr);
-      }
-
-    octave_value val = retval.length () ? retval(0) : octave_value ();
-
-    if (val.is_function ())
-      {
-        octave_function *fcn = val.function_value (true);
-
-        if (fcn)
-          {
-            octave_value_list empty_args;
-
-            retval = (lvalue_list
-                      ? val.do_multi_index_op (nargout, empty_args,
-                                               lvalue_list)
-                      : val.do_multi_index_op (nargout, empty_args));
-          }
-      }
-
-    return retval;
-  }
-
-  octave_value
-  tree_index_expression::rvalue1 (int nargout)
-  {
-    octave_value retval;
-
-    const octave_value_list tmp = rvalue (nargout);
-
-    if (! tmp.empty ())
-      retval = tmp(0);
-
-    return retval;
-  }
-
   octave_lvalue
-  tree_index_expression::lvalue (void)
+  tree_index_expression::lvalue (tree_evaluator *tw)
   {
     octave_lvalue retval;
 
     std::list<octave_value_list> idx;
     std::string tmp_type;
 
     int n = args.size ();
 
     std::list<tree_argument_list *>::iterator p_args = args.begin ();
     std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
     std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
-    retval = expr->lvalue ();
+    retval = expr->lvalue (tw);
 
     octave_value tmp = retval.value ();
 
     octave_idx_type tmpi = 0;
     std::list<octave_value_list> tmpidx;
 
     for (int i = 0; i < n; i++)
       {
@@ -541,17 +273,17 @@ namespace octave
             tmpidx.clear ();
           }
 
         switch (type[i])
           {
           case '(':
             {
               octave_value_list tidx
-                = make_value_list (*p_args, *p_arg_nm, &tmp, false);
+                = make_value_list (tw, *p_args, *p_arg_nm, &tmp, false);
 
               idx.push_back (tidx);
 
               if (i < n - 1)
                 {
                   if (type[i+1] != '.')
                     error ("() must be followed by . or close the index chain");
 
@@ -559,17 +291,17 @@ namespace octave
                   tmpi = i+1;
                 }
             }
             break;
 
           case '{':
             {
               octave_value_list tidx
-                = make_value_list (*p_args, *p_arg_nm, &tmp, false);
+                = make_value_list (tw, *p_args, *p_arg_nm, &tmp, false);
 
               if (tmp.is_undefined ())
                 {
                   if (tidx.has_magic_colon ())
                     err_invalid_inquiry_subscript ();
 
                   tmp = Cell ();
                 }
@@ -584,17 +316,17 @@ namespace octave
               idx.push_back (tidx);
               tmpidx.push_back (tidx);
               tmpi = i;
             }
             break;
 
           case '.':
             {
-              octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
+              octave_value tidx = get_struct_index (tw, p_arg_nm, p_dyn_field);
 
               bool autoconv = (tmp.is_zero_by_zero ()
                                && (tmp.is_matrix_type () || tmp.is_string ()
                                    || tmp.is_cell ()));
 
               if (i > 0 && type[i-1] == '(')
                 {
                   octave_value_list pidx = idx.back ();
@@ -679,22 +411,16 @@ namespace octave
       new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
 
     new_idx_expr->dyn_field = new_dyn_field;
 
     new_idx_expr->copy_base (*this);
 
     return new_idx_expr;
   }
-
-  void
-  tree_index_expression::accept (tree_walker& tw)
-  {
-    tw.visit_index_expression (*this);
-  }
 }
 
 /*
 %!test
 %! clear x;
 %! clear y;
 %! y = 3;
 %! x(y(end)) = 1;
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -30,23 +30,23 @@ along with Octave; see the file COPYING.
 class octave_map;
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "str-vec.h"
 
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
   class tree_argument_list;
-
-  class tree_walker;
+  class tree_evaluator;
 
   // Index expressions.
 
   class tree_index_expression : public tree_expression
   {
   public:
 
     tree_index_expression (tree_expression *e = 0, tree_argument_list *lst = 0,
@@ -81,33 +81,36 @@ namespace octave
     tree_expression *expression (void) { return expr; }
 
     std::list<tree_argument_list *> arg_lists (void) { return args; }
 
     std::string type_tags (void) { return type; }
 
     std::list<string_vector> arg_names (void) { return arg_nm; }
 
+    std::list<tree_expression *> dyn_fields (void) { return dyn_field; }
+
     bool lvalue_ok (void) const { return expr->lvalue_ok (); }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
-    octave_value_list rvalue (int nargout,
-                              const std::list<octave_lvalue> *lvalue_list);
-
-    octave_lvalue lvalue (void);
+    octave_lvalue lvalue (tree_evaluator *tw);
 
     tree_index_expression *dup (symbol_table::scope_id scope,
                                 symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_index_expression (*this);
+    }
+
+    std::string
+    get_struct_index
+    (tree_evaluator *tw, std::list<string_vector>::const_iterator p_arg_nm,
+     std::list<tree_expression *>::const_iterator p_dyn_field) const;
 
   private:
 
     // The LHS of this index expression.
     tree_expression *expr;
 
     // The indices (only valid if type == paren || type == brace).
     std::list<tree_argument_list *> args;
@@ -120,21 +123,16 @@ namespace octave
     std::list<string_vector> arg_nm;
 
     // The list of dynamic field names, if any.
     std::list<tree_expression *> dyn_field;
 
     tree_index_expression (int l, int c);
 
     octave_map make_arg_struct (void) const;
-
-    std::string
-    get_struct_index
-    (std::list<string_vector>::const_iterator p_arg_nm,
-     std::list<tree_expression *>::const_iterator p_dyn_field) const;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::tree_index_expression' instead")
 typedef octave::tree_index_expression tree_index_expression;
 
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -663,17 +663,18 @@ void
 jit_convert::visit_no_op_command (tree_no_op_command&)
 {
   throw jit_fail_exception ("No visit_no_op_command implementation");
 }
 
 void
 jit_convert::visit_constant (tree_constant& tc)
 {
-  octave_value v = tc.rvalue1 ();
+  octave_value v = tc.value ();
+
   jit_type *ty = jit_typeinfo::type_of (v);
 
   if (ty == jit_typeinfo::get_scalar ())
     {
       double dv = v.double_value ();
       result = factory.create<jit_const_scalar> (dv);
     }
   else if (ty == jit_typeinfo::get_range ())
diff --git a/libinterp/parse-tree/pt-jump.cc b/libinterp/parse-tree/pt-jump.cc
--- a/libinterp/parse-tree/pt-jump.cc
+++ b/libinterp/parse-tree/pt-jump.cc
@@ -41,50 +41,32 @@ namespace octave
 
   tree_command *
   tree_break_command::dup (symbol_table::scope_id,
                            symbol_table::context_id) const
   {
     return new tree_break_command (line (), column ());
   }
 
-  void
-  tree_break_command::accept (tree_walker& tw)
-  {
-    tw.visit_break_command (*this);
-  }
-
   // Continue.
 
   // Nonzero means we're jumping to the end of a loop.
   int tree_continue_command::continuing = 0;
 
   tree_command *
   tree_continue_command::dup (symbol_table::scope_id,
                               symbol_table::context_id) const
   {
     return new tree_continue_command (line (), column ());
   }
 
-  void
-  tree_continue_command::accept (tree_walker& tw)
-  {
-    tw.visit_continue_command (*this);
-  }
-
   // Return.
 
   // Nonzero means we're returning from a function.
   int tree_return_command::returning = 0;
 
   tree_command *
   tree_return_command::dup (symbol_table::scope_id,
                             symbol_table::context_id) const
   {
     return new tree_return_command (line (), column ());
   }
-
-  void
-  tree_return_command::accept (tree_walker& tw)
-  {
-    tw.visit_return_command (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-jump.h b/libinterp/parse-tree/pt-jump.h
--- a/libinterp/parse-tree/pt-jump.h
+++ b/libinterp/parse-tree/pt-jump.h
@@ -21,22 +21,21 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_pt_jump_h)
 #define octave_pt_jump_h 1
 
 #include "octave-config.h"
 
 #include "pt-cmd.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
-
   // Break.
 
   class tree_break_command : public tree_command
   {
   public:
 
     tree_break_command (int l = -1, int c = -1)
       : tree_command (l, c) { }
@@ -47,17 +46,20 @@ namespace octave
 
     tree_break_command& operator = (const tree_break_command&) = delete;
 
     ~tree_break_command (void) = default;
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_break_command (*this);
+    }
 
     static int breaking;
   };
 
   // Continue.
 
   class tree_continue_command : public tree_command
   {
@@ -72,17 +74,20 @@ namespace octave
 
     tree_continue_command& operator = (const tree_continue_command&) = delete;
 
     ~tree_continue_command (void) = default;
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_continue_command (*this);
+    }
 
     static int continuing;
   };
 
   // Return.
 
   class tree_return_command : public tree_command
   {
@@ -97,17 +102,20 @@ namespace octave
 
     tree_return_command& operator = (const tree_return_command&) = delete;
 
     ~tree_return_command (void) = default;
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_return_command (*this);
+    }
 
     static int returning;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::tree_break_command' instead")
diff --git a/libinterp/parse-tree/pt-loop.cc b/libinterp/parse-tree/pt-loop.cc
--- a/libinterp/parse-tree/pt-loop.cc
+++ b/libinterp/parse-tree/pt-loop.cc
@@ -63,41 +63,29 @@ namespace octave
   {
     return new tree_while_command (expr ? expr->dup (scope, context) : 0,
                                    list ? list->dup (scope, context) : 0,
                                    lead_comm ? lead_comm->dup () : 0,
                                    trail_comm ? trail_comm->dup (): 0,
                                    line (), column ());
   }
 
-  void
-  tree_while_command::accept (tree_walker& tw)
-  {
-    tw.visit_while_command (*this);
-  }
-
   // Do-Until
 
   tree_command *
   tree_do_until_command::dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const
   {
     return new tree_do_until_command (expr ? expr->dup (scope, context) : 0,
                                       list ? list->dup (scope, context) : 0,
                                       lead_comm ? lead_comm->dup () : 0,
                                       trail_comm ? trail_comm->dup (): 0,
                                       line (), column ());
   }
 
-  void
-  tree_do_until_command::accept (tree_walker& tw)
-  {
-    tw.visit_do_until_command (*this);
-  }
-
   // For.
 
   tree_simple_for_command::~tree_simple_for_command (void)
   {
     delete lhs;
     delete expr;
     delete maxproc;
     delete list;
@@ -116,22 +104,16 @@ namespace octave
       (parallel, lhs ? lhs->dup (scope, context) : 0,
        expr ? expr->dup (scope, context) : 0,
        maxproc ? maxproc->dup (scope, context) : 0,
        list ? list->dup (scope, context) : 0,
        lead_comm ? lead_comm->dup () : 0,
        trail_comm ? trail_comm->dup () : 0, line (), column ());
   }
 
-  void
-  tree_simple_for_command::accept (tree_walker& tw)
-  {
-    tw.visit_simple_for_command (*this);
-  }
-
   tree_complex_for_command::~tree_complex_for_command (void)
   {
     delete lhs;
     delete expr;
     delete list;
     delete lead_comm;
     delete trail_comm;
   }
@@ -142,15 +124,9 @@ namespace octave
   {
     return new tree_complex_for_command (lhs ? lhs->dup (scope, context) : 0,
                                          expr ? expr->dup (scope, context) : 0,
                                          list ? list->dup (scope, context) : 0,
                                          lead_comm ? lead_comm->dup () : 0,
                                          trail_comm ? trail_comm->dup () : 0,
                                          line (), column ());
   }
-
-  void
-  tree_complex_for_command::accept (tree_walker& tw)
-  {
-    tw.visit_complex_for_command (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -25,28 +25,27 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 class octave_value;
 class octave_lvalue;
 
 #include "comment-list.h"
 #include "pt-cmd.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 class jit_info;
 
 namespace octave
 {
   class tree_argument_list;
   class tree_expression;
   class tree_statement_list;
 
-  class tree_walker;
-
   // While.
 
   class tree_while_command : public tree_command
   {
   public:
 
     tree_while_command (int l = -1, int c = -1)
       : tree_command (l, c), expr (0), list (0), lead_comm (0),
@@ -92,17 +91,20 @@ namespace octave
 
     octave_comment_list *leading_comment (void) { return lead_comm; }
 
     octave_comment_list *trailing_comment (void) { return trail_comm; }
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_while_command (*this);
+    }
 
 #if defined (HAVE_LLVM)
     // some functions use by tree_jit
     jit_info *get_info (void) const
     {
       return compiled;
     }
 
@@ -161,17 +163,20 @@ namespace octave
 
     tree_do_until_command& operator = (const tree_do_until_command&) = delete;
 
     ~tree_do_until_command (void) = default;
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_do_until_command (*this);
+    }
   };
 
   // For.
 
   class tree_simple_for_command : public tree_command
   {
   public:
 
@@ -218,17 +223,20 @@ namespace octave
 
     octave_comment_list *leading_comment (void) { return lead_comm; }
 
     octave_comment_list *trailing_comment (void) { return trail_comm; }
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_simple_for_command (*this);
+    }
 
 #if defined (HAVE_LLVM)
     // some functions use by tree_jit
     jit_info *get_info (void) const
     {
       return compiled;
     }
 
@@ -300,17 +308,20 @@ namespace octave
 
     octave_comment_list *leading_comment (void) { return lead_comm; }
 
     octave_comment_list *trailing_comment (void) { return trail_comm; }
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_complex_for_command (*this);
+    }
 
   private:
 
     // Expression to modify.
     tree_argument_list *lhs;
 
     // Expression to evaluate.
     tree_expression *expr;
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -34,180 +34,32 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "errwarn.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "pt-mat.h"
+#include "pt-tm-const.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "ov.h"
 #include "variables.h"
 
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 // The character to fill with when creating string arrays.
 char Vstring_fill_char = ' ';
 
 namespace octave
 {
-  // General matrices.  This list type is much more work to handle than
-  // constant matrices, but it allows us to construct matrices from
-  // other matrices, variables, and functions.
-
-  // But first, some internal classes that make our job much easier.
-
-  class
-  tm_row_const
-  {
-  private:
-
-    class
-    tm_row_const_rep : public octave::base_list<octave_value>
-    {
-    public:
-
-      tm_row_const_rep (void)
-        : count (1), dv (0, 0), all_str (false),
-          all_sq_str (false), all_dq_str (false),
-          some_str (false), all_real (false), all_cmplx (false),
-          all_mt (true), any_cell (false), any_sparse (false),
-          any_class (false), all_1x1 (false),
-          first_elem_is_struct (false), class_nm (), ok (false)
-      { }
-
-      tm_row_const_rep (const tree_argument_list& row)
-        : count (1), dv (0, 0), all_str (false), all_sq_str (false),
-          some_str (false), all_real (false), all_cmplx (false),
-          all_mt (true), any_cell (false), any_sparse (false),
-          any_class (false), all_1x1 (! row.empty ()),
-          first_elem_is_struct (false), class_nm (), ok (false)
-      { init (row); }
-
-      ~tm_row_const_rep (void) = default;
-
-      octave::refcount<int> count;
-
-      dim_vector dv;
-
-      bool all_str;
-      bool all_sq_str;
-      bool all_dq_str;
-      bool some_str;
-      bool all_real;
-      bool all_cmplx;
-      bool all_mt;
-      bool any_cell;
-      bool any_sparse;
-      bool any_class;
-      bool all_1x1;
-      bool first_elem_is_struct;
-
-      std::string class_nm;
-
-      bool ok;
-
-      void do_init_element (const octave_value&, bool&);
-
-      void init (const tree_argument_list&);
-
-      void cellify (void);
-
-    private:
-
-      tm_row_const_rep (const tm_row_const_rep&);
-
-      tm_row_const_rep& operator = (const tm_row_const_rep&);
-
-    };
-
-  public:
-
-    typedef tm_row_const_rep::iterator iterator;
-    typedef tm_row_const_rep::const_iterator const_iterator;
-
-    tm_row_const (void)
-      : rep (0) { }
-
-    tm_row_const (const tree_argument_list& row)
-      : rep (new tm_row_const_rep (row)) { }
-
-    tm_row_const (const tm_row_const& x)
-      : rep (x.rep)
-    {
-      if (rep)
-        rep->count++;
-    }
-
-    tm_row_const& operator = (const tm_row_const& x)
-    {
-      if (this != &x && rep != x.rep)
-        {
-          if (rep && --rep->count == 0)
-            delete rep;
-
-          rep = x.rep;
-
-          if (rep)
-            rep->count++;
-        }
-
-      return *this;
-    }
-
-    ~tm_row_const (void)
-    {
-      if (rep && --rep->count == 0)
-        delete rep;
-    }
-
-    octave_idx_type rows (void) { return rep->dv(0); }
-    octave_idx_type cols (void) { return rep->dv(1); }
-
-    bool empty (void) const { return rep->empty (); }
-
-    size_t length (void) const { return rep->length (); }
-
-    dim_vector dims (void) { return rep->dv; }
-
-    bool all_strings_p (void) const { return rep->all_str; }
-    bool all_sq_strings_p (void) const { return rep->all_sq_str; }
-    bool all_dq_strings_p (void) const { return rep->all_dq_str; }
-    bool some_strings_p (void) const { return rep->some_str; }
-    bool all_real_p (void) const { return rep->all_real; }
-    bool all_complex_p (void) const { return rep->all_cmplx; }
-    bool all_empty_p (void) const { return rep->all_mt; }
-    bool any_cell_p (void) const { return rep->any_cell; }
-    bool any_sparse_p (void) const { return rep->any_sparse; }
-    bool any_class_p (void) const { return rep->any_class; }
-    bool all_1x1_p (void) const { return rep->all_1x1; }
-    bool first_elem_struct_p (void) const { return rep->first_elem_is_struct; }
-
-    std::string class_name (void) const { return rep->class_nm; }
-
-    void cellify (void) { rep->cellify (); }
-
-    operator bool () const { return (rep && rep->ok); }
-
-    iterator begin (void) { return rep->begin (); }
-    const_iterator begin (void) const { return rep->begin (); }
-
-    iterator end (void) { return rep->end (); }
-    const_iterator end (void) const { return rep->end (); }
-
-  private:
-
-    tm_row_const_rep *rep;
-  };
-
   std::string
   get_concat_class (const std::string& c1, const std::string& c2)
   {
     std::string retval = octave_base_value::static_class_name ();
 
     if (c1 == c2)
       retval = c1;
     else if (c1.empty ())
@@ -270,833 +122,35 @@ namespace octave
         else if (c2_is_double && c1_is_built_in_type)
           retval = c2;
         else if (c1_is_logical && c2_is_logical)
           retval = c1;
       }
 
     return retval;
   }
-}
-
-OCTAVE_NORETURN static
-void
-eval_error (const char *msg, const dim_vector& x, const dim_vector& y)
-{
-  error ("%s (%s vs %s)", msg, x.str ().c_str (), y.str ().c_str ());
-}
-
-namespace octave
-{
-  void
-  tm_row_const::tm_row_const_rep::do_init_element (const octave_value& val,
-                                                   bool& first_elem)
-  {
-    std::string this_elt_class_nm
-      = val.is_object () ? std::string ("class") : val.class_name ();
-
-    class_nm = get_concat_class (class_nm, this_elt_class_nm);
-
-    dim_vector this_elt_dv = val.dims ();
-
-    if (! this_elt_dv.zero_by_zero ())
-      {
-        all_mt = false;
-
-        if (first_elem)
-          {
-            if (val.is_map ())
-              first_elem_is_struct = true;
-
-            first_elem = false;
-          }
-      }
-
-    append (val);
-
-    if (all_str && ! val.is_string ())
-      all_str = false;
-
-    if (all_sq_str && ! val.is_sq_string ())
-      all_sq_str = false;
-
-    if (all_dq_str && ! val.is_dq_string ())
-      all_dq_str = false;
-
-    if (! some_str && val.is_string ())
-      some_str = true;
-
-    if (all_real && ! val.is_real_type ())
-      all_real = false;
-
-    if (all_cmplx && ! (val.is_complex_type () || val.is_real_type ()))
-      all_cmplx = false;
-
-    if (! any_cell && val.is_cell ())
-      any_cell = true;
-
-    if (! any_sparse && val.is_sparse_type ())
-      any_sparse = true;
-
-    if (! any_class && val.is_object ())
-      any_class = true;
-
-    // Special treatment of sparse matrices to avoid out-of-memory error
-    all_1x1 = all_1x1 && ! val.is_sparse_type () && val.numel () == 1;
-  }
-
-  void
-  tm_row_const::tm_row_const_rep::init (const tree_argument_list& row)
-  {
-    all_str = true;
-    all_sq_str = true;
-    all_dq_str = true;
-    all_real = true;
-    all_cmplx = true;
-    any_cell = false;
-    any_sparse = false;
-    any_class = false;
-
-    bool first_elem = true;
-
-    for (tree_expression* elt : row)
-      {
-        octave_quit ();
-
-        octave_value tmp = elt->rvalue1 ();
-
-        if (tmp.is_undefined ())
-          {
-            ok = true;
-            return;
-          }
-        else
-          {
-            if (tmp.is_cs_list ())
-              {
-                octave_value_list tlst = tmp.list_value ();
-
-                for (octave_idx_type i = 0; i < tlst.length (); i++)
-                  {
-                    octave_quit ();
-
-                    do_init_element (tlst(i), first_elem);
-                  }
-              }
-            else
-              do_init_element (tmp, first_elem);
-          }
-      }
-
-    if (any_cell && ! any_class && ! first_elem_is_struct)
-      cellify ();
-
-    first_elem = true;
-
-    for (const octave_value& val : *this)
-      {
-        octave_quit ();
-
-        dim_vector this_elt_dv = val.dims ();
-
-        if (! this_elt_dv.zero_by_zero ())
-          {
-            all_mt = false;
-
-            if (first_elem)
-              {
-                first_elem = false;
-                dv = this_elt_dv;
-              }
-            else if ((! any_class) && (! dv.hvcat (this_elt_dv, 1)))
-              eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
-          }
-      }
-
-    ok = true;
-  }
-
-  void
-  tm_row_const::tm_row_const_rep::cellify (void)
-  {
-    bool elt_changed = false;
-
-    for (auto& elt : *this)
-      {
-        octave_quit ();
-
-        if (! elt.is_cell ())
-          {
-            elt_changed = true;
-
-            if (elt.is_empty ())
-              elt = Cell ();
-            else
-              elt = Cell (elt);
-          }
-      }
-
-    if (elt_changed)
-      {
-        bool first_elem = true;
-
-        for (const octave_value& val : *this)
-          {
-            octave_quit ();
-
-            dim_vector this_elt_dv = val.dims ();
-
-            if (! this_elt_dv.zero_by_zero ())
-              {
-                if (first_elem)
-                  {
-                    first_elem = false;
-                    dv = this_elt_dv;
-                  }
-                else if (! dv.hvcat (this_elt_dv, 1))
-                  eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
-              }
-          }
-      }
-  }
-
-  class
-  tm_const : public octave::base_list<tm_row_const>
-  {
-  public:
-
-    tm_const (const tree_matrix& tm)
-      : dv (0, 0), all_str (false), all_sq_str (false), all_dq_str (false),
-        some_str (false), all_real (false), all_cmplx (false),
-        all_mt (true), any_cell (false), any_sparse (false),
-        any_class (false), class_nm (), ok (false)
-    { init (tm); }
-
-    ~tm_const (void) = default;
-
-    octave_idx_type rows (void) const { return dv.elem (0); }
-    octave_idx_type cols (void) const { return dv.elem (1); }
-
-    dim_vector dims (void) const { return dv; }
-
-    bool all_strings_p (void) const { return all_str; }
-    bool all_sq_strings_p (void) const { return all_sq_str; }
-    bool all_dq_strings_p (void) const { return all_dq_str; }
-    bool some_strings_p (void) const { return some_str; }
-    bool all_real_p (void) const { return all_real; }
-    bool all_complex_p (void) const { return all_cmplx; }
-    bool all_empty_p (void) const { return all_mt; }
-    bool any_cell_p (void) const { return any_cell; }
-    bool any_sparse_p (void) const { return any_sparse; }
-    bool any_class_p (void) const { return any_class; }
-    bool all_1x1_p (void) const { return all_1x1; }
-
-    std::string class_name (void) const { return class_nm; }
-
-    operator bool () const { return ok; }
-
-  private:
-
-    dim_vector dv;
-
-    bool all_str;
-    bool all_sq_str;
-    bool all_dq_str;
-    bool some_str;
-    bool all_real;
-    bool all_cmplx;
-    bool all_mt;
-    bool any_cell;
-    bool any_sparse;
-    bool any_class;
-    bool all_1x1;
-
-    std::string class_nm;
-
-    bool ok;
-
-    tm_const (void);
-
-    tm_const (const tm_const&);
-
-    tm_const& operator = (const tm_const&);
-
-    void init (const tree_matrix& tm);
-  };
-
-  void
-  tm_const::init (const tree_matrix& tm)
-  {
-    all_str = true;
-    all_sq_str = true;
-    all_dq_str = true;
-    all_real = true;
-    all_cmplx = true;
-    any_cell = false;
-    any_sparse = false;
-    any_class = false;
-    all_1x1 = ! tm.empty ();
-
-    bool first_elem = true;
-    bool first_elem_is_struct = false;
-
-    // Just eval and figure out if what we have is complex or all strings.
-    // We can't check columns until we know that this is a numeric matrix --
-    // collections of strings can have elements of different lengths.
-    for (const tree_argument_list* elt : tm)
-      {
-        octave_quit ();
-
-        tm_row_const tmp (*elt);
-
-        if (first_elem)
-          {
-            first_elem_is_struct = tmp.first_elem_struct_p ();
-
-            first_elem = false;
-          }
-
-        if (tmp && ! tmp.empty ())
-          {
-            if (all_str && ! tmp.all_strings_p ())
-              all_str = false;
-
-            if (all_sq_str && ! tmp.all_sq_strings_p ())
-              all_sq_str = false;
-
-            if (all_dq_str && ! tmp.all_dq_strings_p ())
-              all_dq_str = false;
-
-            if (! some_str && tmp.some_strings_p ())
-              some_str = true;
-
-            if (all_real && ! tmp.all_real_p ())
-              all_real = false;
-
-            if (all_cmplx && ! tmp.all_complex_p ())
-              all_cmplx = false;
-
-            if (all_mt && ! tmp.all_empty_p ())
-              all_mt = false;
-
-            if (! any_cell && tmp.any_cell_p ())
-              any_cell = true;
-
-            if (! any_sparse && tmp.any_sparse_p ())
-              any_sparse = true;
-
-            if (! any_class && tmp.any_class_p ())
-              any_class = true;
-
-            all_1x1 = all_1x1 && tmp.all_1x1_p ();
-
-            append (tmp);
-          }
-        else
-          break;
-      }
-
-    if (any_cell && ! any_class && ! first_elem_is_struct)
-      {
-        for (auto& elt : *this)
-          {
-            octave_quit ();
-
-            elt.cellify ();
-          }
-      }
-
-    first_elem = true;
-
-    for (tm_row_const& elt : *this)
-      {
-        octave_quit ();
-
-        octave_idx_type this_elt_nr = elt.rows ();
-        octave_idx_type this_elt_nc = elt.cols ();
-
-        std::string this_elt_class_nm = elt.class_name ();
-        class_nm = get_concat_class (class_nm, this_elt_class_nm);
-
-        dim_vector this_elt_dv = elt.dims ();
-
-        all_mt = false;
-
-        if (first_elem)
-          {
-            first_elem = false;
-
-            dv = this_elt_dv;
-          }
-        else if (all_str && dv.ndims () == 2
-                 && this_elt_dv.ndims () == 2)
-          {
-            // FIXME: this is Octave's specialty.
-            // Character matrices allow rows of unequal length.
-            if (this_elt_nc > cols ())
-              dv(1) = this_elt_nc;
-            dv(0) += this_elt_nr;
-          }
-        else if ((! any_class) && (! dv.hvcat (this_elt_dv, 0)))
-          eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
-      }
-
-    ok = true;
-  }
-
-  octave_value_list
-  tree_matrix::rvalue (int nargout)
-  {
-    if (nargout > 1)
-      error ("invalid number of output arguments for matrix list");
-
-    return rvalue1 (nargout);
-  }
 
   void
   maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
   {
     if (! (all_dq_strings_p || all_sq_strings_p))
       warning_with_id ("Octave:mixed-string-concat",
                        "concatenation of different character string types may have unintended consequences");
   }
-}
-
-template <typename TYPE, typename T>
-static void
-single_type_concat (Array<T>& result, octave::tm_const& tmp)
-{
-  octave_idx_type r = 0;
-  octave_idx_type c = 0;
-
-  for (octave::tm_row_const& row : tmp)
-    {
-      // Skip empty arrays to allow looser rules.
-      if (row.dims ().any_zero ())
-        continue;
-
-      for (auto& elt : row)
-        {
-          octave_quit ();
-
-          TYPE ra = octave_value_extract<TYPE> (elt);
-
-          // Skip empty arrays to allow looser rules.
-
-          if (! ra.is_empty ())
-            {
-              result.insert (ra, r, c);
-
-              c += ra.columns ();
-            }
-        }
-
-      r += row.rows ();
-      c = 0;
-    }
-}
-
-template <typename TYPE, typename T>
-static void
-single_type_concat (Array<T>& result, const dim_vector& dv,
-                    octave::tm_const& tmp)
-{
-  if (dv.any_zero ())
-    {
-      result = Array<T> (dv);
-      return;
-    }
-
-  if (tmp.length () == 1)
-    {
-      // If possible, forward the operation to liboctave.
-      // Single row.
-      octave::tm_row_const& row = tmp.front ();
-      if (! (equal_types<T, char>::value || equal_types<T, octave_value>::value)
-          && row.all_1x1_p ())
-        {
-          // Optimize all scalars case.
-          result.clear (dv);
-          assert (static_cast<size_t> (result.numel ()) == row.length ());
-          octave_idx_type i = 0;
-          for (const auto& elt : row)
-            result(i++) = octave_value_extract<T> (elt);
-
-          return;
-        }
-
-      octave_idx_type ncols = row.length ();
-      octave_idx_type i = 0;
-      OCTAVE_LOCAL_BUFFER (Array<T>, array_list, ncols);
-
-      for (const auto& elt : row)
-        {
-          octave_quit ();
-
-          array_list[i++] = octave_value_extract<TYPE> (elt);
-        }
-
-      result = Array<T>::cat (-2, ncols, array_list);
-    }
-  else
-    {
-      result = Array<T> (dv);
-      single_type_concat<TYPE> (result, tmp);
-    }
-}
-
-template <typename TYPE, typename T>
-static void
-single_type_concat (Sparse<T>& result, const dim_vector& dv,
-                    octave::tm_const& tmp)
-{
-  if (dv.any_zero ())
-    {
-      result = Sparse<T> (dv);
-      return;
-    }
-
-  // Sparse matrices require preallocation for efficient indexing; besides,
-  // only horizontal concatenation can be efficiently handled by indexing.
-  // So we just cat all rows through liboctave, then cat the final column.
-  octave_idx_type nrows = tmp.length ();
-  octave_idx_type j = 0;
-  OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_row_list, nrows);
-  for (octave::tm_row_const& row : tmp)
-    {
-      octave_idx_type ncols = row.length ();
-      octave_idx_type i = 0;
-      OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, ncols);
-
-      for (auto& elt : row)
-        {
-          octave_quit ();
-
-          sparse_list[i] = octave_value_extract<TYPE> (elt);
-          i++;
-        }
-
-      Sparse<T> stmp = Sparse<T>::cat (-2, ncols, sparse_list);
-      sparse_row_list[j] = stmp;
-      j++;
-    }
-
-  result = Sparse<T>::cat (-1, nrows, sparse_row_list);
-}
-
-template <typename MAP>
-static void
-single_type_concat (octave_map& result, const dim_vector& dv,
-                    octave::tm_const& tmp)
-{
-  if (dv.any_zero ())
-    {
-      result = octave_map (dv);
-      return;
-    }
-
-  octave_idx_type nrows = tmp.length ();
-  octave_idx_type j = 0;
-  OCTAVE_LOCAL_BUFFER (octave_map, map_row_list, nrows);
-  for (octave::tm_row_const& row : tmp)
-    {
-      octave_idx_type ncols = row.length ();
-      octave_idx_type i = 0;
-      OCTAVE_LOCAL_BUFFER (MAP, map_list, ncols);
-
-      for (auto& elt : row)
-        {
-          octave_quit ();
-
-          map_list[i] = octave_value_extract<MAP> (elt);
-          i++;
-        }
-
-      octave_map mtmp = octave_map::cat (-2, ncols, map_list);
-      map_row_list[j] = mtmp;
-      j++;
-    }
-
-  result = octave_map::cat (-1, nrows, map_row_list);
-}
-
-template <typename TYPE>
-static octave_value
-do_single_type_concat (const dim_vector& dv, octave::tm_const& tmp)
-{
-  TYPE result;
-
-  single_type_concat<TYPE> (result, dv, tmp);
-
-  return result;
-}
-
-template <>
-octave_value
-do_single_type_concat<octave_map> (const dim_vector& dv, octave::tm_const& tmp)
-{
-  octave_map result;
-
-  if (tmp.all_1x1_p ())
-    single_type_concat<octave_scalar_map> (result, dv, tmp);
-  else
-    single_type_concat<octave_map> (result, dv, tmp);
-
-  return result;
-}
-
-static octave_value
-do_class_concat (octave::tm_const& tmc)
-{
-  octave_value retval;
-
-  octave_value_list rows (tmc.length (), octave_value ());
-
-  octave_idx_type j = 0;
-  for (octave::tm_row_const& tmrc : tmc)
-    {
-      octave_quit ();
-
-      if (tmrc.length () == 1)
-        rows(j++) = *(tmrc.begin ());
-      else
-        {
-          octave_value_list row (tmrc.length (), octave_value ());
-
-          octave_idx_type i = 0;
-          for (auto& elt : tmrc)
-            row(i++) = elt;
-
-          rows(j++) = do_class_concat (row, "horzcat", 1);
-        }
-    }
-
-  if (rows.length () == 1)
-    retval = rows(0);
-  else
-    retval = do_class_concat (rows, "vertcat", 0);
-
-  return retval;
-}
-
-namespace octave
-{
-  octave_value
-  tree_matrix::rvalue1 (int)
-  {
-    octave_value retval = Matrix ();
-
-    bool all_strings_p = false;
-    bool all_sq_strings_p = false;
-    bool all_dq_strings_p = false;
-    bool all_empty_p = false;
-    bool all_real_p = false;
-    bool any_sparse_p = false;
-    bool any_class_p = false;
-    bool frc_str_conv = false;
-
-    tm_const tmp (*this);
-
-    if (tmp && ! tmp.empty ())
-      {
-        dim_vector dv = tmp.dims ();
-        all_strings_p = tmp.all_strings_p ();
-        all_sq_strings_p = tmp.all_sq_strings_p ();
-        all_dq_strings_p = tmp.all_dq_strings_p ();
-        all_empty_p = tmp.all_empty_p ();
-        all_real_p = tmp.all_real_p ();
-        any_sparse_p = tmp.any_sparse_p ();
-        any_class_p = tmp.any_class_p ();
-        frc_str_conv = tmp.some_strings_p ();
-
-        // Try to speed up the common cases.
-
-        std::string result_type = tmp.class_name ();
-
-        if (any_class_p)
-          {
-            retval = do_class_concat (tmp);
-          }
-        else if (result_type == "double")
-          {
-            if (any_sparse_p)
-              {
-                if (all_real_p)
-                  retval = do_single_type_concat<SparseMatrix> (dv, tmp);
-                else
-                  retval = do_single_type_concat<SparseComplexMatrix> (dv, tmp);
-              }
-            else
-              {
-                if (all_real_p)
-                  retval = do_single_type_concat<NDArray> (dv, tmp);
-                else
-                  retval = do_single_type_concat<ComplexNDArray> (dv, tmp);
-              }
-          }
-        else if (result_type == "single")
-          {
-            if (all_real_p)
-              retval = do_single_type_concat<FloatNDArray> (dv, tmp);
-            else
-              retval = do_single_type_concat<FloatComplexNDArray> (dv, tmp);
-          }
-        else if (result_type == "char")
-          {
-            char type = all_dq_strings_p ? '"' : '\'';
-
-            if (! all_strings_p)
-              warn_implicit_conversion ("Octave:num-to-str",
-                                        "numeric", result_type);
-            else
-              maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
-
-            charNDArray result (dv, Vstring_fill_char);
-
-            single_type_concat<charNDArray> (result, tmp);
-
-            retval = octave_value (result, type);
-          }
-        else if (result_type == "logical")
-          {
-            if (any_sparse_p)
-              retval = do_single_type_concat<SparseBoolMatrix> (dv, tmp);
-            else
-              retval = do_single_type_concat<boolNDArray> (dv, tmp);
-          }
-        else if (result_type == "int8")
-          retval = do_single_type_concat<int8NDArray> (dv, tmp);
-        else if (result_type == "int16")
-          retval = do_single_type_concat<int16NDArray> (dv, tmp);
-        else if (result_type == "int32")
-          retval = do_single_type_concat<int32NDArray> (dv, tmp);
-        else if (result_type == "int64")
-          retval = do_single_type_concat<int64NDArray> (dv, tmp);
-        else if (result_type == "uint8")
-          retval = do_single_type_concat<uint8NDArray> (dv, tmp);
-        else if (result_type == "uint16")
-          retval = do_single_type_concat<uint16NDArray> (dv, tmp);
-        else if (result_type == "uint32")
-          retval = do_single_type_concat<uint32NDArray> (dv, tmp);
-        else if (result_type == "uint64")
-          retval = do_single_type_concat<uint64NDArray> (dv, tmp);
-        else if (result_type == "cell")
-          retval = do_single_type_concat<Cell> (dv, tmp);
-        else if (result_type == "struct")
-          retval = do_single_type_concat<octave_map> (dv, tmp);
-        else
-          {
-            // The line below might seem crazy, since we take a copy of
-            // the first argument, resize it to be empty and then resize
-            // it to be full.  This is done since it means that there is
-            // no recopying of data, as would happen if we used a single
-            // resize.  It should be noted that resize operation is also
-            // significantly slower than the do_cat_op function, so it
-            // makes sense to have an empty matrix and copy all data.
-            //
-            // We might also start with a empty octave_value using
-            //
-            //    ctmp = octave_value_typeinfo::lookup_type
-            //          (tmp.begin() -> begin() -> type_name());
-            //
-            // and then directly resize.  However, for some types there
-            // might be some additional setup needed, and so this should
-            // be avoided.
-
-            octave_value ctmp;
-
-            // Find the first non-empty object
-
-            if (any_sparse_p)
-              {
-                // Start with sparse matrix to avoid issues memory issues
-                // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
-                if (all_real_p)
-                  ctmp = octave_sparse_matrix ().resize (dv);
-                else
-                  ctmp = octave_sparse_complex_matrix ().resize (dv);
-              }
-            else
-              {
-                for (tm_row_const& row : tmp)
-                  {
-                    octave_quit ();
-
-                    for (auto& elt : row)
-                      {
-                        octave_quit ();
-
-                        ctmp = elt;
-
-                        if (! ctmp.all_zero_dims ())
-                          goto found_non_empty;
-                      }
-                  }
-
-                ctmp = (*(tmp.begin () -> begin ()));
-
-              found_non_empty:
-
-                if (! all_empty_p)
-                  ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
-              }
-
-            // Now, extract the values from the individual elements and
-            // insert them in the result matrix.
-
-            int dv_len = dv.ndims ();
-            octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
-            Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
-
-            for (tm_row_const& row : tmp)
-              {
-                octave_quit ();
-
-                for (auto& elt : row)
-                  {
-                    octave_quit ();
-
-                    if (elt.is_empty ())
-                      continue;
-
-                    ctmp = do_cat_op (ctmp, elt, ra_idx);
-
-                    ra_idx (1) += elt.columns ();
-                  }
-
-                ra_idx (0) += row.rows ();
-                ra_idx (1) = 0;
-              }
-
-            retval = ctmp;
-
-            if (frc_str_conv && ! retval.is_string ())
-              retval = retval.convert_to_str ();
-          }
-      }
-
-    return retval;
-  }
 
   tree_expression *
   tree_matrix::dup (symbol_table::scope_id scope,
                     symbol_table::context_id context) const
   {
     tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
 
     new_matrix->copy_base (*this, scope, context);
 
     return new_matrix;
   }
-
-  void
-  tree_matrix::accept (tree_walker& tw)
-  {
-    tw.visit_matrix (*this);
-  }
 }
 
 
 /*
 ## test concatenation with all zero matrices
 %!assert ([ "" 65*ones(1,10) ], "AAAAAAAAAA")
 %!assert ([ 65*ones(1,10) "" ], "AAAAAAAAAA")
 
diff --git a/libinterp/parse-tree/pt-mat.h b/libinterp/parse-tree/pt-mat.h
--- a/libinterp/parse-tree/pt-mat.h
+++ b/libinterp/parse-tree/pt-mat.h
@@ -28,27 +28,26 @@ along with Octave; see the file COPYING.
 #include <iosfwd>
 
 class octave_value;
 class octave_value_list;
 
 #include "base-list.h"
 #include "pt-array-list.h"
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 // The character to fill with when creating string arrays.
 extern char Vstring_fill_char;
 
 namespace octave
 {
   class tree_argument_list;
 
-  class tree_walker;
-
   // General matrices.  This allows us to construct matrices from
   // other matrices, variables, and functions.
 
   class tree_matrix : public tree_array_list
   {
   public:
 
     tree_matrix (tree_argument_list *row = 0, int l = -1, int c = -1)
@@ -62,24 +61,23 @@ namespace octave
     tree_matrix& operator = (const tree_matrix&) = delete;
 
     ~tree_matrix (void) = default;
 
     bool is_matrix (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_matrix (*this);
+    }
   };
 
   extern std::string
   get_concat_class (const std::string& c1, const std::string& c2);
 
   extern void
   maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p);
 }
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -107,169 +107,27 @@ namespace octave
             delete *p;
             erase (p);
           }
       }
 
     return retval;
   }
 
-  void
-  tree_parameter_list::initialize_undefined_elements (const std::string& warnfor,
-                                                      int nargout,
-                                                      const octave_value& val)
-  {
-    bool warned = false;
-
-    int count = 0;
-
-    octave_value tmp = symbol_table::varval (".ignored.");
-    const Matrix ignored = tmp.is_defined () ? tmp.matrix_value () : Matrix ();
-
-    octave_idx_type k = 0;
-
-    for (tree_decl_elt* elt : *this)
-      {
-        if (++count > nargout)
-          break;
-
-        if (! elt->is_variable ())
-          {
-            if (! warned)
-              {
-                warned = true;
-
-                while (k < ignored.numel ())
-                  {
-                    octave_idx_type l = ignored (k);
-                    if (l == count)
-                      {
-                        warned = false;
-                        break;
-                      }
-                    else if (l > count)
-                      break;
-                    else
-                      k++;
-                  }
-
-                if (warned)
-                  {
-                    warning_with_id
-                      ("Octave:undefined-return-values",
-                       "%s: some elements in list of return values are undefined",
-                       warnfor.c_str ());
-                  }
-              }
-
-            octave_lvalue lval = elt->lvalue ();
-
-            lval.assign (octave_value::op_asn_eq, val);
-          }
-      }
-  }
-
-  void
-  tree_parameter_list::define_from_arg_vector (const octave_value_list& args)
-  {
-    int expected_nargin = length ();
-
-    iterator p = begin ();
-
-    for (int i = 0; i < expected_nargin; i++)
-      {
-        tree_decl_elt *elt = *p++;
-
-        octave_lvalue ref = elt->lvalue ();
-
-        if (i < args.length ())
-          {
-            if (args(i).is_defined () && args(i).is_magic_colon ())
-              {
-                if (! elt->eval ())
-                  error ("no default value for argument %d", i+1);
-              }
-            else
-              ref.define (args(i));
-          }
-        else
-          elt->eval ();
-      }
-  }
-
-  void
-  tree_parameter_list::undefine (void)
-  {
-    int len = length ();
-
-    iterator p = begin ();
-
-    for (int i = 0; i < len; i++)
-      {
-        tree_decl_elt *elt = *p++;
-
-        octave_lvalue ref = elt->lvalue ();
-
-        ref.assign (octave_value::op_asn_eq, octave_value ());
-      }
-  }
-
   std::list<std::string>
   tree_parameter_list::variable_names (void) const
   {
     std::list<std::string> retval;
 
     for (tree_decl_elt* elt : *this)
       retval.push_back (elt->name ());
 
     return retval;
   }
 
-  octave_value_list
-  tree_parameter_list::convert_to_const_vector (int nargout,
-                                                const Cell& varargout)
-  {
-    octave_idx_type vlen = varargout.numel ();
-    int len = length ();
-
-    // Special case.  Will do a shallow copy.
-    if (len == 0)
-      return varargout;
-    else if (nargout <= len)
-      {
-        octave_value_list retval (nargout);
-
-        int i = 0;
-
-        for (tree_decl_elt* elt : *this)
-          {
-            if (elt->is_defined ())
-              retval(i++) = elt->rvalue1 ();
-            else
-              break;
-          }
-
-        return retval;
-      }
-    else
-      {
-        octave_value_list retval (len + vlen);
-
-        int i = 0;
-
-        for (tree_decl_elt* elt : *this)
-          retval(i++) = elt->rvalue1 ();
-
-        for (octave_idx_type j = 0; j < vlen; j++)
-          retval(i++) = varargout(j);
-
-        return retval;
-      }
-  }
-
   bool
   tree_parameter_list::is_defined (void)
   {
     bool status = true;
 
     for (tree_decl_elt* elt : *this)
       {
         if (! elt->is_variable ())
@@ -292,22 +150,16 @@ namespace octave
       new_list->mark_varargs ();
 
     for (const tree_decl_elt* elt : *this)
       new_list->append (elt->dup (scope, context));
 
     return new_list;
   }
 
-  void
-  tree_parameter_list::accept (tree_walker& tw)
-  {
-    tw.visit_parameter_list (*this);
-  }
-
   // Return lists.
 
   tree_return_list::~tree_return_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
@@ -321,15 +173,9 @@ namespace octave
   {
     tree_return_list *new_list = new tree_return_list ();
 
     for (const tree_index_expression* elt : *this)
       new_list->append (elt->dup (scope, context));
 
     return new_list;
   }
-
-  void
-  tree_return_list::accept (tree_walker& tw)
-  {
-    tw.visit_return_list (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -27,26 +27,25 @@ along with Octave; see the file COPYING.
 
 class Cell;
 
 class octave_value;
 class octave_value_list;
 
 #include "base-list.h"
 #include "pt-decl.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
   class tree_identifier;
   class tree_index_expression;
   class tree_va_return_list;
 
-  class tree_walker;
-
   // Parameter lists.  Used to hold the list of input and output
   // parameters in a function definition.  Elements are identifiers
   // only.
 
   class tree_parameter_list : public octave::base_list<tree_decl_elt *>
   {
   public:
 
@@ -76,34 +75,27 @@ namespace octave
     void mark_as_formal_parameters (void);
 
     bool validate (in_or_out type);
 
     bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
     bool varargs_only (void) { return (marked_for_varargs < 0); }
 
-    void initialize_undefined_elements (const std::string& warnfor,
-                                        int nargout, const octave_value& val);
-
-    void define_from_arg_vector (const octave_value_list& args);
-
-    void undefine (void);
-
     bool is_defined (void);
 
     std::list<std::string> variable_names (void) const;
 
-    octave_value_list convert_to_const_vector (int nargout,
-                                               const Cell& varargout);
-
     tree_parameter_list *dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_parameter_list (*this);
+    }
 
   private:
 
     int marked_for_varargs;
 
     void mark_varargs (void) { marked_for_varargs = 1; }
 
     void mark_varargs_only (void) { marked_for_varargs = -1; }
@@ -126,17 +118,20 @@ namespace octave
 
     tree_return_list& operator = (const tree_return_list&) = delete;
 
     ~tree_return_list (void);
 
     tree_return_list *dup (symbol_table::scope_id scope,
                            symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_return_list (*this);
+    }
   };
 
   class tree_va_return_list : public octave::base_list<octave_value>
   {
   public:
 
     tree_va_return_list (void) { }
 
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -50,42 +50,30 @@ namespace octave
   tree_if_clause::dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const
   {
     return new tree_if_clause (expr ? expr->dup (scope, context) : 0,
                                list ? list->dup (scope, context) : 0,
                                lead_comm ? lead_comm->dup () : 0);
   }
 
-  void
-  tree_if_clause::accept (tree_walker& tw)
-  {
-    tw.visit_if_clause (*this);
-  }
-
   // List of if commands.
 
   tree_if_command_list *
   tree_if_command_list::dup (symbol_table::scope_id scope,
                              symbol_table::context_id context) const
   {
     tree_if_command_list *new_icl = new tree_if_command_list ();
 
     for (const tree_if_clause* elt : *this)
       new_icl->append (elt ? elt->dup (scope, context) : 0);
 
     return new_icl;
   }
 
-  void
-  tree_if_command_list::accept (tree_walker& tw)
-  {
-    tw.visit_if_command_list (*this);
-  }
-
   // If.
 
   tree_if_command::~tree_if_command (void)
   {
     delete list;
     delete lead_comm;
     delete trail_comm;
   }
@@ -95,95 +83,48 @@ namespace octave
                         symbol_table::context_id context) const
   {
     return new tree_if_command (list ? list->dup (scope, context) : 0,
                                 lead_comm ? lead_comm->dup () : 0,
                                 trail_comm ? trail_comm->dup () : 0,
                                 line (), column ());
   }
 
-  void
-  tree_if_command::accept (tree_walker& tw)
-  {
-    tw.visit_if_command (*this);
-  }
-
   // Switch cases.
 
   tree_switch_case::~tree_switch_case (void)
   {
     delete label;
     delete list;
     delete lead_comm;
   }
 
-  bool
-  tree_switch_case::label_matches (const octave_value& val)
-  {
-    octave_value label_value = label->rvalue1 ();
-
-    if (label_value.is_defined ())
-      {
-        if (label_value.is_cell ())
-          {
-            Cell cell (label_value.cell_value ());
-
-            for (octave_idx_type i = 0; i < cell.rows (); i++)
-              {
-                for (octave_idx_type j = 0; j < cell.columns (); j++)
-                  {
-                    bool match = val.is_equal (cell(i,j));
-
-                    if (match)
-                      return true;
-                  }
-              }
-          }
-        else
-          return val.is_equal (label_value);
-      }
-
-    return false;
-  }
-
   tree_switch_case *
   tree_switch_case::dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const
   {
     return new tree_switch_case (label ? label->dup (scope, context) : 0,
                                  list ? list->dup (scope, context) : 0,
                                  lead_comm ? lead_comm->dup () : 0);
   }
 
-  void
-  tree_switch_case::accept (tree_walker& tw)
-  {
-    tw.visit_switch_case (*this);
-  }
-
   // List of switch cases.
 
   tree_switch_case_list *
   tree_switch_case_list::dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const
   {
     tree_switch_case_list *new_scl = new tree_switch_case_list ();
 
     for (const tree_switch_case* elt : *this)
       new_scl->append (elt ? elt->dup (scope, context) : 0);
 
     return new_scl;
   }
 
-  void
-  tree_switch_case_list::accept (tree_walker& tw)
-  {
-    tw.visit_switch_case_list (*this);
-  }
-
   // Switch.
 
   tree_switch_command::~tree_switch_command (void)
   {
     delete expr;
     delete list;
     delete lead_comm;
     delete trail_comm;
@@ -194,15 +135,9 @@ namespace octave
                             symbol_table::context_id context) const
   {
     return new tree_switch_command (expr ? expr->dup (scope, context) : 0,
                                     list ? list->dup (scope, context) : 0,
                                     lead_comm ? lead_comm->dup () : 0,
                                     trail_comm ? trail_comm->dup () : 0,
                                     line (), column ());
   }
-
-  void
-  tree_switch_command::accept (tree_walker& tw)
-  {
-    tw.visit_switch_command (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -23,25 +23,24 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_pt_select_h)
 #define octave_pt_select_h 1
 
 #include "octave-config.h"
 
 #include "base-list.h"
 #include "comment-list.h"
 #include "pt-cmd.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
   class tree_expression;
   class tree_statement_list;
 
-  class tree_walker;
-
   // If.
 
   class tree_if_clause : public tree
   {
   public:
 
     tree_if_clause (int l = -1, int c = -1)
       : tree (l, c), expr (0), list (0), lead_comm (0) { }
@@ -69,17 +68,20 @@ namespace octave
 
     tree_statement_list *commands (void) { return list; }
 
     octave_comment_list *leading_comment (void) { return lead_comm; }
 
     tree_if_clause *dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_if_clause (*this);
+    }
 
   private:
 
     // The condition to test.
     tree_expression *expr;
 
     // The list of statements to evaluate if expr is true.
     tree_statement_list *list;
@@ -110,17 +112,20 @@ namespace octave
           delete *p;
           erase (p);
         }
     }
 
     tree_if_command_list *dup (symbol_table::scope_id scope,
                                symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_if_command_list (*this);
+    }
   };
 
   class tree_if_command : public tree_command
   {
   public:
 
     tree_if_command (int l = -1, int c = -1)
       : tree_command (l, c), list (0), lead_comm (0), trail_comm (0) { }
@@ -141,17 +146,20 @@ namespace octave
 
     octave_comment_list *leading_comment (void) { return lead_comm; }
 
     octave_comment_list *trailing_comment (void) { return trail_comm; }
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_if_command (*this);
+    }
 
   private:
 
     // List of if commands (if, elseif, elseif, ... else, endif)
     tree_if_command_list *list;
 
     // Comment preceding IF token.
     octave_comment_list *lead_comm;
@@ -183,28 +191,29 @@ namespace octave
     tree_switch_case (const tree_switch_case&) = delete;
 
     tree_switch_case& operator = (const tree_switch_case&) = delete;
 
     ~tree_switch_case (void);
 
     bool is_default_case (void) { return ! label; }
 
-    bool label_matches (const octave_value& val);
-
     tree_expression *case_label (void) { return label; }
 
     tree_statement_list *commands (void) { return list; }
 
     octave_comment_list *leading_comment (void) { return lead_comm; }
 
     tree_switch_case *dup (symbol_table::scope_id scope,
                            symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_switch_case (*this);
+    }
 
   private:
 
     // The case label.
     tree_expression *label;
 
     // The list of statements to evaluate if the label matches.
     tree_statement_list *list;
@@ -235,17 +244,20 @@ namespace octave
           delete *p;
           erase (p);
         }
     }
 
     tree_switch_case_list *dup (symbol_table::scope_id scope,
                                 symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_switch_case_list (*this);
+    }
   };
 
   class tree_switch_command : public tree_command
   {
   public:
 
     tree_switch_command (int l = -1, int c = -1)
       : tree_command (l, c), expr (0), list (0), lead_comm (0),
@@ -271,17 +283,20 @@ namespace octave
 
     octave_comment_list *leading_comment (void) { return lead_comm; }
 
     octave_comment_list *trailing_comment (void) { return trail_comm; }
 
     tree_command *dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_switch_command (*this);
+    }
 
   private:
 
     // Value on which to switch.
     tree_expression *expr;
 
     // List of cases (case 1, case 2, ..., default)
     tree_switch_case_list *list;
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -177,22 +177,16 @@ namespace octave
 
     new_stmt->expr = expr ? expr->dup (scope, context) : 0;
 
     new_stmt->comm = comm ? comm->dup () : 0;
 
     return new_stmt;
   }
 
-  void
-  tree_statement::accept (tree_walker& tw)
-  {
-    tw.visit_statement (*this);
-  }
-
   // Create a "breakpoint" tree-walker, and get it to "walk" this statement list
   // (FIXME: What does that do???)
   int
   tree_statement_list::set_breakpoint (int line, const std::string& condition)
   {
     tree_breakpoint tbp (line, tree_breakpoint::set, condition);
     accept (tbp);
 
@@ -311,15 +305,9 @@ namespace octave
 
     new_list->function_body = function_body;
 
     for (const tree_statement* elt : *this)
       new_list->append (elt ? elt->dup (scope, context) : 0);
 
     return new_list;
   }
-
-  void
-  tree_statement_list::accept (tree_walker& tw)
-  {
-    tw.visit_statement_list (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -27,26 +27,25 @@ along with Octave; see the file COPYING.
 
 class octave_value_list;
 
 #include <deque>
 
 #include "base-list.h"
 #include "bp-table.h"
 #include "comment-list.h"
+#include "pt.h"
+#include "pt-walk.h"
 #include "symtab.h"
-#include "pt.h"
 
 namespace octave
 {
   class tree_command;
   class tree_expression;
 
-  class tree_walker;
-
   // A statement is either a command to execute or an expression to
   // evaluate.
 
   class tree_statement : public tree
   {
   public:
 
     tree_statement (void)
@@ -106,17 +105,20 @@ namespace octave
 
     void set_command (tree_command *c) { cmd = c; }
 
     void set_expression (tree_expression *e) { expr = e; }
 
     tree_statement *dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_statement (*this);
+    }
 
   private:
 
     // Only one of cmd or expr can be valid at once.
 
     // Command to execute.
     tree_command *cmd;
 
@@ -181,17 +183,20 @@ namespace octave
                                      const bp_table::intmap& line,
                                      const std::string& condition);
 
     bp_table::intmap remove_all_breakpoints (const std::string& file);
 
     tree_statement_list *dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_statement_list (*this);
+    }
 
   private:
 
     // Does this list of statements make up the body of a function?
     bool function_body;
 
     // Does this list of statements make up the body of a function?
     bool anon_function_body;
diff --git a/libinterp/parse-tree/pt-tm-const.cc b/libinterp/parse-tree/pt-tm-const.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/parse-tree/pt-tm-const.cc
@@ -0,0 +1,402 @@
+/*
+
+Copyright (C) 1996-2017 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#include <iostream>
+
+#include "oct-locbuf.h"
+#include "quit.h"
+
+#include "data.h"
+#include "defun.h"
+#include "error.h"
+#include "errwarn.h"
+#include "oct-map.h"
+#include "ovl.h"
+#include "pt-arg-list.h"
+#include "pt-bp.h"
+#include "pt-eval.h"
+#include "pt-exp.h"
+#include "pt-mat.h"
+#include "pt-tm-const.h"
+#include "utils.h"
+#include "ov.h"
+#include "variables.h"
+
+#include "ov-cx-mat.h"
+#include "ov-flt-cx-mat.h"
+#include "ov-re-sparse.h"
+#include "ov-cx-sparse.h"
+
+OCTAVE_NORETURN static
+void
+eval_error (const char *msg, const dim_vector& x, const dim_vector& y)
+{
+  error ("%s (%s vs %s)", msg, x.str ().c_str (), y.str ().c_str ());
+}
+
+namespace octave
+{
+  void
+  tm_row_const::tm_row_const_rep::do_init_element (const octave_value& val,
+                                                   bool& first_elem)
+  {
+    std::string this_elt_class_nm
+      = val.is_object () ? std::string ("class") : val.class_name ();
+
+    class_nm = get_concat_class (class_nm, this_elt_class_nm);
+
+    dim_vector this_elt_dv = val.dims ();
+
+    if (! this_elt_dv.zero_by_zero ())
+      {
+        all_mt = false;
+
+        if (first_elem)
+          {
+            if (val.is_map ())
+              first_elem_is_struct = true;
+
+            first_elem = false;
+          }
+      }
+
+    append (val);
+
+    if (all_str && ! val.is_string ())
+      all_str = false;
+
+    if (all_sq_str && ! val.is_sq_string ())
+      all_sq_str = false;
+
+    if (all_dq_str && ! val.is_dq_string ())
+      all_dq_str = false;
+
+    if (! some_str && val.is_string ())
+      some_str = true;
+
+    if (all_real && ! val.is_real_type ())
+      all_real = false;
+
+    if (all_cmplx && ! (val.is_complex_type () || val.is_real_type ()))
+      all_cmplx = false;
+
+    if (! any_cell && val.is_cell ())
+      any_cell = true;
+
+    if (! any_sparse && val.is_sparse_type ())
+      any_sparse = true;
+
+    if (! any_class && val.is_object ())
+      any_class = true;
+
+    // Special treatment of sparse matrices to avoid out-of-memory error
+    all_1x1 = all_1x1 && ! val.is_sparse_type () && val.numel () == 1;
+  }
+
+  void
+  tm_row_const::tm_row_const_rep::init (const tree_argument_list& row,
+                                        tree_evaluator *tw)
+  {
+    all_str = true;
+    all_sq_str = true;
+    all_dq_str = true;
+    all_real = true;
+    all_cmplx = true;
+    any_cell = false;
+    any_sparse = false;
+    any_class = false;
+
+    bool first_elem = true;
+
+    for (tree_expression* elt : row)
+      {
+        octave_quit ();
+
+        octave_value tmp = tw->evaluate (elt);
+
+        if (tmp.is_undefined ())
+          {
+            ok = true;
+            return;
+          }
+        else
+          {
+            if (tmp.is_cs_list ())
+              {
+                octave_value_list tlst = tmp.list_value ();
+
+                for (octave_idx_type i = 0; i < tlst.length (); i++)
+                  {
+                    octave_quit ();
+
+                    do_init_element (tlst(i), first_elem);
+                  }
+              }
+            else
+              do_init_element (tmp, first_elem);
+          }
+      }
+
+    if (any_cell && ! any_class && ! first_elem_is_struct)
+      cellify ();
+
+    first_elem = true;
+
+    for (const octave_value& val : *this)
+      {
+        octave_quit ();
+
+        dim_vector this_elt_dv = val.dims ();
+
+        if (! this_elt_dv.zero_by_zero ())
+          {
+            all_mt = false;
+
+            if (first_elem)
+              {
+                first_elem = false;
+                dv = this_elt_dv;
+              }
+            else if ((! any_class) && (! dv.hvcat (this_elt_dv, 1)))
+              eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
+          }
+      }
+
+    ok = true;
+  }
+
+  void
+  tm_row_const::tm_row_const_rep::cellify (void)
+  {
+    bool elt_changed = false;
+
+    for (auto& elt : *this)
+      {
+        octave_quit ();
+
+        if (! elt.is_cell ())
+          {
+            elt_changed = true;
+
+            if (elt.is_empty ())
+              elt = Cell ();
+            else
+              elt = Cell (elt);
+          }
+      }
+
+    if (elt_changed)
+      {
+        bool first_elem = true;
+
+        for (const octave_value& val : *this)
+          {
+            octave_quit ();
+
+            dim_vector this_elt_dv = val.dims ();
+
+            if (! this_elt_dv.zero_by_zero ())
+              {
+                if (first_elem)
+                  {
+                    first_elem = false;
+                    dv = this_elt_dv;
+                  }
+                else if (! dv.hvcat (this_elt_dv, 1))
+                  eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
+              }
+          }
+      }
+  }
+
+  void
+  tm_const::init (const tree_matrix& tm, tree_evaluator *tw)
+  {
+    all_str = true;
+    all_sq_str = true;
+    all_dq_str = true;
+    all_real = true;
+    all_cmplx = true;
+    any_cell = false;
+    any_sparse = false;
+    any_class = false;
+    all_1x1 = ! tm.empty ();
+
+    bool first_elem = true;
+    bool first_elem_is_struct = false;
+
+    // Just eval and figure out if what we have is complex or all strings.
+    // We can't check columns until we know that this is a numeric matrix --
+    // collections of strings can have elements of different lengths.
+    for (const tree_argument_list* elt : tm)
+      {
+        octave_quit ();
+
+        tm_row_const tmp (*elt, tw);
+
+        if (first_elem)
+          {
+            first_elem_is_struct = tmp.first_elem_struct_p ();
+
+            first_elem = false;
+          }
+
+        if (tmp && ! tmp.empty ())
+          {
+            if (all_str && ! tmp.all_strings_p ())
+              all_str = false;
+
+            if (all_sq_str && ! tmp.all_sq_strings_p ())
+              all_sq_str = false;
+
+            if (all_dq_str && ! tmp.all_dq_strings_p ())
+              all_dq_str = false;
+
+            if (! some_str && tmp.some_strings_p ())
+              some_str = true;
+
+            if (all_real && ! tmp.all_real_p ())
+              all_real = false;
+
+            if (all_cmplx && ! tmp.all_complex_p ())
+              all_cmplx = false;
+
+            if (all_mt && ! tmp.all_empty_p ())
+              all_mt = false;
+
+            if (! any_cell && tmp.any_cell_p ())
+              any_cell = true;
+
+            if (! any_sparse && tmp.any_sparse_p ())
+              any_sparse = true;
+
+            if (! any_class && tmp.any_class_p ())
+              any_class = true;
+
+            all_1x1 = all_1x1 && tmp.all_1x1_p ();
+
+            append (tmp);
+          }
+        else
+          break;
+      }
+
+    if (any_cell && ! any_class && ! first_elem_is_struct)
+      {
+        for (auto& elt : *this)
+          {
+            octave_quit ();
+
+            elt.cellify ();
+          }
+      }
+
+    first_elem = true;
+
+    for (tm_row_const& elt : *this)
+      {
+        octave_quit ();
+
+        octave_idx_type this_elt_nr = elt.rows ();
+        octave_idx_type this_elt_nc = elt.cols ();
+
+        std::string this_elt_class_nm = elt.class_name ();
+        class_nm = get_concat_class (class_nm, this_elt_class_nm);
+
+        dim_vector this_elt_dv = elt.dims ();
+
+        all_mt = false;
+
+        if (first_elem)
+          {
+            first_elem = false;
+
+            dv = this_elt_dv;
+          }
+        else if (all_str && dv.ndims () == 2
+                 && this_elt_dv.ndims () == 2)
+          {
+            // FIXME: this is Octave's specialty.
+            // Character matrices allow rows of unequal length.
+            if (this_elt_nc > cols ())
+              dv(1) = this_elt_nc;
+            dv(0) += this_elt_nr;
+          }
+        else if ((! any_class) && (! dv.hvcat (this_elt_dv, 0)))
+          eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
+      }
+
+    ok = true;
+  }
+
+  template <>
+  octave_value
+  do_single_type_concat<octave_map> (const dim_vector& dv,
+                                     octave::tm_const& tmp)
+  {
+    octave_map result;
+
+    if (tmp.all_1x1_p ())
+      single_type_concat<octave_scalar_map> (result, dv, tmp);
+    else
+      single_type_concat<octave_map> (result, dv, tmp);
+
+    return result;
+  }
+
+  octave_value do_class_concat (octave::tm_const& tmc)
+  {
+    octave_value retval;
+
+    octave_value_list rows (tmc.length (), octave_value ());
+
+    octave_idx_type j = 0;
+    for (octave::tm_row_const& tmrc : tmc)
+      {
+        octave_quit ();
+
+        if (tmrc.length () == 1)
+          rows(j++) = *(tmrc.begin ());
+        else
+          {
+            octave_value_list row (tmrc.length (), octave_value ());
+
+            octave_idx_type i = 0;
+            for (auto& elt : tmrc)
+              row(i++) = elt;
+
+            rows(j++) = do_class_concat (row, "horzcat", 1);
+          }
+      }
+
+    if (rows.length () == 1)
+      retval = rows(0);
+    else
+      retval = do_class_concat (rows, "vertcat", 0);
+
+    return retval;
+  }
+}
diff --git a/libinterp/parse-tree/pt-tm-const.h b/libinterp/parse-tree/pt-tm-const.h
new file mode 100644
--- /dev/null
+++ b/libinterp/parse-tree/pt-tm-const.h
@@ -0,0 +1,435 @@
+/*
+
+Copyright (C) 1996-2017 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_pt_tm_const_h)
+#define octave_pt_tm_const_h 1
+
+#include "octave-config.h"
+
+#include <string>
+
+#include "Array.h"
+#include "Sparse.h"
+#include "base-list.h"
+
+#include "data.h"
+#include "dim-vector.h"
+#include "oct-map.h"
+#include "ov.h"
+#include "ovl.h"
+
+namespace octave
+{
+  class tree_evaluator;
+
+  // General matrices.  This list type is much more work to handle than
+  // constant matrices, but it allows us to construct matrices from
+  // other matrices, variables, and functions.
+
+  // But first, some internal classes that make our job much easier.
+
+  class
+  tm_row_const
+  {
+  private:
+
+    class
+    tm_row_const_rep : public octave::base_list<octave_value>
+    {
+    public:
+
+      tm_row_const_rep (void)
+        : count (1), dv (0, 0), all_str (false),
+          all_sq_str (false), all_dq_str (false),
+          some_str (false), all_real (false), all_cmplx (false),
+          all_mt (true), any_cell (false), any_sparse (false),
+          any_class (false), all_1x1 (false),
+          first_elem_is_struct (false), class_nm (), ok (false)
+      { }
+
+      tm_row_const_rep (const tree_argument_list& row, tree_evaluator *tw)
+        : count (1), dv (0, 0), all_str (false), all_sq_str (false),
+          some_str (false), all_real (false), all_cmplx (false),
+          all_mt (true), any_cell (false), any_sparse (false),
+          any_class (false), all_1x1 (! row.empty ()),
+          first_elem_is_struct (false), class_nm (), ok (false)
+      { init (row, tw); }
+
+      ~tm_row_const_rep (void) = default;
+
+      octave::refcount<int> count;
+
+      dim_vector dv;
+
+      bool all_str;
+      bool all_sq_str;
+      bool all_dq_str;
+      bool some_str;
+      bool all_real;
+      bool all_cmplx;
+      bool all_mt;
+      bool any_cell;
+      bool any_sparse;
+      bool any_class;
+      bool all_1x1;
+      bool first_elem_is_struct;
+
+      std::string class_nm;
+
+      bool ok;
+
+      void do_init_element (const octave_value&, bool&);
+
+      void init (const tree_argument_list&, tree_evaluator *tw);
+
+      void cellify (void);
+
+    private:
+
+      tm_row_const_rep (const tm_row_const_rep&);
+
+      tm_row_const_rep& operator = (const tm_row_const_rep&);
+
+    };
+
+  public:
+
+    typedef tm_row_const_rep::iterator iterator;
+    typedef tm_row_const_rep::const_iterator const_iterator;
+
+    tm_row_const (void)
+      : rep (0) { }
+
+    tm_row_const (const tree_argument_list& row, tree_evaluator *tw)
+      : rep (new tm_row_const_rep (row, tw)) { }
+
+    tm_row_const (const tm_row_const& x)
+      : rep (x.rep)
+    {
+      if (rep)
+        rep->count++;
+    }
+
+    tm_row_const& operator = (const tm_row_const& x)
+    {
+      if (this != &x && rep != x.rep)
+        {
+          if (rep && --rep->count == 0)
+            delete rep;
+
+          rep = x.rep;
+
+          if (rep)
+            rep->count++;
+        }
+
+      return *this;
+    }
+
+    ~tm_row_const (void)
+    {
+      if (rep && --rep->count == 0)
+        delete rep;
+    }
+
+    octave_idx_type rows (void) { return rep->dv(0); }
+    octave_idx_type cols (void) { return rep->dv(1); }
+
+    bool empty (void) const { return rep->empty (); }
+
+    size_t length (void) const { return rep->length (); }
+
+    dim_vector dims (void) { return rep->dv; }
+
+    bool all_strings_p (void) const { return rep->all_str; }
+    bool all_sq_strings_p (void) const { return rep->all_sq_str; }
+    bool all_dq_strings_p (void) const { return rep->all_dq_str; }
+    bool some_strings_p (void) const { return rep->some_str; }
+    bool all_real_p (void) const { return rep->all_real; }
+    bool all_complex_p (void) const { return rep->all_cmplx; }
+    bool all_empty_p (void) const { return rep->all_mt; }
+    bool any_cell_p (void) const { return rep->any_cell; }
+    bool any_sparse_p (void) const { return rep->any_sparse; }
+    bool any_class_p (void) const { return rep->any_class; }
+    bool all_1x1_p (void) const { return rep->all_1x1; }
+    bool first_elem_struct_p (void) const { return rep->first_elem_is_struct; }
+
+    std::string class_name (void) const { return rep->class_nm; }
+
+    void cellify (void) { rep->cellify (); }
+
+    operator bool () const { return (rep && rep->ok); }
+
+    iterator begin (void) { return rep->begin (); }
+    const_iterator begin (void) const { return rep->begin (); }
+
+    iterator end (void) { return rep->end (); }
+    const_iterator end (void) const { return rep->end (); }
+
+  private:
+
+    tm_row_const_rep *rep;
+  };
+
+  class
+  tm_const : public octave::base_list<tm_row_const>
+  {
+  public:
+
+    tm_const (const tree_matrix& tm, tree_evaluator *tw = 0)
+      : dv (0, 0), all_str (false), all_sq_str (false),
+        all_dq_str (false),
+        some_str (false), all_real (false), all_cmplx (false),
+        all_mt (true), any_cell (false), any_sparse (false),
+        any_class (false), class_nm (), ok (false)
+    { init (tm, tw); }
+
+    ~tm_const (void) = default;
+
+    octave_idx_type rows (void) const { return dv.elem (0); }
+    octave_idx_type cols (void) const { return dv.elem (1); }
+
+    dim_vector dims (void) const { return dv; }
+
+    bool all_strings_p (void) const { return all_str; }
+    bool all_sq_strings_p (void) const { return all_sq_str; }
+    bool all_dq_strings_p (void) const { return all_dq_str; }
+    bool some_strings_p (void) const { return some_str; }
+    bool all_real_p (void) const { return all_real; }
+    bool all_complex_p (void) const { return all_cmplx; }
+    bool all_empty_p (void) const { return all_mt; }
+    bool any_cell_p (void) const { return any_cell; }
+    bool any_sparse_p (void) const { return any_sparse; }
+    bool any_class_p (void) const { return any_class; }
+    bool all_1x1_p (void) const { return all_1x1; }
+
+    std::string class_name (void) const { return class_nm; }
+
+    operator bool () const { return ok; }
+
+  private:
+
+    dim_vector dv;
+
+    bool all_str;
+    bool all_sq_str;
+    bool all_dq_str;
+    bool some_str;
+    bool all_real;
+    bool all_cmplx;
+    bool all_mt;
+    bool any_cell;
+    bool any_sparse;
+    bool any_class;
+    bool all_1x1;
+
+    std::string class_nm;
+
+    bool ok;
+
+    tm_const (void);
+
+    tm_const (const tm_const&);
+
+    tm_const& operator = (const tm_const&);
+
+    void init (const tree_matrix& tm, tree_evaluator *tw);
+  };
+
+  template <typename TYPE, typename T>
+  void
+  single_type_concat (Array<T>& result, octave::tm_const& tmp)
+  {
+    octave_idx_type r = 0;
+    octave_idx_type c = 0;
+
+    for (octave::tm_row_const& row : tmp)
+      {
+        // Skip empty arrays to allow looser rules.
+        if (row.dims ().any_zero ())
+          continue;
+
+        for (auto& elt : row)
+          {
+            octave_quit ();
+
+            TYPE ra = octave_value_extract<TYPE> (elt);
+
+            // Skip empty arrays to allow looser rules.
+
+            if (! ra.is_empty ())
+              {
+                result.insert (ra, r, c);
+
+                c += ra.columns ();
+              }
+          }
+
+        r += row.rows ();
+        c = 0;
+      }
+  }
+
+  template <typename TYPE, typename T>
+  void
+  single_type_concat (Array<T>& result, const dim_vector& dv,
+                      octave::tm_const& tmp)
+  {
+    if (dv.any_zero ())
+      {
+        result = Array<T> (dv);
+        return;
+      }
+
+    if (tmp.length () == 1)
+      {
+        // If possible, forward the operation to liboctave.
+        // Single row.
+        octave::tm_row_const& row = tmp.front ();
+        if (! (equal_types<T, char>::value || equal_types<T, octave_value>::value)
+            && row.all_1x1_p ())
+          {
+            // Optimize all scalars case.
+            result.clear (dv);
+            assert (static_cast<size_t> (result.numel ()) == row.length ());
+            octave_idx_type i = 0;
+            for (const auto& elt : row)
+              result(i++) = octave_value_extract<T> (elt);
+
+            return;
+          }
+
+        octave_idx_type ncols = row.length ();
+        octave_idx_type i = 0;
+        OCTAVE_LOCAL_BUFFER (Array<T>, array_list, ncols);
+
+        for (const auto& elt : row)
+          {
+            octave_quit ();
+
+            array_list[i++] = octave_value_extract<TYPE> (elt);
+          }
+
+        result = Array<T>::cat (-2, ncols, array_list);
+      }
+    else
+      {
+        result = Array<T> (dv);
+        single_type_concat<TYPE> (result, tmp);
+      }
+  }
+
+  template <typename TYPE, typename T>
+  void
+  single_type_concat (Sparse<T>& result, const dim_vector& dv,
+                      octave::tm_const& tmp)
+  {
+    if (dv.any_zero ())
+      {
+        result = Sparse<T> (dv);
+        return;
+      }
+
+    // Sparse matrices require preallocation for efficient indexing; besides,
+    // only horizontal concatenation can be efficiently handled by indexing.
+    // So we just cat all rows through liboctave, then cat the final column.
+    octave_idx_type nrows = tmp.length ();
+    octave_idx_type j = 0;
+    OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_row_list, nrows);
+    for (octave::tm_row_const& row : tmp)
+      {
+        octave_idx_type ncols = row.length ();
+        octave_idx_type i = 0;
+        OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, ncols);
+
+        for (auto& elt : row)
+          {
+            octave_quit ();
+
+            sparse_list[i] = octave_value_extract<TYPE> (elt);
+            i++;
+          }
+
+        Sparse<T> stmp = Sparse<T>::cat (-2, ncols, sparse_list);
+        sparse_row_list[j] = stmp;
+        j++;
+      }
+
+    result = Sparse<T>::cat (-1, nrows, sparse_row_list);
+  }
+
+  template <typename MAP>
+  void
+  single_type_concat (octave_map& result, const dim_vector& dv,
+                      octave::tm_const& tmp)
+  {
+    if (dv.any_zero ())
+      {
+        result = octave_map (dv);
+        return;
+      }
+
+    octave_idx_type nrows = tmp.length ();
+    octave_idx_type j = 0;
+    OCTAVE_LOCAL_BUFFER (octave_map, map_row_list, nrows);
+    for (octave::tm_row_const& row : tmp)
+      {
+        octave_idx_type ncols = row.length ();
+        octave_idx_type i = 0;
+        OCTAVE_LOCAL_BUFFER (MAP, map_list, ncols);
+
+        for (auto& elt : row)
+          {
+            octave_quit ();
+
+            map_list[i] = octave_value_extract<MAP> (elt);
+            i++;
+          }
+
+        octave_map mtmp = octave_map::cat (-2, ncols, map_list);
+        map_row_list[j] = mtmp;
+        j++;
+      }
+
+    result = octave_map::cat (-1, nrows, map_row_list);
+  }
+
+  template <typename TYPE>
+  octave_value
+  do_single_type_concat (const dim_vector& dv, octave::tm_const& tmp)
+  {
+    TYPE result;
+
+    single_type_concat<TYPE> (result, dv, tmp);
+
+    return result;
+  }
+
+  template <>
+  octave_value
+  do_single_type_concat<octave_map> (const dim_vector& dv,
+                                     octave::tm_const& tmp);
+
+  extern octave_value do_class_concat (octave::tm_const& tmc);
+}
+
+#endif
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -40,155 +40,36 @@ namespace octave
   std::string
   tree_unary_expression::oper (void) const
   {
     return octave_value::unary_op_as_string (etype);
   }
 
   // Prefix expressions.
 
-  octave_value_list
-  tree_prefix_expression::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    if (nargout > 1)
-      error ("prefix operator '%s': invalid number of output arguments",
-             oper ().c_str ());
-
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
-
-  octave_value
-  tree_prefix_expression::rvalue1 (int)
-  {
-    octave_value retval;
-
-    if (op)
-      {
-        if (etype == octave_value::op_incr || etype == octave_value::op_decr)
-          {
-            octave_lvalue ref = op->lvalue ();
-
-            BEGIN_PROFILER_BLOCK (tree_prefix_expression)
-
-              ref.do_unary_op (etype);
-
-            retval = ref.value ();
-
-            END_PROFILER_BLOCK
-              }
-        else
-          {
-            octave_value val = op->rvalue1 ();
-
-            if (val.is_defined ())
-              {
-                BEGIN_PROFILER_BLOCK (tree_prefix_expression)
-
-                  // Attempt to do the operation in-place if it is unshared
-                  // (a temporary expression).
-                  if (val.get_count () == 1)
-                    retval = val.do_non_const_unary_op (etype);
-                  else
-                    retval = ::do_unary_op (etype, val);
-
-                END_PROFILER_BLOCK
-                  }
-          }
-      }
-
-    return retval;
-  }
-
   tree_expression *
   tree_prefix_expression::dup (symbol_table::scope_id scope,
                                symbol_table::context_id context) const
   {
     tree_prefix_expression *new_pe
       = new tree_prefix_expression (op ? op->dup (scope, context) : 0,
                                     line (), column (), etype);
 
     new_pe->copy_base (*this);
 
     return new_pe;
   }
 
-  void
-  tree_prefix_expression::accept (tree_walker& tw)
-  {
-    tw.visit_prefix_expression (*this);
-  }
-
   // Postfix expressions.
 
-  octave_value_list
-  tree_postfix_expression::rvalue (int nargout)
-  {
-    octave_value_list retval;
-
-    if (nargout > 1)
-      error ("postfix operator '%s': invalid number of output arguments",
-             oper ().c_str ());
-
-    retval = rvalue1 (nargout);
-
-    return retval;
-  }
-
-  octave_value
-  tree_postfix_expression::rvalue1 (int)
-  {
-    octave_value retval;
-
-    if (op)
-      {
-        if (etype == octave_value::op_incr || etype == octave_value::op_decr)
-          {
-            octave_lvalue ref = op->lvalue ();
-
-            retval = ref.value ();
-
-            BEGIN_PROFILER_BLOCK (tree_postfix_expression)
-
-              ref.do_unary_op (etype);
-
-            END_PROFILER_BLOCK
-              }
-        else
-          {
-            octave_value val = op->rvalue1 ();
-
-            if (val.is_defined ())
-              {
-                BEGIN_PROFILER_BLOCK (tree_postfix_expression)
-
-                  retval = ::do_unary_op (etype, val);
-
-                END_PROFILER_BLOCK
-                  }
-          }
-      }
-
-    return retval;
-  }
-
   tree_expression *
   tree_postfix_expression::dup (symbol_table::scope_id scope,
                                 symbol_table::context_id context) const
   {
     tree_postfix_expression *new_pe
       = new tree_postfix_expression (op ? op->dup (scope, context) : 0,
                                      line (), column (), etype);
 
     new_pe->copy_base (*this);
 
     return new_pe;
   }
-
-  void
-  tree_postfix_expression::accept (tree_walker& tw)
-  {
-    tw.visit_postfix_expression (*this);
-  }
 }
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -27,22 +27,21 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
 #include "pt-exp.h"
+#include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class tree_walker;
-
   // Unary expressions.
 
   class tree_unary_expression : public tree_expression
   {
   protected:
 
     tree_unary_expression (int l = -1, int c = -1,
                            octave_value::unary_op t
@@ -102,24 +101,23 @@ namespace octave
     tree_prefix_expression (const tree_prefix_expression&) = delete;
 
     tree_prefix_expression& operator = (const tree_prefix_expression&) = delete;
 
     ~tree_prefix_expression (void) = default;
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_prefix_expression (*this);
+    }
 
     std::string profiler_name (void) const { return "prefix " + oper (); }
   };
 
   // Postfix expressions.
 
   class tree_postfix_expression : public tree_unary_expression
   {
@@ -138,24 +136,23 @@ namespace octave
     tree_postfix_expression (const tree_postfix_expression&) = delete;
 
     tree_postfix_expression& operator = (const tree_postfix_expression&) = delete;
 
     ~tree_postfix_expression (void) = default;
 
     bool rvalue_ok (void) const { return true; }
 
-    octave_value rvalue1 (int nargout = 1);
-
-    octave_value_list rvalue (int nargout);
-
     tree_expression *dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw);
+    void accept (tree_walker& tw)
+    {
+      tw.visit_postfix_expression (*this);
+    }
 
     std::string profiler_name (void) const { return "postfix " + oper (); }
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::tree_unary_expression' instead")
