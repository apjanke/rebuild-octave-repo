# HG changeset patch
# User jwe
# Date 886358631 0
#      Sun Feb 01 18:43:51 1998 +0000
# Node ID 267b3a5c6b28c5581e3ad461cd5068edc06879ee
# Parent  8bf70ba446d0ef4e6d8fa3ca0cdce3ce0e643ce7
[project @ 1998-02-01 18:43:51 by jwe]

diff --git a/libcruft/quadpack/dqagi.f b/libcruft/quadpack/dqagi.f
--- a/libcruft/quadpack/dqagi.f
+++ b/libcruft/quadpack/dqagi.f
@@ -17,18 +17,17 @@ C            HOPEFULLY SATISFYING FOLLOW
 C            ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
 C***DESCRIPTION
 C
 C        INTEGRATION OVER INFINITE INTERVALS
 C        STANDARD FORTRAN SUBROUTINE
 C
 C        PARAMETERS
 C         ON ENTRY
-C            F      - DOUBLE PRECISION
-C                     FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
+C            F      - SUBROUTINE F(X,RESULT) DEFINING THE INTEGRAND
 C                     FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
 C                     DECLARED E X T E R N A L IN THE DRIVER PROGRAM.
 C
 C            BOUND  - DOUBLE PRECISION
 C                     FINITE BOUND OF INTEGRATION RANGE
 C                     (HAS NO MEANING IF INTERVAL IS DOUBLY-INFINITE)
 C
 C            INF    - INTEGER
@@ -151,17 +150,17 @@ C                     THE RIGHT END POIN
 C                    WORK(LIMIT*2+1), ...,WORK(LIMIT*2+LAST) CONTAIN THE
 C                     INTEGRAL APPROXIMATIONS OVER THE SUBINTERVALS,
 C                    WORK(LIMIT*3+1), ..., WORK(LIMIT*3)
 C                     CONTAIN THE ERROR ESTIMATES.
 C***REFERENCES  (NONE)
 C***ROUTINES CALLED  DQAGIE,XERROR
 C***END PROLOGUE  DQAGI
 C
-      DOUBLE PRECISION ABSERR,BOUND,EPSABS,EPSREL,F,RESULT,WORK
+      DOUBLE PRECISION ABSERR,BOUND,EPSABS,EPSREL,RESULT,WORK
       INTEGER IER,INF,IWORK,LAST,LENW,LIMIT,LVL,L1,L2,L3,NEVAL
 C
       DIMENSION IWORK(LIMIT),WORK(LENW)
 C
       EXTERNAL F
 C
 C         CHECK VALIDITY OF LIMIT AND LENW.
 C
diff --git a/libcruft/quadpack/dqagie.f b/libcruft/quadpack/dqagie.f
--- a/libcruft/quadpack/dqagie.f
+++ b/libcruft/quadpack/dqagie.f
@@ -15,18 +15,17 @@ C            OR I = INTEGRAL OF F OVER (
 C            OR I = INTEGRAL OF F OVER (-INFINITY,+INFINITY),
 C            HOPEFULLY SATISFYING FOLLOWING CLAIM FOR ACCURACY
 C            ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
 C***DESCRIPTION
 C
 C INTEGRATION OVER INFINITE INTERVALS
 C STANDARD FORTRAN SUBROUTINE
 C
-C            F      - DOUBLE PRECISION
-C                     FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
+C            F      - SUBROUTINE F(X,IERR,RESULT) DEFINING THE INTEGRAND
 C                     FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
 C                     DECLARED E X T E R N A L IN THE DRIVER PROGRAM.
 C
 C            BOUND  - DOUBLE PRECISION
 C                     FINITE BOUND OF INTEGRATION RANGE
 C                     (HAS NO MEANING IF INTERVAL IS DOUBLY-INFINITE)
 C
 C            INF    - DOUBLE PRECISION
@@ -148,17 +147,17 @@ C                     NUMBER OF SUBINTER
 C                     IN THE SUBDIVISION PROCESS
 C
 C***REFERENCES  (NONE)
 C***ROUTINES CALLED  D1MACH,DQELG,DQK15I,DQPSRT
 C***END PROLOGUE  DQAGIE
       DOUBLE PRECISION ABSEPS,ABSERR,ALIST,AREA,AREA1,AREA12,AREA2,A1,
      *  A2,BLIST,BOUN,BOUND,B1,B2,CORREC,DABS,DEFABS,DEFAB1,DEFAB2,
      *  DMAX1,DRES,D1MACH,ELIST,EPMACH,EPSABS,EPSREL,ERLARG,ERLAST,
-     *  ERRBND,ERRMAX,ERROR1,ERROR2,ERRO12,ERRSUM,ERTEST,F,OFLOW,RESABS,
+     *  ERRBND,ERRMAX,ERROR1,ERROR2,ERRO12,ERRSUM,ERTEST,OFLOW,RESABS,
      *  RESEPS,RESULT,RES3LA,RLIST,RLIST2,SMALL,UFLOW
       INTEGER ID,IER,IERRO,INF,IORD,IROFF1,IROFF2,IROFF3,JUPBND,K,KSGN,
      *  KTMIN,LAST,LIMIT,MAXERR,NEVAL,NRES,NRMAX,NUMRL2
       LOGICAL EXTRAP,NOEXT
 C
       DIMENSION ALIST(LIMIT),BLIST(LIMIT),ELIST(LIMIT),IORD(LIMIT),
      *  RES3LA(3),RLIST(LIMIT),RLIST2(52)
 C
diff --git a/libcruft/quadpack/dqagp.f b/libcruft/quadpack/dqagp.f
--- a/libcruft/quadpack/dqagp.f
+++ b/libcruft/quadpack/dqagp.f
@@ -18,18 +18,17 @@ C            SINGULARITIES, DISCONTINUIT
 C***DESCRIPTION
 C
 C        COMPUTATION OF A DEFINITE INTEGRAL
 C        STANDARD FORTRAN SUBROUTINE
 C        DOUBLE PRECISION VERSION
 C
 C        PARAMETERS
 C         ON ENTRY
-C            F      - DOUBLE PRECISION
-C                     FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
+C            F      - SUBROUTINE F(X,IERR,RESULT) DEFINING THE INTEGRAND
 C                     FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
 C                     DECLARED E X T E R N A L IN THE DRIVER PROGRAM.
 C
 C            A      - DOUBLE PRECISION
 C                     LOWER LIMIT OF INTEGRATION
 C
 C            B      - DOUBLE PRECISION
 C                     UPPER LIMIT OF INTEGRATION
diff --git a/libcruft/quadpack/dqagpe.f b/libcruft/quadpack/dqagpe.f
--- a/libcruft/quadpack/dqagpe.f
+++ b/libcruft/quadpack/dqagpe.f
@@ -19,18 +19,17 @@ C            OCCUR(E.G. SINGULARITIES,DI
 C***DESCRIPTION
 C
 C        COMPUTATION OF A DEFINITE INTEGRAL
 C        STANDARD FORTRAN SUBROUTINE
 C        DOUBLE PRECISION VERSION
 C
 C        PARAMETERS
 C         ON ENTRY
-C            F      - DOUBLE PRECISION
-C                     FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
+C            F      - SUBROUTINE F(X,IERR,RESULT) DEFINING THE INTEGRAND
 C                     FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
 C                     DECLARED E X T E R N A L IN THE DRIVER PROGRAM.
 C
 C            A      - DOUBLE PRECISION
 C                     LOWER LIMIT OF INTEGRATION
 C
 C            B      - DOUBLE PRECISION
 C                     UPPER LIMIT OF INTEGRATION
@@ -188,17 +187,17 @@ C                     NUMBER OF SUBINTER
 C                     SUBDIVISIONS PROCESS
 C
 C***REFERENCES  (NONE)
 C***ROUTINES CALLED  D1MACH,DQELG,DQK21,DQPSRT
 C***END PROLOGUE  DQAGPE
       DOUBLE PRECISION A,ABSEPS,ABSERR,ALIST,AREA,AREA1,AREA12,AREA2,A1,
      *  A2,B,BLIST,B1,B2,CORREC,DABS,DEFABS,DEFAB1,DEFAB2,DMAX1,DMIN1,
      *  DRES,D1MACH,ELIST,EPMACH,EPSABS,EPSREL,ERLARG,ERLAST,ERRBND,
-     *  ERRMAX,ERROR1,ERRO12,ERROR2,ERRSUM,ERTEST,F,OFLOW,POINTS,PTS,
+     *  ERRMAX,ERROR1,ERRO12,ERROR2,ERRSUM,ERTEST,OFLOW,POINTS,PTS,
      *  RESA,RESABS,RESEPS,RESULT,RES3LA,RLIST,RLIST2,SIGN,TEMP,UFLOW
       INTEGER I,ID,IER,IERRO,IND1,IND2,IORD,IP1,IROFF1,IROFF2,IROFF3,J,
      *  JLOW,JUPBND,K,KSGN,KTMIN,LAST,LEVCUR,LEVEL,LEVMAX,LIMIT,MAXERR,
      *  NDIN,NEVAL,NINT,NINTP1,NPTS,NPTS2,NRES,NRMAX,NUMRL2
       LOGICAL EXTRAP,NOEXT
 C
 C
       DIMENSION ALIST(LIMIT),BLIST(LIMIT),ELIST(LIMIT),IORD(LIMIT),
diff --git a/libcruft/quadpack/dqk15i.f b/libcruft/quadpack/dqk15i.f
--- a/libcruft/quadpack/dqk15i.f
+++ b/libcruft/quadpack/dqk15i.f
@@ -15,18 +15,17 @@ C            J = INTEGRAL OF ABS(TRANSFO
 C***DESCRIPTION
 C
 C           INTEGRATION RULE
 C           STANDARD FORTRAN SUBROUTINE
 C           DOUBLE PRECISION VERSION
 C
 C           PARAMETERS
 C            ON ENTRY
-C              F      - DOUBLE PRECISION
-C                       FUCTION SUBPROGRAM DEFINING THE INTEGRAND
+C              F      - SUBROUTINE F(X,IERR,RESULT) DEFINING THE INTEGRAND
 C                       FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
 C                       DECLARED E X T E R N A L IN THE CALLING PROGRAM.
 C
 C              BOUN   - DOUBLE PRECISION
 C                       FINITE BOUND OF ORIGINAL INTEGRATION
 C                       RANGE (SET TO ZERO IF INF = +2)
 C
 C              INF    - INTEGER
@@ -146,20 +145,20 @@ C***FIRST EXECUTABLE STATEMENT  DQK15I
       EPMACH = D1MACH(4)
       UFLOW = D1MACH(1)
       DINF = MIN0(1,INF)
 C
       CENTR = 0.5D+00*(A+B)
       HLGTH = 0.5D+00*(B-A)
       TABSC1 = BOUN+DINF*(0.1D+01-CENTR)/CENTR
       IERR = 0
-      FVAL1 = F(TABSC1,IERR)
+      CALL F(TABSC1,IERR,FVAL1)
       IF (IERR .LT. 0) RETURN
       IF(INF.EQ.2) THEN
-        FVALT = F(-TABSC1,IERR)
+        CALL F(-TABSC1,IERR,FVALT)
         IF (IERR .LT. 0) RETURN
         FVAL1 = FVAL1+FVALT
       ENDIF
       FC = (FVAL1/CENTR)/CENTR
 C
 C           COMPUTE THE 15-POINT KRONROD APPROXIMATION TO
 C           THE INTEGRAL, AND ESTIMATE THE ERROR.
 C
@@ -167,27 +166,27 @@ C
       RESK = WGK(8)*FC
       RESABS = DABS(RESK)
       DO 10 J=1,7
         ABSC = HLGTH*XGK(J)
         ABSC1 = CENTR-ABSC
         ABSC2 = CENTR+ABSC
         TABSC1 = BOUN+DINF*(0.1D+01-ABSC1)/ABSC1
         TABSC2 = BOUN+DINF*(0.1D+01-ABSC2)/ABSC2
-        FVAL1 = F(TABSC1,IERR)
+        CALL F(TABSC1,IERR,FVAL1)
         IF (IERR .LT. 0) RETURN
-        FVAL2 = F(TABSC2,IERR)
+        CALL F(TABSC2,IERR,FVAL2)
         IF (IERR .LT. 0) RETURN
         IF(INF.EQ.2) THEN
-          FVALT = F(-TABSC1,IERR)
+          CALL F(-TABSC1,IERR,FVALT)
           IF (IERR .LT. 0) RETURN
           FVAL1 = FVAL1+FVALT
         ENDIF
         IF(INF.EQ.2) THEN
-          FVALT = F(-TABSC2,IERR)
+          CALL F(-TABSC2,IERR,FVALT)
           IF (IERR .LT. 0) RETURN
           FVAL2 = FVAL2+FVALT
         ENDIF
         FVAL1 = (FVAL1/ABSC1)/ABSC1
         FVAL2 = (FVAL2/ABSC2)/ABSC2
         FV1(J) = FVAL1
         FV2(J) = FVAL2
         FSUM = FVAL1+FVAL2
diff --git a/libcruft/quadpack/dqk21.f b/libcruft/quadpack/dqk21.f
--- a/libcruft/quadpack/dqk21.f
+++ b/libcruft/quadpack/dqk21.f
@@ -12,18 +12,17 @@ C                       J = INTEGRAL OF 
 C***DESCRIPTION
 C
 C           INTEGRATION RULES
 C           STANDARD FORTRAN SUBROUTINE
 C           DOUBLE PRECISION VERSION
 C
 C           PARAMETERS
 C            ON ENTRY
-C              F      - DOUBLE PRECISION
-C                       FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
+C              F      - SUBROUTINE F(X,IERR,RESULT) DEFINING THE INTEGRAND
 C                       FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
 C                       DECLARED E X T E R N A L IN THE DRIVER PROGRAM.
 C
 C              A      - DOUBLE PRECISION
 C                       LOWER LIMIT OF INTEGRATION
 C
 C              B      - DOUBLE PRECISION
 C                       UPPER LIMIT OF INTEGRATION
@@ -135,40 +134,40 @@ C
       HLGTH = 0.5D+00*(B-A)
       DHLGTH = DABS(HLGTH)
 C
 C           COMPUTE THE 21-POINT KRONROD APPROXIMATION TO
 C           THE INTEGRAL, AND ESTIMATE THE ABSOLUTE ERROR.
 C
       RESG = 0.0D+00
       IERR = 0
-      FC = F(CENTR,IERR)
+      CALL F (CENTR,IERR,FC)
       IF (IERR .LT. 0) RETURN
       RESK = WGK(11)*FC
       RESABS = DABS(RESK)
       DO 10 J=1,5
         JTW = 2*J
         ABSC = HLGTH*XGK(JTW)
-        FVAL1 = F(CENTR-ABSC,IERR)
+        CALL F(CENTR-ABSC,IERR,FVAL1)
         IF (IERR .LT. 0) RETURN
-        FVAL2 = F(CENTR+ABSC,IERR)
+        CALL F(CENTR+ABSC,IERR,FVAL2)
         IF (IERR .LT. 0) RETURN
         FV1(JTW) = FVAL1
         FV2(JTW) = FVAL2
         FSUM = FVAL1+FVAL2
         RESG = RESG+WG(J)*FSUM
         RESK = RESK+WGK(JTW)*FSUM
         RESABS = RESABS+WGK(JTW)*(DABS(FVAL1)+DABS(FVAL2))
    10 CONTINUE
       DO 15 J = 1,5
         JTWM1 = 2*J-1
         ABSC = HLGTH*XGK(JTWM1)
-        FVAL1 = F(CENTR-ABSC,IERR)
+        CALL F(CENTR-ABSC,IERR,FVAL1)
         IF (IERR .LT. 0) RETURN
-        FVAL2 = F(CENTR+ABSC,IERR)
+        CALL F(CENTR+ABSC,IERR,FVAL2)
         IF (IERR .LT. 0) RETURN
         FV1(JTWM1) = FVAL1
         FV2(JTWM1) = FVAL2
         FSUM = FVAL1+FVAL2
         RESK = RESK+WGK(JTWM1)*FSUM
         RESABS = RESABS+WGK(JTWM1)*(DABS(FVAL1)+DABS(FVAL2))
    15 CONTINUE
       RESKH = RESK*0.5D+00
