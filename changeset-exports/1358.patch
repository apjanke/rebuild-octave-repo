# HG changeset patch
# User jwe
# Date 810335524 0
#      Tue Sep 05 21:12:04 1995 +0000
# Node ID dc9c01f66a192f416253a9fcb750c830f2fbd7bc
# Parent  749071f4833665ac4ec046be5d81cd117076b9de
[project @ 1995-09-05 21:10:01 by jwe]

diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -213,19 +213,19 @@ idx_vector::init_state (const char *rc, 
     }
   else if (min_val < 0)
     {
       ::error ("%s index %d out of range", rc, min_val+1);
       initialized = 0;
       return;
     }
 #if 0
-// Checking max index against size won't work right here unless we
-// also look at resize on range error, and we have to do that later
-// on anyway.
+  // Checking max index against size won't work right here unless we
+  // also look at resize on range error, and we have to do that later
+  // on anyway.
 
   else if (max_val >= z_len)
     {
       ::error ("%s index %d out of range", rc, max_val+1);
       initialized = 0;
       return;
     }
 #endif
diff --git a/liboctave/utils.cc b/liboctave/utils.cc
--- a/liboctave/utils.cc
+++ b/liboctave/utils.cc
@@ -27,28 +27,26 @@ Software Foundation, 59 Temple Place - S
 
 #include <sys/types.h>
 #include <unistd.h>
 #include <signal.h>
 #include <stdlib.h>
 
 #include "f77-uscore.h"
 
-/*
- * All the STOP statements in the Fortran routines have been replaced
- * with a call to XSTOPX, defined in the file libcruft/misc/xstopx.f.
- *
- * The XSTOPX function calls this function, which will send a SIGINT
- * signal to the program that invoked it.
- *
- * Octave\'s SIGINT signal handler calls jump_to_top_level(), and the
- * user will end up at the top level instead of the shell prompt.
- *
- * Programs that don\'t handle SIGINT will be interrupted.
- */
+// All the STOP statements in the Fortran routines have been replaced
+// with a call to XSTOPX, defined in the file libcruft/misc/xstopx.f.
+//
+// The XSTOPX function calls this function, which will send a SIGINT
+// signal to the program that invoked it.
+//
+// Octave's SIGINT signal handler calls jump_to_top_level(), and the
+// user will end up at the top level instead of the shell prompt.
+//
+// Programs that don't handle SIGINT will be interrupted.
 
 extern "C"
 {
 
   volatile void
 #if defined (F77_APPEND_UNDERSCORE)
   do_stop_ (void)
 #else
diff --git a/src/arith-ops.cc b/src/arith-ops.cc
--- a/src/arith-ops.cc
+++ b/src/arith-ops.cc
@@ -54,17 +54,17 @@ Software Foundation, 59 Temple Place - S
   do \
     { \
       error ("division by zero attempted"); \
       return tree_constant (); \
     } \
   while (0)
 #endif
 
-// But first, some stupid functions that don\'t deserve to be in the
+// But first, some stupid functions that don't deserve to be in the
 // Matrix class...
 
 enum
 Matrix_bool_op
 {
   Matrix_LT,
   Matrix_LE,
   Matrix_EQ,
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -305,17 +305,18 @@ change_to_directory (const char *newdir)
       if (! the_current_working_directory)
 	get_working_directory ("cd_links");
 
       if (the_current_working_directory)
 	t = make_absolute (newdir, the_current_working_directory);
       else
 	t = strsave (newdir);
 
-// Get rid of trailing `/'.
+      // Get rid of trailing `/'.
+
       {
 	register int len_t = strlen (t);
 	if (len_t > 1)
 	  {
 	    --len_t;
 	    if (t[len_t] == '/')
 	      t[len_t] = '\0';
 	  }
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -154,20 +154,20 @@ dld_octave_resolve_reference (const char
 	  error ("failed to link file %s", file);
 	  return 0;
 	}
 
       if (dld_function_executable_p (name))
 	return (void *) dld_get_func (name);
     }
 
-// For each library, try to find it in a list of directories, then
-// link to it.  It would have been nice to use the kpathsea functions
-// here too, but calls to them can't be nested as they would need to
-// be here...
+  // For each library, try to find it in a list of directories, then
+  // link to it.  It would have been nice to use the kpathsea
+  // functions here too, but calls to them can't be nested as they
+  // would need to be here...
 
   char **libs = pathstring_to_vector (lib_list);
   char **ptr = libs;
   char *lib_list_elt;
 
   while ((lib_list_elt = *ptr++))
     {
       char *lib = kpse_path_search (lib_dir_path, lib_list_elt,
@@ -178,17 +178,17 @@ dld_octave_resolve_reference (const char
 	  error ("failed to link library %s", lib);
 	  return 0;
 	}
 
       if (dld_function_executable_p (name))
 	return (void *) dld_get_func (name);
     }
 
-// If we get here, there was a problem.
+  // If we get here, there was a problem.
 
   ostrstream output_buf;
   octave_list_undefined_symbols (output_buf);
   char *msg = output_buf.str ();
   error (msg);
   delete [] msg;
 
   return 0;
@@ -269,19 +269,19 @@ init_dynamic_linker (void)
 
 // OLD:
 
 #if 0
 
 void
 octave_dld_tc2_unlink_by_symbol (const char *name, int hard)
 {
-// XXX FIXME XXX -- need to determine the name mangling scheme
-// automatically, in case it changes, or is different on different
-// systems, even if they have g++.
+  // XXX FIXME XXX -- need to determine the name mangling scheme
+  // automatically, in case it changes, or is different on different
+  // systems, even if they have g++.
 
   char *mangled_fcn_name = strconcat (name, "__FRC13Octave_objecti");
 
   int status = dld_unlink_by_symbol (mangled_fcn_name, hard);
 
   if (status != 0)
     error ("octave_dld_tc2_unlink_by_symbol: %s", dld_strerror (0));
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1073,17 +1073,17 @@ do_printf (const char *type, const Octav
 	{
 	  error ("%s: invalid format string", type);
 	  return retval;
 	}
 
       fmt_arg_count++;
     }
 
-// Scan fmt for % escapes and print out the arguments.
+  // Scan fmt for % escapes and print out the arguments.
 
   ostrstream output_buf;
 
   char *ptr = fmt;
 
   for (;;)
     {
       char c;
@@ -1095,17 +1095,18 @@ do_printf (const char *type, const Octav
 
       if (*ptr == '%')
 	{
 	  ptr++;
 	  output_buf << c;
 	  continue;
 	}
 
-// We must be looking at a format specifier.  Extract it or fail.
+      // We must be looking at a format specifier.  Extract it or
+      // fail.
 
       int status = process_printf_format (ptr, args, output_buf, type);
 
       if (status < 0)
 	return retval;
 
       ptr += status;
     }
@@ -1224,18 +1225,18 @@ process_scanf_format (const char *s, ost
     {
       chars_from_fmt_str++;
       s++;
     }
 
   if (*s == '\0')
     goto invalid_format;
 
-// Even if we don't have a place to store them, attempt to convert
-// everything specified by the format string.
+  // Even if we don't have a place to store them, attempt to convert
+  // everything specified by the format string.
 
   if (fmt_arg_count > (nargout ? nargout : 1))
     store_value = 0;
 
   switch (*s)
     {
     case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':
       {
@@ -1262,20 +1263,20 @@ process_scanf_format (const char *s, ost
 	  values(fmt_arg_count++) = temp;
       }
       break;
 
     case 's':
       {
 	if (string_width < 1)
 	  {
-// XXX FIXME XXX -- The code below is miscompiled on the Alpha with
-// gcc 2.6.0, so that string_width is never incremented, even though
-// reading the data works correctly.  One fix is to use a fixed-size
-// buffer...
+	    // XXX FIXME XXX -- The code below is miscompiled on the
+	    // Alpha with gcc 2.6.0, so that string_width is never
+	    // incremented, even though reading the data works
+	    // correctly.  One fix is to use a fixed-size buffer...
 //	    string_width = 8192;
 
 	    string_width = 0;
 	    long original_position = ftell (fptr);
 
 	    int c;
 
 	    while ((c = getc (fptr)) != EOF && isspace (c))
@@ -1401,19 +1402,20 @@ do_scanf (const char *type, const Octave
       char *string;
 
       if (strcmp (type, "scanf") == 0)
 	scanf_fmt = args(0).string_value ();
 
       if (strcmp (type, "scanf") == 0
 	  || (doing_fscanf && file.number () == 0))
 	{
-// XXX FIXME XXX -- this should probably be possible for more than
-// just stdin/stdout pairs, using a list of output streams to flush.
-// The list could be created with a function like iostream's tie().
+	  // XXX FIXME XXX -- this should probably be possible for
+	  // more than just stdin/stdout pairs, using a list of output
+	  // streams to flush.  The list could be created with a
+	  // function like iostream's tie().
 
 	  flush_output_to_pager ();
 
 	  string = gnu_readline ("");
 
 	  if (string && *string)
 	    maybe_save_history (string);
 	}
@@ -1449,17 +1451,17 @@ do_scanf (const char *type, const Octave
 	}
     }
   else if (! doing_fscanf)
     {
       error ("%s: first argument must be a string", type);
       return retval;
     }
 
-// Scan scanf_fmt for % escapes and assign the arguments.
+  // Scan scanf_fmt for % escapes and assign the arguments.
 
   retval.resize (nargout);
 
   char *ptr = scanf_fmt;
 
   for (;;)
     {
       ostrstream fmt;
@@ -1472,17 +1474,18 @@ do_scanf (const char *type, const Octave
 
       if (*ptr == '%')
 	{
 	  ptr++;
 	  fmt << c;
 	  continue;
 	}
 
-// We must be looking at a format specifier.  Extract it or fail.
+      // We must be looking at a format specifier.  Extract it or
+      // fail.
 
       int status = process_scanf_format (ptr, fmt, type, nargout,
 					 fptr, retval);
 
       if (status < 0)
 	{
 	  if (fmt_arg_count == 0)
 	    retval.resize (0);
@@ -1618,37 +1621,36 @@ fread_internal (const Octave_object& arg
 
   int nargin = args.length ();
 
   Pix p = file_io_get_file (args(0), "r", "fread");
 
   if (! p)
     return retval;
 
-// Get type and number of bytes per element to read.
+  // Get type and number of bytes per element to read.
+
   char *prec = "uchar";
   if (nargin > 2)
     {
       prec = args(2).string_value ();
 
       if (error_state)
 	{
 	  error ("fread: precision must be a specified as a string");
 	  return retval;
 	}
     }
 
-// Get file info.
-
   file_info file = file_list (p);
 
   FILE *fptr = file.fptr ();
 
-// Set up matrix to read into.  If specified in arguments use that
-// number, otherwise read everyting left in file.
+  // Set up matrix to read into.  If specified in arguments use that
+  // number, otherwise read everyting left in file.
 
   double dnr = 0.0;
   double dnc = 0.0;
   int nr;
   int nc;
 
   if (nargin > 1)
     {
@@ -1729,27 +1731,28 @@ fread_internal (const Octave_object& arg
 	      return retval;
 	    }
 	  else
 	    nc = NINT (dnc);
 	}
     }
   else
     {
-// No size parameter, read what's left of the file.
+      // No size parameter, read what's left of the file.
+
       nc = 1;
       int n = num_items_remaining (fptr, prec);
       nr = n / nc;
       if (n > nr * nc)
 	nr++;
     }
 
   Matrix m (nr, nc, octave_NaN);
 
-// Read data.
+  // Read data.
 
   int count = m.read (fptr, prec);
 
   if (nargout > 1)
     retval(1) = (double) count;
 
   retval(0) = m;
 
@@ -1805,17 +1808,18 @@ fwrite_internal (const Octave_object& ar
 
   int nargin = args.length ();
 
   Pix p = file_io_get_file (args(0), "a+", "fwrite");
 
   if (! p)
     return retval;
 
-// Get type and number of bytes per element to read.
+  // Get type and number of bytes per element to read.
+
   char *prec = "uchar";
   if (nargin > 2)
     {
       prec = args(2).string_value ();
 
       if (error_state)
 	{
 	  error ("fwrite: precision must be a specified as a string");
@@ -1870,17 +1874,16 @@ DEFUN ("fwrite", Ffwrite, Sfwrite, 3, 1,
 //     fid : file id from fopen
 //     eof : non zero for an end of file condition
 
 static Octave_object
 feof_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-// Get file info.
   Pix p = return_valid_file (args(0));
 
   if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   retval(0) = (double) feof (file.fptr ());
@@ -1914,17 +1917,16 @@ DEFUN ("feof", Ffeof, Sfeof, 1, 1,
 //     message : system error message
 //     errnum  : error number
 
 static Octave_object
 ferror_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-// Get file info.
   Pix p = return_valid_file (args(0));
 
   if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   int ierr = ferror (file.fptr ());
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -456,30 +456,31 @@ simple_help (void)
       display_symtab_names (output_buf, names, count, msg); \
       char **ptr = names; \
       while (*ptr) \
         delete [] *ptr++; \
       delete [] names; \
     } \
   while (0)
 
-// XXX FIXME XXX -- is this distinction needed?
+  // XXX FIXME XXX -- is this distinction needed?
+
   LIST_SYMBOLS (symbol_def::TEXT_FUNCTION,
 		"text functions (these names are also reserved)");
 
   LIST_SYMBOLS (symbol_def::MAPPER_FUNCTION, "mapper functions");
 
   LIST_SYMBOLS (symbol_def::BUILTIN_FUNCTION, "general functions");
 
   LIST_SYMBOLS (symbol_def::BUILTIN_VARIABLE, "builtin variables");
 
-// Also need to list variables and currently compiled functions from
-// the symbol table, if there are any.
+  // Also need to list variables and currently compiled functions from
+  // the symbol table, if there are any.
 
-// Also need to search octave_path for script files.
+  // Also need to search octave_path for script files.
 
   char *path_elt = kpse_path_element (user_pref.loadpath);
 
   while (path_elt)
     {
       str_llist_type *elt_dirs = kpse_element_dirs (path_elt);
 
       str_llist_elt_type *dir;
@@ -723,17 +724,18 @@ DEFUN_TEXT ("type", Ftype, Stype, -1, 1,
 display the definition of each NAME that refers to a function")
 {
   Octave_object retval;
 
   DEFINE_ARGV("type");
 
   if (argc > 1)
     {
-// XXX FIXME XXX -- we should really use getopt ()
+      // XXX FIXME XXX -- we should really use getopt ()
+
       int quiet = 0;
       if (argv[1] && strcmp (argv[1], "-q") == 0)
 	{
 	  quiet = 1;
 	  argc--;
 	  argv++;
 	}
 
@@ -767,17 +769,18 @@ display the definition of each NAME that
 		  tree_fvc *defn = sym_rec->def ();
 
 		  if (nargout == 0 && ! quiet)
 		    output_buf << *argv << " is a user-defined function\n";
 
 		  defn->print_code (output_buf);
 		}
 
-// XXX FIXME XXX -- this code should be shared with Fwhich
+	      // XXX FIXME XXX -- this code should be shared with
+	      // Fwhich.
 
 	      else if (sym_rec->is_text_function ())
 		output_buf << *argv << " is a builtin text-function\n";
 	      else if (sym_rec->is_builtin_function ())
 		output_buf << *argv << " is a builtin function\n";
 	      else if (sym_rec->is_user_variable ()
 		       || sym_rec->is_builtin_variable ())
 		{
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -313,17 +313,18 @@ decode_prompt_string (const char *string
 	
 	    case 'w':
 	    case 'W':
 	      {
 		char t_string[MAXPATHLEN];
 #define EFFICIENT
 #ifdef EFFICIENT
 
-// Use the value of PWD because it is much more effecient.
+		// Use the value of PWD because it is much more
+		// effecient.
 
 		temp = user_pref.pwd;
 
 		if (! temp)
 		  octave_getcwd (t_string, MAXPATHLEN);
 		else
 		  strcpy (t_string, temp);
 #else
@@ -414,17 +415,18 @@ decode_prompt_string (const char *string
 	      result = tmp;
 	    }
 	  result[result_index++] = c;
 	  result[result_index] = '\0';
 	}
     }
 
 #if 0
-// I don't really think that this is a good idea.  Do you?
+  // I don't really think that this is a good idea.  Do you?
+
   if (! find_variable ("NO_PROMPT_VARS"))
     {
       WORD_LIST *expand_string (), *list;
       char *string_list ();
 
       list = expand_string (result, 1);
       free (result);
       result = string_list (list);
@@ -558,17 +560,17 @@ octave_read (char *buf, int max_size)
   else
     {
       FILE *curr_stream = rl_instream;
       if (reading_fcn_file || reading_script_file)
 	curr_stream = ff_instream;
 
       assert (curr_stream);
 
-// Why is this required?
+      // Why is this required?
       buf[0] = '\0';
 
       if (fgets (buf, max_size, curr_stream))
 	{
 	  int len = strlen (buf);
 	  if (len > max_size - 2)
 	    status = -1;
 	  else
@@ -875,20 +877,22 @@ set_saved_history (void)
     {
       if (history_set_pos (saved_history_line_to_use))
 	{
 	  h = current_history ();
 	  if (h)
 	    {
 	      rl_insert_text (h->line);
 
-// Get rid of any undo list created by the previous insert, so the
-// line won't totally be erased when the edits are undone (they will
-// be normally, because this is a history  line -- cf. readline.c:
-// line 380 or so).
+	      // Get rid of any undo list created by the previous
+	      // insert, so the line won't totally be erased when the
+	      // edits are undone (they will be normally, because this
+	      // is a history  line -- cf. readline.c: line 380 or
+	      // so).
+
 	      if (rl_undo_list)
 		{
 		  free_undo_list ();
 		  rl_undo_list = 0;
 		}
 	    }
 	}
     }
@@ -897,41 +901,46 @@ set_saved_history (void)
 }
 
 static void
 operate_and_get_next (int count, int c)
 {
   int where;
   extern int history_stifled, history_length, max_input_history;
 
-// Accept the current line.
+  // Accept the current line.
+
   rl_newline ();
 
-// Find the current line, and find the next line to use.
+  // Find the current line, and find the next line to use.
+
   where = where_history ();
 
   if (history_stifled && (history_length >= max_input_history))
     saved_history_line_to_use = where;
   else
     saved_history_line_to_use = where + 1;
 
   old_rl_startup_hook = rl_startup_hook;
   rl_startup_hook = (Function *) set_saved_history;
 }
 
 void
 initialize_readline (void)
 {
-// Allow conditional parsing of the ~/.inputrc file
+  // Allow conditional parsing of the ~/.inputrc file
+
   rl_readline_name = "Octave";
 
-// Tell the completer that we want to try first.
+  // Tell the completer that we want to try first.
+
   rl_attempted_completion_function = (CPPFunction *) command_completer;
 
-// Bind operate-and-get-next.
+  // Bind operate-and-get-next.
+
   rl_add_defun ("operate-and-get-next",
 		(Function *) operate_and_get_next, CTRL ('O'));
 }
 
 static int
 match_sans_spaces (const char *standard, const char *test)
 {
   char *tmp = strsave (test);
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -902,17 +902,17 @@ too_large_for_float (const ComplexMatrix
 // for NAME.  If GLOBAL is nonzero, make the variable global.
 //
 // Assumes TC is defined.
 
 static void
 install_loaded_variable (int force, char *name, const tree_constant& tc,
 			 int global, char *doc)
 {
-// Is there already a symbol by this name?  If so, what is it?
+  // Is there already a symbol by this name?  If so, what is it?
 
   symbol_record *lsr = curr_sym_tab->lookup (name, 0, 0);
 
   int is_undefined = 1;
   int is_variable = 0;
   int is_function = 0;
   int is_global = 0;
 
@@ -1236,17 +1236,17 @@ extract_keyword (istream& is, char *keyw
 //
 // XXX FIXME XXX -- this format is fairly rigid, and doesn't allow for
 // arbitrary comments, etc.  Someone should fix that.
 
 static char *
 read_ascii_data (istream& is, const char *filename, int& global,
 		 tree_constant& tc)
 {
-// Read name for this entry or break on EOF.
+  // Read name for this entry or break on EOF.
 
   char *name = extract_keyword (is, "name");
 
   if (! name)
     return 0;
 
   if (! *name)
     {
@@ -1258,17 +1258,17 @@ read_ascii_data (istream& is, const char
 
   if (! valid_identifier (name))
     {
       error ("load: bogus identifier `%s' found in file `%s'", name, filename);
       delete [] name;
       return 0;
     }
 
-// Look for type keyword
+  // Look for type keyword.
 
   char *tag = extract_keyword (is, "type");
 
   if (tag && *tag)
     {
       char *ptr = strchr (tag, ' ');
       if (ptr)
 	{
@@ -1354,17 +1354,18 @@ read_ascii_data (istream& is, const char
 	      else
 		error ("load: failed to load string constant");
 	    }
 	  else
 	    error ("load: failed to extract string length");
 	}
       else if (strncmp (ptr, "range", 5) == 0)
 	{
-// # base, limit, range comment added by save().
+	  // # base, limit, range comment added by save().
+
 	  skip_comments (is);
 	  Range tmp;
 	  is >> tmp;
 	  if (is)
 	    tc = tmp;
 	  else
 	    error ("load: failed to load range constant");
 	}
@@ -1455,18 +1456,18 @@ read_binary_data (istream& is, int swap,
 {
   char tmp = 0;
 
   FOUR_BYTE_INT name_len = 0, doc_len = 0;
   char *name = 0;
 
   doc = 0;
 
-// We expect to fail here, at the beginning of a record, so not being
-// able to read another name should not result in an error.
+  // We expect to fail here, at the beginning of a record, so not
+  // being able to read another name should not result in an error.
 
   is.read (&name_len, 4);
   if (! is)
     return 0;
   if (swap)
     swap_4_bytes ((char *) &name_len);
 
   name = new char [name_len+1];
@@ -1663,18 +1664,19 @@ read_mat_binary_data (istream& is, doubl
 static int
 read_mat_file_header (istream& is, int& swap, FOUR_BYTE_INT& mopt, 
 		      FOUR_BYTE_INT& nr, FOUR_BYTE_INT& nc,
 		      FOUR_BYTE_INT& imag, FOUR_BYTE_INT& len,
 		      int quiet = 0)
 {
   swap = 0;
 
-// We expect to fail here, at the beginning of a record, so not being
-// able to read another mopt value should not result in an error. 
+  // We expect to fail here, at the beginning of a record, so not
+  // being able to read another mopt value should not result in an
+  // error.
 
   is.read (&mopt, 4);
   if (! is)
     return 1;
 
   if (! is.read (&nr, 4))
     goto data_read_error;
 
@@ -1696,17 +1698,17 @@ read_mat_file_header (istream& is, int& 
 //
 // Gag me.
 
 #if defined (WORDS_BIGENDIAN)
   if (mopt == 0)
     swap = 1;
 #endif
 
-// mopt is signed, therefore byte swap may result in negative value.
+  // mopt is signed, therefore byte swap may result in negative value.
 
   if (mopt > 9999 || mopt < 0)
     swap = 1;
 
   if (swap)
     {
       swap_4_bytes ((char *) &mopt);
       swap_4_bytes ((char *) &nr);
@@ -1775,19 +1777,19 @@ get_floating_point_format (int mach)
 // FILENAME is used for error messages.
 //
 // This format provides no way to tag the data as global.
 
 static char *
 read_mat_binary_data (istream& is, const char *filename,
 		      tree_constant& tc)
 {
-// These are initialized here instead of closer to where they are
-// first used to avoid errors from gcc about goto crossing
-// initialization of variable.
+  // These are initialized here instead of closer to where they are
+  // first used to avoid errors from gcc about goto crossing
+  // initialization of variable.
 
   Matrix re;
   floating_point_format flt_fmt = OCTAVE_UNKNOWN_FLT_FMT;
   char *name = 0;
   int swap = 0, type = 0, prec = 0, mach = 0, dlen = 0;
 
   FOUR_BYTE_INT mopt, nr, nc, imag, len;
 
@@ -1861,17 +1863,17 @@ read_mat_binary_data (istream& is, const
 	for (int i = 0; i < nr; i++)
 	  ctmp.elem (i, j) = Complex (re.elem (i, j), im.elem (i, j));
 
       tc = ctmp;
     }
   else
     tc = re;
 
-// XXX FIXME XXX -- this needs to change once strings really work.
+  // XXX FIXME XXX -- this needs to change once strings really work.
 
   if (type == 1 && nr == 1)
     tc = tc.convert_to_str ();
 
   return name;
 
  data_read_error:
   error ("load: trouble reading binary file `%s'", filename);
@@ -2110,19 +2112,19 @@ found in the file will be replaced with 
 
   DEFINE_ARGV ("load");
 
   argc--;
   argv++;
 
   int force = 0;
 
-// It isn't necessary to have the default load format stored in a user
-// preference variable since we can determine the type of file as we
-// are reading.
+  // It isn't necessary to have the default load format stored in a
+  // user preference variable since we can determine the type of file
+  // as we are reading.
 
   load_save_format format = LS_UNKNOWN;
 
   int list_only = 0;
   int verbose = 0;
 
   while (argc > 0)
     {
@@ -2181,19 +2183,20 @@ found in the file will be replaced with 
 
   if (strcmp (*argv, "-") == 0)
     {
       argc--;
       argv++;
 
       if (format != LS_UNKNOWN)
 	{
-// XXX FIXME XXX -- if we have already seen EOF on a previous call,
-// how do we fix up the state of cin so that we can get additional
-// input?  I'm afraid that we can't fix this using cin only.
+	  // XXX FIXME XXX -- if we have already seen EOF on a
+	  // previous call, how do we fix up the state of cin so that
+	  // we can get additional input?  I'm afraid that we can't
+	  // fix this using cin only.
 
 	  retval = do_load (cin, orig_fname, force, format, flt_fmt,
 			    list_only, swap, verbose, argv, argc,
 			    nargout);
 	}
       else
 	error ("load: must specify file format if reading from stdin");
     }
@@ -2899,18 +2902,18 @@ save variables in a file")
 {
   Octave_object retval;
 
   DEFINE_ARGV ("save");
 
   argc--;
   argv++;
 
-// Here is where we would get the default save format if it were
-// stored in a user preference variable.
+  // Here is where we would get the default save format if it were
+  // stored in a user preference variable.
 
   int save_builtins = 0;
 
   int save_as_floats = 0;
 
   load_save_format format = get_default_save_format ();
 
   while (argc > 0)
@@ -2965,18 +2968,18 @@ save variables in a file")
       return retval;
     }
 
   if (strcmp (*argv, "-") == 0)
     {
       argc--;
       argv++;
 
-// XXX FIXME XXX -- should things intended for the screen end up in a 
-// tree_constant (string)?
+      // XXX FIXME XXX -- should things intended for the screen end up
+      // in a tree_constant (string)?
 
       ostrstream buf;
 
       save_vars (argv, argc, buf, save_builtins, format,
 		 save_as_floats);
 
       maybe_page_output (buf);
     }
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -183,18 +183,19 @@ do_history (int argc, char **argv)
 	  switch ((*argv)[1])
 	    {
 	    case 'a':		// Append `new' lines to file.
 	      {
 		if (history_lines_this_session)
 		  {
 		    if (history_lines_this_session < where_history ())
 		      {
-// If the filename was supplied, then create it if it doesn't already
-// exist.
+			// If the filename was supplied, then create
+			// it if it doesn't already exist.
+
 			if (file)
 			  {
 			    struct stat buf;
 
 			    if (stat (file, &buf) == -1)
 			      {
 				int tem;
 
@@ -216,17 +217,20 @@ do_history (int argc, char **argv)
 	      result = write_history (file);
 	      break;
 
 	    case 'r':		// Read entire file.
 	      result = read_history (file);
 	      break;
 
 	    case 'n':		// Read `new' history from file.
-// Read all of the lines in the file that we haven't already read.
+
+	      // Read all of the lines in the file that we haven't
+	      // already read.
+
 	      using_history ();
 	      result = read_history_range (file, history_lines_in_file, -1);
 	      using_history ();
 	      history_lines_in_file = where_history ();
 	      break;
 	    }
 	  return;
 	}
@@ -336,17 +340,17 @@ edit_history_readline (fstream& stream)
   if (lindex + 2 >= line_len)
     {
       char *tmp_line = new char [lindex+3];
       strcpy (tmp_line, line);
       delete [] line;
       line = tmp_line;
     }
 
-// Finish with newline if none in file.
+  // Finish with newline if none in file.
 
   line[lindex++] = '\n';
   line[lindex++] = '\0';
   return line;
 }
 
 extern "C"
 {
@@ -371,19 +375,19 @@ edit_history_repl_hist (char *command)
     return;
 
   int i = 0;
 
   for (i = 0; hlist[i]; i++)
     ; // Count 'em.
   i--;
 
-// History_get () takes a parameter that should be offset by history_base.
+  // History_get () takes a parameter that should be offset by history_base.
 
-// Don't free this.
+  // Don't free this.
   HIST_ENTRY *histent = history_get (history_base + i);
   if (! histent)
     return;
 
   char *data = 0;
   if (histent->data)
     {
       int len = strlen (histent->data);
@@ -432,32 +436,32 @@ mk_tmp_hist_file (int argc, char **argv,
 
   hlist = history_list ();
 
   int hist_count = 0;
 
   while (hlist[hist_count++])
     ; // Find the number of items in the history list.
 
-// The current command line is already part of the history list by the
-// time we get to this point.  Delete it from the list.
+  // The current command line is already part of the history list by
+  // the time we get to this point.  Delete it from the list.
 
   hist_count -= 2;
   if (! insert_curr)
     remove_history (hist_count);
   hist_count--;
 
-// If no numbers have been specified, the default is to edit the last
-// command in the history list.
+  // If no numbers have been specified, the default is to edit the
+  // last command in the history list.
 
   int hist_end = hist_count;
   int hist_beg = hist_count;
   int reverse = 0;
 
-// Process options
+  // Process options.
 
   int usage_error = 0;
   if (argc == 3)
     {
       argv++;
       if (sscanf (*argv++, "%d", &hist_beg) != 1
 	  || sscanf (*argv, "%d", &hist_end) != 1)
 	usage_error = 1;
@@ -529,40 +533,39 @@ mk_tmp_hist_file (int argc, char **argv,
 void
 do_edit_history (int argc, char **argv)
 {
   char *name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
 
   if (! name)
     return;
 
-// Call up our favorite editor on the file of commands.
+  // Call up our favorite editor on the file of commands.
 
   ostrstream buf;
   buf << user_pref.editor << " " << name << ends;
   char *cmd = buf.str ();
 
-// Ignore interrupts while we are off editing commands.  Should we
-// maybe avoid using system()?
+  // Ignore interrupts while we are off editing commands.  Should we
+  // maybe avoid using system()?
 
   volatile sig_handler *saved_sigint_handler = signal (SIGINT, SIG_IGN);
   system (cmd);
   signal (SIGINT, saved_sigint_handler);
 
-// Write the commands to the history file since parse_and_execute
-// disables command line history while it executes.
+  // Write the commands to the history file since parse_and_execute
+  // disables command line history while it executes.
 
   fstream file (name, ios::in);
 
   char *line;
   int first = 1;
   while ((line = edit_history_readline (file)) != 0)
     {
-
-// Skip blank lines
+      // Skip blank lines.
 
       if (line[0] == '\n')
 	{
 	  delete [] line;
 	  continue;
 	}
 
       if (first)
@@ -571,58 +574,60 @@ do_edit_history (int argc, char **argv)
 	  edit_history_repl_hist (line);
 	}
       else
 	edit_history_add_hist (line);
     }
 
   file.close ();
 
-// Turn on command echo, so the output from this will make better sense.
+  // Turn on command echo, so the output from this will make better
+  // sense.
 
   begin_unwind_frame ("do_edit_history");
   unwind_protect_int (echo_input);
   unwind_protect_int (input_from_tmp_history_file);
   echo_input = 1;
   input_from_tmp_history_file = 1;
 
   parse_and_execute (name, 1);
 
   run_unwind_frame ("do_edit_history");
 
-// Delete the temporary file.  Should probably be done with an
-// unwind_protect.
+  // Delete the temporary file.  Should probably be done with an
+  // unwind_protect.
 
   unlink (name);
 
   delete [] name;
 }
 
 void
 do_run_history (int argc, char **argv)
 {
   char *name = mk_tmp_hist_file (argc, argv, 1, "run_history");
 
   if (! name)
     return;
 
-// Turn on command echo, so the output from this will make better sense.
+  // Turn on command echo, so the output from this will make better
+  // sense.
 
   begin_unwind_frame ("do_run_history");
   unwind_protect_int (echo_input);
   unwind_protect_int (input_from_tmp_history_file);
   echo_input = 1;
   input_from_tmp_history_file = 1;
 
   parse_and_execute (name, 1);
 
   run_unwind_frame ("do_run_history");
 
-// Delete the temporary file.  Should probably be done with an
-// unwind_protect.
+  // Delete the temporary file.  Should probably be done with an
+  // unwind_protect.
 
   unlink (name);
 
   delete [] name;
 }
 
 int
 current_history_number (void)
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -154,27 +154,27 @@ octave_Complex_error_handler (const char
 
 // Nonzero means we read ~/.octaverc and ./.octaverc.
 // (--norc; --ignore-init-file; -f)
 static int read_init_files = 1;
 
 // Nonzero means we printed messages about reading startup files.
 static int reading_startup_message_printed = 0;
 
-// Nonzero means we don\'t print the usual startup message.
+// Nonzero means we don't print the usual startup message.
 // (--quiet; --silent; -q)
 static int inhibit_startup_message = 0;
 
 // Usage message
 static const char *usage_string = 
   "octave [-?Vdfhiqvx] [-p path] [--debug] [--help] [--ignore-init-file]\n\
        [--info-file file] [--interactive] [--path path] [--silent]\n\
        [--verbose] [--version] [--echo-commands] [file]";
 
-// This is here so that it\'s more likely that the usage message and
+// This is here so that it's more likely that the usage message and
 // the real set of options will agree.
 static const char *short_opts = "?Vdfhip:qvx";
 
 // Long options.  See the comments in getopt.h for the meanings of the
 // fields in this structure.
 #define INFO_FILE_OPTION 1
 static struct option long_opts[] =
   {
@@ -258,18 +258,18 @@ initialize_globals (char *name)
   else
     {
       putenv_cmd = new char [len];
       sprintf (putenv_cmd, "PATH=%s" SEPCHAR_STR "%s", arch_dir, bin_dir);
     }
 
   putenv (putenv_cmd);
 
-// This may seem odd, but doing it this way means that we don't have
-// to modify the kpathsea library...
+  // This may seem odd, but doing it this way means that we don't have
+  // to modify the kpathsea library...
 
   char *odb = getenv ("OCTAVE_DB_DIR");
 
   if (odb)
     putenv (strconcat ("TEXMF=", odb));
   else
     {
       char *oh = getenv ("OCTAVE_HOME");
@@ -378,32 +378,32 @@ execute_startup_files (void)
 {
   begin_unwind_frame ("execute_startup_files");
 
   unwind_protect_int (input_from_startup_file);
   input_from_startup_file = 1;
 
   int verbose = (verbose_flag && ! inhibit_startup_message);
 
-// Execute commands from the site-wide configuration file.
+  // Execute commands from the site-wide configuration file.
 
   char *sd = get_site_defaults ();
 
   parse_and_execute (sd, 0, verbose);
 
-// Try to execute commands from $HOME/.octaverc and ./.octaverc.
+  // Try to execute commands from $HOME/.octaverc and ./.octaverc.
 
   char *home_rc = 0;
   if (home_directory)
     {
       home_rc = strconcat (home_directory, "/.octaverc");
       parse_and_execute (home_rc, 0, verbose);
     }
 
-// Names alone are not enough.
+  // Names alone are not enough.
 
   struct stat home_rc_statbuf;
   stat (home_rc, &home_rc_statbuf);
   delete [] home_rc;
 
   struct stat dot_rc_statbuf;
   stat ("./.octaverc", &dot_rc_statbuf);
 
@@ -467,18 +467,18 @@ clean_up_and_exit (int retval)
   if (!quitting_gracefully && (interactive || forced_interactive))
     cout << "\n";
 
   if (retval == EOF)
     retval = 0;
 
   exit (retval);
 
-// This is bogus but should prevent g++ from giving a warning saying
-// that this volatile function does return.
+  // This is bogus but should prevent g++ from giving a warning saying
+  // that this volatile function does return.
 
   panic_impossible ();
 }
 
 static void
 print_version_and_exit (void)
 {
   cout << OCTAVE_NAME_AND_VERSION << "\n";
@@ -493,19 +493,19 @@ initialize_error_handlers ()
   set_liboctave_error_handler (error);
 }
 
 // You guessed it.
 
 int
 main (int argc, char **argv)
 {
-// The order of these calls is important, and initialize_globals must
-// come before the options are processed because some command line
-// options override defaults.
+  // The order of these calls is important, and initialize_globals
+  // must come before the options are processed because some command
+  // line options override defaults.
 
   init_user_prefs ();
 
   initialize_pager ();
 
   sysdep_init ();
 
   initialize_error_handlers ();
@@ -562,24 +562,24 @@ main (int argc, char **argv)
 
 	default:
 	  usage ();
 	  break;
 	}
     }
 
 #if defined (HAVE_ATEXIT) || (HAVE_ON_EXIT)
-// Make sure we clean up when we exit.  If we don't have atexit or
-// on_exit, we're going to leave some junk files around if we exit
-// abnormally.
+  // Make sure we clean up when we exit.  If we don't have atexit or
+  // on_exit, we're going to leave some junk files around if we exit
+  // abnormally.
   atexit (cleanup_tmp_files);
 #endif
 
-// These can come after command line args since none of them set any
-// defaults that might be changed by command line options.
+  // These can come after command line args since none of them set any
+  // defaults that might be changed by command line options.
 
   install_signal_handlers ();
 
   initialize_history ();
 
   initialize_file_io ();
 
   initialize_symbol_tables ();  
@@ -598,22 +598,23 @@ main (int argc, char **argv)
       saving_history = 0;
       execute_startup_files ();
       saving_history = 1;
     }
 
   if (! inhibit_startup_message && reading_startup_message_printed)
     cout << endl;
 
-// Avoid counting commands executed from startup files.
+  // Avoid counting commands executed from startup files.
+
   current_command_number = 1;
 
-// If there is an extra argument, see if it names a file to read.
-// Additional arguments are taken as command line options for the
-// script.
+  // If there is an extra argument, see if it names a file to read.
+  // Additional arguments are taken as command line options for the
+  // script.
 
   int remaining_args = argc - optind;
   if (remaining_args > 0)
     {
       if (remaining_args == 1)
 	intern_argv (argc, argv);
       else
 	intern_argv (remaining_args, argv+optind);
@@ -636,44 +637,44 @@ main (int argc, char **argv)
 
       interactive = (isatty (fileno (stdin)) && isatty (fileno (stdout)));
 
       intern_argv (argc, argv);
 
       switch_to_buffer (create_buffer (get_input_from_stdin ()));
     }
 
-// Force input to be echoed if not really interactive, but the user
-// has forced interactive behavior.
+  // Force input to be echoed if not really interactive, but the user
+  // has forced interactive behavior.
 
   if (!interactive && forced_interactive)
     {
       rl_blink_matching_paren = 0;
       echo_input = 1;
     }
 
   if (! (interactive || forced_interactive))
     using_readline = 0;
 
-// Allow the user to interrupt us without exiting.
+  // Allow the user to interrupt us without exiting.
 
   volatile sig_handler *saved_sigint_handler = signal (SIGINT, SIG_IGN);
 
   if (setjmp (toplevel) != 0)
     {
       raw_mode (0);
 
       cout << "\n";
     }
 
   can_interrupt = 1;
 
   signal (SIGINT, saved_sigint_handler);
 
-// The big loop.
+  // The big loop.
 
   int retval;
   do
     {
       curr_sym_tab = top_level_sym_tab;
 
       reset_parser ();
 
@@ -860,19 +861,19 @@ eval_string (const char *string, int pri
   switch_to_buffer (new_buf);
 
   unwind_protect_ptr (curr_sym_tab);
 
   reset_parser ();
 
   parse_status = yyparse ();
 
-// Important to reset the idea of where input is coming from before
-// trying to eval the command we just parsed -- it might contain the
-// name of an function file that still needs to be parsed!
+  // Important to reset the idea of where input is coming from before
+  // trying to eval the command we just parsed -- it might contain the
+  // name of an function file that still needs to be parsed!
 
   tree_statement_list *command = global_command;
 
   run_unwind_frame ("eval_string");
 
   Octave_object retval;
 
   if (parse_status == 0 && command)
@@ -904,17 +905,17 @@ eval_string (const tree_constant& arg, i
   char *string = arg.string_value ();
 
   if (error_state)
     {
       error ("eval: expecting string argument");
       return -1.0;
     }
 
-// Yes Virginia, we always print here...
+  // Yes Virginia, we always print here...
 
   return eval_string (string, 1, 1, parse_status, nargout);
 }
 
 DEFUN ("eval", Feval, Seval, 2, 1,
   "eval (TRY, CATCH)\n\
 \n\
 Evaluate the string TRY as octave code.  If that fails, evaluate the\n\
@@ -985,19 +986,19 @@ DEFUN ("system", Fsystem, Ssystem, 2, 1,
       char ch;
       while (cmd.get (ch))
 	output_buf.put (ch);
 
       output_buf << ends;
 
       int status = cmd.close ();
 
-// The value in status is as returned by waitpid.  If the process
-// exited normally, extract the actual exit status of the command.
-// Otherwise, return 127 as a failure code.
+      // The value in status is as returned by waitpid.  If the
+      // process exited normally, extract the actual exit status of
+      // the command.  Otherwise, return 127 as a failure code.
 
       if ((status & 0xff) == 0)
 	status = (status & 0xff00) >> 8;
       else
 	status = 127;
 
       if (nargout > 0 || nargin > 1)
 	{
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -117,18 +117,18 @@ maybe_page_output (ostrstream& msg_buf)
       cout.flush ();
       delete [] message;
     }
 }
 
 void
 flush_output_to_pager (void)
 {
- // Extract message from buffer, then delete the buffer so that any
- // new messages get sent separately.
+  // Extract message from buffer, then delete the buffer so that any
+  // new messages get sent separately.
 
   *pager_buf << ends;
   char *message = pager_buf->str ();
   initialize_pager ();
 
   if (! message || ! *message)
     {
       delete [] message;
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -328,17 +328,18 @@ print_as_structure (const tree_constant&
 // Construct return vector of empty matrices.  Return empty matrices
 // and/or gripe when appropriate.
 
 Octave_object
 vector_of_empties (int nargout, const char *fcn_name)
 {
   Octave_object retval;
 
-// Got an empty argument, check if should gripe/return empty values.
+  // Got an empty argument, check if should gripe/return empty
+  // values.
 
   int flag = user_pref.propagate_empty_matrices;
   if (flag != 0)
     {
       if (flag < 0)
 	gripe_empty_arg (fcn_name, 0);
 
       Matrix m;
@@ -1560,18 +1561,19 @@ TC_REP::convert_to_str (void) const
 
 	if (xisnan (d))
 	  {
 	    ::error ("invalid conversion from NaN to character");
 	    return retval;
 	  }
 	else
 	  {
+	    // XXX FIXME XXX -- warn about out of range conversions?
+
 	    int i = NINT (d);
-// Warn about out of range conversions?
 	    char s[2];
 	    s[0] = (char) i;
 	    s[1] = '\0';
 	    retval = s;
 	  }
       }
       break;
 
@@ -1610,17 +1612,18 @@ TC_REP::convert_to_str (void) const
 
 			if (xisnan (d))
 			  {
 			    ::error ("invalid conversion from NaN to character");
 			    return retval;
 			  }
 			else
 			  {
-			    // Warn about out of range conversions?
+			    // XXX FIXME XXX -- warn about out of
+			    // range conversions?
 
 			    int ival = NINT (d);
 			    buf[j] = (char) ival;
 			  }
 		      }
 
 		    s.elem (i).assign (buf, nc);
 		  }
@@ -1646,18 +1649,20 @@ TC_REP::convert_to_str (void) const
 	    if (xisnan (d))
 	      {
 		::error ("invalid conversion from NaN to character");
 		delete [] s;
 		return retval;
 	      }
 	    else
 	      {
+		// XXX FIXME XXX -- warn about out of range
+		// conversions?
+
 		int ival = NINT (d);
-// Warn about out of range conversions?
 		s[i] = (char) ival;
 	      }
 	  }
 	retval = s;
 	delete [] s;
       }
       break;
 
@@ -1988,21 +1993,23 @@ TC_REP::maybe_resize (int i, force_orien
 {
   int nr = rows ();
   int nc = columns ();
 
   i++;
 
   assert (i >= 0 && (nr <= 1 || nc <= 1));
 
-// This function never reduces the size of a vector, and all vectors
-// have dimensions of at least 0x0.  If i is 0, it is either because
-// a vector has been indexed with a vector of all zeros (in which case
-// the index vector is empty and nothing will happen) or a vector has
-// been indexed with 0 (an error which will be caught elsewhere).
+  // This function never reduces the size of a vector, and all vectors
+  // have dimensions of at least 0x0.  If i is 0, it is either because
+  // a vector has been indexed with a vector of all zeros (in which
+  // case the index vector is empty and nothing will happen) or a
+  // vector has been indexed with 0 (an error which will be caught
+  // elsewhere).
+
   if (i == 0)
     return;
 
   if (nr <= 1 && nc <= 1 && i >= 1)
     {
       if (user_pref.resize_on_range_error)
 	{
 	  if (f_orient == row_orient)
@@ -2066,17 +2073,17 @@ TC_REP::maybe_mutate (void)
 	  type_tag = matrix_constant;
 	}
       break;
 
     default:
       break;
     }
 
-// Avoid calling rows() and columns() for things like magic_colon.
+  // Avoid calling rows() and columns() for things like magic_colon.
 
   int nr = 1;
   int nc = 1;
   if (type_tag == matrix_constant
       || type_tag == complex_matrix_constant
       || type_tag == range_constant)
     {
       nr = rows ();
@@ -2149,19 +2156,20 @@ TC_REP::print (ostream& output_buf)
       break;
 
     case range_constant:
       octave_print_internal (output_buf, *range);
       break;
 
     case map_constant:
       {
-// XXX FIXME XXX -- would be nice to print the output in some standard
-// order.  Maybe all substructures first, maybe alphabetize entries,
-// etc.
+	// XXX FIXME XXX -- would be nice to print the output in some
+	// standard order.  Maybe all substructures first, maybe
+	// alphabetize entries, etc.
+
 	begin_unwind_frame ("TC_REP_print");
 
 	unwind_protect_int (structure_indent_level);
 	unwind_protect_int (user_pref.struct_levels_to_print);
 
 	if (user_pref.struct_levels_to_print-- > 0)
 	  {
 	    output_buf << "{\n";
@@ -2217,19 +2225,19 @@ TC_REP::print_code (ostream& os)
       octave_print_internal (os, *matrix, 1);
       break;
 
     case complex_scalar_constant:
      {
 	double re = complex_scalar->real ();
 	double im = complex_scalar->imag ();
 
-// If we have the original text and a pure imaginary, just print the
-// original text, because this must be a constant that was parsed as
-// part of a function.
+	// If we have the original text and a pure imaginary, just
+	// print the original text, because this must be a constant
+	// that was parsed as part of a function.
 
 	if (orig_text && re == 0.0 && im > 0.0)
 	  os << orig_text;
 	else
 	  octave_print_internal (os, *complex_scalar, 1);
       }
       break;
 
@@ -2613,23 +2621,23 @@ TC_REP::do_index (const Octave_object& a
 
     case complex_matrix_constant:
     case matrix_constant:
       retval = do_matrix_index (args);
       break;
 
     case string_constant:
       gripe_string_invalid ();
-//      retval = do_string_index (args);
+      //      retval = do_string_index (args);
       break;
 
     default:
 
-// This isn\'t great, but it\'s easier than implementing a lot of
-// other special indexing functions.
+      // This isn't great, but it's easier than implementing a lot
+      // of other special indexing functions.
 
       force_numeric ();
 
       if (! error_state && is_numeric_type ())
 	retval = do_index (args);
 
       break;
     }
@@ -2703,17 +2711,17 @@ TC_REP::do_scalar_index (const Octave_ob
 		  }
 		else
 		  break;
 	      }
 	    else
 	      break;
 	  }
 
-// Fall through...
+	  // Fall through...
 
 	case 1:
 	  {
 	    tree_constant arg = args(0);
 
 	    if (arg.is_matrix_type ())
 	      {
 		Matrix mi = arg.matrix_value ();
@@ -2751,19 +2759,19 @@ TC_REP::do_scalar_index (const Octave_ob
 		      break;
 		  }
 		else
 		  break;
 	      }
 	    else
 	      break;
 
-// If only one index, cols will not be set, so we set it.
-// If single index is [], rows will be zero, and we should set cols to
-// zero too.
+	    // If only one index, cols will not be set, so we set it.
+	    // If single index is [], rows will be zero, and we should
+	    // set cols to zero too.
 
 	    if (cols < 0)
 	      {
 		if (rows == 0)
 		  cols = 0;
 		else
 		  {
 		    if (user_pref.prefer_column_vectors)
@@ -3012,17 +3020,18 @@ TC_REP::fortran_style_matrix_index (cons
 	Matrix mi = tmp_i.matrix_value ();
 	if (mi.rows () == 0 || mi.columns () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = mtmp;
 	  }
 	else
 	  {
-// Yes, we really do want to call this with mi.
+	    // Yes, we really do want to call this with mi.
+
 	    retval = fortran_style_matrix_index (mi);
 	  }
       }
       break;
 
     case string_constant:
       gripe_string_invalid ();
       break;
@@ -3071,17 +3080,18 @@ TC_REP::fortran_style_matrix_index (cons
       const double *cop_out_index = mi.data ();
 
       idx_vector iv (mi, 1, "", len);
       if (! iv || range_max_check (iv.max (), len) < 0)
 	return retval;
 
       int result_size = iv.length ();
 
-// XXX FIXME XXX -- there is way too much duplicate code here...
+      // XXX FIXME XXX -- there is way too much duplicate code
+      // here...
 
       if (iv.one_zero_only ())
 	{
 	  if (iv.ones_count () == 0)
 	    {
 	      retval = Matrix ();
 	    }
 	  else
@@ -4138,20 +4148,20 @@ TC_REP::do_matrix_index (TC_REP::constan
 void
 TC_REP::assign (tree_constant& rhs, const Octave_object& args)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
   if (error_state)
     return;
 
-// This is easier than actually handling assignments to strings.
-// An assignment to a range will normally require a conversion to a
-// vector since it will normally destroy the equally-spaced property
-// of the range elements.
+  // This is easier than actually handling assignments to strings.  An
+  // assignment to a range will normally require a conversion to a
+  // vector since it will normally destroy the equally-spaced property
+  // of the range elements.
 
   if (is_defined () && ! is_numeric_type ())
     force_numeric ();
 
   if (error_state)
     return;
 
   switch (type_tag)
@@ -4254,25 +4264,24 @@ TC_REP::do_scalar_assignment (const tree
 	  delete old_complex;
 	}
       else if (type_tag == scalar_constant)
 	{
 	  matrix = new Matrix (1, 1, scalar);
 	  type_tag = matrix_constant;
 	}
 
-// If there is an error, the call to do_matrix_assignment should not
-// destroy the current value.
-// TC_REP::eval(int) will take
-// care of converting single element matrices back to scalars.
+      // If there is an error, the call to do_matrix_assignment should
+      // not destroy the current value.  TC_REP::eval(int) will take
+      // care of converting single element matrices back to scalars.
 
       do_matrix_assignment (rhs, args);
 
-// I don't think there's any other way to revert back to unknown
-// constant types, so here it is.
+      // I don't think there's any other way to revert back to unknown
+      // constant types, so here it is.
 
       if (old_type_tag == unknown_constant && error_state)
 	{
 	  if (type_tag == matrix_constant)
 	    delete matrix;
 	  else if (type_tag == complex_matrix_constant)
 	    delete complex_matrix;
 
@@ -4316,18 +4325,19 @@ TC_REP::do_matrix_assignment (const tree
 	{
 	  matrix = new Matrix ();
 	  type_tag = matrix_constant;
 	}
     }
 
   int nargin = args.length ();
 
-// The do_matrix_assignment functions can't handle empty matrices, so
-// don't let any pass through here.
+  // The do_matrix_assignment functions can't handle empty matrices,
+  // so don't let any pass through here.
+
   switch (nargin)
     {
     case 1:
       {
 	tree_constant arg = args(0);
 
 	if (arg.is_undefined ())
 	  ::error ("matrix index is undefined");
@@ -4347,19 +4357,20 @@ TC_REP::do_matrix_assignment (const tree
 	  ::error ("second matrix index is undefined");
 	else if (arg_a.is_empty () || arg_b.is_empty ())
 	  {
 	    if (! rhs.is_empty ())
 	      {
 		::error ("in assignment expression, a matrix index is empty");
 		::error ("but the right hand side is not an empty matrix");
 	      }
-// XXX FIXME XXX -- to really be correct here, we should probably
-// check to see if the assignment conforms, but that seems like more
-// work than it's worth right now...
+
+	    // XXX FIXME XXX -- to really be correct here, we should
+	    // probably check to see if the assignment conforms, but
+	    // that seems like more work than it's worth right now...
 	  }
 	else
 	  do_matrix_assignment (rhs, arg_a, arg_b);
       }
       break;
 
     default:
       if (nargin == 0)
@@ -4383,29 +4394,32 @@ TC_REP::do_matrix_assignment (const tree
     {
       if (i_arg.is_empty ())
 	{
 	  if (! rhs.is_empty ())
 	    {
 	      ::error ("in assignment expression, matrix index is empty but");
 	      ::error ("right hand side is not an empty matrix");
 	    }
-// XXX FIXME XXX -- to really be correct here, we should probably
-// check to see if the assignment conforms, but that seems like more
-// work than it's worth right now...
-
-// The assignment functions can't handle empty matrices, so don't let
-// any pass through here.
+
+	  // XXX FIXME XXX -- to really be correct here, we should
+	  // probably check to see if the assignment conforms, but
+	  // that seems like more work than it's worth right now...
+
+	  // The assignment functions can't handle empty matrices, so
+	  // don't let any pass through here.
+
 	  return;
 	}
 
-// We can't handle the case of assigning to a vector first, since even
-// then, the two operations are not equivalent.  For example, the
-// expression V(:) = M is handled differently depending on whether the
-// user specified do_fortran_indexing = "true".
+      // We can't handle the case of assigning to a vector first,
+      // since even then, the two operations are not equivalent.  For
+      // example, the expression V(:) = M is handled differently
+      // depending on whether the user specified do_fortran_indexing =
+      // "true".
 
       if (user_pref.do_fortran_indexing)
 	fortran_style_matrix_assignment (rhs, i_arg);
       else if (nr <= 1 || nc <= 1)
 	vector_assignment (rhs, i_arg);
       else
 	panic_impossible ();
     }
@@ -4582,17 +4596,19 @@ TC_REP::fortran_style_matrix_assignment 
       gripe_string_invalid ();
       break;
 
     case range_constant:
       gripe_range_invalid ();
       break;
 
     case magic_colon:
-// a(:) = [] is equivalent to a(:,:) = [].
+
+      // a(:) = [] is equivalent to a(:,:) = [].
+
       if (rhs_nr == 0 && rhs_nc == 0)
 	do_matrix_assignment (rhs, magic_colon, magic_colon);
       else
 	fortran_style_matrix_assignment (rhs, magic_colon);
       break;
 
     default:
       panic_impossible ();
@@ -5193,17 +5209,17 @@ TC_REP::do_matrix_assignment (const tree
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
-/* MA1 */
+// -*- MA1 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs, int i,
 			      const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   if (error_state)
     return;
@@ -5348,17 +5364,17 @@ TC_REP::do_matrix_assignment (const tree
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
-/* MA2 */
+// -*- MA2 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      idx_vector& iv, const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   if (error_state)
     return;
@@ -5488,17 +5504,17 @@ TC_REP::do_matrix_assignment (const tree
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
-/* MA3 */
+// -*- MA3 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs, Range& ri,
 			      const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   if (error_state)
     return;
@@ -5633,17 +5649,17 @@ TC_REP::do_matrix_assignment (const tree
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
-/* MA4 */
+// -*- MA4 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      TC_REP::constant_type i,
 			      const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   if (error_state)
@@ -5823,36 +5839,36 @@ TC_REP::do_matrix_assignment (const tree
 //   ---------+---+---+----+----+
 //   vector   | 2 | 6 | 10 | 14 |
 //   ---------+---+---+----+----+
 //   range    | 3 | 7 | 11 | 15 |
 //   ---------+---+---+----+----+
 //   colon    | 4 | 8 | 12 | 16 |
 //   ---------+---+---+----+----+
 
-/* 1 */
+// -*- 1 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs, int i, int j)
 {
   REP_ELEM_ASSIGN (i, j, rhs.double_value (), rhs.complex_value (),
 		   rhs.is_real_type ());
 }
 
-/* 2 */
+// -*- 2 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs, int i, idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int j = 0; j < jv.capacity (); j++)
     REP_ELEM_ASSIGN (i, jv.elem (j), rhs_m.elem (0, j),
 		     rhs_cm.elem (0, j), rhs.is_real_type ());
 }
 
-/* 3 */
+// -*- 3 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs, int i, Range& rj)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = rj.base ();
   double increment = rj.inc ();
 
@@ -5860,17 +5876,17 @@ TC_REP::do_matrix_assignment (const tree
     {
       double tmp = b + j * increment;
       int col = tree_to_mat_idx (tmp);
       REP_ELEM_ASSIGN (i, col, rhs_m.elem (0, j), rhs_cm.elem (0, j),
 		       rhs.is_real_type ());
     }
 }
 
-/* 4 */
+// -*- 4 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs, int i,
 			      TC_REP::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   int nc = columns ();
 
@@ -5890,32 +5906,32 @@ TC_REP::do_matrix_assignment (const tree
     {
       REP_ELEM_ASSIGN (i, 0, rhs.double_value (),
 		       rhs.complex_value (), rhs.is_real_type ());
     }
   else
     panic_impossible ();
 }
 
-/* 5 */
+// -*- 5 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      idx_vector& iv, int j)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int i = 0; i < iv.capacity (); i++)
     {
       int row = iv.elem (i);
       REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, 0),
 		       rhs_cm.elem (i, 0), rhs.is_real_type ());
     }
 }
 
-/* 6 */
+// -*- 6 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      idx_vector& iv, idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int i = 0; i < iv.capacity (); i++)
     {
@@ -5924,17 +5940,17 @@ TC_REP::do_matrix_assignment (const tree
 	{
 	  int col = jv.elem (j);
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 7 */
+// -*- 7 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      idx_vector& iv, Range& rj)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = rj.base ();
   double increment = rj.inc ();
@@ -5947,17 +5963,17 @@ TC_REP::do_matrix_assignment (const tree
 	  double tmp = b + j * increment;
 	  int col = tree_to_mat_idx (tmp);
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 8 */
+// -*- 8 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      idx_vector& iv, TC_REP::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
@@ -5976,17 +5992,17 @@ TC_REP::do_matrix_assignment (const tree
 	      int row = iv.elem (i);
 	      REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, j),
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
-/* 9 */
+// -*- 9 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs, Range& ri, int j)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = ri.base ();
   double increment = ri.inc ();
 
@@ -5994,17 +6010,17 @@ TC_REP::do_matrix_assignment (const tree
     {
       double tmp = b + i * increment;
       int row = tree_to_mat_idx (tmp);
       REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, 0),
 		       rhs_cm.elem (i, 0), rhs.is_real_type ());
     }
 }
 
-/* 10 */
+// -*- 10 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      Range& ri, idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = ri.base ();
   double increment = ri.inc ();
@@ -6017,17 +6033,17 @@ TC_REP::do_matrix_assignment (const tree
 	  double tmp = b + i * increment;
 	  int row = tree_to_mat_idx (tmp);
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_m.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 11 */
+// -*- 11 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      Range& ri, Range& rj)
 {
   double ib = ri.base ();
   double iinc = ri.inc ();
   double jb = rj.base ();
   double jinc = rj.inc ();
@@ -6043,17 +6059,17 @@ TC_REP::do_matrix_assignment (const tree
 	  double jtmp = jb + j * jinc;
 	  int col = tree_to_mat_idx (jtmp);
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem  (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 12 */
+// -*- 12 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      Range& ri, TC_REP::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
@@ -6074,17 +6090,17 @@ TC_REP::do_matrix_assignment (const tree
 	  int row = tree_to_mat_idx (itmp);
 	  for (int j = 0; j < nc; j++)
 	    REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, j),
 			     rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 13 */
+// -*- 13 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      TC_REP::constant_type mci, int j)
 {
   assert (mci == magic_colon);
 
   int nr = rows ();
 
@@ -6104,17 +6120,17 @@ TC_REP::do_matrix_assignment (const tree
     {
       REP_ELEM_ASSIGN (0, j, rhs.double_value (),
 		       rhs.complex_value (), rhs.is_real_type ());
     }
   else
     panic_impossible ();
 }
 
-/* 14 */
+// -*- 14 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      TC_REP::constant_type mci, idx_vector& jv)
 {
   assert (mci == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
@@ -6133,17 +6149,17 @@ TC_REP::do_matrix_assignment (const tree
 	      int col = jv.elem (j);
 	      REP_ELEM_ASSIGN (i, col, rhs_m.elem (i, j),
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
-/* 15 */
+// -*- 15 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      TC_REP::constant_type mci, Range& rj)
 {
   assert (mci == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
@@ -6166,17 +6182,17 @@ TC_REP::do_matrix_assignment (const tree
 	    {
 	      REP_ELEM_ASSIGN (i, col, rhs_m.elem (i, j),
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
-/* 16 */
+// -*- 16 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
 			      TC_REP::constant_type mci,
 			      TC_REP::constant_type mcj)
 {
   assert (mci == magic_colon && mcj == magic_colon);
 
   switch (type_tag)
@@ -6364,17 +6380,18 @@ TC_REP::delete_rows (Range& ri)
   int num_to_delete = ri.nelem ();
 
   if (num_to_delete == 0)
     return;
 
   int nr = rows ();
   int nc = columns ();
 
-// If deleting all rows of a column vector, make result 0x0.
+  // If deleting all rows of a column vector, make result 0x0.
+
   if (nc == 1 && num_to_delete == nr)
     nc = 0;
 
   double ib = ri.base ();
   double iinc = ri.inc ();
 
   int max_idx = tree_to_mat_idx (ri.max ());
 
@@ -6482,17 +6499,18 @@ TC_REP::delete_columns (idx_vector& jv)
   int num_to_delete = jv.length ();
 
   if (num_to_delete == 0)
     return;
 
   int nr = rows ();
   int nc = columns ();
 
-// If deleting all columns of a row vector, make result 0x0.
+  // If deleting all columns of a row vector, make result 0x0.
+
   if (nr == 1 && num_to_delete == nc)
     nr = 0;
 
   if (type_tag == matrix_constant)
     {
       Matrix *new_matrix = new Matrix (nr, nc-num_to_delete);
       if (nc > num_to_delete)
 	{
@@ -6546,17 +6564,18 @@ TC_REP::delete_columns (Range& rj)
   int num_to_delete = rj.nelem ();
 
   if (num_to_delete == 0)
     return;
 
   int nr = rows ();
   int nc = columns ();
 
-// If deleting all columns of a row vector, make result 0x0.
+  // If deleting all columns of a row vector, make result 0x0.
+
   if (nr == 1 && num_to_delete == nc)
     nr = 0;
 
   double jb = rj.base ();
   double jinc = rj.inc ();
 
   int max_idx = tree_to_mat_idx (rj.max ());
 
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -78,18 +78,19 @@ extern int breaking;
 
 static tree **
 list_to_vector (tree *list, int& len)
 {
   len = list->length () + 1;
 
   tree **args = new tree * [len];
 
-// args[0] may eventually hold something useful, like the function
-// name.
+  // args[0] may eventually hold something useful, like the function
+  // name.
+
   tree *tmp_list = list;
   for (int k = 1; k < len; k++)
     {
       args[k] = tmp_list;
       tmp_list = tmp_list->next_elem ();
     }
   return args;
 }
@@ -292,25 +293,26 @@ struct const_matrix_list
 tree_constant
 tree_matrix::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-// Just count the elements without looking at them.
+  // Just count the elements without looking at them.
 
   int total_len = length ();
 
-// Easier to deal with this later instead of a tree_matrix structure.
+  // Easier to deal with this later instead of a tree_matrix
+  // structure.
 
   const_matrix_list *list = new const_matrix_list [total_len];
 
-// Stats we want to keep track of.
+  // Stats we want to keep track of.
 
   int all_strings = 1;
 
   int found_complex = 0;
 
   int row_total = 0;
   int col_total = 0;
 
@@ -319,32 +321,32 @@ tree_matrix::eval (int print)
   int cols_this_row = 0;
 
   int first_row = 1;
 
   int empties_ok = user_pref.empty_list_elements_ok;
 
   tree_matrix *ptr = this;
 
-// Stuff for the result matrix or string.  Declared here so that we
-// don't get warnings from gcc about the goto crossing the
-// initialization of these values.
+  // Stuff for the result matrix or string.  Declared here so that we
+  // don't get warnings from gcc about the goto crossing the
+  // initialization of these values.
 
   int put_row = 0;
   int put_col = 0;
 
   int prev_nr = 0;
   int prev_nc = 0;
 
   Matrix m;
   ComplexMatrix cm;
 
   Octave_str_obj string;
 
-// Eliminate empties and gather stats.
+  // Eliminate empties and gather stats.
 
   int found_new_row_in_empties = 0;
 
   int len = 0;
   for (int i = 0; i < total_len; i++)
     {
       tree_expression *elem = ptr->element;
       if (! elem)
@@ -402,21 +404,21 @@ tree_matrix::eval (int print)
 
       len++;
 
     next:
 
       ptr = ptr->next;
     }
 
-//  if (all_strings)
-//    cerr << "all strings\n";
-
-// Compute size of result matrix, and check to see that the dimensions
-// of all the elements will match up properly.
+  //  if (all_strings)
+  //    cerr << "all strings\n";
+
+  // Compute size of result matrix, and check to see that the dimensions
+  // of all the elements will match up properly.
 
   for (int i = 0; i < len; i++)
     {
       dir direct = list[i].direction;
 
       int nr = list[i].nr;
       int nc = list[i].nc;
 
@@ -464,26 +466,26 @@ tree_matrix::eval (int print)
 
 	    default:
 	      panic_impossible ();
 	      break;
 	    }
 	}
     }
 
-// Don\'t forget to check to see if the last element will fit.
+  // Don't forget to check to see if the last element will fit.
 
   if (cols_this_row != col_total && ! all_strings)
     {
       ::error ("number of columns must match");
       goto done;
     }
 
-// Now, extract the values from the individual elements and insert
-// them in the result matrix.
+  // Now, extract the values from the individual elements and insert
+  // them in the result matrix.
 
   if (all_strings)
     string.resize (row_total);
   else if (found_complex)
     cm.resize (row_total, col_total, 0.0);
   else
     m.resize (row_total, col_total, 0.0);
 
@@ -1003,17 +1005,18 @@ tree_identifier::eval (int print, int na
 
   if (! script_file_executed)
     {
       if (object_to_eval)
 	{
 	  if (maybe_do_ans_assign && nargout == 1)
 	    {
 
-// Don't count the output arguments that we create automatically.
+	      // Don't count the output arguments that we create
+	      // automatically.
 
 	      nargout = 0;
 
 	      retval = object_to_eval->eval (0, nargout, args);
 
 	      if (retval.length () > 0 && retval(0).is_defined ())
 		bind_ans (retval(0), print);
 	    }
@@ -1227,17 +1230,18 @@ tree_index_expression::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (list)
     {
-// Extract the arguments into a simple vector.  Don't pass null args.
+      // Extract the arguments into a simple vector.  Don't pass null
+      // args.
 
       Octave_object args = list->convert_to_const_vector ();
 
       if (error_state)
 	eval_error ();
       else
 	{
 	  int nargin = args.length ();
@@ -1279,17 +1283,18 @@ tree_index_expression::eval (int print, 
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (list)
     {
-// Extract the arguments into a simple vector.  Don't pass null args.
+      // Extract the arguments into a simple vector.  Don't pass null
+      // args.
 
       Octave_object args = list->convert_to_const_vector ();
 
       if (error_state)
 	eval_error ();
       else
 	{
 	  int nargin = args.length ();
@@ -1932,17 +1937,17 @@ tree_simple_assignment_expression::eval 
       else if (! index)
 	{
 	  retval = lhs->assign (rhs_val);
 	  if (error_state)
 	    eval_error ();
 	}
       else
 	{
-// Extract the arguments into a simple vector.
+	  // Extract the arguments into a simple vector.
 
 	  Octave_object args = index->convert_to_const_vector ();
 
 	  if (error_state)
 	    eval_error ();
 	  else
 	    {
 	      int nargin = args.length ();
@@ -1970,18 +1975,16 @@ tree_simple_assignment_expression::eval_
 {
   if (error_state > 0)
     {
       int l = line ();
       int c = column ();
       if (l != -1 && c != -1)
 	::error ("evaluating assignment expression near line %d, column %d",
 		 l, c);
-//      else
-//	::error ("evaluating assignment expression");
     }
 }
 
 void
 tree_simple_assignment_expression::print_code (ostream& os)
 {
   print_code_indent (os);
 
@@ -2062,18 +2065,19 @@ tree_multi_assignment_expression::eval (
       int pad_after = 0;
       int last_was_scalar_type = 0;
       for (Pix p = lhs->first (); p != 0; lhs->next (p))
 	{
 	  tree_index_expression *lhs_expr = lhs->operator () (p);
 
 	  if (i < nargout)
 	    {
-// XXX FIXME? XXX -- this is apparently the way Matlab works, but
-// maybe we should have the option of skipping the assignment instead.
+	      // XXX FIXME? XXX -- this is apparently the way Matlab
+	      // works, but maybe we should have the option of
+	      // skipping the assignment instead.
 
 	      tree_constant *tmp = 0;
 	      if (results(i).is_undefined ())
 		{
 		  error ("element number %d undefined in return list", i+1);
 		  eval_error ();
 		  break;
 		}
@@ -2273,17 +2277,17 @@ tree_colon_expression::print_code (ostre
   print_code_indent (os);
 
   if (in_parens)
     os << "(";
 
   if (op1)
     op1->print_code (os);
 
-// Stupid syntax.
+  // Stupid syntax.
 
   if (op3)
     {
       os << ":";
       op3->print_code (os);
     }
 
   if (op2)
@@ -2565,22 +2569,24 @@ tree_function::stash_fcn_file_name (void
   file_name = fcn_name ? fcn_file_in_path (fcn_name) : 0;
 }
 
 void
 tree_function::mark_as_system_fcn_file (void)
 {
   if (file_name)
     {
-// We really should stash the whole path to the file we found, when we
-// looked it up, to avoid possible race conditions...  XXX FIXME XXX
-//
-// We probably also don't need to get the library directory every
-// time, but since this function is only called when the function file
-// is parsed, it probably doesn't matter that much.
+      // We really should stash the whole path to the file we found,
+      // when we looked it up, to avoid possible race conditions...
+      // XXX FIXME XXX
+      //
+      // We probably also don't need to get the library directory
+      // every time, but since this function is only called when the
+      // function file is parsed, it probably doesn't matter that
+      // much.
 
       char *oct_lib = octave_lib_dir ();
       int len = strlen (oct_lib);
 
       char *ff_name = fcn_file_in_path (file_name);
 
       if (strncmp (oct_lib, ff_name, len) == 0)
 	system_fcn_file = 1;
@@ -2707,83 +2713,88 @@ tree_function::eval (int print, int narg
 
   if (call_depth > 1)
     {
       sym_tab->push_context ();
       add_unwind_protect (pop_symbol_table_context, (void *) sym_tab);
 
       if (vr_list)
 	{
-// Push new vr_list.
+	  // Push new vr_list.
+
 	  unwind_protect_ptr (vr_list);
 	  vr_list = new tree_va_return_list;
 
-// Clear and delete the new one before restoring the old one.
+	  // Clear and delete the new one before restoring the old
+	  // one.
+
 	  add_unwind_protect (delete_vr_list, (void *) vr_list);
 	}
     }
 
   if (vr_list)
     vr_list->clear ();
 
-// Force symbols to be undefined again when this function exits.
+  // Force symbols to be undefined again when this function exits.
 
   add_unwind_protect (clear_symbol_table, (void *) sym_tab);
 
-// Save old and set current symbol table context, for eval_undefined_error().
+  // Save old and set current symbol table context, for
+  // eval_undefined_error().
 
   unwind_protect_ptr (curr_sym_tab);
   curr_sym_tab = sym_tab;
 
   unwind_protect_ptr (curr_function);
   curr_function = this;
 
-//  unwind_protect_ptr (args_passed);
+  //  unwind_protect_ptr (args_passed);
+
   args_passed = args;
 
   unwind_protect_int (num_args_passed);
   num_args_passed = nargin;
 
   unwind_protect_int (num_named_args);
   unwind_protect_int (curr_va_arg_number);
 
   if (param_list && ! param_list->varargs_only ())
     {
       param_list->define_from_arg_vector (args);
       if (error_state)
 	goto abort;
     }
 
-// The following code is in a separate scope to avoid warnings from
-// G++ about `goto abort' crossing the initialization of some
-// variables.
+  // The following code is in a separate scope to avoid warnings from
+  // G++ about `goto abort' crossing the initialization of some
+  // variables.
 
   {
     bind_nargin_and_nargout (nargin, nargout);
       
-// Evaluate the commands that make up the function.  Always turn on
-// printing for commands inside functions.   Maybe this should be
-// toggled by a user-leval variable?
+    // Evaluate the commands that make up the function.  Always turn
+    // on printing for commands inside functions.   Maybe this should
+    // be toggled by a user-leval variable?
 
     int pf = ! user_pref.silent_functions;
     tree_constant last_computed_value = cmd_list->eval (pf);
 
     if (returning)
       returning = 0;
 
     if (breaking)
       breaking--;
 
     if (error_state)
       {
 	traceback_error ();
 	goto abort;
       }
     
-// Copy return values out.
+    // Copy return values out.
 
     if (ret_list)
       {
 	if (nargout > 0 && user_pref.define_all_return_values)
 	  {
 	    tree_constant tmp = builtin_any_variable ("default_return_value");
 	    if (tmp.is_defined ())
 	      ret_list->initialize_undefined_elements (tmp);
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -203,19 +203,19 @@ tree_statement_list::print_code (ostream
     }
 }
 
 Octave_object
 tree_argument_list::convert_to_const_vector (void)
 {
   int len = length ();
 
-// XXX FIXME XXX -- would be nice to know in advance how largs args
-// needs to be even when we have a list containing an all_va_args
-// token.
+  // XXX FIXME XXX -- would be nice to know in advance how largs args
+  // needs to be even when we have a list containing an all_va_args
+  // token.
 
   Octave_object args;
   args.resize (len);
 
   Pix p = first ();
   int j = 0;
   for (int k = 0; k < len; k++)
     {
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -56,17 +56,17 @@ Software Foundation, 59 Temple Place - S
 #include "user-prefs.h"
 #include "utils.h"
 
 extern "C"
 {
 #include <readline/tilde.h>
 }
 
-// The number of lines we\'ve plotted so far.
+// The number of lines we've plotted so far.
 static int plot_line_count = 0;
 
 // Is this a parametric plot?  Makes a difference for 3D plotting.
 static int parametric_plot = 0;
 
 // The gnuplot terminal type.
 static char *gnuplot_terminal_type = 0;
 
@@ -153,17 +153,18 @@ open_plot_stream (void)
       if (gnuplot_terminal_type)
 	plot_stream << "set term " << gnuplot_terminal_type << "\n";
     }
 }
 
 static int
 send_to_plot_stream (const char *cmd)
 {
-// From sighandlers.cc:
+  // From sighandlers.cc:
+
   extern int pipe_handler_error_count;
 
   if (! plot_stream.is_open ())
     {
       open_plot_stream ();
 
       if (error_state)
 	return -1;
@@ -296,19 +297,19 @@ tree_plot_command::eval (void)
       int status = plot_list->print (ndim, plot_buf);
 
       if (error_state || status < 0)
 	return;
     }
 
   plot_buf << "\n" << ends;
 
-// Just testing...
-//  char *message = plot_buf.str ();
-//  cout << "[*]" << message << "[*]\n";
+  // Just testing...
+  //  char *message = plot_buf.str ();
+  //  cout << "[*]" << message << "[*]\n";
 
   if (parametric_plot && ndim == 2)
     {
       warning ("can't make 2D parametric plot -- setting noparametric...");
       send_to_plot_stream ("set noparametric\n");
       char *message = plot_buf.str ();
       send_to_plot_stream (message);
       delete [] message;
@@ -840,48 +841,51 @@ subplot::handle_plot_data (int ndim, ost
     {
       tree_constant data = plot_data->eval (0);
 
       if (! error_state && data.is_defined ())
 	{
 	  char *file = 0;
 	  if (data.is_string ())
 	    {
-// Should really try to look at data file to determine n_max.  Can't
-// do much about other arbitrary gnuplot commands though...
+	      // Should really try to look at data file to determine
+	      // n_max.  Can't do much about other arbitrary gnuplot
+	      // commands though...
 
 	      int n_max = 0;
 
 	      file = tilde_expand (data.string_value ());
 	      ifstream ftmp (file);
 	      if (ftmp)
 		{
 		  plot_buf << " \"" << file << '"';
 		  free (file);
 		}
 	      else
 		{
 		  free (file);
 		  file = 0;
 
-// Opening as a file failed.  Let's try passing it along as a plot
-// command.
+		  // Opening as a file failed.  Let's try passing it
+		  // along as a plot command.
+
 		  plot_buf << " " << data.string_value ();
 		}
 
 	      if (using_clause)
 		{
 		  int status = using_clause->print (ndim, n_max, plot_buf);
 		  if (status < 0)
 		    return -1;
 		}
 	    }
 	  else
 	    {
-// Eliminate the need for printing a using clause to plot_buf.
+	      // Eliminate the need for printing a using clause to
+	      // plot_buf.
 
 	      tree_constant tmp_data = extract_plot_data (ndim, data);
 
 	      if (tmp_data.is_defined ())
 		{
 		  switch (ndim)
 		    {
 		    case 2:
@@ -1087,27 +1091,28 @@ do_external_plotter_cd (const char *newd
 }
 
 DEFUN ("clearplot", Fclearplot, Sclearplot, 0, 0,
   "clearplot (): clear the plot window")
 {
   Octave_object retval;
   send_to_plot_stream ("clear\n");
 
-// XXX FIXME XXX -- instead of just clearing these things, it would be
-// nice if we could reset things to a user-specified default state.
+  // XXX FIXME XXX -- instead of just clearing these things, it would
+  // be nice if we could reset things to a user-specified default
+  // state.
 
   send_to_plot_stream ("set title\n");
   send_to_plot_stream ("set xlabel\n");
   send_to_plot_stream ("set ylabel\n");
   send_to_plot_stream ("set nogrid\n");
   send_to_plot_stream ("set nolabel\n");
 
-// This makes a simple `replot' not work after a `clearplot' command
-// has been issued.
+  // This makes a simple `replot' not work after a `clearplot' command
+  // has been issued.
 
   plot_line_count = 0;
 
   return retval;
 }
 
 DEFALIAS (clg, clearplot);
 
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -120,18 +120,18 @@ sigchld_handler (int i)
 // Handle SIGINT by restarting the parser (see octave.cc).
 
 // XXX FIXME XXX -- it would probably be good to try to use POSIX
 // signal interface if it is available.
 
 static RETSIGTYPE
 sigint_handler (int i)
 {
-// Can this ever cause trouble on systems that don't forget signal
-// handlers when they are invoked?
+  // Can this ever cause trouble on systems that don't forget signal
+  // handlers when they are invoked?
 
   signal (SIGINT, sigint_handler);
 
   if (can_interrupt)
     {
       jump_to_top_level ();
       panic_impossible ();
     }
@@ -141,25 +141,26 @@ sigint_handler (int i)
 #else
   return 0;
 #endif
 }
 
 static RETSIGTYPE
 sigpipe_handler (int i)
 {
-// Can this ever cause trouble on systems that don't forget signal
-// handlers when they are invoked?
+  // Can this ever cause trouble on systems that don't forget signal
+  // handlers when they are invoked?
 
   signal (SIGPIPE, sigpipe_handler);
 
   if (pipe_handler_error_count++ == 0)
     message (0, "broken pipe");
 
-// Don\'t loop forever on account of this.
+  // Don't loop forever on account of this.
+
   if (pipe_handler_error_count  > 100)
     jump_to_top_level ();
 
 #if RETSIGTYPE == void
   return;
 #else
   return 0;
 #endif
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -80,17 +80,17 @@ DEFUN ("toascii", Ftoascii, Stoascii, 1,
 
       if (arg.is_string ())
 	{
 	  Octave_str_obj str = args(0).all_strings ();
 
 	  int nr = str.num_strings ();
 	  int nc = str.max_length ();
 
-// XXX FIXME XXX -- should fill with user-specified value.
+	  // XXX FIXME XXX -- should fill with user-specified value.
 
 	  Matrix m (nr, nc, 0);
 
 	  for (int i = 0; i < nr; i++)
 	    {
 	      nc = str.elem (i).length ();
 	      for (int j = 0; j < nc; j++)
 		m (i, j) = toascii (str.elem (i) [j]);
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -398,17 +398,18 @@ symbol_record::define (tree_constant *t)
     {
       saved_def = definition->def ();
     }
 
   definition->define (t);
 
   if (sv_fcn && sv_fcn () < 0)
     {
-// Would be nice to be able to avoid this cast.  XXX FIXME XXX
+      // Would be nice to be able to avoid this cast.  XXX FIXME XXX
+
       definition->define ((tree_constant *) saved_def);
       return 0;
     }
 
   delete saved_def;
 
   return 1;
 }
@@ -682,17 +683,18 @@ symbol_record_info::symbol_record_info (
 symbol_record_info::symbol_record_info (const symbol_record& sr)
 {
   init_state ();
 
   type = sr.type ();
 
   if (sr.is_variable () && sr.is_defined ())
     {
-// Would be nice to avoid this cast.  XXX FIXME XXX
+      // Would be nice to avoid this cast.  XXX FIXME XXX
+
       tree_constant *tmp = (tree_constant *) sr.def ();
       if (tmp->is_real_scalar ())
 	const_type = SR_INFO_SCALAR;
       else if (tmp->is_complex_scalar ())
 	const_type = SR_INFO_COMPLEX_SCALAR;
       else if (tmp->is_real_matrix ())
 	const_type = SR_INFO_MATRIX;
       else if (tmp->is_complex_matrix ())
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -186,18 +186,18 @@ octave_ieee_init (void)
   extern unsigned int DQNAN[2];
   octave_NaN = (*((double *) (DQNAN)));
 #else
   octave_NaN = octave_Inf / octave_Inf;
 #endif
 
 #else
 
-// This is sort of cheesy, but what can we do, other than blowing it
-// off completely, or writing an entire IEEE emulation package?
+  // This is sort of cheesy, but what can we do, other than blowing it
+  // off completely, or writing an entire IEEE emulation package?
 
   octave_Inf = DBL_MAX;
   octave_NaN = DBL_MAX;
 
 #endif
 
   float_params fp[5];
 
@@ -254,44 +254,44 @@ octave_ieee_init (void)
 }
 
 #if defined (EXCEPTION_IN_MATH)
 extern "C"
 {
 int
 matherr (struct exception *x)
 {
-// Possibly print our own message someday.  Should probably be
-// user-switchable.
+  // Possibly print our own message someday.  Should probably be
+  // user-switchable.
 
   switch (x->type)
     {
     case DOMAIN:
     case SING:
     case OVERFLOW:
     case UNDERFLOW:
     case TLOSS:
     case PLOSS:
     default:
       break;
     }
 
-// But don't print the system message.
+  // But don't print the system message.
 
   return 1;
 }
 }
 #endif
 
 void
 sysdep_init (void)
 {
 #if defined (__386BSD__) || defined (__FreeBSD__)
 #if defined (HAVE_FLOATINGPOINT_H)
-// Disable trapping on common exceptions.
+  // Disable trapping on common exceptions.
   fpsetmask (~(FP_X_OFL|FP_X_INV|FP_X_DZ|FP_X_DNML|FP_X_UFL|FP_X_IMP));
 #endif
 #endif
 
 #ifdef NeXT
   NeXT_init ();
 #endif
 
@@ -328,28 +328,28 @@ raw_mode (int on)
 
 #if defined (HAVE_TERMIOS_H)
   {
     struct termios s;
     static struct termios save_term;
 
     if (on)
       {
-// Get terminal modes.
+	// Get terminal modes.
 
 	tcgetattr (tty_fd, &s);
 
-// Save modes and set certain variables dependent on modes.
+	// Save modes and set certain variables dependent on modes.
 
 	save_term = s;
 //	ospeed = s.c_cflag & CBAUD;
 //	erase_char = s.c_cc[VERASE];
 //	kill_char = s.c_cc[VKILL];
 
-// Set the modes to the way we want them.
+	// Set the modes to the way we want them.
 
 	s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
 	s.c_oflag |=  (OPOST|ONLCR);
 #if defined (OCRNL)
 	s.c_oflag &= ~(OCRNL);
 #endif
 #if defined (ONOCR)
 	s.c_oflag &= ~(ONOCR);
@@ -357,40 +357,41 @@ raw_mode (int on)
 #if defined (ONLRET)
 	s.c_oflag &= ~(ONLRET);
 #endif
 	s.c_cc[VMIN] = 1;
 	s.c_cc[VTIME] = 0;
       }      
     else
       {
-// Restore saved modes.
+	// Restore saved modes.
+
 	s = save_term;
       }
     tcsetattr (tty_fd, TCSAFLUSH, &s);
   }
 #elif defined (HAVE_TERMIO_H)
   {
     struct termio s;
     static struct termio save_term;
 
     if (on)
       {
-// Get terminal modes.
+	// Get terminal modes.
 
 	ioctl (tty_fd, TCGETA, &s);
 
-// Save modes and set certain variables dependent on modes.
+	// Save modes and set certain variables dependent on modes.
 
 	save_term = s;
 //	ospeed = s.c_cflag & CBAUD;
 //	erase_char = s.c_cc[VERASE];
 //	kill_char = s.c_cc[VKILL];
 
-// Set the modes to the way we want them.
+	// Set the modes to the way we want them.
 
 	s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
 	s.c_oflag |=  (OPOST|ONLCR);
 #if defined (OCRNL)
 	s.c_oflag &= ~(OCRNL);
 #endif
 #if defined (ONOCR)
 	s.c_oflag &= ~(ONOCR);
@@ -398,47 +399,49 @@ raw_mode (int on)
 #if defined (ONLRET)
 	s.c_oflag &= ~(ONLRET);
 #endif
 	s.c_cc[VMIN] = 1;
 	s.c_cc[VTIME] = 0;
       }      
     else
       {
-// Restore saved modes.
+	// Restore saved modes.
+
 	s = save_term;
       }
     ioctl (tty_fd, TCSETAW, &s);
   }
 #elif defined (HAVE_SGTTY_H)
   {
     struct sgttyb s;
     static struct sgttyb save_term;
 
     if (on)
       {
-// Get terminal modes.
+	// Get terminal modes.
 
 	ioctl (tty_fd, TIOCGETP, &s);
 
-// Save modes and set certain variables dependent on modes.
+	// Save modes and set certain variables dependent on modes.
 
 	save_term = s;
 //	ospeed = s.sg_ospeed;
 //	erase_char = s.sg_erase;
 //	kill_char = s.sg_kill;
 
-// Set the modes to the way we want them.
+	// Set the modes to the way we want them.
 
 	s.sg_flags |= CBREAK;
 	s.sg_flags &= ~(ECHO);
       } 
     else
       {
-// Restore saved modes.
+	// Restore saved modes.
+
 	s = save_term;
       }
     ioctl (tty_fd, TIOCSETN, &s);
   }
 #else
 LOSE! LOSE!
 #endif
 
@@ -539,17 +542,17 @@ DEFUN ("getenv", Fgetenv, Sgetenv, 1, 1,
   return retval;
 }
 
 DEFUN ("kbhit", Fkbhit, Skbhit, 0, 1,
   "kbhit: get a single character from the terminal")
 {
   Octave_object retval;
 
-// XXX FIXME XXX -- add timeout and default value args?
+  // XXX FIXME XXX -- add timeout and default value args?
 
   if (interactive)
     {
       int c = kbhit ();
       char *s = new char [2];
       s[0] = c;
       s[1] = '\0';
       retval = s;
diff --git a/src/tc-rep.cc b/src/tc-rep.cc
--- a/src/tc-rep.cc
+++ b/src/tc-rep.cc
@@ -1203,18 +1203,19 @@ TC_REP::convert_to_str (void) const
 
 	if (xisnan (d))
 	  {
 	    ::error ("invalid conversion from NaN to character");
 	    return retval;
 	  }
 	else
 	  {
+	    // XXX FIXME XXX -- warn about out of range conversions?
+
 	    int i = NINT (d);
-// Warn about out of range conversions?
 	    char s[2];
 	    s[0] = (char) i;
 	    s[1] = '\0';
 	    retval = tree_constant (s);
 	  }
       }
       break;
 
@@ -1246,18 +1247,20 @@ TC_REP::convert_to_str (void) const
 		    if (xisnan (d))
 		      {
 			::error ("invalid conversion from NaN to character");
 			delete [] s;
 			return retval;
 		      }
 		    else
 		      {
+			// XXX FIXME XXX -- warn about out of range
+			// conversions?
+
 			int ival = NINT (d);
-// Warn about out of range conversions?
 			s[i] = (char) ival;
 		      }
 		  }
 		retval = tree_constant (s);
 		delete [] s;
 	      }
 	  }
       }
@@ -1278,18 +1281,20 @@ TC_REP::convert_to_str (void) const
 	    if (xisnan (d))
 	      {
 		::error ("invalid conversion from NaN to character");
 		delete [] s;
 		return retval;
 	      }
 	    else
 	      {
+		// XXX FIXME XXX --  warn about out of range
+		// conversions?
+
 		int ival = NINT (d);
-// Warn about out of range conversions?
 		s[i] = (char) ival;
 	      }
 	  }
 	retval = tree_constant (s);
 	delete [] s;
       }
       break;
 
@@ -1610,21 +1615,23 @@ TC_REP::maybe_resize (int i, force_orien
 {
   int nr = rows ();
   int nc = columns ();
 
   i++;
 
   assert (i >= 0 && (nr <= 1 || nc <= 1));
 
-// This function never reduces the size of a vector, and all vectors
-// have dimensions of at least 0x0.  If i is 0, it is either because
-// a vector has been indexed with a vector of all zeros (in which case
-// the index vector is empty and nothing will happen) or a vector has
-// been indexed with 0 (an error which will be caught elsewhere).
+  // This function never reduces the size of a vector, and all vectors
+  // have dimensions of at least 0x0.  If i is 0, it is either because
+  // a vector has been indexed with a vector of all zeros (in which
+  // case the index vector is empty and nothing will happen) or a
+  // vector has been indexed with 0 (an error which will be caught
+  // elsewhere).
+
   if (i == 0)
     return;
 
   if (nr <= 1 && nc <= 1 && i >= 1)
     {
       if (user_pref.resize_on_range_error)
 	{
 	  if (f_orient == row_orient)
@@ -1688,17 +1695,17 @@ TC_REP::maybe_mutate (void)
 	  type_tag = matrix_constant;
 	}
       break;
 
     default:
       break;
     }
 
-// Avoid calling rows() and columns() for things like magic_colon.
+  // Avoid calling rows() and columns() for things like magic_colon.
 
   int nr = 1;
   int nc = 1;
   if (type_tag == matrix_constant
       || type_tag == complex_matrix_constant
       || type_tag == range_constant)
     {
       nr = rows ();
@@ -1771,19 +1778,20 @@ TC_REP::print (ostream& output_buf)
       break;
 
     case range_constant:
       octave_print_internal (output_buf, *range);
       break;
 
     case map_constant:
       {
-// XXX FIXME XXX -- would be nice to print the output in some standard
-// order.  Maybe all substructures first, maybe alphabetize entries,
-// etc.
+	// XXX FIXME XXX -- would be nice to print the output in some
+	// standard order.  Maybe all substructures first, maybe
+	// alphabetize entries, etc.
+
 	begin_unwind_frame ("TC_REP_print");
 
 	unwind_protect_int (structure_indent_level);
 	unwind_protect_int (user_pref.struct_levels_to_print);
 
 	if (user_pref.struct_levels_to_print-- > 0)
 	  {
 	    output_buf << "{\n";
@@ -1839,19 +1847,19 @@ TC_REP::print_code (ostream& os)
       octave_print_internal (os, *matrix, 1);
       break;
 
     case complex_scalar_constant:
      {
 	double re = complex_scalar->real ();
 	double im = complex_scalar->imag ();
 
-// If we have the original text and a pure imaginary, just print the
-// original text, because this must be a constant that was parsed as
-// part of a function.
+	// If we have the original text and a pure imaginary, just
+	// print the original text, because this must be a constant
+	// that was parsed as part of a function.
 
 	if (orig_text && re == 0.0 && im > 0.0)
 	  os << orig_text;
 	else
 	  octave_print_internal (os, *complex_scalar, 1);
       }
       break;
 
diff --git a/src/user-prefs.cc b/src/user-prefs.cc
--- a/src/user-prefs.cc
+++ b/src/user-prefs.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "error.h"
 #include "mappers.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
 // The list of user preferences.  Values change when global variables
-// change, so we don\'t have to do a variable look up every time we
+// change, so we don't have to do a variable look up every time we
 // need to check a preference.
 user_preferences user_pref;
 
 // Initialize global user_pref structure.
 
 void
 init_user_prefs (void)
 {
@@ -205,17 +205,17 @@ implicit_str_to_num_ok (void)
   user_pref.implicit_str_to_num_ok =
     check_str_pref ("implicit_str_to_num_ok");
 
   return 0;
 }
 
 
 // Should we allow silent conversion of complex to real when a real
-// type is what we\'re really looking for?
+// type is what we're really looking for?
 
 int
 ok_to_lose_imaginary_part (void)
 {
   user_pref.ok_to_lose_imaginary_part =
     check_str_pref ("ok_to_lose_imaginary_part");
 
   return 0;
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -397,19 +397,20 @@ get_fcn_file_names (int& num, const char
 		  else
 		    retval[i][len-4] = '\0';
 		}
 
 	      i++;
 
 	      if (i == num_max - 1)
 		{
-// Reallocate the array.  Only copy pointers, not the strings they
-// point to, then only delete the original array of pointers, and not
-// the strings they point to.
+		  // Reallocate the array.  Only copy pointers, not
+		  // the strings they point to, then only delete the
+		  // original array of pointers, and not the strings
+		  // they point to.
 
 		  num_max += 256;
 		  char **tmp = new char * [num_max];
 		  for (int j = 0; j < i; j++)
 		    tmp[j] = retval[j];
 
 		  delete [] retval;
 
@@ -446,19 +447,20 @@ get_fcn_file_names (int& num, int no_suf
 
 	  if (elt_dir)
 	    {
 	      int tmp_num;
 	      char **names = get_fcn_file_names (tmp_num, elt_dir, no_suffix);
 
 	      if (i + tmp_num >= num_max - 1)
 		{
-// Reallocate the array.  Only copy pointers, not the strings they
-// point to, then only delete the original array of pointers, and not
-// the strings they point to.
+		  // Reallocate the array.  Only copy pointers, not
+		  // the strings they point to, then only delete the
+		  // original array of pointers, and not the strings
+		  // they point to.
 
 		  num_max += 1024;
 		  char **tmp = new char * [num_max];
 		  for (int j = 0; j < i; j++)
 		    tmp[j] = retval[j];
 
 		  delete [] retval;
 
@@ -563,57 +565,57 @@ empty_arg (const char *name, int nr, int
 }
 
 // Format a list in neat columns.  Mostly stolen from GNU ls.  This
 // should maybe be in utils.cc.
 
 ostrstream&
 list_in_columns (ostrstream& os, char **list)
 {
-// Compute the maximum name length.
+  // Compute the maximum name length.
 
   int max_name_length = 0;
   int total_names = 0;
   char **names = 0;
   for (names = list; *names; names++)
     {
       total_names++;
       int name_length = strlen (*names);
       if (name_length > max_name_length)
 	max_name_length = name_length;
     }
 
-// Allow at least two spaces between names.
+  // Allow at least two spaces between names.
 
   max_name_length += 2;
 
-// Calculate the maximum number of columns that will fit.
+  // Calculate the maximum number of columns that will fit.
 
   int line_length = terminal_columns ();
   int cols = line_length / max_name_length;
   if (cols == 0)
     cols = 1;
 
-// Calculate the number of rows that will be in each column except
-// possibly  for a short column on the right.
+  // Calculate the number of rows that will be in each column except
+  // possibly  for a short column on the right.
 
   int rows = total_names / cols + (total_names % cols != 0);
 
-// Recalculate columns based on rows.
+  // Recalculate columns based on rows.
 
   cols = total_names / rows + (total_names % rows != 0);
 
   names = list;
   int count;
   for (int row = 0; row < rows; row++)
     {
       count = row;
       int pos = 0;
 
-// Print the next row.
+      // Print the next row.
 
       while (1)
 	{
 	  os << *(names + count);
 	  int name_length = strlen (*(names + count));
 
 	  count += rows;
 	  if (count >= total_names)
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -638,17 +638,17 @@ static int
 parse_fcn_file (int exec_script, char *ff)
 {
   begin_unwind_frame ("parse_fcn_file");
 
   int script_file_executed = 0;
 
   assert (ff);
 
-// Open function file and parse.
+  // Open function file and parse.
 
   int old_reading_fcn_file_state = reading_fcn_file;
 
   unwind_protect_ptr (rl_instream);
   unwind_protect_ptr (ff_instream);
 
   unwind_protect_int (using_readline);
   unwind_protect_int (input_line_number);
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -181,18 +181,20 @@ xpow (const Matrix& a, double b)
       int btmp = (int) b;
       if (btmp == 0)
 	{
 	  DiagMatrix result (nr, nr, 1.0);
 	  retval = tree_constant (result);
 	}
       else
 	{
-// Too much copying?
-// XXX FIXME XXX -- we shouldn\'t do this if the exponent is large...
+	  // Too much copying?
+	  // XXX FIXME XXX -- we shouldn't do this if the exponent is
+	  // large...
+
 	  Matrix atmp;
 	  if (btmp < 0)
 	    {
 	      btmp = -btmp;
 	      atmp = a.inverse ();
 	    }
 	  else
 	    atmp = a;
@@ -357,18 +359,20 @@ xpow (const ComplexMatrix& a, double b)
       int btmp = (int) b;
       if (btmp == 0)
 	{
 	  DiagMatrix result (nr, nr, 1.0);
 	  retval = tree_constant (result);
 	}
       else
 	{
-// Too much copying?
-// XXX FIXME XXX -- we shouldn\'t do this if the exponent is large...
+	  // Too much copying?
+	  // XXX FIXME XXX -- we shouldn't do this if the exponent is
+	  // large...
+
 	  ComplexMatrix atmp;
 	  if (btmp < 0)
 	    {
 	      btmp = -btmp;
 	      atmp = a.inverse ();
 	    }
 	  else
 	    atmp = a;
@@ -444,17 +448,18 @@ xpow (const ComplexMatrix& a, const Comp
 tree_constant
 elem_xpow (double a, const Matrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
-// For now, assume the worst.
+  // For now, assume the worst.
+
   if (a < 0.0)
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  result.elem (i, j) = pow (atmp, b.elem (i, j));
 
