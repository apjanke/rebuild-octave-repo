# HG changeset patch
# User jwe
# Date 754690984 0
#      Tue Nov 30 20:23:04 1993 +0000
# Node ID 780cbbc57b7c315dc020729445e51846e9e87f11
# Parent  5a9e23307fb08f3dbbc2d59ff2b332582eb9c380
[project @ 1993-11-30 20:23:04 by jwe]

diff --git a/libcruft/misc/lo-error.cc b/libcruft/misc/lo-error.cc
--- a/libcruft/misc/lo-error.cc
+++ b/libcruft/misc/lo-error.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 
 #include "lo-error.h"
 
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -16,174 +16,253 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-// Written by John C. Campbell <jcc@che.utexas.edu>.
-
 #if !defined (_Array_h)
 #define _Array_h 1
 
-#include <iostream.h>
-#include <assert.h>
+#if defined (__GNUG__) && defined (USE_EXTERNAL_TEMPLATES)
+#pragma interface
+#endif
+
+// Classes we declare.
 
-template <class T> class Array;  
+template <class T> class ArrayRep;
+template <class T> class Array;
+template <class T> class Array2;
+template <class T> class Array3;
+template <class T> class DiagArray;
+
+/*
+ * The real representation of all arrays.
+ */
 
 template <class T>
 class ArrayRep
 {
+// Rethink resize()?
   friend class Array<T>;
+  friend class Array2<T>;
+  friend class Array3<T>;
+  friend class DiagArray<T>;
+
+protected:
+
+  ArrayRep (T *d, int l);
 
 public:
 
-  ArrayRep  (void);
-  ArrayRep  (int);
-  ArrayRep  (const ArrayRep<T>& a);
+  ArrayRep (void);
+  ArrayRep (int n);
+  ArrayRep (const ArrayRep<T>& a);
 
   ~ArrayRep (void);
-  
+
   int length (void) const;
-  
+
   T& elem (int n);
-  T& checkelem (int n);
-  T& operator () (int n);
-  
+
   T elem (int n) const;
-  T checkelem (int n) const;
-  T operator () (int n) const;
-  
+
+  void resize (int n);
+
 private:
-  
+
   T *data;
   int len;
   int count;
 };
 
+/*
+ * One dimensional array class.  Handles the reference counting for
+ * all the derived classes.
+ */
+
 template <class T>
 class Array
 {
+protected:
+
+  ArrayRep<T> *rep;
+
+  Array (T *d, int l);
+
 public:
-  
+
   Array (void);
-  Array (int);
-  Array (int n, T val);
+  Array (int n);
+  Array (int n, const T& val);
+
   Array (const Array<T>& a);
 
   ~Array (void);
 
   Array<T>& operator = (const Array<T>& a);
-  
+
+  int capacity (void) const;
   int length (void) const;
 
   T& elem (int n);
   T& checkelem (int n);
   T& operator () (int n);
 
+// No checking.
+  T& xelem (int n);
+
   T elem (int n) const;
   T checkelem (int n) const;
   T operator () (int n) const;
 
-protected:
+  void resize (int n);
+  void resize (int n, const T& val);
+
+  const T *data (void) const;
 
-  ArrayRep<T> *rep;
+  T *fortran_vec (void);
 };
 
+/*
+ * Two dimensional array class.
+ */
+
 template <class T>
 class Array2 : public Array<T>
 {
+protected:
+
+  int d1;
+  int d2;
+
+  Array2 (T *d, int n, int m);
+
 public:
 
   Array2 (void);
   Array2 (int n, int m);
-  Array2 (int n, int m, T val);
+  Array2 (int n, int m, const T& val);
   Array2 (const Array2<T>& a);
+  Array2 (const DiagArray<T>& a);
 
   Array2<T>& operator = (const Array2<T>& a);
 
   int dim1 (void) const;
   int dim2 (void) const;
- 
+
+  int rows (void) const;
+  int cols (void) const;
+  int columns (void) const;
+
   T& elem (int i, int j);
-  T& checkelem (int i, int j); 
+  T& checkelem (int i, int j);
   T& operator () (int i, int j);
-  
+
+// No checking.
+  T& xelem (int i, int j);
+
   T elem (int i, int j) const;
   T checkelem (int i, int j) const;
   T operator () (int i, int j) const;
 
-protected:
-  
-  int d1;
-  int d2;
+  void resize (int n, int m);
+  void resize (int n, int m, const T& val);
 };
 
+/*
+ * Three dimensional array class.
+ */
+
 template <class T>
 class Array3 : public Array2<T>
 {
+protected:
+
+  int d3;
+
+  Array3 (T *d, int n, int m, int k);
+
 public:
 
   Array3 (void);
   Array3 (int n, int m, int k);
-  Array3 (int n, int m, int k, T val);
+  Array3 (int n, int m, int k, const T& val);
   Array3 (const Array3<T>& a);
 
   Array3<T>& operator = (const Array3<T>& a);
 
   int dim3 (void) const;
 
   T& elem (int i, int j, int k);
-  T& checkelem (int i, int j, int k); 
-  T& operator()(int i,int j,int k);
-  
+  T& checkelem (int i, int j, int k);
+  T& operator () (int i, int j, int k);
+
+// No checking.
+  T& xelem (int i, int j, int k);
+
   T elem (int i, int j, int k) const;
-  T checkelem(int i,int j,int k)const;
-  T operator()(int i,int j,int k) const;
+  T checkelem (int i, int j, int k) const;
+  T operator () (int i, int j, int k) const;
 
-protected:
-  
-  int d3;
+  void resize (int n, int m, int k);
+  void resize (int n, int m, int k, const T& val);
 };
 
+/*
+ * A two-dimensional array with diagonal elements only.
+ */
+
 template <class T>
 class DiagArray : public Array<T>
 {
+protected:
+
+  int nr;
+  int nc;
+
+  DiagArray (T *d, int r, int c);
+
 public:
-  
+
   DiagArray (void);
-  DiagArray (int n): Array<T> (n) {}
+  DiagArray (int n);
+  DiagArray (int n, const T& val);
   DiagArray (int r, int c);
-  DiagArray (int r, int c, T val);
+  DiagArray (int r, int c, const T& val);
   DiagArray (const Array<T>& a);
   DiagArray (const DiagArray<T>& a);
 
   DiagArray<T>& operator = (const DiagArray<T>& a);
 
+  int dim1 (void) const;
+  int dim2 (void) const;
+
   int rows (void) const;
   int cols (void) const;
   int columns (void) const;
 
   T& elem (int r, int c);
   T& checkelem (int r, int c);
   T& operator () (int r, int c);
 
+// No checking.
+  T& xelem (int r, int c);
+
   T elem (int r, int c) const;
   T checkelem (int r, int c) const;
   T operator () (int r, int c) const;
 
-protected:
-
-  int nr;
-  int nc;
+  void resize (int n, int m);
+  void resize (int n, int m, const T& val);
 };
 
-#ifdef __GNUG__
+#if defined (__GNUG__) && ! defined (USE_EXTERNAL_TEMPLATES)
 #include "Array.cc"
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/Bounds.cc b/liboctave/Bounds.cc
--- a/liboctave/Bounds.cc
+++ b/liboctave/Bounds.cc
@@ -16,21 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
+
 #include "Bounds.h"
 #include "lo-error.h"
 
 // error handling
 
 void
 Bounds::error (const char* msg)
 {
diff --git a/liboctave/Bounds.h b/liboctave/Bounds.h
--- a/liboctave/Bounds.h
+++ b/liboctave/Bounds.h
@@ -19,21 +19,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_Bounds_h)
 #define _Bounds_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
+class ostream;
 
-#include <iostream.h>
 #include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class Bounds
 {
diff --git a/liboctave/ColVector.cc b/liboctave/ColVector.cc
--- a/liboctave/ColVector.cc
+++ b/liboctave/ColVector.cc
@@ -16,27 +16,26 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-// I\'m not sure how this is supposed to work if the .h file declares
-// several classes, each of which is defined in a separate file...
-//
-// #ifdef __GNUG__
-// #pragma implementation "Matrix.h"
-// #endif
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <iostream.h>
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
+#include "f77-uscore.h"
 #include "lo-error.h"
-#include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   int F77_FCN (dgemm) (const char*, const char*, const int*,
 		       const int*, const int*, const double*,
 		       const double*, const int*, const double*,
@@ -64,121 +63,17 @@ extern "C"
 		       const int*, const Complex*, Complex*, const int*,
 		       long, long);
 }
 
 /*
  * Column Vector class.
  */
 
-ColumnVector::ColumnVector (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create column vector with negative dimension");
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  len = n;
-  if (n > 0)
-    data = new double [len];
-  else
-    data = (double *) NULL;
-}
-
-ColumnVector::ColumnVector (int n, double val)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create column vector with negative dimension");
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  len = n;
-  if (n > 0)
-    {
-      data = new double [len];
-      copy (data, len, val);
-    }
-  else
-    data = (double *) NULL;
-}
-
-ColumnVector::ColumnVector (const ColumnVector& a)
-{
-  len = a.len;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (double *) NULL;
-}
-
-ColumnVector::ColumnVector (double a)
-{
-  len = 1;
-  data = new double [1];
-  data[0] = a;
-}
-
-ColumnVector&
-ColumnVector::operator = (const ColumnVector& a)
-{
-  if (this != &a)
-    {
-      delete [] data;
-      len = a.len;
-      if (len > 0)
-	{
-	  data = new double [len];
-	  copy (data, a.data, len);
-	}
-      else
-	data = (double *) NULL;
-    }
-  return *this;
-}
-
-double&
-ColumnVector::checkelem (int n)
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static double foo = 0.0;
-      return foo;
-    }
-#endif
-
-  return elem (n);
-}
-
-double
-ColumnVector::checkelem (int n) const
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return 0.0;
-    }
-#endif
-
-  return elem (n);
-}
-
+#if 0
 ColumnVector&
 ColumnVector::resize (int n)
 {
   if (n < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return *this;
@@ -206,613 +101,391 @@ ColumnVector::resize (int n, double val)
 {
   int old_len = len;
   resize (n);
   for (int i = old_len; i < len; i++)
     data[i] = val;
 
   return *this;
 }
+#endif
 
 int
 ColumnVector::operator == (const ColumnVector& a) const
 {
-  if (len != a.len)
+  int len = length ();
+  if (len != a.length ())
     return 0;
-  return equal (data, a.data, len);
+  return equal (data (), a.data (), len);
 }
 
 int
 ColumnVector::operator != (const ColumnVector& a) const
 {
-  if (len != a.len)
-    return 1;
-  return !equal (data, a.data, len);
+  return !(*this == a);
 }
 
 ColumnVector&
 ColumnVector::insert (const ColumnVector& a, int r)
 {
-  if (r < 0 || r + a.len - 1 > len)
+  int a_len = a.length ();
+  if (r < 0 || r + a_len - 1 > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    data[r+i] = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r+i) = a.elem (i);
 
   return *this;
 }
 
 ColumnVector&
 ColumnVector::fill (double val)
 {
+  int len = length ();
   if (len > 0)
-    copy (data, len, val);
+    for (int i = 0; i < len; i++)
+      elem (i) = val;
   return *this;
 }
 
 ColumnVector&
 ColumnVector::fill (double val, int r1, int r2)
 {
+  int len = length ();
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   for (int i = r1; i <= r2; i++)
-    data[i] = val;
+    elem (i) = val;
 
   return *this;
 }
 
 ColumnVector
 ColumnVector::stack (const ColumnVector& a) const
 {
+  int len = length ();
   int nr_insert = len;
-  ColumnVector retval (len + a.len);
+  ColumnVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 RowVector
 ColumnVector::transpose (void) const
 {
-  return RowVector (dup (data, len), len);
+  int len = length ();
+  return RowVector (dup (data (), len), len);
 }
 
 // resize is the destructive equivalent for this one
 
 ColumnVector
 ColumnVector::extract (int r1, int r2) const
 {
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   int new_r = r2 - r1 + 1;
 
   ColumnVector result (new_r);
 
   for (int i = 0; i < new_r; i++)
-    result.data[i] = elem (r1+i);
+    result.elem (i) = elem (r1+i);
 
   return result;
 }
 
-// column vector by scalar -> column vector operations
+// column vector by column vector -> column vector operations
 
-ColumnVector
-ColumnVector::operator + (double s) const
+ColumnVector&
+ColumnVector::operator += (const ColumnVector& a)
 {
-  return ColumnVector (add (data, len, s), len);
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return ColumnVector ();
+    }
+
+  if (len == 0)
+    return *this;
+
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), len);
+  return *this;
 }
 
-ColumnVector
-ColumnVector::operator - (double s) const
+ColumnVector&
+ColumnVector::operator -= (const ColumnVector& a)
 {
-  return ColumnVector (subtract (data, len, s), len);
-}
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return ColumnVector ();
+    }
 
-ColumnVector
-ColumnVector::operator * (double s) const
-{
-  return ColumnVector (multiply (data, len, s), len);
-}
+  if (len == 0)
+    return *this;
 
-ColumnVector
-ColumnVector::operator / (double s) const
-{
-  return ColumnVector (divide (data, len, s), len);
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), len);
+  return *this;
 }
 
 // scalar by column vector -> column vector operations
 
-ColumnVector
-operator + (double s, const ColumnVector& a)
+ComplexColumnVector
+operator + (const ColumnVector& a, const Complex& s)
 {
-  return ColumnVector (add (a.data, a.len, s), a.len);
+  int len = a.length ();
+  return ComplexColumnVector (add (a.data (), len, s), len);
 }
 
-ColumnVector
-operator - (double s, const ColumnVector& a)
+ComplexColumnVector
+operator - (const ColumnVector& a, const Complex& s)
 {
-  return ColumnVector (subtract (s, a.data, a.len), a.len);
+  int len = a.length ();
+  return ComplexColumnVector (subtract (a.data (), len, s), len);
 }
 
-ColumnVector
-operator * (double s, const ColumnVector& a)
+ComplexColumnVector
+operator * (const ColumnVector& a, const Complex& s)
 {
-  return ColumnVector (multiply (a.data, a.len, s), a.len);
-}
-
-ColumnVector
-operator / (double s, const ColumnVector& a)
-{
-  return ColumnVector (divide (s, a.data, a.len), a.len);
+  int len = a.length ();
+  return ComplexColumnVector (multiply (a.data (), len, s), len);
 }
 
 ComplexColumnVector
-ColumnVector::operator + (const Complex& s) const
+operator / (const ColumnVector& a, const Complex& s)
 {
-  return ComplexColumnVector (add (data, len, s), len);
+  int len = a.length ();
+  return ComplexColumnVector (divide (a.data (), len, s), len);
+}
+
+// scalar by column vector -> column vector operations
+
+ComplexColumnVector
+operator + (const Complex& s, const ColumnVector& a)
+{
+  int a_len = a.length ();
+  return ComplexColumnVector (add (a.data (), a_len, s), a_len);
 }
 
 ComplexColumnVector
-ColumnVector::operator - (const Complex& s) const
+operator - (const Complex& s, const ColumnVector& a)
 {
-  return ComplexColumnVector (subtract (data, len, s), len);
+  int a_len = a.length ();
+  return ComplexColumnVector (subtract (s, a.data (), a_len), a_len);
 }
 
 ComplexColumnVector
-ColumnVector::operator * (const Complex& s) const
+operator * (const Complex& s, const ColumnVector& a)
 {
-  return ComplexColumnVector (multiply (data, len, s), len);
+  int a_len = a.length ();
+  return ComplexColumnVector (multiply (a.data (), a_len, s), a_len);
 }
 
 ComplexColumnVector
-ColumnVector::operator / (const Complex& s) const
+operator / (const Complex& s, const ColumnVector& a)
 {
-  return ComplexColumnVector (divide (data, len, s), len);
+  int a_len = a.length ();
+  return ComplexColumnVector (divide (s, a.data (), a_len), a_len);
 }
 
 // column vector by row vector -> matrix operations
 
 Matrix
-ColumnVector::operator * (const RowVector& a) const
+operator * (const ColumnVector& v, const RowVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  int a_len = a.length ();
+  if (len != a_len)
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return Matrix ();
     }
 
   if (len == 0)
     return Matrix (len, len, 0.0);
 
   char transa = 'N';
   char transb = 'N';
   double alpha = 1.0;
   double beta  = 0.0;
   int anr = 1;
-  int anc = a.len;
 
-  double *c = new double [len * a.len];
+  double *c = new double [len * a_len];
 
-  F77_FCN (dgemm) (&transa, &transb, &len, &anc, &anr, &alpha, data,
-		   &len, a.data, &anr, &beta, c, &len, 1L, 1L);
+  F77_FCN (dgemm) (&transa, &transb, &len, &a_len, &anr, &alpha,
+		   v.data (), &len, a.data (), &anr, &beta, c, &len,
+		   1L, 1L); 
 
-  return Matrix (c, len, a.len);
+  return Matrix (c, len, a_len);
 }
 
 ComplexMatrix
-ColumnVector::operator * (const ComplexRowVector& a) const
+operator * (const ColumnVector& v, const ComplexRowVector& a)
 {
-  ComplexColumnVector tmp (*this);
+  ComplexColumnVector tmp (v);
   return tmp * a;
 }
 
-// column vector by column vector -> column vector operations
-
-ColumnVector
-ColumnVector::operator + (const ColumnVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
-      return ColumnVector ();
-    }
-
-  if (len == 0)
-    return ColumnVector (0);
-
-  return ColumnVector (add (data, a.data, len), len);
-}
-
-ColumnVector
-ColumnVector::operator - (const ColumnVector& a) const
+ComplexColumnVector
+operator + (const ColumnVector& v, const ComplexColumnVector& a)
 {
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
-      return ColumnVector ();
-    }
-
-  if (len == 0)
-    return ColumnVector (0);
-
-  return ColumnVector (subtract (data, a.data, len), len);
-}
-
-ComplexColumnVector
-ColumnVector::operator + (const ComplexColumnVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (len == 0)
-    return ComplexColumnVector (0);
-
-  return ComplexColumnVector (add (data, a.data, len), len);
-}
-
-ComplexColumnVector
-ColumnVector::operator - (const ComplexColumnVector& a) const
-{
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector subtraction attempted");
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
-  return ComplexColumnVector (subtract (data, a.data, len), len);
+  return ComplexColumnVector (add (v.data (), a.data (), len), len);
 }
 
-ColumnVector
-ColumnVector::product (const ColumnVector& a) const
+ComplexColumnVector
+operator - (const ColumnVector& v, const ComplexColumnVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
-      return ColumnVector ();
+	("nonconformant vector subtraction attempted");
+      return ComplexColumnVector ();
     }
 
   if (len == 0)
-    return ColumnVector (0);
-
-  return ColumnVector (multiply (data, a.data, len), len);
-}
+    return ComplexColumnVector (0);
 
-ColumnVector
-ColumnVector::quotient (const ColumnVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
-      return ColumnVector ();
-    }
-
-  if (len == 0)
-    return ColumnVector (0);
-
-  return ColumnVector (divide (data, a.data, len), len);
+  return ComplexColumnVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
-ColumnVector::product (const ComplexColumnVector& a) const
+product (const ColumnVector& v, const ComplexColumnVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector product attempted");
       return ColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
-  return ComplexColumnVector (multiply (data, a.data, len), len);
+  return ComplexColumnVector (multiply (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
-ColumnVector::quotient (const ComplexColumnVector& a) const
+quotient (const ColumnVector& v, const ComplexColumnVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector quotient attempted");
       return ColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
-  return ComplexColumnVector (divide (data, a.data, len), len);
-}
-
-ColumnVector&
-ColumnVector::operator += (const ColumnVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
-      return ColumnVector ();
-    }
-
-  if (len == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
+  return ComplexColumnVector (divide (v.data (), a.data (), len), len);
 }
 
-ColumnVector&
-ColumnVector::operator -= (const ColumnVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
-      return ColumnVector ();
-    }
-
-  if (len == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
-}
-
-// unary operations
-
-ColumnVector
-ColumnVector::operator - (void) const
-{
-  if (len == 0)
-    return ColumnVector (0);
-
-  return ColumnVector (negate (data, len), len);
-}
+// other operations
 
 ColumnVector
 map (d_d_Mapper f, const ColumnVector& a)
 {
   ColumnVector b (a);
   b.map (f);
   return b;
 }
 
 void
 ColumnVector::map (d_d_Mapper f)
 {
-  for (int i = 0; i < len; i++)
-    data[i] = f (data[i]);
+  for (int i = 0; i < length (); i++)
+    elem (i) = f (elem (i));
 }
 
 double
 ColumnVector::min (void) const
 {
+  int len = length ();
   if (len == 0)
     return 0.0;
 
-  double res = data[0];
+  double res = elem (0);
 
   for (int i = 1; i < len; i++)
-    if (data[i] < res)
-      res = data[i];
+    if (elem (i) < res)
+      res = elem (i);
 
   return res;
 }
 
 double
 ColumnVector::max (void) const
 {
+  int len = length ();
   if (len == 0)
     return 0.0;
 
-  double res = data[0];
+  double res = elem (0);
 
   for (int i = 1; i < len; i++)
-    if (data[i] > res)
-      res = data[i];
+    if (elem (i) > res)
+      res = elem (i);
 
   return res;
 }
 
 ostream&
 operator << (ostream& os, const ColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.len; i++)
-    os << /* setw (field_width) << */ a.data[i] << "\n";
+  for (int i = 0; i < a.length (); i++)
+    os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 /*
  * Complex Column Vector class
  */
 
-ComplexColumnVector::ComplexColumnVector (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create column vector with negative dimension");
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  len = n;
-  if (n > 0)
-    data = new Complex [len];
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexColumnVector::ComplexColumnVector (int n, double val)
+ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
+   : Array<Complex> (a.length ())
 {
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create column vector with negative dimension");
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  len = n;
-  if (n > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexColumnVector::ComplexColumnVector (int n, const Complex& val)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create column vector with negative dimension");
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  len = n;
-  if (n > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
-{
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
+  for (int i = 0; i < length (); i++)
+    elem (i) = a.elem (i);
 }
 
-ComplexColumnVector::ComplexColumnVector (const ComplexColumnVector& a)
-{
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexColumnVector::ComplexColumnVector (double a)
-{
-  len = 1;
-  data = new Complex [1];
-  data[0] = a;
-}
-
-ComplexColumnVector::ComplexColumnVector (const Complex& a)
-{
-  len = 1;
-  data = new Complex [1];
-  data[0] = Complex (a);
-}
-
-ComplexColumnVector&
-ComplexColumnVector::operator = (const ColumnVector& a)
-{
-  delete [] data;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-
-  return *this;
-}
-
-ComplexColumnVector&
-ComplexColumnVector::operator = (const ComplexColumnVector& a)
-{
-  if (this != &a)
-    {
-      delete [] data;
-      len = a.len;
-      if (len > 0)
-	{
-	  data = new Complex [len];
-	  copy (data, a.data, len);
-	}
-      else
-	data = (Complex *) NULL;
-    }
-  return *this;
-}
-
-Complex&
-ComplexColumnVector::checkelem (int n)
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static Complex foo (0.0);
-      return foo;
-    }
-#endif
-
-  return elem (n);
-}
-
-Complex
-ComplexColumnVector::checkelem (int n) const
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return Complex (0.0);
-    }
-#endif
-
-  return elem (n);
-}
-
+#if 0
 ComplexColumnVector&
 ComplexColumnVector::resize (int n)
 {
   if (n < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return *this;
@@ -851,607 +524,526 @@ ComplexColumnVector::resize (int n, cons
 {
   int old_len = len;
   resize (n);
   for (int i = old_len; i < len; i++)
     data[i] = val;
 
   return *this;
 }
+#endif
 
 int
 ComplexColumnVector::operator == (const ComplexColumnVector& a) const
 {
-  if (len != a.len)
+  int len = length ();
+  if (len != a.length ())
     return 0;
-  return equal (data, a.data, len);
+  return equal (data (), a.data (), len);
 }
 
 int
 ComplexColumnVector::operator != (const ComplexColumnVector& a) const
 {
-  if (len != a.len)
-    return 0;
-  return !equal (data, a.data, len);
+  return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ColumnVector& a, int r)
 {
-  if (r < 0 || r + a.len - 1 > len)
+  int a_len = a.length ();
+  if (r < 0 || r + a_len - 1 > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    data[r+i] = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ComplexColumnVector& a, int r)
 {
-  if (r < 0 || r + a.len - 1 > len)
+  int a_len = a.length ();
+  if (r < 0 || r + a_len - 1 > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    data[r+i] = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val)
 {
+  int len = length ();
   if (len > 0)
-    copy (data, len, val);
+    for (int i = 0; i < len; i++)
+      elem (i) = val;
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val)
 {
+  int len = length ();
   if (len > 0)
-    copy (data, len, val);
+    for (int i = 0; i < len; i++)
+      elem (i) = val;
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val, int r1, int r2)
 {
+  int len = length ();
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   for (int i = r1; i <= r2; i++)
-    data[i] = val;
+    elem (i) = val;
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val, int r1, int r2)
 {
+  int len = length ();
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   for (int i = r1; i <= r2; i++)
-    data[i] = val;
+    elem (i) = val;
 
   return *this;
 }
 
 ComplexColumnVector
 ComplexColumnVector::stack (const ColumnVector& a) const
 {
+  int len = length ();
   int nr_insert = len;
-  ComplexColumnVector retval (len + a.len);
+  ComplexColumnVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 ComplexColumnVector
 ComplexColumnVector::stack (const ComplexColumnVector& a) const
 {
+  int len = length ();
   int nr_insert = len;
-  ComplexColumnVector retval (len + a.len);
+  ComplexColumnVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 ComplexRowVector
 ComplexColumnVector::hermitian (void) const
 {
-  return ComplexRowVector (conj_dup (data, len), len);
+  int len = length ();
+  return ComplexRowVector (conj_dup (data (), len), len);
 }
 
 ComplexRowVector
 ComplexColumnVector::transpose (void) const
 {
-  return ComplexRowVector (dup (data, len), len);
+  int len = length ();
+  return ComplexRowVector (dup (data (), len), len);
 }
 
 ColumnVector
 real (const ComplexColumnVector& a)
 {
+  int a_len = a.length ();
   ColumnVector retval;
-  if (a.len > 0)
-    retval = ColumnVector (real_dup (a.data, a.len), a.len);
+  if (a_len > 0)
+    retval = ColumnVector (real_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 ColumnVector
 imag (const ComplexColumnVector& a)
 {
+  int a_len = a.length ();
   ColumnVector retval;
-  if (a.len > 0)
-    retval = ColumnVector (imag_dup (a.data, a.len), a.len);
+  if (a_len > 0)
+    retval = ColumnVector (imag_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 ComplexColumnVector
 conj (const ComplexColumnVector& a)
 {
+  int a_len = a.length ();
   ComplexColumnVector retval;
-  if (a.len > 0)
-    retval = ComplexColumnVector (conj_dup (a.data, a.len), a.len);
+  if (a_len > 0)
+    retval = ComplexColumnVector (conj_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexColumnVector
 ComplexColumnVector::extract (int r1, int r2) const
 {
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   int new_r = r2 - r1 + 1;
 
   ComplexColumnVector result (new_r);
 
   for (int i = 0; i < new_r; i++)
-    result.data[i] = elem (r1+i);
+    result.elem (i) = elem (r1+i);
 
   return result;
 }
 
+// column vector by column vector -> column vector operations
+
+ComplexColumnVector&
+ComplexColumnVector::operator += (const ColumnVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), len);
+  return *this;
+}
+
+ComplexColumnVector&
+ComplexColumnVector::operator -= (const ColumnVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), len);
+  return *this;
+}
+
+ComplexColumnVector&
+ComplexColumnVector::operator += (const ComplexColumnVector& a)
+{
+  int len = length ();
+
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), len);
+  return *this;
+}
+
+ComplexColumnVector&
+ComplexColumnVector::operator -= (const ComplexColumnVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), len);
+  return *this;
+}
+
 // column vector by scalar -> column vector operations
 
 ComplexColumnVector
-ComplexColumnVector::operator + (double s) const
-{
-  return ComplexColumnVector (add (data, len, s), len);
-}
-
-ComplexColumnVector
-ComplexColumnVector::operator - (double s) const
+operator + (const ComplexColumnVector& v, double s)
 {
-  return ComplexColumnVector (subtract (data, len, s), len);
-}
-
-ComplexColumnVector
-ComplexColumnVector::operator * (double s) const
-{
-  return ComplexColumnVector (multiply (data, len, s), len);
+  int len = v.length ();
+  return ComplexColumnVector (add (v.data (), len, s), len);
 }
 
 ComplexColumnVector
-ComplexColumnVector::operator / (double s) const
+operator - (const ComplexColumnVector& v, double s)
 {
-  return ComplexColumnVector (divide (data, len, s), len);
-}
-
-ComplexColumnVector
-ComplexColumnVector::operator + (const Complex& s) const
-{
-  return ComplexColumnVector (add (data, len, s), len);
+  int len = v.length ();
+  return ComplexColumnVector (subtract (v.data (), len, s), len);
 }
 
 ComplexColumnVector
-ComplexColumnVector::operator - (const Complex& s) const
+operator * (const ComplexColumnVector& v, double s)
 {
-  return ComplexColumnVector (subtract (data, len, s), len);
+  int len = v.length ();
+  return ComplexColumnVector (multiply (v.data (), len, s), len);
 }
 
 ComplexColumnVector
-ComplexColumnVector::operator * (const Complex& s) const
+operator / (const ComplexColumnVector& v, double s)
 {
-  return ComplexColumnVector (multiply (data, len, s), len);
-}
-
-ComplexColumnVector
-ComplexColumnVector::operator / (const Complex& s) const
-{
-  return ComplexColumnVector (divide (data, len, s), len);
+  int len = v.length ();
+  return ComplexColumnVector (divide (v.data (), len, s), len);
 }
 
 // scalar by column vector -> column vector operations
 
 ComplexColumnVector
 operator + (double s, const ComplexColumnVector& a)
 {
-  return ComplexColumnVector (add (a.data, a.len, s), a.len);
+  int a_len = a.length ();
+  return ComplexColumnVector (add (a.data (), a_len, s), a_len);
 }
 
 ComplexColumnVector
 operator - (double s, const ComplexColumnVector& a)
 {
-  return ComplexColumnVector (subtract (s, a.data, a.len), a.len);
+  int a_len = a.length ();
+  return ComplexColumnVector (subtract (s, a.data (), a_len), a_len);
 }
 
 ComplexColumnVector
 operator * (double s, const ComplexColumnVector& a)
 {
-  return ComplexColumnVector (multiply (a.data, a.len, s), a.len);
+  int a_len = a.length ();
+  return ComplexColumnVector (multiply (a.data (), a_len, s), a_len);
 }
 
 ComplexColumnVector
 operator / (double s, const ComplexColumnVector& a)
 {
-  return ComplexColumnVector (divide (s, a.data, a.len), a.len);
-}
-
-ComplexColumnVector
-operator + (const Complex& s, const ComplexColumnVector& a)
-{
-  return ComplexColumnVector (add (a.data, a.len, s), a.len);
-}
-
-ComplexColumnVector
-operator - (const Complex& s, const ComplexColumnVector& a)
-{
-  return ComplexColumnVector (subtract (s, a.data, a.len), a.len);
-}
-
-ComplexColumnVector
-operator * (const Complex& s, const ComplexColumnVector& a)
-{
-  return ComplexColumnVector (multiply (a.data, a.len, s), a.len);
-}
-
-ComplexColumnVector
-operator / (const Complex& s, const ComplexColumnVector& a)
-{
-  return ComplexColumnVector (divide (s, a.data, a.len), a.len);
+  int a_len = a.length ();
+  return ComplexColumnVector (divide (s, a.data (), a_len), a_len);
 }
 
 // column vector by row vector -> matrix operations
 
 ComplexMatrix
-ComplexColumnVector::operator * (const RowVector& a) const
+operator * (const ComplexColumnVector& v, const ComplexRowVector& a)
 {
-  ComplexRowVector tmp (a);
-  return *this * tmp;
-}
-
-ComplexMatrix
-ComplexColumnVector::operator * (const ComplexRowVector& a) const
-{
-  if (len != a.len)
+  int len = v.length ();
+  int a_len = a.length ();
+  if (len != a_len)
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return ComplexMatrix ();
     }
 
   if (len == 0)
     return ComplexMatrix (len, len, 0.0);
 
   char transa = 'N';
   char transb = 'N';
   Complex alpha (1.0);
   Complex beta (0.0);
   int anr = 1;
-  int anc = a.len;
 
-  Complex *c = new Complex [len * a.len];
+  Complex *c = new Complex [len * a_len];
 
-  F77_FCN (zgemm) (&transa, &transb, &len, &anc, &anr, &alpha, data,
-		   &len, a.data, &anr, &beta, c, &len, 1L, 1L);
+  F77_FCN (zgemm) (&transa, &transb, &len, &a_len, &anr, &alpha,
+		   v.data (), &len, a.data (), &anr, &beta, c, &len,
+		   1L, 1L);
 
-  return ComplexMatrix (c, len, a.len);
+  return ComplexMatrix (c, len, a_len);
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector
-ComplexColumnVector::operator + (const ColumnVector& a) const
+operator + (const ComplexColumnVector& v, const ColumnVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector addition attempted");
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
-  return ComplexColumnVector (add (data, a.data, len), len);
+  return ComplexColumnVector (add (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
-ComplexColumnVector::operator - (const ColumnVector& a) const
+operator - (const ComplexColumnVector& v, const ColumnVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector subtraction attempted");
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
-  return ComplexColumnVector (subtract (data, a.data, len), len);
-}
-
-ComplexColumnVector
-ComplexColumnVector::operator + (const ComplexColumnVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (len == 0)
-    return ComplexColumnVector (0);
-
-  return ComplexColumnVector (add (data, a.data, len), len);
+  return ComplexColumnVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
-ComplexColumnVector::operator - (const ComplexColumnVector& a) const
+product (const ComplexColumnVector& v, const ColumnVector& a)
 {
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (len == 0)
-    return ComplexColumnVector (0);
-
-  return ComplexColumnVector (subtract (data, a.data, len), len);
-}
-
-ComplexColumnVector
-ComplexColumnVector::product (const ColumnVector& a) const
-{
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector product attempted");
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
-  return ComplexColumnVector (multiply (data, a.data, len), len);
+  return ComplexColumnVector (multiply (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
-ComplexColumnVector::quotient (const ColumnVector& a) const
+quotient (const ComplexColumnVector& v, const ColumnVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector quotient attempted");
       return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
-  return ComplexColumnVector (divide (data, a.data, len), len);
-}
-
-ComplexColumnVector
-ComplexColumnVector::product (const ComplexColumnVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (len == 0)
-    return ComplexColumnVector (0);
-
-  return ComplexColumnVector (multiply (data, a.data, len), len);
-}
-
-ComplexColumnVector
-ComplexColumnVector::quotient (const ComplexColumnVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (len == 0)
-    return ComplexColumnVector (0);
-
-  return ComplexColumnVector (divide (data, a.data, len), len);
-}
-
-ComplexColumnVector&
-ComplexColumnVector::operator += (const ColumnVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
+  return ComplexColumnVector (divide (v.data (), a.data (), len), len);
 }
 
-ComplexColumnVector&
-ComplexColumnVector::operator -= (const ColumnVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
-}
-
-ComplexColumnVector&
-ComplexColumnVector::operator += (const ComplexColumnVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-ComplexColumnVector&
-ComplexColumnVector::operator -= (const ComplexColumnVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
-}
-
-// unary operations
-
-ComplexColumnVector
-ComplexColumnVector::operator - (void) const
-{
-  if (len == 0)
-    return ComplexColumnVector (0);
-
-  return ComplexColumnVector (negate (data, len), len);
-}
+// other operations
 
 ComplexColumnVector
 map (c_c_Mapper f, const ComplexColumnVector& a)
 {
   ComplexColumnVector b (a);
   b.map (f);
   return b;
 }
 
 ColumnVector
 map (d_c_Mapper f, const ComplexColumnVector& a)
 {
-  ColumnVector b (a.len);
-  for (int i = 0; i < a.len; i++)
+  int a_len = a.length ();
+  ColumnVector b (a_len);
+  for (int i = 0; i < a_len; i++)
     b.elem (i) = f (a.elem (i));
   return b;
 }
 
 void
 ComplexColumnVector::map (c_c_Mapper f)
 {
-  for (int i = 0; i < len; i++)
-    data[i] = f (data[i]);
+  for (int i = 0; i < length (); i++)
+    elem (i) = f (elem (i));
 }
 
 Complex
 ComplexColumnVector::min (void) const
 {
+  int len = length ();
   if (len == 0)
     return 0.0;
 
-  Complex res = data[0];
+  Complex res = elem (0);
   double absres = abs (res);
 
   for (int i = 1; i < len; i++)
-    if (abs (data[i]) < absres)
+    if (abs (elem (i)) < absres)
       {
-	res = data[i];
+	res = elem (i);
 	absres = abs (res);
       }
 
   return res;
 }
 
 Complex
 ComplexColumnVector::max (void) const
 {
+  int len = length ();
   if (len == 0)
     return 0.0;
 
-  Complex res = data[0];
+  Complex res = elem (0);
   double absres = abs (res);
 
   for (int i = 1; i < len; i++)
-    if (abs (data[i]) > absres)
+    if (abs (elem (i)) > absres)
       {
-	res = data[i];
+	res = elem (i);
 	absres = abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 ostream&
 operator << (ostream& os, const ComplexColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.len; i++)
-    os << /* setw (field_width) << */ a.data[i] << "\n";
+  for (int i = 0; i < a.length (); i++)
+    os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -16,21 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
+
 #include "CollocWt.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (jcobi) (int*, int*, int*, int*, double*, double*,
 		       double*, double*, double*, double*); 
diff --git a/liboctave/CollocWt.h b/liboctave/CollocWt.h
--- a/liboctave/CollocWt.h
+++ b/liboctave/CollocWt.h
@@ -19,21 +19,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_CollocWt_h)
 #define _CollocWt_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
+class ostream;
 
-#include <iostream.h>
 #include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class CollocWt
 {
diff --git a/liboctave/DAE.h b/liboctave/DAE.h
--- a/liboctave/DAE.h
+++ b/liboctave/DAE.h
@@ -19,25 +19,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_DAE_h)
 #define _DAE_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
-#include <iostream.h>
 #include "ODE.h"
 #include "DAEFunc.h"
 #include "Matrix.h"
-#include "f77-uscore.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class DAE : public ODE, public DAEFunc
 {
 public:
diff --git a/liboctave/DAEFunc.cc b/liboctave/DAEFunc.cc
--- a/liboctave/DAEFunc.cc
+++ b/liboctave/DAEFunc.cc
@@ -16,21 +16,20 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include "DAEFunc.h"
 
 DAEFunc::DAEFunc (void)
 {
   fun = NULL;
   jac = NULL;
 }
 
diff --git a/liboctave/DAEFunc.h b/liboctave/DAEFunc.h
--- a/liboctave/DAEFunc.h
+++ b/liboctave/DAEFunc.h
@@ -19,21 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_DAEFunc_h)
 #define _DAEFunc_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
-#include <iostream.h>
 #include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 #ifndef _DAEFunc_typedefs
 #define _DAEFunc_typedefs 1
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -16,22 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include "DAE.h"
+#include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (ddassl) (int (*)(), const int*, double*, double*,
 			double*, double*, const int*, const double*,
 			const double*, int*, double*, const int*, 
 			int*, const int*, const double*, const int*,
@@ -227,17 +227,17 @@ ddassl_j (double *time, double *state, d
   DAEJac tmp_jac;
   tmp_jac.dfdxdot = &tmp_dfdxdot;
   tmp_jac.dfdx    = &tmp_dfdx;
 
   tmp_jac = user_jac (tmp_state, tmp_deriv, *time);
 
   // Fix up the matrix of partial derivatives for dassl.
 
-  tmp_dfdx = tmp_dfdx + (*cj * tmp_dfdxdot);
+  tmp_dfdx = tmp_dfdx + (tmp_dfdxdot * (*cj));
 
   for (int j = 0; j < nn; j++)
     for (int i = 0; i < nn; i++)
       pd [nn * j + i] = tmp_dfdx.elem (i, j);
 
   return 0;
 }
 
diff --git a/liboctave/DiagMatrix.cc b/liboctave/DiagMatrix.cc
--- a/liboctave/DiagMatrix.cc
+++ b/liboctave/DiagMatrix.cc
@@ -16,225 +16,31 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-// I\'m not sure how this is supposed to work if the .h file declares
-// several classes, each of which is defined in a separate file...
-//
-// #ifdef __GNUG__
-// #pragma implementation "Matrix.h"
-// #endif
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <iostream.h>
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 
 /*
  * Diagonal Matrix class.
  */
 
-DiagMatrix::DiagMatrix (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  nr = n;
-  nc = n;
-  len = n;
-  if (len > 0)
-    data = new double [len];
-  else
-    data = (double *) NULL;
-}
-
-DiagMatrix::DiagMatrix (int n, double val)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  nr = n;
-  nc = n;
-  len = n;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, len, val);
-    }
-  else
-    data = (double *) NULL;
-}
-
-DiagMatrix::DiagMatrix (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = r < c ? r : c;
-  if (len > 0)
-    data = new double [len];
-  else
-    data = (double *) NULL;
-}
-
-DiagMatrix::DiagMatrix (int r, int c, double val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = r < c ? r : c;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, len, val);
-    }
-  else
-    data = (double *) NULL;
-}
-
-DiagMatrix::DiagMatrix (const RowVector& a)
-{
-  nr = a.len;
-  nc = nr;
-  len = nr;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (double *) NULL;
-}
-
-DiagMatrix::DiagMatrix (const ColumnVector& a)
-{
-  nr = a.len;
-  nc = nr;
-  len = nr;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (double *) NULL;
-}
-
-DiagMatrix::DiagMatrix (const DiagMatrix& a)
-{
-  nr = a.nr;
-  nc = a.nc;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (double *) NULL;
-}
-
-DiagMatrix::DiagMatrix (double a)
-{
-  nr = 1;
-  nc = 1;
-  len = 1;
-  data = new double [1];
-  data[0] = a;
-}
-
-DiagMatrix&
-DiagMatrix::operator = (const DiagMatrix& a)
-{
-  if (this != &a)
-    {
-      delete [] data;
-      nr = a.nr;
-      nc = a.nc;
-      len = a.len;
-      if (len > 0)
-	{
-	  data = new double [len];
-	  copy (data, a.data, len);
-	}
-      else
-	data = (double *) NULL;
-    }
-  return *this;
-}
-
-double&
-DiagMatrix::checkelem (int r, int c)
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static double foo = 0.0;
-      return foo;
-    }
-#endif
-
-  return elem (r, c);
-}
-
-double
-DiagMatrix::checkelem (int r, int c) const
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return 0.0;
-    }
-#endif
-
-  return elem (r, c);
-}
-
+#if 0
 DiagMatrix&
 DiagMatrix::resize (int r, int c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimensions");
       return *this;
@@ -289,146 +95,160 @@ DiagMatrix::resize (int r, int c, double
   delete [] data;
   nr = r;
   nc = c;
   len = new_len;
   data = new_data;
 
   return *this;
 }
+#endif
 
 int
 DiagMatrix::operator == (const DiagMatrix& a) const
 {
-  if (nr != a.nr || nc != a.nc)
+  if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
-  return equal (data, a.data, len);
+  return equal (data (), a.data (), length ());
 }
 
 int
 DiagMatrix::operator != (const DiagMatrix& a) const
 {
-  if (nr != a.nr || nc != a.nc)
-    return 1;
-
-  return !equal (data, a.data, len);
+  return !(*this == a);
 }
 
 DiagMatrix&
 DiagMatrix::fill (double val)
 {
-  copy (data, len, val);
+  for (int i = 0; i < length (); i++)
+    elem (i, i) = val;
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (double val, int beg, int end)
 {
-  if (beg < 0 || end >= len || end < beg)
+  if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (end > beg)
-    copy (data+beg, beg-end, val);
+  for (int i = beg; i < end; i++)
+    elem (i, i) = val;
+
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a)
 {
-  if (a.len != len)
+  int len = length ();
+  if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data, a.data, len);
+  for (int i = 0; i < len; i++)
+    elem (i, i) = a.elem (i);
+
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a)
 {
-  if (a.len != len)
+  int len = length ();
+  if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data, a.data, len);
+  for (int i = 0; i < len; i++)
+    elem (i, i) = a.elem (i);
+
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a, int beg)
 {
-  if (beg < 0 || beg + a.len >= len)
+  int a_len = a.length ();
+  if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data+beg, a.data, a.len);
+  for (int i = 0; i < a_len; i++)
+    elem (i+beg, i+beg) = a.elem (i);
+
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a, int beg)
 {
-  if (beg < 0 || beg + a.len >= len)
+  int a_len = a.length ();
+  if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data+beg, a.data, a.len);
+  for (int i = 0; i < a_len; i++)
+    elem (i+beg, i+beg) = a.elem (i);
+
   return *this;
 }
 
 DiagMatrix
 DiagMatrix::transpose (void) const
 {
-  return DiagMatrix (dup (data, len), nc, nr);
+  return DiagMatrix (dup (data (), length ()), cols (), rows ());
 }
 
 Matrix
 DiagMatrix::extract (int r1, int c1, int r2, int c2) const
 {
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   int new_r = r2 - r1 + 1;
   int new_c = c2 - c1 + 1;
 
   Matrix result (new_r, new_c);
 
   for (int j = 0; j < new_c; j++)
     for (int i = 0; i < new_r; i++)
-      result.data[new_r*j+i] = elem (r1+i, c1+j);
+      result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // extract row or column i.
 
 RowVector
 DiagMatrix::row (int i) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (i < 0 || i >= nr)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 
   RowVector retval (nc, 0.0);
   if (nr <= nc || (nr > nc && i < nc))
-    retval.data [i] = data[i];
+    retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 RowVector
 DiagMatrix::row (char *s) const
 {
   if (s == (char *) NULL)
@@ -436,36 +256,38 @@ DiagMatrix::row (char *s) const
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (0);
   else if (c == 'l' || c == 'L')
-    return row (nr - 1);
+    return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 }
 
 ColumnVector
 DiagMatrix::column (int i) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (i < 0 || i >= nc)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 
   ColumnVector retval (nr, 0.0);
   if (nr >= nc || (nr < nc && i < nr))
-    retval.data [i] = data[i];
+    retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ColumnVector
 DiagMatrix::column (char *s) const
 {
   if (s == (char *) NULL)
@@ -473,579 +295,506 @@ DiagMatrix::column (char *s) const
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
-    return column (nc - 1);
+    return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 }
 
 DiagMatrix
-DiagMatrix::inverse (int &info) const
-{
-  if (nr != nc)
-    {
-      (*current_liboctave_error_handler) ("inverse requires square matrix");
-      return DiagMatrix ();
-    }
-
-  info = 0;
-  double *tmp_data = dup (data, len);
-  for (int i = 0; i < len; i++)
-    {
-      if (data[i] == 0.0)
-	{
-	  info = -1;
-	  copy (tmp_data, data, len); // Restore contents.
-	  break;
-	}
-      else
-	{
-	  tmp_data[i] = 1.0 / data[i];
-	}
-    }
-
-  return DiagMatrix (tmp_data, nr, nc);
-}
-
-DiagMatrix
 DiagMatrix::inverse (void) const
 {
   int info;
   return inverse (info);
 }
 
+DiagMatrix
+DiagMatrix::inverse (int &info) const
+{
+  int nr = rows ();
+  int nc = cols ();
+  int len = length ();
+  if (nr != nc)
+    {
+      (*current_liboctave_error_handler) ("inverse requires square matrix");
+      return DiagMatrix ();
+    }
+
+  info = 0;
+  double *tmp_data = dup (data (), len);
+  for (int i = 0; i < len; i++)
+    {
+      if (elem (i, i) == 0.0)
+	{
+	  info = -1;
+	  copy (tmp_data, data (), len); // Restore contents.
+	  break;
+	}
+      else
+	{
+	  tmp_data[i] = 1.0 / elem (i, i);
+	}
+    }
+
+  return DiagMatrix (tmp_data, nr, nc);
+}
+
+// diagonal matrix by diagonal matrix -> diagonal matrix operations
+
+DiagMatrix&
+DiagMatrix::operator += (const DiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
+
+  if (nc == 0 || nr == 0)
+    return *this;
+
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), length ());
+  return *this;
+}
+
+DiagMatrix&
+DiagMatrix::operator -= (const DiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), length ());
+  return *this;
+}
+
 // diagonal matrix by scalar -> matrix operations
 
 Matrix
-DiagMatrix::operator + (double s) const
+operator + (const DiagMatrix& a, double s)
 {
-  Matrix tmp (nr, nc, s);
-  return *this + tmp;
+  Matrix tmp (a.rows (), a.cols (), s);
+  return a + tmp;
 }
 
 Matrix
-DiagMatrix::operator - (double s) const
+operator - (const DiagMatrix& a, double s)
 {
-  Matrix tmp (nr, nc, -s);
-  return *this + tmp;
+  Matrix tmp (a.rows (), a.cols (), -s);
+  return a + tmp;
 }
 
 ComplexMatrix
-DiagMatrix::operator + (const Complex& s) const
+operator + (const DiagMatrix& a, const Complex& s)
 {
-  ComplexMatrix tmp (nr, nc, s);
-  return *this + tmp;
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return a + tmp;
 }
 
 ComplexMatrix
-DiagMatrix::operator - (const Complex& s) const
+operator - (const DiagMatrix& a, const Complex& s)
 {
-  ComplexMatrix tmp (nr, nc, -s);
-  return *this + tmp;
+  ComplexMatrix tmp (a.rows (), a.cols (), -s);
+  return a + tmp;
 }
 
 // diagonal matrix by scalar -> diagonal matrix operations
 
-DiagMatrix
-DiagMatrix::operator * (double s) const
+ComplexDiagMatrix
+operator * (const DiagMatrix& a, const Complex& s)
 {
-  return DiagMatrix (multiply (data, len, s), nr, nc);
-}
-
-DiagMatrix
-DiagMatrix::operator / (double s) const
-{
-  return DiagMatrix (divide (data, len, s), nr, nc);
+  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
 ComplexDiagMatrix
-DiagMatrix::operator * (const Complex& s) const
+operator / (const DiagMatrix& a, const Complex& s)
 {
-  return ComplexDiagMatrix (multiply (data, len, s), nr, nc);
-}
-
-ComplexDiagMatrix
-DiagMatrix::operator / (const Complex& s) const
-{
-  return ComplexDiagMatrix (divide (data, len, s), nr, nc);
+  return ComplexDiagMatrix (divide (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
 // scalar by diagonal matrix -> matrix operations
 
 Matrix
 operator + (double s, const DiagMatrix& a)
 {
-  return a + s;
+  Matrix tmp (a.rows (), a.cols (), s);
+  return tmp + a;
 }
 
 Matrix
 operator - (double s, const DiagMatrix& a)
 {
-  return -a + s;
+  Matrix tmp (a.rows (), a.cols (), s);
+  return tmp - a;
+}
+
+ComplexMatrix
+operator + (const Complex& s, const DiagMatrix& a)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp + a;
+}
+
+ComplexMatrix
+operator - (const Complex& s, const DiagMatrix& a)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp - a;
 }
 
 // scalar by diagonal matrix -> diagonal matrix operations
 
-DiagMatrix
-operator * (double s, const DiagMatrix& a)
+ComplexDiagMatrix
+operator * (const Complex& s, const DiagMatrix& a)
 {
-  return DiagMatrix (multiply (a.data, a.len, s), a.nr, a.nc);
-}
-
-DiagMatrix
-operator / (double s, const DiagMatrix& a)
-{
-  return DiagMatrix (divide (s, a.data, a.len), a.nr, a.nc);
+  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 ColumnVector
-DiagMatrix::operator * (const ColumnVector& a) const
+operator * (const DiagMatrix& m, const ColumnVector& a)
 {
-  if (nc != a.len)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_len = a.length ();
+  if (nc != a_len)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ColumnVector (0);
 
   ColumnVector result (nr);
 
-  for (int i = 0; i < a.len; i++)
-    result.data[i] = a.data[i] * data[i];
+  for (int i = 0; i < a_len; i++)
+    result.elem (i) = a.elem (i) * m.elem (i, i);
 
-  for (i = a.len; i < nr; i++)
-    result.data[i] = 0.0;
+  for (i = a_len; i < nr; i++)
+    result.elem (i) = 0.0;
 
   return result;
 }
 
 ComplexColumnVector
-DiagMatrix::operator * (const ComplexColumnVector& a) const
+operator * (const DiagMatrix& m, const ComplexColumnVector& a)
 {
-  if (nc != a.len)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_len = a.length ();
+  if (nc != a_len)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
-  for (int i = 0; i < a.len; i++)
-    result.data[i] = a.data[i] * data[i];
+  for (int i = 0; i < a_len; i++)
+    result.elem (i) = a.elem (i) * m.elem (i, i);
 
-  for (i = a.len; i < nr; i++)
-    result.data[i] = 0.0;
+  for (i = a_len; i < nr; i++)
+    result.elem (i) = 0.0;
 
   return result;
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
-DiagMatrix
-DiagMatrix::operator + (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return DiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return DiagMatrix (nr, nc);
-
-  return DiagMatrix (add (data, a.data, len), nr , nc);
-}
-
-DiagMatrix
-DiagMatrix::operator - (const DiagMatrix& a) const
+ComplexDiagMatrix
+operator + (const DiagMatrix& m, const ComplexDiagMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return DiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return DiagMatrix (nr, nc);
-
-  return DiagMatrix (subtract (data, a.data, len), nr, nc);
-}
-
-DiagMatrix
-DiagMatrix::operator * (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return DiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return DiagMatrix (nr, nc);
-
-  return DiagMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-DiagMatrix::operator + (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexDiagMatrix ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
-  return ComplexDiagMatrix (add (data, a.data, len), nr , nc);
+  return ComplexDiagMatrix (add (m.data (), a.data (), m.length ()),  nr, nc);
 }
 
 ComplexDiagMatrix
-DiagMatrix::operator - (const ComplexDiagMatrix& a) const
+operator - (const DiagMatrix& m, const ComplexDiagMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexDiagMatrix ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
-  return ComplexDiagMatrix (subtract (data, a.data, len), nr, nc);
+  return ComplexDiagMatrix (subtract (m.data (), a.data (), m.length ()),
+			    nr, nc);
 }
 
 ComplexDiagMatrix
-DiagMatrix::operator * (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-DiagMatrix
-DiagMatrix::product (const DiagMatrix& a) const
+product (const DiagMatrix& m, const ComplexDiagMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix product attempted");
-      return DiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return DiagMatrix (nr, nc);
-
-  return DiagMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-DiagMatrix
-DiagMatrix::quotient (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix quotient attempted");
-      return DiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return DiagMatrix (nr, nc);
-
-  return DiagMatrix (divide (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-DiagMatrix::product (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix product attempted");
       return ComplexDiagMatrix ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
-  return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-DiagMatrix::quotient (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix quotient attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (divide (data, a.data, len), nr, nc);
-}
-
-DiagMatrix&
-DiagMatrix::operator += (const DiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return *this;
-    }
-
-  if (nc == 0 || nr == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-DiagMatrix&
-DiagMatrix::operator -= (const DiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-
-  subtract2 (data, a.data, len);
-  return *this;
+  return ComplexDiagMatrix (multiply (m.data (), a.data (), m.length ()),
+			    nr, nc);
 }
 
 // diagonal matrix by matrix -> matrix operations
 
 Matrix
-DiagMatrix::operator + (const Matrix& a) const
+operator + (const DiagMatrix& m, const Matrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return Matrix ();
     }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   Matrix result (a);
-  for (int i = 0; i < len; i++)
-    result.elem (i, i) += data[i];
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
 Matrix
-DiagMatrix::operator - (const Matrix& a) const
+operator - (const DiagMatrix& m, const Matrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return Matrix ();
     }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   Matrix result (-a);
-  for (int i = 0; i < len; i++)
-    result.elem (i, i) += data[i];
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
 Matrix
-DiagMatrix::operator * (const Matrix& a) const
+operator * (const DiagMatrix& m, const Matrix& a)
 {
-  if (nc != a.nr)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return Matrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
-    return Matrix (nr, a.nc, 0.0);
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return Matrix (nr, a_nc, 0.0);
 
-  Matrix c (nr, a.nc);
+  Matrix c (nr, a_nc);
 
-  for (int i = 0; i < len; i++)
+  for (int i = 0; i < m.length (); i++)
     {
-      if (data[i] == 1.0)
+      if (m.elem (i, i) == 1.0)
 	{
-	  for (int j = 0; j < a.nc; j++)
+	  for (int j = 0; j < a_nc; j++)
 	    c.elem (i, j) = a.elem (i, j);
 	}
-      else if (data[i] == 0.0)
+      else if (m.elem (i, i) == 0.0)
 	{
-	  for (int j = 0; j < a.nc; j++)
+	  for (int j = 0; j < a_nc; j++)
 	    c.elem (i, j) = 0.0;
 	}
       else
 	{
-	  for (int j = 0; j < a.nc; j++)
-	    c.elem (i, j) = data[i] * a.elem (i, j);
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
 	}
     }
 
   if (nr > nc)
     {
-      for (int j = 0; j < a.nc; j++)
-	for (int i = a.nr; i < nr; i++)
+      for (int j = 0; j < a_nc; j++)
+	for (int i = a_nr; i < nr; i++)
 	  c.elem (i, j) = 0.0;
     }
 
   return c;
 }
 
 ComplexMatrix
-DiagMatrix::operator + (const ComplexMatrix& a) const
+operator + (const DiagMatrix& m, const ComplexMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (a);
-  for (int i = 0; i < len; i++)
-    result.elem (i, i) += data[i];
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-DiagMatrix::operator - (const ComplexMatrix& a) const
+operator - (const DiagMatrix& m, const ComplexMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (-a);
-  for (int i = 0; i < len; i++)
-    result.elem (i, i) += data[i];
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-DiagMatrix::operator * (const ComplexMatrix& a) const
+operator * (const DiagMatrix& m, const ComplexMatrix& a)
 {
-  if (nc != a.nr)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexMatrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
+  if (nr == 0 || nc == 0 || a_nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
-  ComplexMatrix c (nr, a.nc);
+  ComplexMatrix c (nr, a_nc);
 
-  for (int i = 0; i < len; i++)
+  for (int i = 0; i < m.length (); i++)
     {
-      if (data[i] == 1.0)
+      if (m.elem (i, i) == 1.0)
 	{
-	  for (int j = 0; j < a.nc; j++)
+	  for (int j = 0; j < a_nc; j++)
 	    c.elem (i, j) = a.elem (i, j);
 	}
-      else if (data[i] == 0.0)
+      else if (m.elem (i, i) == 0.0)
 	{
-	  for (int j = 0; j < a.nc; j++)
+	  for (int j = 0; j < a_nc; j++)
 	    c.elem (i, j) = 0.0;
 	}
       else
 	{
-	  for (int j = 0; j < a.nc; j++)
-	    c.elem (i, j) = data[i] * a.elem (i, j);
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
 	}
     }
 
   if (nr > nc)
     {
-      for (int j = 0; j < a.nc; j++)
-	for (int i = a.nr; i < nr; i++)
+      for (int j = 0; j < a_nc; j++)
+	for (int i = a_nr; i < nr; i++)
 	  c.elem (i, j) = 0.0;
     }
 
   return c;
 }
 
-// unary operations
-
-DiagMatrix
-DiagMatrix::operator - (void) const
-{
-  return DiagMatrix (negate (data, len), nr, nc);
-}
+// other operations
 
 ColumnVector
 DiagMatrix::diag (void) const
 {
   return diag (0);
 }
 
 // Could be optimized...
 
 ColumnVector
 DiagMatrix::diag (int k) const
 {
-  int nnr = nr;
-  int nnc = nc;
+  int nnr = rows ();
+  int nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ColumnVector d;
 
   if (nnr > 0 && nnc > 0)
@@ -1074,349 +823,57 @@ DiagMatrix::diag (int k) const
     cerr << "diag: requested diagonal out of range\n";
 
   return d;
 }
 
 ostream&
 operator << (ostream& os, const DiagMatrix& a)
 {
-  double ZERO = 0.0;
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.nr; i++)
+  for (int i = 0; i < a.rows (); i++)
     {
-      for (int j = 0; j < a.nc; j++)
+      for (int j = 0; j < a.cols (); j++)
 	{
 	  if (i == j)
-	    os << " " /* setw (field_width) */ << a.data[i];
+	    os << " " /* setw (field_width) */ << a.elem (i, i);
 	  else
-	    os << " " /* setw (field_width) */ << ZERO;
+	    os << " " /* setw (field_width) */ << 0.0;
 	}
       os << "\n";
     }
   return os;
 }
 
 /*
  * Complex Diagonal Matrix class
  */
 
-ComplexDiagMatrix::ComplexDiagMatrix (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = n;
-  nc = n;
-  len = n;
-  if (len > 0)
-    data = new Complex [len];
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (int n, double val)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = n;
-  nc = n;
-  len = n;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (int n, const Complex& val)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = n;
-  nc = n;
-  len = n;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (int r, int c)
+ComplexDiagMatrix::ComplexDiagMatrix (const RowVector& a)
+  : DiagArray<Complex> (a.length ())
 {
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = r < c ? r : c;
-  if (len > 0)
-    data = new Complex [len];
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (int r, int c, double val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = r < c ? r : c;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (int r, int c, const Complex& val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = r < c ? r : c;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (const RowVector& a)
-{
-  nr = a.len;
-  nc = nr;
-  len = nr;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (const ComplexRowVector& a)
-{
-  nr = a.len;
-  nc = nr;
-  len = nr;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
+  for (int i = 0; i < length (); i++)
+    elem (i, i) = a.elem (i);
 }
 
 ComplexDiagMatrix::ComplexDiagMatrix (const ColumnVector& a)
+  : DiagArray<Complex> (a.length ())
 {
-  nr = a.len;
-  nc = nr;
-  len = nr;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (const ComplexColumnVector& a)
-{
-  nr = a.len;
-  nc = nr;
-  len = nr;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
+  for (int i = 0; i < length (); i++)
+    elem (i, i) = a.elem (i);
 }
 
 ComplexDiagMatrix::ComplexDiagMatrix (const DiagMatrix& a)
-{
-  nr = a.nr;
-  nc = a.nc;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (const ComplexDiagMatrix& a)
+  : DiagArray<Complex> (a.rows (), a.cols ())
 {
-  nr = a.nr;
-  nc = a.nc;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (double a)
-{
-  nr = 1;
-  nc = 1;
-  len = 1;
-  data = new Complex [1];
-  data[0] = a;
-}
-
-ComplexDiagMatrix::ComplexDiagMatrix (const Complex& a)
-{
-  nr = 1;
-  nc = 1;
-  len = 1;
-  data = new Complex [1];
-  data[0] = Complex (a);
+  for (int i = 0; i < length (); i++)
+    elem (i, i) = a.elem (i, i);
 }
 
-ComplexDiagMatrix&
-ComplexDiagMatrix::operator = (const DiagMatrix& a)
-{
-  delete [] data;
-  nr = a.nr;
-  nc = a.nc;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-
-  return *this;
-}
-
-ComplexDiagMatrix&
-ComplexDiagMatrix::operator = (const ComplexDiagMatrix& a)
-{
-  if (this != &a)
-    {
-      delete [] data;
-      nr = a.nr;
-      nc = a.nc;
-      len = a.len;
-      if (len > 0)
-	{
-	  data = new Complex [len];
-	  copy (data, a.data, len);
-	}
-      else
-	data = (Complex *) NULL;
-    }
-  return *this;
-}
-
-Complex&
-ComplexDiagMatrix::checkelem (int r, int c)
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static Complex foo (0.0);
-      return foo;
-    }
-#endif
-
-  return elem (r, c);
-}
-
-Complex
-ComplexDiagMatrix::checkelem (int r, int c) const
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return Complex (0.0);
-    }
-#endif
-
-  return elem (r, c);
-}
-
+#if 0
 ComplexDiagMatrix&
 ComplexDiagMatrix::resize (int r, int c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimensions");
       return *this;
@@ -1505,217 +962,249 @@ ComplexDiagMatrix::resize (int r, int c,
   delete [] data;
   nr = r;
   nc = c;
   len = new_len;
   data = new_data;
 
   return *this;
 }
+#endif
 
 int
 ComplexDiagMatrix::operator == (const ComplexDiagMatrix& a) const
 {
-  if (nr != a.nr || nc != a.nc)
+  if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
-  return equal (data, a.data, len);
+  return equal (data (), a.data (), length ());
 }
 
 int
 ComplexDiagMatrix::operator != (const ComplexDiagMatrix& a) const
 {
-  if (nr != a.nr || nc != a.nc)
-    return 1;
-
-  return !equal (data, a.data, len);
+  return !(*this == a);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::hermitian (void) const
 {
-  return ComplexDiagMatrix (conj_dup (data, len), nc, nr);
+  return ComplexDiagMatrix (conj_dup (data (), length ()), cols (), rows ());
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (double val)
 {
-  copy (data, len, val);
+  for (int i = 0; i < length (); i++)
+    elem (i, i) = val;
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const Complex& val)
 {
-  copy (data, len, val);
+  for (int i = 0; i < length (); i++)
+    elem (i, i) = val;
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (double val, int beg, int end)
 {
-  if (beg < 0 || end >= len || end < beg)
+  if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (end > beg)
-    copy (data+beg, beg-end, val);
+  for (int i = beg; i < end; i++)
+    elem (i, i) = val;
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const Complex& val, int beg, int end)
 {
-  if (beg < 0 || end >= len || end < beg)
+  if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (end > beg)
-    copy (data+beg, beg-end, val);
+  for (int i = beg; i < end; i++)
+    elem (i, i) = val;
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a)
 {
-  if (a.len != len)
+  int len = length ();
+  if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data, a.data, len);
+  for (int i = 0; i < len; i++)
+    elem (i, i) = a.elem (i);
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a)
 {
-  if (a.len != len)
+  int len = length ();
+  if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data, a.data, len);
+  for (int i = 0; i < len; i++)
+    elem (i, i) = a.elem (i);
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a)
 {
-  if (a.len != len)
+  int len = length ();
+  if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data, a.data, len);
+  for (int i = 0; i < len; i++)
+    elem (i, i) = a.elem (i);
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a)
 {
-  if (a.len != len)
+  int len = length ();
+  if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data, a.data, len);
+  for (int i = 0; i < len; i++)
+    elem (i, i) = a.elem (i);
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a, int beg)
 {
-  if (beg < 0 || beg + a.len >= len)
+  int a_len = a.length ();
+  if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data+beg, a.data, a.len);
+  for (int i = 0; i < a_len; i++)
+    elem (i+beg, i+beg) = a.elem (i);
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a, int beg)
 {
-  if (beg < 0 || beg + a.len >= len)
+  int a_len = a.length ();
+  if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data+beg, a.data, a.len);
+  for (int i = 0; i < a_len; i++)
+    elem (i+beg, i+beg) = a.elem (i);
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a, int beg)
 {
-  if (beg < 0 || beg + a.len >= len)
+  int a_len = a.length ();
+  if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data+beg, a.data, a.len);
+  for (int i = 0; i < a_len; i++)
+    elem (i+beg, i+beg) = a.elem (i);
+
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a, int beg)
 {
-  if (beg < 0 || beg + a.len >= len)
+  int a_len = a.length ();
+  if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  copy (data+beg, a.data, a.len);
+  for (int i = 0; i < a_len; i++)
+    elem (i+beg, i+beg) = a.elem (i);
+
   return *this;
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::transpose (void) const
 {
-  return ComplexDiagMatrix (dup (data, len), nc, nr);
+  return ComplexDiagMatrix (dup (data (), length ()), cols (), rows ());
 }
 
 DiagMatrix
 real (const ComplexDiagMatrix& a)
 {
   DiagMatrix retval;
-  if (a.len > 0)
-    retval = DiagMatrix (real_dup (a.data, a.len), a.nr, a.nc);
+  int a_len = a.length ();
+  if (a_len > 0)
+    retval = DiagMatrix (real_dup (a.data (), a_len), a.rows (),
+			 a.cols ());
   return retval;
 }
 
 DiagMatrix
 imag (const ComplexDiagMatrix& a)
 {
   DiagMatrix retval;
-  if (a.len > 0)
-    retval = DiagMatrix (imag_dup (a.data, a.len), a.nr, a.nc);
+  int a_len = a.length ();
+  if (a_len > 0)
+    retval = DiagMatrix (imag_dup (a.data (), a_len), a.rows (),
+			 a.cols ());
   return retval;
 }
 
 ComplexDiagMatrix
 conj (const ComplexDiagMatrix& a)
 {
   ComplexDiagMatrix retval;
-  if (a.len > 0)
-    retval = ComplexDiagMatrix (conj_dup (a.data, a.len), a.nr, a.nc);
+  int a_len = a.length ();
+  if (a_len > 0)
+    retval = ComplexDiagMatrix (conj_dup (a.data (), a_len),
+				a.rows (), a.cols ());
   return retval;
 }
 
 // resize is the destructive analog for this one
 
 ComplexMatrix
 ComplexDiagMatrix::extract (int r1, int c1, int r2, int c2) const
 {
@@ -1724,35 +1213,37 @@ ComplexDiagMatrix::extract (int r1, int 
 
   int new_r = r2 - r1 + 1;
   int new_c = c2 - c1 + 1;
 
   ComplexMatrix result (new_r, new_c);
 
   for (int j = 0; j < new_c; j++)
     for (int i = 0; i < new_r; i++)
-      result.data[new_r*j+i] = elem (r1+i, c1+j);
+      result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // extract row or column i.
 
 ComplexRowVector
 ComplexDiagMatrix::row (int i) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (i < 0 || i >= nr)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 
   ComplexRowVector retval (nc, 0.0);
   if (nr <= nc || (nr > nc && i < nc))
-    retval.data [i] = data[i];
+    retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexRowVector
 ComplexDiagMatrix::row (char *s) const
 {
   if (s == (char *) NULL)
@@ -1760,36 +1251,38 @@ ComplexDiagMatrix::row (char *s) const
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (0);
   else if (c == 'l' || c == 'L')
-    return row (nr - 1);
+    return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (int i) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (i < 0 || i >= nc)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 
   ComplexColumnVector retval (nr, 0.0);
   if (nr >= nc || (nr < nc && i < nr))
-    retval.data [i] = data[i];
+    retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (char *s) const
 {
   if (s == (char *) NULL)
@@ -1797,634 +1290,545 @@ ComplexDiagMatrix::column (char *s) cons
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
-    return column (nc - 1);
+    return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 }
 
 ComplexDiagMatrix
-ComplexDiagMatrix::inverse (int& info) const
-{
-  if (nr != nc)
-    {
-      (*current_liboctave_error_handler) ("inverse requires square matrix");
-      return DiagMatrix ();
-    }
-
-  info = 0;
-  for (int i = 0; i < len; i++)
-    {
-      if (data[i] == 0.0)
-	{
-	  info = -1;
-	  return *this;
-	}
-      else
-	data[i] = 1.0 / data[i];
-    }
-
-  return *this;
-}
-
-ComplexDiagMatrix
 ComplexDiagMatrix::inverse (void) const
 {
   int info;
   return inverse (info);
 }
 
+ComplexDiagMatrix
+ComplexDiagMatrix::inverse (int& info) const
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != nc)
+    {
+      (*current_liboctave_error_handler) ("inverse requires square matrix");
+      return DiagMatrix ();
+    }
+
+  ComplexDiagMatrix retval (nr, nc);
+
+  info = 0;
+  for (int i = 0; i < length (); i++)
+    {
+      if (elem (i, i) == 0.0)
+	{
+	  info = -1;
+	  return *this;
+	}
+      else
+	retval.elem (i, i) = 1.0 / elem (i, i);
+    }
+
+  return *this;
+}
+
+// diagonal matrix by diagonal matrix -> diagonal matrix operations
+
+ComplexDiagMatrix&
+ComplexDiagMatrix::operator += (const DiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), length ());
+  return *this;
+}
+
+ComplexDiagMatrix&
+ComplexDiagMatrix::operator -= (const DiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), length ());
+  return *this;
+}
+
+ComplexDiagMatrix&
+ComplexDiagMatrix::operator += (const ComplexDiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), length ());
+  return *this;
+}
+
+ComplexDiagMatrix&
+ComplexDiagMatrix::operator -= (const ComplexDiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), length ());
+  return *this;
+}
+
 // diagonal matrix by scalar -> matrix operations
 
 ComplexMatrix
-ComplexDiagMatrix::operator + (double s) const
+operator + (const ComplexDiagMatrix& a, double s)
 {
-  ComplexMatrix tmp (nr, nc, s);
-  return *this + tmp;
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return a + tmp;
 }
 
 ComplexMatrix
-ComplexDiagMatrix::operator - (double s) const
+operator - (const ComplexDiagMatrix& a, double s)
 {
-  ComplexMatrix tmp (nr, nc, -s);
-  return *this + tmp;
+  ComplexMatrix tmp (a.rows (), a.cols (), -s);
+  return a + tmp;
 }
 
 ComplexMatrix
-ComplexDiagMatrix::operator + (const Complex& s) const
+operator + (const ComplexDiagMatrix& a, const Complex& s)
 {
-  ComplexMatrix tmp (nr, nc, s);
-  return *this + tmp;
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return a + tmp;
 }
 
 ComplexMatrix
-ComplexDiagMatrix::operator - (const Complex& s) const
+operator - (const ComplexDiagMatrix& a, const Complex& s)
 {
-  ComplexMatrix tmp (nr, nc, -s);
-  return *this + tmp;
+  ComplexMatrix tmp (a.rows (), a.cols (), -s);
+  return a + tmp;
 }
 
 // diagonal matrix by scalar -> diagonal matrix operations
 
 ComplexDiagMatrix
-ComplexDiagMatrix::operator * (double s) const
+operator * (const ComplexDiagMatrix& a, double s)
 {
-  return ComplexDiagMatrix (multiply (data, len, s), nr, nc);
+  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
 ComplexDiagMatrix
-ComplexDiagMatrix::operator / (double s) const
-{
-  return ComplexDiagMatrix (divide (data, len, s), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::operator * (const Complex& s) const
+operator / (const ComplexDiagMatrix& a, double s)
 {
-  return ComplexDiagMatrix (multiply (data, len, s), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::operator / (const Complex& s) const
-{
-  return ComplexDiagMatrix (divide (data, len, s), nr, nc);
+  return ComplexDiagMatrix (divide (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
 // scalar by diagonal matrix -> matrix operations
 
 ComplexMatrix
 operator + (double s, const ComplexDiagMatrix& a)
 {
-  return a + s;
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp + a;
 }
 
 ComplexMatrix
 operator - (double s, const ComplexDiagMatrix& a)
 {
-  return -a + s;
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp - a;
 }
 
 ComplexMatrix
 operator + (const Complex& s, const ComplexDiagMatrix& a)
 {
-  return a + s;
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp + a;
 }
 
 ComplexMatrix
 operator - (const Complex& s, const ComplexDiagMatrix& a)
 {
-  return -a + s;
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp - a;
 }
 
 // scalar by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix
 operator * (double s, const ComplexDiagMatrix& a)
 {
-  return ComplexDiagMatrix (multiply (a.data, a.len, s), a.nr, a.nc);
-}
-
-ComplexDiagMatrix
- operator / (double s, const ComplexDiagMatrix& a)
-{
-  return ComplexDiagMatrix (divide (s, a.data, a.len), a.nr, a.nc);
-}
-
-ComplexDiagMatrix
- operator * (const Complex& s, const ComplexDiagMatrix& a)
-{
-  return ComplexDiagMatrix (multiply (a.data, a.len, s), a.nr, a.nc);
-}
-
-ComplexDiagMatrix
-operator / (const Complex& s, const ComplexDiagMatrix& a)
-{
-  return ComplexDiagMatrix (divide (s, a.data, a.len), a.nr, a.nc);
+  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 ComplexColumnVector
-ComplexDiagMatrix::operator * (const ColumnVector& a) const
+operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
 {
-  if (nc != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix muliplication attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexColumnVector (0);
-
-  ComplexColumnVector result (nr);
-
-  for (int i = 0; i < a.len; i++)
-    result.data[i] = a.data[i] * data[i];
-
-  for (i = a.len; i < nr; i++)
-    result.data[i] = 0.0;
-
-  return result;
-}
-
-ComplexColumnVector
-ComplexDiagMatrix::operator * (const ComplexColumnVector& a) const
-{
-  if (nc != a.len)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_len = a.length ();
+  if (nc != a_len)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix muliplication attempted");
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
-  for (int i = 0; i < a.len; i++)
-    result.data[i] = a.data[i] * data[i];
+  for (int i = 0; i < a_len; i++)
+    result.elem (i) = a.elem (i) * m.elem (i, i);
+
+  for (i = a_len; i < nr; i++)
+    result.elem (i) = 0.0;
+
+  return result;
+}
 
-  for (i = a.len; i < nr; i++)
-    result.data[i] = 0.0;
+ComplexColumnVector
+operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_len = a.length ();
+  if (nc != a_len)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix muliplication attempted");
+      return ComplexColumnVector ();
+    }
+
+  if (nc == 0 || nr == 0)
+    return ComplexColumnVector (0);
+
+  ComplexColumnVector result (nr);
+
+  for (int i = 0; i < a_len; i++)
+    result.elem (i) = a.elem (i) * m.elem (i, i);
+
+  for (i = a_len; i < nr; i++)
+    result.elem (i) = 0.0;
 
   return result;
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix
-ComplexDiagMatrix::operator + (const DiagMatrix& a) const
+operator + (const ComplexDiagMatrix& m, const DiagMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexDiagMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
-  return ComplexDiagMatrix (add (data, a.data, len), nr , nc);
+  return ComplexDiagMatrix (add (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexDiagMatrix
-ComplexDiagMatrix::operator - (const DiagMatrix& a) const
+operator - (const ComplexDiagMatrix& m, const DiagMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexDiagMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
-  return ComplexDiagMatrix (subtract (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::operator * (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::operator + (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (add (data, a.data, len), nr , nc);
+  return ComplexDiagMatrix (subtract (m.data (), a.data (), m.length ()),
+			    nr, nc);
 }
 
 ComplexDiagMatrix
-ComplexDiagMatrix::operator - (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (subtract (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::operator * (const ComplexDiagMatrix& a) const
+product (const ComplexDiagMatrix& m, const DiagMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::product (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix product attempted");
       return ComplexDiagMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
-  return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::quotient (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix quotient attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (divide (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::product (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix product attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix
-ComplexDiagMatrix::quotient (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix quotient attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (divide (data, a.data, len), nr, nc);
-}
-
-ComplexDiagMatrix&
-ComplexDiagMatrix::operator += (const DiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-ComplexDiagMatrix&
-ComplexDiagMatrix::operator -= (const DiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
-}
-
-ComplexDiagMatrix&
-ComplexDiagMatrix::operator += (const ComplexDiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-ComplexDiagMatrix&
-ComplexDiagMatrix::operator -= (const ComplexDiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
+  return ComplexDiagMatrix (multiply (m.data (), a.data (), m.length ()),
+			    nr, nc);
 }
 
 // diagonal matrix by matrix -> matrix operations
 
 ComplexMatrix
-ComplexDiagMatrix::operator + (const Matrix& a) const
+operator + (const ComplexDiagMatrix& m, const Matrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (a);
-  for (int i = 0; i < len; i++)
-    result.elem (i, i) += data[i];
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-ComplexDiagMatrix::operator - (const Matrix& a) const
+operator - (const ComplexDiagMatrix& m, const Matrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (-a);
-  for (int i = 0; i < len; i++)
-    result.elem (i, i) += data[i];
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-ComplexDiagMatrix::operator * (const Matrix& a) const
+operator * (const ComplexDiagMatrix& m, const Matrix& a)
 {
-  if (nc != a.nr)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexMatrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
-    return ComplexMatrix (nr, a.nc, 0.0);
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return ComplexMatrix (nr, a_nc, 0.0);
 
-  ComplexMatrix c (nr, a.nc);
+  ComplexMatrix c (nr, a_nc);
 
-  for (int i = 0; i < len; i++)
+  for (int i = 0; i < m.length (); i++)
     {
-      if (data[i] == 1.0)
+      if (m.elem (i, i) == 1.0)
 	{
-	  for (int j = 0; j < a.nc; j++)
+	  for (int j = 0; j < a_nc; j++)
 	    c.elem (i, j) = a.elem (i, j);
 	}
-      else if (data[i] == 0.0)
+      else if (m.elem (i, i) == 0.0)
 	{
-	  for (int j = 0; j < a.nc; j++)
+	  for (int j = 0; j < a_nc; j++)
 	    c.elem (i, j) = 0.0;
 	}
       else
 	{
-	  for (int j = 0; j < a.nc; j++)
-	    c.elem (i, j) = data[i] * a.elem (i, j);
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
 	}
     }
 
   if (nr > nc)
     {
-      for (int j = 0; j < a.nc; j++)
-	for (int i = a.nr; i < nr; i++)
+      for (int j = 0; j < a_nc; j++)
+	for (int i = a_nr; i < nr; i++)
 	  c.elem (i, j) = 0.0;
     }
 
   return c;
 }
 
 ComplexMatrix
-ComplexDiagMatrix::operator + (const ComplexMatrix& a) const
+operator + (const ComplexDiagMatrix& m, const ComplexMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (a);
-  for (int i = 0; i < len; i++)
-    result.elem (i, i) += data[i];
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-ComplexDiagMatrix::operator - (const ComplexMatrix& a) const
+operator - (const ComplexDiagMatrix& m, const ComplexMatrix& a)
 {
-  if (nr != a.nr || nc != a.nc)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (-a);
-  for (int i = 0; i < len; i++)
-    result.elem (i, i) += data[i];
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-ComplexDiagMatrix::operator * (const ComplexMatrix& a) const
+operator * (const ComplexDiagMatrix& m, const ComplexMatrix& a)
 {
-  if (nc != a.nr)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexMatrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
-    return ComplexMatrix (nr, a.nc, 0.0);
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return ComplexMatrix (nr, a_nc, 0.0);
 
-  ComplexMatrix c (nr, a.nc);
+  ComplexMatrix c (nr, a_nc);
 
-  for (int i = 0; i < len; i++)
+  for (int i = 0; i < m.length (); i++)
     {
-      if (data[i] == 1.0)
+      if (m.elem (i, i) == 1.0)
 	{
-	  for (int j = 0; j < a.nc; j++)
+	  for (int j = 0; j < a_nc; j++)
 	    c.elem (i, j) = a.elem (i, j);
 	}
-      else if (data[i] == 0.0)
+      else if (m.elem (i, i) == 0.0)
 	{
-	  for (int j = 0; j < a.nc; j++)
+	  for (int j = 0; j < a_nc; j++)
 	    c.elem (i, j) = 0.0;
 	}
       else
 	{
-	  for (int j = 0; j < a.nc; j++)
-	    c.elem (i, j) = data[i] * a.elem (i, j);
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
 	}
     }
 
   if (nr > nc)
     {
-      for (int j = 0; j < a.nc; j++)
-	for (int i = a.nr; i < nr; i++)
+      for (int j = 0; j < a_nc; j++)
+	for (int i = a_nr; i < nr; i++)
 	  c.elem (i, j) = 0.0;
     }
 
   return c;
 }
 
-// unary operations
-
-ComplexDiagMatrix
-ComplexDiagMatrix::operator - (void) const
-{
-  return ComplexDiagMatrix (negate (data, len), nr, nc);
-}
+// other operations
 
 ComplexColumnVector
 ComplexDiagMatrix::diag (void) const
 {
   return diag (0);
 }
 
 // Could be optimized...
 
 ComplexColumnVector
 ComplexDiagMatrix::diag (int k) const
 {
-  int nnr = nr;
-  int nnc = nc;
+  int nnr = rows ();
+  int nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ComplexColumnVector d;
 
   if (nnr > 0 && nnc > 0)
@@ -2457,22 +1861,22 @@ ComplexDiagMatrix::diag (int k) const
 
 // i/o
 
 ostream&
 operator << (ostream& os, const ComplexDiagMatrix& a)
 {
   Complex ZERO (0.0);
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.nr; i++)
+  for (int i = 0; i < a.rows (); i++)
     {
-      for (int j = 0; j < a.nc; j++)
+      for (int j = 0; j < a.cols (); j++)
 	{
 	  if (i == j)
-	    os << " " /* setw (field_width) */ << a.data[i];
+	    os << " " /* setw (field_width) */ << a.elem (i, i);
 	  else
 	    os << " " /* setw (field_width) */ << ZERO;
 	}
       os << "\n";
     }
   return os;
 }
 
diff --git a/liboctave/FEGrid.cc b/liboctave/FEGrid.cc
--- a/liboctave/FEGrid.cc
+++ b/liboctave/FEGrid.cc
@@ -16,20 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
+#include <iostream.h>
+
 #include "FEGrid.h"
 #include "lo-error.h"
 
 // error handling
 
 void
 FEGrid::error (const char* msg) const
 {
diff --git a/liboctave/FEGrid.h b/liboctave/FEGrid.h
--- a/liboctave/FEGrid.h
+++ b/liboctave/FEGrid.h
@@ -19,19 +19,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_FEGrid_h)
 #define _FEGrid_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
+class ostream;
 
 #include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class FEGrid
diff --git a/liboctave/FSQP.cc b/liboctave/FSQP.cc
--- a/liboctave/FSQP.cc
+++ b/liboctave/FSQP.cc
@@ -16,24 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #ifndef FSQP_MISSING
 
-#ifdef __GNUG__
-#pragma implementation
-#endif
-
-#include <iostream.h>
-#include <math.h>
 #include "FSQP.h"
 #include "f77-uscore.h"
 
 #endif /* FSQP_MISSING */
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/FSQP.h b/liboctave/FSQP.h
--- a/liboctave/FSQP.h
+++ b/liboctave/FSQP.h
@@ -16,39 +16,36 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifndef FSQP_MISSING
-
 #if !defined (_FSQP_h)
 #define _FSQP_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
+#ifndef FSQP_MISSING
 
+#include "Matrix.h"
 #include "NLP.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class FSQP : public NLP
 {
  public:
  private:
 };
 
-#endif
+#endif /* FSQP_MISSING */
 
-#endif /* FSQP_MISSING */
+#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/LP.cc b/liboctave/LP.cc
--- a/liboctave/LP.cc
+++ b/liboctave/LP.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "LP.h"
 
 LP::LP (void) {}
 
 LP::LP (const Vector& c_arg) : c (c_arg) { }
 
diff --git a/liboctave/LP.h b/liboctave/LP.h
--- a/liboctave/LP.h
+++ b/liboctave/LP.h
@@ -19,23 +19,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_LP_h)
 #define _LP_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
+#include "Matrix.h"
 #include "Bounds.h"
 #include "LinConst.h"
-#include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class LP
 {
  public:
diff --git a/liboctave/LPsolve.cc b/liboctave/LPsolve.cc
--- a/liboctave/LPsolve.cc
+++ b/liboctave/LPsolve.cc
@@ -16,24 +16,21 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
-#include <math.h>
 #include "LPsolve.h"
-#include "f77-uscore.h"
 
 Vector
 LPsolve::minimize (double& objf, int& inform, Vector& lambda)
 {
 }
 
 void
 LPsolve::set_default_options (void)
diff --git a/liboctave/LPsolve.h b/liboctave/LPsolve.h
--- a/liboctave/LPsolve.h
+++ b/liboctave/LPsolve.h
@@ -19,20 +19,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_LPsolve_h)
 #define _LPsolve_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
+#include "Matrix.h"
 #include "LP.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class LPsolve : public LP
 {
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -16,21 +16,20 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include "ODE.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (lsode) (int (*)(), int *, double *, double *, double *,
 		       int *, double *, double *, int *, int *, int *,
diff --git a/liboctave/LinConst.cc b/liboctave/LinConst.cc
--- a/liboctave/LinConst.cc
+++ b/liboctave/LinConst.cc
@@ -16,21 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
+
 #include "LinConst.h"
 #include "lo-error.h"
 
 // error handling
 
 void
 LinConst::error (const char* msg)
 {
diff --git a/liboctave/LinConst.h b/liboctave/LinConst.h
--- a/liboctave/LinConst.h
+++ b/liboctave/LinConst.h
@@ -19,21 +19,20 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_LinConst_h)
 #define _LinConst_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
+#include <float.h>
 
-#include <float.h>
+class ostream;
+
 #include "Matrix.h"
 #include "Bounds.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class LinConst : public Bounds
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -23,28 +23,29 @@ include $(TOPDIR)/Makeconf
 	    mv $@.tmp $@ ; \
 	else \
 	  $(CXX) -MM $(CPPFLAGS) $(ALL_CXXFLAGS) $< | \
 	    sed -e 's/$*\.o/& $@/g' -e 's,$(srcdir)/,,g' > $@.tmp && \
 	    mv $@.tmp $@ ; \
 	fi
 
 INCLUDES = Array.h Bounds.h CollocWt.h DAE.h DAEFunc.h FEGrid.h \
-	FSQP.h LinConst.h LP.h LPsolve.h Matrix.h NLConst.h NLEqn.h \
-	NLFunc.h NLP.h NPSOL.h ODE.h ODEFunc.h Objective.h QLD.h \
-	QP.h QPSOL.h Quad.h Range.h f77-uscore.h sun-utils.h \
-	lo-error.h
+	FSQP.h LinConst.h LP.h LPsolve.h MArray.h Matrix.h NLConst.h \
+	NLEqn.h NLFunc.h NLP.h NPSOL.h ODE.h ODEFunc.h Objective.h \
+	QLD.h QP.h QPSOL.h Quad.h Range.h mx-kludge.h lo-error.h \
+	f77-uscore.h sun-utils.h
 
-SOURCES = Bounds.cc ColVector.cc CollocWt.cc DAE.cc DAEFunc.cc \
-	DiagMatrix.cc FEGrid.cc FSQP.cc LinConst.cc LP.cc LPsolve.cc \
-	Matrix-ext.cc Matrix.cc NLConst.cc NLEqn.cc NLFunc.cc NPSOL.cc \
-	Objective.cc ODE.cc ODEFunc.cc QLD.cc QP.cc QPSOL.cc Quad.cc \
-	Range.cc RowVector.cc sun-utils.cc lo-error.cc
+SOURCES = Array.cc Bounds.cc ColVector.cc CollocWt.cc DAE.cc \
+	DAEFunc.cc DiagMatrix.cc FEGrid.cc FSQP.cc LinConst.cc LP.cc \
+	LPsolve.cc Matrix-ext.cc Matrix.cc NLConst.cc NLEqn.cc \
+	NLFunc.cc NPSOL.cc Objective.cc ODE.cc ODEFunc.cc QLD.cc \
+	QP.cc QPSOL.cc Quad.cc Range.cc RowVector.cc lo-error.cc \
+	sun-utils.cc
 
-EXTRAS = mx-inlines.cc Array.cc
+EXTRAS = MArray.cc mx-kludge.cc mx-inlines.cc
 
 DISTFILES = Makefile.in $(SOURCES) $(INCLUDES) $(EXTRAS)
 
 MAKEDEPS = $(patsubst %.cc, %.d, $(SOURCES))
 
 OBJECTS = $(patsubst %.cc, %.o, $(SOURCES))
 
 LIBOCTAVE_DEPEND := $(patsubst %, ../liboctave.a(%), $(OBJECTS))
diff --git a/liboctave/Matrix-ext.cc b/liboctave/Matrix-ext.cc
--- a/liboctave/Matrix-ext.cc
+++ b/liboctave/Matrix-ext.cc
@@ -16,20 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
+#include <iostream.h>
+
 #include "Matrix.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
@@ -154,23 +156,24 @@ extern "C"
 
 /*
  * AEPBALANCE operations
  */
 
 int
 AEPBALANCE::init (const Matrix& a, const char *balance_job)
 {
-  if (a.nr != a.nc)
+  int a_nc = a.cols ();
+  if (a.rows () != a_nc)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
       return -1;
     }
 
-  int n = a.nc;
+  int n = a_nc;
 
 // Parameters for balance call.
 
   int info;
   int ilo;
   int ihi;
   double *scale = new double [n];
 
@@ -194,17 +197,17 @@ AEPBALANCE::init (const Matrix& a, const
 
   return info;
 }
 
 int
 ComplexAEPBALANCE::init (const ComplexMatrix& a, const char *balance_job)
 {
 
-  int n = a.nc;
+  int n = a.cols ();
 
 // Parameters for balance call.
 
   int info;
   int ilo;
   int ihi;
   double *scale = new double [n];
 
@@ -217,38 +220,41 @@ ComplexAEPBALANCE::init (const ComplexMa
 
 // Initialize balancing matrix to identity.
 
   balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     balancing_mat (i, i) = 1.0;
 
   F77_FCN (zgebak) (balance_job, "R", &n, &ilo, &ihi, scale, &n, 
-		    balancing_mat.fortran_vec(), &n, &info, 1L, 1L);
+		    balancing_mat.fortran_vec (), &n, &info, 1L, 1L);
 
   delete [] scale;
 
   return info;
 }
 
 /*
  * GEPBALANCE operations
  */
 
 int
 GEPBALANCE::init (const Matrix& a, const Matrix& b, const char *balance_job)
 {
-  if (a.nr != a.nc || a.nr != b.nr || b.nr != b.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  int b_nr = b.rows ();
+  if (a_nr != a_nc || a_nr != b_nr || b_nr != b.cols ())
     {
       (*current_liboctave_error_handler)
 	("GEPBALANCE requires square matrices of the same size");
       return -1;
     }
 
-  int n = a.nc;
+  int n = a_nc;
 
 // Parameters for balance call.
 
   int info;
   int ilo;
   int ihi;
   double *cscale = new double [n];
   double *cperm = new double [n];
@@ -271,17 +277,17 @@ GEPBALANCE::init (const Matrix& a, const
   
 // Copy matrices into local structure.
 
   balanced_a_mat = a;
   balanced_b_mat = b;
 
 // Initialize balancing matrices to identity.
 
-  left_balancing_mat = Matrix(n,n,0.0);
+  left_balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     left_balancing_mat (i, i) = 1.0;
 
   right_balancing_mat = left_balancing_mat;
 
 // Check for permutation option.
 
   if (*balance_job == 'P' || *balance_job == 'B')
@@ -310,26 +316,26 @@ GEPBALANCE::init (const Matrix& a, const
   else
     {
 
 // Set scaling data to 0's.
 
       for (int tmp = ilo-1; tmp < ihi; tmp++)
 	{
 	  cscale[tmp] = 0.0;
-	  wk.elem(tmp,0) = 0.0;
+	  wk.elem (tmp, 0) = 0.0;
 	}
     }
 
 // Scaleg returns exponents, not values, so...
 
   for (int tmp = ilo-1; tmp < ihi; tmp++)
     {
-      cscale[tmp] = pow(2.0,cscale[tmp]);
-      wk.elem(tmp,0) = pow(2.0,-wk.elem(tmp,0));
+      cscale[tmp] = pow (2.0, cscale[tmp]);
+      wk.elem (tmp, 0) = pow (2.0, -wk.elem (tmp, 0));
     }
 
 // Column permutations/scaling.
 
   F77_FCN (dgebak) (balance_job, "R", &n, &ilo, &ihi, cscale, &n, 
 		    right_balancing_mat.fortran_vec (), &n, &info, 1L,
 		    1L);
     
@@ -361,193 +367,197 @@ GEPBALANCE::init (const Matrix& a, const
 
 /*
  * CHOL stuff
  */
 
 int
 CHOL::init (const Matrix& a)
 {
-  if (a.nr != a.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("CHOL requires square matrix");
       return -1;
     }
 
   char uplo = 'U';
 
-  int n = a.nc;
+  int n = a_nc;
   int info;
 
-  double *h = dup (a.data, a.len);
+  double *h = dup (a.data (), a.length ());
 
   F77_FCN (dpotrf) (&uplo, &n, h, &n, &info, 1L);
 
   chol_mat = Matrix (h, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
   if (n > 1)
-    for (int j = 0; j < a.nc; j++)
-      for (int i = j+1; i < a.nr; i++)
+    for (int j = 0; j < a_nc; j++)
+      for (int i = j+1; i < a_nr; i++)
         chol_mat.elem (i, j) = 0.0;
 
-
   return info;
 }
 
-
 int
 ComplexCHOL::init (const ComplexMatrix& a)
 {
-   if (a.nr != a.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+   if (a_nr != a_nc)
      {
        (*current_liboctave_error_handler)
 	 ("ComplexCHOL requires square matrix");
        return -1;
      }
 
    char uplo = 'U';
 
-   int n = a.nc;
+   int n = a_nc;
    int info;
 
-   Complex *h = dup (a.data, a.len);
+   Complex *h = dup (a.data (), a.length ());
 
    F77_FCN (zpotrf) (&uplo, &n, h, &n, &info, 1L);
 
    chol_mat = ComplexMatrix (h, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
   if (n > 1)
-    for (int j = 0; j < a.nc; j++)
-      for (int i = j+1; i < a.nr; i++)
+    for (int j = 0; j < a_nc; j++)
+      for (int i = j+1; i < a_nr; i++)
         chol_mat.elem (i, j) = 0.0;
 
    return info;
 }
 
-
 /*
  * HESS stuff
  */
 
 int
 HESS::init (const Matrix& a)
 {
-  if (a.nr != a.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("HESS requires square matrix");
       return -1;
     }
 
   char jobbal = 'N';
   char side = 'R';
 
-  int n = a.nc;
+  int n = a_nc;
   int lwork = 32 * n;
   int info;
   int ilo;
   int ihi;
 
-  double *h = dup(a.data, a.len);
+  double *h = dup (a.data (), a.length ());
 
   double *tau = new double [n+1];
   double *scale = new double [n];
   double *z = new double [n*n];
   double *work = new double [lwork];
 
   F77_FCN (dgebal) (&jobbal, &n, h, &n, &ilo, &ihi, scale, &info,
 		    1L, 1L);
 
   F77_FCN (dgehrd) (&n, &ilo, &ihi, h, &n, tau, work, &lwork, &info,
 		    1L, 1L);
 
-  copy(z,h,n*n);
+  copy (z, h, n*n);
 
   F77_FCN (dorghr) (&n, &ilo, &ihi, z, &n, tau, work, &lwork, &info,
 		    1L, 1L);
 
   F77_FCN (dgebak) (&jobbal, &side, &n, &ilo, &ihi, scale, &n, z, &n, 
 		    &info, 1L, 1L);
 
 // We need to clear out all of the area below the sub-diagonal which was used
 // to store the unitary matrix.
 
-  hess_mat = Matrix(h,n,n);
-  unitary_hess_mat = Matrix(z,n,n);
+  hess_mat = Matrix (h, n, n);
+  unitary_hess_mat = Matrix (z, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for 
 // that matter :-)), please let me know! 
 
   if (n > 2)
-    for (int j = 0; j < a.nc; j++)
-      for (int i = j+2; i < a.nr; i++)
-        hess_mat.elem(i,j) = 0;
+    for (int j = 0; j < a_nc; j++)
+      for (int i = j+2; i < a_nr; i++)
+        hess_mat.elem (i, j) = 0;
 
   delete [] tau;
   delete [] work;
   delete [] scale;
 
   return info;
 }
 
-
 int
 ComplexHESS::init (const ComplexMatrix& a)
 {
-   if (a.nr != a.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+   if (a_nr != a_nc)
      {
        (*current_liboctave_error_handler)
 	 ("ComplexHESS requires square matrix");
        return -1;
      }
 
    char job = 'N';
    char side = 'R';
 
-   int n = a.nc;
+   int n = a_nc;
    int lwork = 32 * n;
    int info;
    int ilo;
    int ihi;
 
-   Complex *h = dup(a.data,a.len);
+   Complex *h = dup (a.data (), a.length ());
 
    double *scale = new double [n];
    Complex *tau = new Complex [n-1];
    Complex *work = new Complex [lwork];
    Complex *z = new Complex [n*n];
 
    F77_FCN (zgebal) (&job, &n, h, &n, &ilo, &ihi, scale, &info, 1L, 1L);
 
    F77_FCN (zgehrd) (&n, &ilo, &ihi, h, &n, tau, work, &lwork, &info, 1L,
 		     1L);
 
-   copy(z,h,n*n);
+   copy (z, h, n*n);
 
    F77_FCN (zunghr) (&n, &ilo, &ihi, z, &n, tau, work, &lwork, &info, 1L,
 		     1L);
 
    F77_FCN (zgebak) (&job, &side, &n, &ilo, &ihi, scale, &n, z, &n, &info,
 		     1L, 1L); 
 
    hess_mat = ComplexMatrix (h,n,n);
    unitary_hess_mat = ComplexMatrix (z,n,n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
    if (n > 2)
-     for (int j = 0; j < a.nc; j++)
-       for (int i = j+2; i < a.nr; i++)
-         hess_mat.elem(i,j) = 0;
+     for (int j = 0; j < a_nc; j++)
+       for (int i = j+2; i < a_nr; i++)
+         hess_mat.elem (i, j) = 0;
 
    delete [] work;
    delete [] tau;
    delete [] scale;
 
    return info;
 }
 
@@ -568,41 +578,43 @@ select_dig (double *a, double *b)
 }
 
 // GAG.
 extern "C" { static int (*dummy_select)(); }
 
 int
 SCHUR::init (const Matrix& a, const char *ord)
 {
-  if (a.nr != a.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("SCHUR requires square matrix");
       return -1;
     }
 
   char jobvs = 'V';
   char sort;
 
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
     sort = 'S';
   else
     sort = 'N';
 
   char sense = 'N';
 
-  int n = a.nc;
+  int n = a_nc;
   int lwork = 8 * n;
   int liwork = 1;
   int info;
   int sdim;
   double rconde;
   double rcondv;
 
-  double *s = dup(a.data,a.len);
+  double *s = dup (a.data (), a.length ());
 
   double *wr = new double [n];
   double *wi = new double [n];
   double *q = new double [n*n];
   double *work = new double [lwork];
 
 // These are not referenced for the non-ordered Schur routine.
 
@@ -630,76 +642,77 @@ SCHUR::init (const Matrix& a, const char
   else
     {
       F77_FCN (dgeesx) (&jobvs, &sort, dummy_select, &sense, &n, s,
 			&n, &sdim, wr, wi, q, &n, &rconde, &rcondv,
 			work, &lwork, iwork, &liwork, bwork, &info,
 			1L, 1L);
     }
 
-
   schur_mat = Matrix (s, n, n);
   unitary_mat = Matrix (q, n, n);
 
   delete [] wr;
   delete [] wi;
   delete [] work;
   delete [] iwork;
   delete [] bwork;
 
   return info;
 }
 
 static int
 complex_select_ana (Complex *a)
 {
-  return (real (*a) < 0.0);
+  return a->real () < 0.0;
 }
 
 static int
 complex_select_dig (Complex *a)
 {
   return (abs (*a) < 1.0);
 }
 
 int
 ComplexSCHUR::init (const ComplexMatrix& a, const char *ord)
 {
-  if (a.nr != a.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
 	("ComplexSCHUR requires square matrix");
       return -1;
     }
 
   char jobvs = 'V';
   char sort;
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
      sort = 'S';
    else
      sort = 'N';
 
   char sense = 'N';
 
-  int n = a.nc;
+  int n = a_nc;
   int lwork = 8 * n;
   int info;
   int sdim;
   double rconde;
   double rcondv;
 
   double *rwork = new double [n];
 
 // bwork is not referenced for non-ordered Schur.
 
   int *bwork = (int *) NULL;
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
     bwork = new int [n];
 
-  Complex *s = dup(a.data,a.len);
+  Complex *s = dup (a.data (), a.length ());
 
   Complex *work = new Complex [lwork];
   Complex *q = new Complex [n*n];
   Complex *w = new Complex [n];
 
   if (*ord == 'A' || *ord == 'a')
     {
       F77_FCN (zgeesx) (&jobvs, &sort, complex_select_ana, &sense,
@@ -743,23 +756,23 @@ operator << (ostream& os, const SCHUR& a
  * SVD stuff
  */
 
 int
 SVD::init (const Matrix& a)
 {
   int info;
 
-  int m = a.nr;
-  int n = a.nc;
+  int m = a.rows ();
+  int n = a.cols ();
 
   char jobu = 'A';
   char jobv = 'A';
 
-  double *tmp_data = dup (a.data, a.len);
+  double *tmp_data = dup (a.data (), a.length ());
 
   int min_mn = m < n ? m : n;
   int max_mn = m > n ? m : n;
 
   double *u = new double[m*m];
   double *s_vec  = new double[min_mn];
   double *vt = new double[n*n];
 
@@ -792,23 +805,23 @@ operator << (ostream& os, const SVD& a)
   return os;
 }
 
 int
 ComplexSVD::init (const ComplexMatrix& a)
 {
   int info;
 
-  int m = a.nr;
-  int n = a.nc;
+  int m = a.rows ();
+  int n = a.cols ();
 
   char jobu = 'A';
   char jobv = 'A';
 
-  Complex *tmp_data = dup (a.data, a.len);
+  Complex *tmp_data = dup (a.data (), a.length ());
 
   int min_mn = m < n ? m : n;
   int max_mn = m > n ? m : n;
 
   Complex *u = new Complex[m*m];
   double *s_vec  = new double[min_mn];
   Complex *vt = new Complex[n*n];
 
@@ -828,36 +841,101 @@ ComplexSVD::init (const ComplexMatrix& a
 
   delete [] tmp_data;
   delete [] work;
 
   return info;
 }
 
 /*
+ * DET stuff.
+ */
+
+int
+DET::value_will_overflow (void) const
+{
+  return det[2] + 1 > log10 (MAXDOUBLE) ? 1 : 0;
+}
+
+int
+DET::value_will_underflow (void) const
+{
+  return det[2] - 1 < log10 (MINDOUBLE) ? 1 : 0;
+}
+
+double
+DET::coefficient (void) const
+{
+  return det[0];
+}
+
+int
+DET::exponent (void) const
+{
+  return (int) det[1];
+}
+
+double
+DET::value (void) const
+{
+  return det[0] * pow (10.0, det[1]);
+}
+
+int
+ComplexDET::value_will_overflow (void) const
+{
+  return det[2].real () + 1 > log10 (MAXDOUBLE) ? 1 : 0;
+}
+
+int
+ComplexDET::value_will_underflow (void) const
+{
+  return det[2].real () - 1 < log10 (MINDOUBLE) ? 1 : 0;
+}
+
+Complex
+ComplexDET::coefficient (void) const
+{
+  return det[0];
+}
+
+int
+ComplexDET::exponent (void) const
+{
+  return (int) (det[1].real ());
+}
+
+Complex
+ComplexDET::value (void) const
+{
+  return det[0] * pow (10.0, det[1].real ());
+}
+
+/*
  * EIG stuff.
  */
 
 int
 EIG::init (const Matrix& a)
 {
-  if (a.nr != a.nc)
+  int a_nr = a.rows ();
+  if (a_nr != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
-  int n = a.nr;
+  int n = a_nr;
 
   int info;
 
   char jobvl = 'N';
   char jobvr = 'V';
 
-  double *tmp_data = dup (a.data, a.len);
+  double *tmp_data = dup (a.data (), a.length ());
   double *wr = new double[n];
   double *wi = new double[n];
   Matrix vr (n, n);
   double *pvr = vr.fortran_vec ();
   int lwork = 8*n;
   double *work = new double[lwork];
 
   double dummy;
@@ -904,37 +982,37 @@ EIG::init (const Matrix& a)
   delete [] work;
 
   return info;
 }
 
 int
 EIG::init (const ComplexMatrix& a)
 {
-
-  if (a.nr != a.nc)
+  int a_nr = a.rows ();
+  if (a_nr != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
-  int n = a.nr;
+  int n = a_nr;
 
   int info;
 
   char jobvl = 'N';
   char jobvr = 'V';
 
   lambda.resize (n);
   v.resize (n, n);
 
   Complex *pw = lambda.fortran_vec ();
   Complex *pvr = v.fortran_vec ();
 
-  Complex *tmp_data = dup (a.data, a.len);
+  Complex *tmp_data = dup (a.data (), a.length ());
 
   int lwork = 8*n;
   Complex *work = new Complex[lwork];
   double *rwork = new double[4*n];
 
   Complex dummy;
   int idummy = 1;
 
@@ -950,27 +1028,29 @@ EIG::init (const ComplexMatrix& a)
 }
 
 /*
  * LU stuff.
  */
 
 LU::LU (const Matrix& a)
 {
-  if (a.nr == 0 || a.nc == 0 || a.nr != a.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (a_nr == 0 || a_nc == 0 || a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("LU requires square matrix");
       return;
     }
 
-  int n = a.nr;
+  int n = a_nr;
 
   int *ipvt = new int [n];
   int *pvt = new int [n];
-  double *tmp_data = dup (a.data, a.len);
+  double *tmp_data = dup (a.data (), a.length ());
   int info = 0;
   int zero = 0;
   double b;
 
   F77_FCN (dgesv) (&n, &zero, tmp_data, &n, ipvt, &b, &n, &info);
 
   Matrix A_fact (tmp_data, n, n);
 
@@ -1012,27 +1092,29 @@ LU::LU (const Matrix& a)
     }
 
   delete [] ipvt;
   delete [] pvt;
 }
 
 ComplexLU::ComplexLU (const ComplexMatrix& a)
 {
-  if (a.nr == 0 || a.nc == 0 || a.nr != a.nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (a_nr == 0 || a_nc == 0 || a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("ComplexLU requires square matrix");
       return;
     }
 
-  int n = a.nr;
+  int n = a_nr;
 
   int *ipvt = new int [n];
   int *pvt = new int [n];
-  Complex *tmp_data = dup (a.data, a.len);
+  Complex *tmp_data = dup (a.data (), a.length ());
   int info = 0;
   int zero = 0;
   Complex b;
 
   F77_FCN (zgesv) (&n, &zero, tmp_data, &n, ipvt, &b, &n, &info);
 
   ComplexMatrix A_fact (tmp_data, n, n);
 
@@ -1078,18 +1160,18 @@ ComplexLU::ComplexLU (const ComplexMatri
 }
 
 /*
  * QR stuff.
  */
 
 QR::QR (const Matrix& a)
 {
-  int m = a.nr;
-  int n = a.nc;
+  int m = a.rows ();
+  int n = a.cols ();
 
   if (m == 0 || n == 0)
     {
       (*current_liboctave_error_handler) ("QR must have non-empty matrix");
       return;
     }
 
   double *tmp_data;
@@ -1097,20 +1179,20 @@ QR::QR (const Matrix& a)
   double *tau = new double[min_mn];
   int lwork = 32*n;
   double *work = new double[lwork];
   int info = 0;
 
   if (m > n)
     {
       tmp_data = new double [m*m];
-      copy (tmp_data, a.data, a.len);
+      copy (tmp_data, a.data (), a.length ());
     }
   else
-   tmp_data = dup (a.data, a.len);
+    tmp_data = dup (a.data (), a.length ());
 
   F77_FCN (dgeqrf) (&m, &n, tmp_data, &m, tau, work, &lwork, &info);
 
   delete [] work;
 
   r.resize (m, n, 0.0);
   for (int j = 0; j < n; j++)
     {
@@ -1127,18 +1209,18 @@ QR::QR (const Matrix& a)
   q = Matrix (tmp_data, m, m);
 
   delete [] tau;
   delete [] work;
 }
 
 ComplexQR::ComplexQR (const ComplexMatrix& a)
 {
-  int m = a.nr;
-  int n = a.nc;
+  int m = a.rows ();
+  int n = a.cols ();
 
   if (m == 0 || n == 0)
     {
       (*current_liboctave_error_handler)
 	("ComplexQR must have non-empty matrix");
       return;
     }
 
@@ -1147,20 +1229,20 @@ ComplexQR::ComplexQR (const ComplexMatri
   Complex *tau = new Complex[min_mn];
   int lwork = 32*n;
   Complex *work = new Complex[lwork];
   int info = 0;
 
   if (m > n)
     {
       tmp_data = new Complex [m*m];
-      copy (tmp_data, a.data, a.len);
+      copy (tmp_data, a.data (), a.length ());
     }
   else
-   tmp_data = dup (a.data, a.len);
+    tmp_data = dup (a.data (), a.length ());
 
   F77_FCN (zgeqrf) (&m, &n, tmp_data, &m, tau, work, &lwork, &info);
 
   delete [] work;
 
   r.resize (m, n, 0.0);
   for (int j = 0; j < n; j++)
     {
diff --git a/liboctave/Matrix.cc b/liboctave/Matrix.cc
--- a/liboctave/Matrix.cc
+++ b/liboctave/Matrix.cc
@@ -16,22 +16,21 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-// I\'m not sure how this is supposed to work if the .h file declares
-// several classes, each of which is defined in a separate file...
-//
-// #ifdef __GNUG__
-// #pragma implementation
-// #endif
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <iostream.h>
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
@@ -109,155 +108,95 @@ extern "C"
 
   int F77_FCN (cffti) (const int*, Complex*);
 
   int F77_FCN (cfftf) (const int*, Complex*, Complex*);
 
   int F77_FCN (cfftb) (const int*, Complex*, Complex*);
 }
 
+// Since this is only temporary, put all of this here, rather than
+// putting each type where it logically belongs.  This way, it will be
+// easier to delete.
+
+#define KLUDGE_MATRICES
+#define TYPE double
+#define KL_MAT_TYPE Matrix
+#include "mx-kludge.cc"
+#undef KLUDGE_MATRICES
+#undef TYPE
+#undef KL_MAT_TYPE
+
+#define KLUDGE_VECTORS
+#define TYPE double
+#define KL_VEC_TYPE ColumnVector
+#include "mx-kludge.cc"
+#undef KLUDGE_VECTORS
+#undef TYPE
+#undef KL_VEC_TYPE
+
+#define KLUDGE_VECTORS
+#define TYPE double
+#define KL_VEC_TYPE RowVector
+#include "mx-kludge.cc"
+#undef KLUDGE_VECTORS
+#undef TYPE
+#undef KL_VEC_TYPE
+
+#define KLUDGE_DIAG_MATRICES
+#define TYPE double
+#define KL_DMAT_TYPE DiagMatrix
+#include "mx-kludge.cc"
+#undef KLUDGE_DIAG_MATRICES
+#undef TYPE
+#undef KL_DMAT_TYPE
+
+#define KLUDGE_MATRICES
+#define TYPE Complex
+#define KL_MAT_TYPE ComplexMatrix
+#include "mx-kludge.cc"
+#undef KLUDGE_MATRICES
+#undef TYPE
+#undef KL_MAT_TYPE
+
+#define KLUDGE_VECTORS
+#define TYPE Complex
+#define KL_VEC_TYPE ComplexColumnVector
+#include "mx-kludge.cc"
+#undef KLUDGE_VECTORS
+#undef TYPE
+#undef KL_VEC_TYPE
+
+#define KLUDGE_VECTORS
+#define TYPE Complex
+#define KL_VEC_TYPE ComplexRowVector
+#include "mx-kludge.cc"
+#undef KLUDGE_VECTORS
+#undef TYPE
+#undef KL_VEC_TYPE
+
+#define KLUDGE_DIAG_MATRICES
+#define TYPE Complex
+#define KL_DMAT_TYPE ComplexDiagMatrix
+#include "mx-kludge.cc"
+#undef KLUDGE_DIAG_MATRICES
+#undef TYPE
+#undef KL_DMAT_TYPE
+
 /*
  * Matrix class.
  */
 
-Matrix::Matrix (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't construct matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = nr * nc;
-  if (len > 0)
-    data = new double [len];
-  else
-    data = (double *) NULL;
-}
-
-Matrix::Matrix (int r, int c, double val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't construct matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = nr * nc;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, len, val);
-    }
-  else
-    data = (double *) NULL;
-}
-
-Matrix::Matrix (const Matrix& a)
-{
-  nr = a.nr;
-  nc = a.nc;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (double *) NULL;
-}
-
-Matrix::Matrix (const DiagMatrix& a)
-{
-  nr = a.nr;
-  nc = a.nc;
-  len = nr * nc;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, len, 0.0);
-      for (int i = 0; i < a.len; i++)
-	data[nr*i+i] = a.data[i];
-    }
-  else
-    data = (double *) NULL;
-}
-
-Matrix::Matrix (double a)
-{
-  nr = 1;
-  nc = 1;
-  len = 1;
-  data = new double [1];
-  data[0] = a;
-}
-
-Matrix&
-Matrix::operator = (const Matrix& a)
-{
-  if (this != &a)
-    {
-      delete [] data;
-      nr = a.nr;
-      nc = a.nc;
-      len = a.len;
-      if (len > 0)
-	{
-	  data = new double [len];
-	  copy (data, a.data, len);
-	}
-      else
-	data = (double *) NULL;
-    }
-  return *this;
-}
-
-double&
-Matrix::checkelem (int r, int c)
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static double foo = 0.0;
-      return foo;
-    }
-#endif
-
-  return elem (r, c);
-}
-
-double
-Matrix::checkelem (int r, int c) const
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return 0.0;
-    }
-#endif
-
-  return elem (r, c);
-}
-
+Matrix::Matrix (const DiagMatrix& a) : Array2<double> (a.rows (), a.cols ())
+{
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) = a.elem (i, i);
+}
+
+#if 0
 Matrix&
 Matrix::resize (int r, int c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimensions");
       return *this;
@@ -318,104 +257,118 @@ Matrix::resize (int r, int c, double val
   delete [] data;
   nr = r;
   nc = c;
   len = new_len;
   data = new_data;
 
   return *this;
 }
+#endif
 
 int
 Matrix::operator == (const Matrix& a) const
 {
-  if (nr != a.nr || nc != a.nc)
+  if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
-  return equal (data, a.data, len);
+  return equal (data (), a.data (), length ());
 }
 
 int
 Matrix::operator != (const Matrix& a) const
 {
   return !(*this == a);
 }
 
 Matrix&
 Matrix::insert (const Matrix& a, int r, int c)
 {
-  if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
+  int a_rows = a.rows ();
+  int a_cols = a.cols ();
+  if (r < 0 || r + a_rows - 1 > rows ()
+      || c < 0 || c + a_cols - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int j = 0; j < a.nc; j++)
-    for (int i = 0; i < a.nr; i++)
+  for (int j = 0; j < a_cols; j++)
+    for (int i = 0; i < a_rows; i++)
       elem (r+i, c+j) = a.elem (i, j);
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const RowVector& a, int r, int c)
 {
-  if (r < 0 || r >= nr || c < 0 || c + a.len - 1 > nc)
+  int a_len = a.length ();
+  if (r < 0 || r >= rows () || c < 0 || c + a_len - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r, c+i) = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const ColumnVector& a, int r, int c)
 {
-  if (r < 0 || r + a.len - 1 > nr || c < 0 || c >= nc)
+  int a_len = a.length ();
+  if (r < 0 || r + a_len - 1 > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r+i, c) = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r+i, c) = a.elem (i);
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const DiagMatrix& a, int r, int c)
 {
-  if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
+  if (r < 0 || r + a.rows () - 1 > rows ()
+      || c < 0 || c + a.cols () - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r+i, c+i) = a.data[i];
+  for (int i = 0; i < a.length (); i++)
+    elem (r+i, c+i) = a.elem (i, i);
 
   return *this;
 }
 
 Matrix&
 Matrix::fill (double val)
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nr > 0 && nc > 0)
-    copy (data, len, val);
+    for (int j = 0; j < nc; j++)
+      for (int i = 0; i < nr; i++)
+	elem (i, j) = val;
+
   return *this;
 }
 
 Matrix&
 Matrix::fill (double val, int r1, int c1, int r2, int c2)
 {
+  int nr = rows ();
+  int nc = rows ();
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
@@ -426,154 +379,172 @@ Matrix::fill (double val, int r1, int c1
       elem (i, j) = val;
 
   return *this;
 }
 
 Matrix
 Matrix::append (const Matrix& a) const
 {
-  if (nr != a.nr)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return Matrix ();
     }
 
   int nc_insert = nc;
-  Matrix retval (nr, nc + a.nc);
+  Matrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const RowVector& a) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return Matrix ();
     }
 
   int nc_insert = nc;
-  Matrix retval (nr, nc + a.len);
+  Matrix retval (nr, nc + a.length ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const ColumnVector& a) const
 {
-  if (nr != a.len)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.length ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return Matrix ();
     }
 
   int nc_insert = nc;
   Matrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const DiagMatrix& a) const
 {
-  if (nr != a.nr)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
-  Matrix retval (nr, nc + a.nc);
+  Matrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::stack (const Matrix& a) const
 {
-  if (nc != a.nc)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return Matrix ();
     }
 
   int nr_insert = nr;
-  Matrix retval (nr + a.nr, nc);
+  Matrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const RowVector& a) const
 {
-  if (nc != a.len)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return Matrix ();
     }
 
   int nr_insert = nr;
   Matrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const ColumnVector& a) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return Matrix ();
     }
 
   int nr_insert = nr;
-  Matrix retval (nr + a.len, nc);
+  Matrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const DiagMatrix& a) const
 {
-  if (nc != a.nc)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return Matrix ();
     }
 
   int nr_insert = nr;
-  Matrix retval (nr + a.nr, nc);
+  Matrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::transpose (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   Matrix result (nc, nr);
-  if (len > 0)
+  if (length () > 0)
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.data[nc*i+j] = data[nr*j+i];
+	  result.elem (j, i) = elem (i, j);
     }
   return result;
 }
 
 Matrix
 Matrix::extract (int r1, int c1, int r2, int c2) const
 {
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
@@ -581,27 +552,28 @@ Matrix::extract (int r1, int c1, int r2,
 
   int new_r = r2 - r1 + 1;
   int new_c = c2 - c1 + 1;
 
   Matrix result (new_r, new_c);
 
   for (int j = 0; j < new_c; j++)
     for (int i = 0; i < new_r; i++)
-      result.data[new_r*j+i] = elem (r1+i, c1+j);
+      result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // extract row or column i.
 
 RowVector
 Matrix::row (int i) const
 {
-  if (i < 0 || i >= nr)
+  int nc = cols ();
+  if (i < 0 || i >= rows ())
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector ();
     }
 
   RowVector retval (nc);
   for (int j = 0; j < nc; j++)
     retval.elem (j) = elem (i, j);
@@ -617,28 +589,29 @@ Matrix::row (char *s) const
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (0);
   else if (c == 'l' || c == 'L')
-    return row (nr - 1);
+    return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector ();
     }
 }
 
 ColumnVector
 Matrix::column (int i) const
 {
-  if (i < 0 || i >= nc)
+  int nr = rows ();
+  if (i < 0 || i >= cols ())
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector ();
     }
 
   ColumnVector retval (nr);
   for (int j = 0; j < nr; j++)
     retval.elem (j) = elem (j, i);
@@ -654,122 +627,129 @@ Matrix::column (char *s) const
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
-    return column (nc - 1);
+    return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector ();
     }
 }
 
 Matrix
+Matrix::inverse (void) const
+{
+  int info;
+  double rcond;
+  return inverse (info, rcond);
+}
+
+Matrix
+Matrix::inverse (int& info) const
+{
+  double rcond;
+  return inverse (info, rcond);
+}
+
+Matrix
 Matrix::inverse (int& info, double& rcond) const
 {
+  int nr = rows ();
+  int nc = cols ();
+  int len = length ();
   if (nr != nc || nr == 0 || nc == 0)
     {
       (*current_liboctave_error_handler) ("inverse requires square matrix");
       return Matrix ();
     }
 
   info = 0;
 
   int *ipvt = new int [nr];
   double *z = new double [nr];
-  double *tmp_data = dup (data, len);
+  double *tmp_data = dup (data (), len);
 
   F77_FCN (dgeco) (tmp_data, &nr, &nc, ipvt, &rcond, z);
 
   if (rcond + 1.0 == 1.0)
     {
       info = -1;
-      copy (tmp_data, data, len);  // Restore matrix contents.
+      copy (tmp_data, data (), len);  // Restore matrix contents.
     }
   else
     {
       int job = 1;
       double dummy;
 
       F77_FCN (dgedi) (tmp_data, &nr, &nc, ipvt, &dummy, z, &job);
     }
 
   delete [] ipvt;
   delete [] z;
 
   return Matrix (tmp_data, nr, nc);
 }
 
-Matrix
-Matrix::inverse (int& info) const
-{
-  double rcond;
-  return inverse (info, rcond);
-}
-
-Matrix
-Matrix::inverse (void) const
-{
-  int info;
-  double rcond;
-  return inverse (info, rcond);
-}
-
 ComplexMatrix
 Matrix::fourier (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   int npts, nsamples;
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
-  Complex *tmp_data = make_complex (data, len);
+  Complex *tmp_data = make_complex (data (), length ());
 
   F77_FCN (cffti) (&npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftf) (&npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   int npts, nsamples;
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
-  Complex *tmp_data = make_complex (data, len);
+  Complex *tmp_data = make_complex (data (), length ());
 
   F77_FCN (cffti) (&npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftb) (&npts, &tmp_data[npts*j], wsave);
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
@@ -794,29 +774,31 @@ Matrix::determinant (int& info) const
   return determinant (info, rcond);
 }
 
 DET
 Matrix::determinant (int& info, double& rcond) const
 {
   DET retval;
 
+  int nr = rows ();
+  int nc = cols ();
   if (nr == 0 || nc == 0)
     {
       double d[2];
       d[0] = 1.0;
       d[1] = 0.0;
       return DET (d);
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
-  double *tmp_data = dup (data, len);
+  double *tmp_data = dup (data (), length ());
 
   F77_FCN (dgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
 
   if (rcond + 1.0 == 1.0)
     {
       info = -1;
     }
   else
@@ -849,45 +831,48 @@ Matrix::solve (const Matrix& b, int& inf
   return solve (b, info, rcond);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, int& info, double& rcond) const
 {
   Matrix retval;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.nr)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     {
       (*current_liboctave_error_handler)
 	("matrix dimension mismatch solution of linear equations");
       return Matrix ();
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
-  double *tmp_data = dup (data, len);
+  double *tmp_data = dup (data (), length ());
 
   F77_FCN (dgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
 
   if (rcond + 1.0 == 1.0)
     {
       info = -2;
     }
   else
     {
       int job = 0;
 
-      double *result = dup (b.data, b.len);
-
-      for (int j = 0; j < b.nc; j++)
+      double *result = dup (b.data (), b.length ());
+
+      int b_nc = b.cols ();
+      for (int j = 0; j < b_nc; j++)
 	F77_FCN (dgesl) (tmp_data, &nr, &nr, ipvt, &result[nr*j], &job);
 
-      retval = Matrix (result, b.nr, b.nc);
+      retval = Matrix (result, b.rows (), b_nc);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
   return retval;
 }
@@ -911,61 +896,64 @@ Matrix::solve (const ComplexMatrix& b, i
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcond);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b) const
 {
-  int info;
-  double rcond;
+  int info; double rcond;
   return solve (b, info, rcond);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, int& info) const
 {
   double rcond;
   return solve (b, info, rcond);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, int& info, double& rcond) const
 {
   ColumnVector retval;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.len)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr == 0 || nc == 0 || nr != nc || nr != b.length ())
     {
       (*current_liboctave_error_handler)
 	("matrix dimension mismatch solution of linear equations");
       return ColumnVector ();
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
-  double *tmp_data = dup (data, len);
+  double *tmp_data = dup (data (), length ());
 
   F77_FCN (dgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
 
   if (rcond + 1.0 == 1.0)
     {
       info = -2;
     }
   else
     {
       int job = 0;
 
-      double *result = dup (b.data, b.len);
+      int b_len = b.length ();
+
+      double *result = dup (b.data (), b_len);
 
       F77_FCN (dgesl) (tmp_data, &nr, &nr, ipvt, result, &job);
 
-      retval = ColumnVector (result, b.len);
+      retval = ColumnVector (result, b_len);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
   return retval;
 }
@@ -1004,29 +992,29 @@ Matrix::lssolve (const Matrix& b, int& i
 {
   int rank;
   return lssolve (b, info, rank);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, int& info, int& rank) const
 {
-  int nrhs = b.nc;
-
-  int m = nr;
-  int n = nc;
-
-  if (m == 0 || n == 0 || m != b.nr)
+  int nrhs = b.cols ();
+
+  int m = rows ();
+  int n = cols ();
+
+  if (m == 0 || n == 0 || m != b.rows ())
     {
       (*current_liboctave_error_handler)
 	("matrix dimension mismatch in solution of least squares problem");
       return Matrix ();
     }
 
-  double *tmp_data = dup (data, len);
+  double *tmp_data = dup (data (), length ());
 
   int nrr = m > n ? m : n;
   Matrix result (nrr, nrhs);
 
   int i, j;
   for (j = 0; j < nrhs; j++)
     for (i = 0; i < m; i++)
       result.elem (i, j) = b.elem (i, j);
@@ -1065,57 +1053,56 @@ Matrix::lssolve (const ComplexMatrix& b)
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b);
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b, int& info) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.lssolve (b, info);
+  return tmp.lssolve (b);
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b, int& info, int& rank) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.lssolve (b, info, rank);
+  return tmp.lssolve (b);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b) const
 {
   int info;
-  int rank;
-  return lssolve (b, info, rank);
+  int rank; return lssolve (b, info, rank);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, int& info) const
 {
   int rank;
   return lssolve (b, info, rank);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, int& info, int& rank) const
 {
   int nrhs = 1;
 
-  int m = nr;
-  int n = nc;
-
-  if (m == 0 || n == 0 || m != b.len)
+  int m = rows ();
+  int n = cols ();
+
+  if (m == 0 || n == 0 || m != b.length ())
     {
       (*current_liboctave_error_handler)
 	("matrix dimension mismatch in solution of least squares problem");
       return ColumnVector ();
     }
 
-  double *tmp_data = dup (data, len);
+  double *tmp_data = dup (data (), length ());
 
   int nrr = m > n ? m : n;
   ColumnVector result (nrr);
 
   int i;
   for (i = 0; i < m; i++)
     result.elem (i) = b.elem (i);
 
@@ -1162,98 +1149,177 @@ Matrix::lssolve (const ComplexColumnVect
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b, int& info, int& rank) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank);
 }
 
-// matrix by scalar -> matrix operations.
-
-Matrix
-Matrix::operator + (double s) const
-{
-  return Matrix (add (data, len, s), nr, nc);
-}
-
-Matrix
-Matrix::operator - (double s) const
-{
-  return Matrix (subtract (data, len, s), nr, nc);
-}
+Matrix&
+Matrix::operator += (const Matrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), length ());
+
+  return *this;
+}
+
+Matrix&
+Matrix::operator -= (const Matrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), length ());
+
+  return *this;
+}
+
+Matrix&
+Matrix::operator += (const DiagMatrix& a)
+{
+  if (rows () != a.rows () || cols () != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
+
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) += a.elem (i, i);
+
+  return *this;
+}
+
+Matrix&
+Matrix::operator -= (const DiagMatrix& a)
+{
+  if (rows () != a.rows () || cols () != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
+
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) -= a.elem (i, i);
+
+  return *this;
+}
+
+// unary operations
 
 Matrix
-Matrix::operator * (double s) const
-{
-  return Matrix (multiply (data, len, s), nr, nc);
-}
-
-Matrix
-Matrix::operator / (double s) const
-{
-  return Matrix (divide (data, len, s), nr, nc);
-}
+Matrix::operator ! (void) const
+{
+  int nr = rows ();
+  int nc = cols ();
+
+  Matrix b (nr, nc);
+
+  for (int j = 0; j < nc; j++)
+    for (int i = 0; i < nr; i++)
+      b.elem (i, j) = ! elem (i, j);
+
+  return b;
+}
+
+// matrix by scalar -> matrix operations.
 
 ComplexMatrix
-Matrix::operator + (const Complex& s) const
-{
-  return ComplexMatrix (add (data, len, s), nr, nc);
+operator + (const Matrix& a, const Complex& s)
+{
+  return ComplexMatrix (add (a.data (), a.length (), s),
+			a.rows (), a.cols ());
 }
 
 ComplexMatrix
-Matrix::operator - (const Complex& s) const
-{
-  return ComplexMatrix (subtract (data, len, s), nr, nc);
+operator - (const Matrix& a, const Complex& s)
+{
+  return ComplexMatrix (subtract (a.data (), a.length (), s),
+			a.rows (), a.cols ());
 }
 
 ComplexMatrix
-Matrix::operator * (const Complex& s) const
-{
-  return ComplexMatrix (multiply (data, len, s), nr, nc);
+operator * (const Matrix& a, const Complex& s)
+{
+  return ComplexMatrix (multiply (a.data (), a.length (), s),
+			a.rows (), a.cols ());
 }
 
 ComplexMatrix
-Matrix::operator / (const Complex& s) const
-{
-  return ComplexMatrix (divide (data, len, s), nr, nc);
-}
-
-// scalar by matrix -> matrix operations
-
-Matrix
-operator + (double s, const Matrix& a)
-{
-  return Matrix (add (a.data, a.len, s), a.nr, a.nc);
-}
-
-Matrix
-operator - (double s, const Matrix& a)
-{
-  return Matrix (subtract (s, a.data, a.len), a.nr, a.nc);
-}
-
-Matrix
-operator * (double s, const Matrix& a)
-{
-  return Matrix (multiply (a.data, a.len, s), a.nr, a.nc);
-}
-
-Matrix
-operator / (double s, const Matrix& a)
-{
-  return Matrix (divide (s, a.data, a.len), a.nr, a.nc);
+operator / (const Matrix& a, const Complex& s)
+{
+  return ComplexMatrix (divide (a.data (), a.length (), s),
+			a.rows (), a.cols ());
+}
+
+// scalar by matrix -> matrix operations.
+
+ComplexMatrix
+operator + (const Complex& s, const Matrix& a)
+{
+  assert (0);
+  return ComplexMatrix ();
+}
+
+ComplexMatrix
+operator - (const Complex& s, const Matrix& a)
+{
+  assert (0);
+  return ComplexMatrix ();
+}
+
+ComplexMatrix
+operator * (const Complex& s, const Matrix& a)
+{
+  assert (0);
+  return ComplexMatrix ();
+}
+
+ComplexMatrix
+operator / (const Complex& s, const Matrix& a)
+{
+  assert (0);
+  return ComplexMatrix ();
 }
 
 // matrix by column vector -> column vector operations
 
 ColumnVector
-Matrix::operator * (const ColumnVector& a) const
-{
-  if (nc != a.len)
+operator * (const Matrix& m, const ColumnVector& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ColumnVector ();
     }
 
   if (nr == 0 || nc == 0)
     return ColumnVector (0);
@@ -1261,458 +1327,362 @@ Matrix::operator * (const ColumnVector& 
   char trans = 'N';
   int ld = nr;
   double alpha = 1.0;
   double beta  = 0.0;
   int i_one = 1;
 
   double *y = new double [nr];
 
-  F77_FCN (dgemv) (&trans, &nr, &nc, &alpha, data, &ld, a.data,
+  F77_FCN (dgemv) (&trans, &nr, &nc, &alpha, m.data (), &ld, a.data (),
 		   &i_one, &beta, y, &i_one, 1L); 
 
   return ColumnVector (y, nr);
 }
 
 ComplexColumnVector
-Matrix::operator * (const ComplexColumnVector& a) const
-{
-  ComplexMatrix tmp (*this);
+operator * (const Matrix& m, const ComplexColumnVector& a)
+{
+  ComplexMatrix tmp (m);
   return tmp * a;
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 Matrix
-Matrix::operator + (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator + (const Matrix& m, const DiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return Matrix ();
     }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
-  Matrix result (*this);
-  for (int i = 0; i < a.len; i++)
-    result.elem (i, i) += a.data[i];
+  Matrix result (m);
+  int a_len = a.length ();
+  for (int i = 0; i < a_len; i++)
+    result.elem (i, i) += a.elem (i, i);
 
   return result;
 }
 
 Matrix
-Matrix::operator - (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator - (const Matrix& m, const DiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return Matrix ();
     }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
-  Matrix result (*this);
-  for (int i = 0; i < a.len; i++)
-    result.elem (i, i) -= a.data[i];
+  Matrix result (m);
+  int a_len = a.length ();
+  for (int i = 0; i < a_len; i++)
+    result.elem (i, i) -= a.elem (i, i);
 
   return result;
 }
 
 Matrix
-Matrix::operator * (const DiagMatrix& a) const
-{
-  if (nc != a.nr)
+operator * (const Matrix& m, const DiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return Matrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
-    return Matrix (nr, a.nc, 0.0);
-
-  double *c = new double [nr*a.nc];
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return Matrix (nr, a_nc, 0.0);
+
+  double *c = new double [nr*a_nc];
   double *ctmp = (double *) NULL;
 
-  for (int j = 0; j < a.len; j++)
+  int a_len = a.length ();
+  for (int j = 0; j < a_len; j++)
     {
       int idx = j * nr;
       ctmp = c + idx;
-      if (a.data[j] == 1.0)
+      if (a.elem (j, j) == 1.0)
 	{
 	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = elem (i, j);
+	    ctmp[i] = m.elem (i, j);
 	}
-      else if (a.data[j] == 0.0)
+      else if (a.elem (j, j) == 0.0)
 	{
 	  for (int i = 0; i < nr; i++)
 	    ctmp[i] = 0.0;
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = a.data[j] * elem (i, j);
+	    ctmp[i] = a.elem (j, j) * m.elem (i, j);
 	}
     }
 
-  if (a.nr < a.nc)
+  if (a_nr < a_nc)
     {
-      for (int i = nr * nc; i < nr * a.nc; i++)
+      for (int i = nr * nc; i < nr * a_nc; i++)
 	ctmp[i] = 0.0;
     }
 
-  return Matrix (c, nr, a.nc);
+  return Matrix (c, nr, a_nc);
 }
 
 ComplexMatrix
-Matrix::operator + (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator + (const Matrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  ComplexMatrix result (*this);
-  for (int i = 0; i < a.len; i++)
-    result.elem (i, i) += a.data[i];
+  ComplexMatrix result (m);
+  for (int i = 0; i < a.length (); i++)
+    result.elem (i, i) += a.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-Matrix::operator - (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator - (const Matrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  ComplexMatrix result (*this);
-  for (int i = 0; i < a.len; i++)
-    result.elem (i, i) -= a.data[i];
+  ComplexMatrix result (m);
+  for (int i = 0; i < a.length (); i++)
+    result.elem (i, i) -= a.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-Matrix::operator * (const ComplexDiagMatrix& a) const
-{
-  if (nc != a.nr)
+operator * (const Matrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexMatrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
-    return ComplexMatrix (nr, a.nc, 0.0);
-
-  Complex *c = new Complex [nr*a.nc];
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return ComplexMatrix (nr, a_nc, 0.0);
+
+  Complex *c = new Complex [nr*a_nc];
   Complex *ctmp = (Complex *) NULL;
 
-  for (int j = 0; j < a.len; j++)
+  for (int j = 0; j < a.length (); j++)
     {
       int idx = j * nr;
       ctmp = c + idx;
-      if (a.data[j] == 1.0)
+      if (a.elem (j, j) == 1.0)
 	{
 	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = elem (i, j);
+	    ctmp[i] = m.elem (i, j);
 	}
-      else if (a.data[j] == 0.0)
+      else if (a.elem (j, j) == 0.0)
 	{
 	  for (int i = 0; i < nr; i++)
 	    ctmp[i] = 0.0;
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = a.data[j] * elem (i, j);
+	    ctmp[i] = a.elem (j, j) * m.elem (i, j);
 	}
     }
 
-  if (a.nr < a.nc)
+  if (a_nr < a_nc)
     {
-      for (int i = nr * nc; i < nr * a.nc; i++)
+      for (int i = nr * nc; i < nr * a_nc; i++)
 	ctmp[i] = 0.0;
     }
 
-  return ComplexMatrix (c, nr, a.nc);
-}
-
-Matrix&
-Matrix::operator += (const DiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return *this;
-    }
-
-  for (int i = 0; i < a.len; i++)
-    elem (i, i) += a.data[i];
-
-  return *this;
-}
-
-Matrix&
-Matrix::operator -= (const DiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return *this;
-    }
-
-  for (int i = 0; i < a.len; i++)
-    elem (i, i) -= a.data[i];
-
-  return *this;
+  return ComplexMatrix (c, nr, a_nc);
 }
 
 // matrix by matrix -> matrix operations
 
 Matrix
-Matrix::operator + (const Matrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  return Matrix (add (data, a.data, len), nr, nc);
-}
-
-Matrix
-Matrix::operator - (const Matrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  return Matrix (subtract (data, a.data, len), nr, nc);
-}
-
-Matrix
-Matrix::operator * (const Matrix& a) const
-{
-  if (nc != a.nr)
+operator * (const Matrix& m, const Matrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return Matrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
-    return Matrix (nr, a.nc, 0.0);
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return Matrix (nr, a_nc, 0.0);
 
   char trans  = 'N';
   char transa = 'N';
 
   int ld  = nr;
-  int lda = a.nr;
+  int lda = a_nr;
 
   double alpha = 1.0;
   double beta  = 0.0;
-  int anc = a.nc;
-
-  double *c = new double [nr*a.nc];
-
-  F77_FCN (dgemm) (&trans, &transa, &nr, &anc, &nc, &alpha, data, &ld,
-		   a.data, &lda, &beta, c, &nr, 1L, 1L);
-
-  return Matrix (c, nr, a.nc);
+
+  double *c = new double [nr*a_nc];
+
+  F77_FCN (dgemm) (&trans, &transa, &nr, &a_nc, &nc, &alpha, m.data (),
+		   &ld, a.data (), &lda, &beta, c, &nr, 1L, 1L);
+
+  return Matrix (c, nr, a_nc);
 }
 
 ComplexMatrix
-Matrix::operator + (const ComplexMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator * (const Matrix& m, const ComplexMatrix& a)
+{
+  ComplexMatrix tmp (m);
+  return tmp * a;
+}
+
+ComplexMatrix
+operator + (const Matrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexMatrix ();
     }
 
-  return ComplexMatrix (add (data, a.data, len), nr, nc);
+  return ComplexMatrix (add (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexMatrix
-Matrix::operator - (const ComplexMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator - (const Matrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  return ComplexMatrix (subtract (data, a.data, len), nr, nc);
+  return ComplexMatrix (subtract (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexMatrix
-Matrix::operator * (const ComplexMatrix& a) const
-{
-  ComplexMatrix tmp (*this);
-  return tmp * a;
-}
-
-Matrix
-Matrix::product (const Matrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix product attempted");
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  return Matrix (multiply (data, a.data, len), nr, nc);
-}
-
-Matrix
-Matrix::quotient (const Matrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix quotient attempted");
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  return Matrix (divide (data, a.data, len), nr, nc);
-}
-
-ComplexMatrix
-Matrix::product (const ComplexMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+product (const Matrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix product attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  return ComplexMatrix (multiply (data, a.data, len), nr, nc);
+  return ComplexMatrix (multiply (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexMatrix
-Matrix::quotient (const ComplexMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+quotient (const Matrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix quotient attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  return ComplexMatrix (divide (data, a.data, len), nr, nc);
-}
-
-Matrix&
-Matrix::operator += (const Matrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-Matrix&
-Matrix::operator -= (const Matrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
+  return ComplexMatrix (divide (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 // other operations.
 
 Matrix
 map (d_d_Mapper f, const Matrix& a)
 {
   Matrix b (a);
   b.map (f);
   return b;
 }
 
 void
 Matrix::map (d_d_Mapper f)
 {
-  for (int i = 0; i < len; i++)
-    data[i] = f (data[i]);
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  for (int i = 0; i < length (); i++)
+    d[i] = f (d[i]);
 }
 
 // XXX FIXME XXX Do these really belong here?  They should maybe be
 // cleaned up a bit, no?  What about corresponding functions for the
 // Vectors?
 
 Matrix
 Matrix::all (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   Matrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, 1);
 	  retval.elem (0, 0) = 1.0;
 	  for (int j = 0; j < nc; j++)
@@ -1755,16 +1725,18 @@ Matrix::all (void) const
 	}
     }
   return retval;
 }
 
 Matrix
 Matrix::any (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   Matrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, 1);
 	  retval.elem (0, 0) = 0.0;
 	  for (int j = 0; j < nc; j++)
@@ -1808,16 +1780,20 @@ Matrix::any (void) const
     }
   return retval;
 }
 
 Matrix
 Matrix::cumprod (void) const
 {
   Matrix retval;
+
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr == 1)
     {
       retval.resize (1, nc);
       if (nc > 0)
 	{
 	  double prod = elem (0, 0);
 	  for (int j = 0; j < nc; j++)
 	    {
@@ -1860,16 +1836,20 @@ Matrix::cumprod (void) const
     }
   return retval;
 }
 
 Matrix
 Matrix::cumsum (void) const
 {
   Matrix retval;
+
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr == 1)
     {
       retval.resize (1, nc);
       if (nc > 0)
 	{
 	  double sum = elem (0, 0);
 	  for (int j = 0; j < nc; j++)
 	    {
@@ -1912,16 +1892,20 @@ Matrix::cumsum (void) const
     }
   return retval;
 }
 
 Matrix
 Matrix::prod (void) const
 {
   Matrix retval;
+
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr == 1)
     {
       retval.resize (1, 1);
       retval.elem (0, 0) = 1.0;
       for (int j = 0; j < nc; j++)
 	retval.elem (0, 0) *= elem (0, j);
     }
   else if (nc == 1)
@@ -1950,16 +1934,20 @@ Matrix::prod (void) const
     }
   return retval;
 }
 
 Matrix
 Matrix::sum (void) const
 {
   Matrix retval;
+
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr == 1)
     {
       retval.resize (1, 1);
       retval.elem (0, 0) = 0.0;
       for (int j = 0; j < nc; j++)
 	retval.elem (0, 0) += elem (0, j);
     }
   else if (nc == 1)
@@ -1988,16 +1976,20 @@ Matrix::sum (void) const
     }
   return retval;
 }
 
 Matrix
 Matrix::sumsq (void) const
 {
   Matrix retval;
+
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr == 1)
     {
       retval.resize (1, 1);
       retval.elem (0, 0) = 0.0;
       for (int j = 0; j < nc; j++)
 	{
 	  double d = elem (0, j);
 	  retval.elem (0, 0) += d * d;
@@ -2033,18 +2025,18 @@ ColumnVector
 Matrix::diag (void) const
 {
   return diag (0);
 }
 
 ColumnVector
 Matrix::diag (int k) const
 {
-  int nnr = nr;
-  int nnc = nc;
+  int nnr = rows ();
+  int nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ColumnVector d;
 
   if (nnr > 0 && nnc > 0)
@@ -2070,41 +2062,24 @@ Matrix::diag (int k) const
 	}
     }
   else
     cerr << "diag: requested diagonal out of range\n";
 
   return d;
 }
 
-// unary operations
-
-Matrix
-Matrix::operator - (void) const
-{
-  return Matrix (negate (data, len), nr, nc);
-}
-
-Matrix
-Matrix::operator ! (void) const
-{
-  Matrix b (nr, nc);
-
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
-      b.elem (i, j) = ! elem (i, j);
-
-  return b;
-}
-
 ColumnVector
 Matrix::row_min (void) const
 {
   ColumnVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
 
       for (int i = 0; i < nr; i++)
 	{
 	  double res = elem (i, 0);
 	  for (int j = 1; j < nc; j++)
@@ -2117,16 +2092,19 @@ Matrix::row_min (void) const
   return result;
 }
 
 ColumnVector
 Matrix::row_min_loc (void) const
 {
   ColumnVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
           int res = 0;
           for (int j = 0; j < nc; j++)
@@ -2139,16 +2117,19 @@ Matrix::row_min_loc (void) const
   return result;
 }
 
 ColumnVector
 Matrix::row_max (void) const
 {
   ColumnVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
 
       for (int i = 0; i < nr; i++)
 	{
 	  double res = elem (i, 0);
 	  for (int j = 1; j < nc; j++)
@@ -2161,16 +2142,19 @@ Matrix::row_max (void) const
   return result;
 }
 
 ColumnVector
 Matrix::row_max_loc (void) const
 {
   ColumnVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
           int res = 0;
           for (int j = 0; j < nc; j++)
@@ -2183,16 +2167,19 @@ Matrix::row_max_loc (void) const
   return result;
 }
 
 RowVector
 Matrix::column_min (void) const
 {
   RowVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
 	{
 	  double res = elem (0, j);
 	  for (int i = 1; i < nr; i++)
@@ -2204,16 +2191,19 @@ Matrix::column_min (void) const
 
   return result;
 }
 RowVector
 Matrix::column_min_loc (void) const
 {
   RowVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
           int res = 0;
           for (int i = 0; i < nr; i++)
@@ -2227,16 +2217,19 @@ Matrix::column_min_loc (void) const
 }
 
 
 RowVector
 Matrix::column_max (void) const
 {
   RowVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
 	{
 	  double res = elem (0, j);
 	  for (int i = 1; i < nr; i++)
@@ -2249,16 +2242,19 @@ Matrix::column_max (void) const
   return result;
 }
 
 RowVector
 Matrix::column_max_loc (void) const
 {
   RowVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
           int res = 0;
           for (int i = 0; i < nr; i++)
@@ -2270,30 +2266,30 @@ Matrix::column_max_loc (void) const
 
   return result;
 }
 
 ostream&
 operator << (ostream& os, const Matrix& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.nr; i++)
+  for (int i = 0; i < a.rows (); i++)
     {
-      for (int j = 0; j < a.nc; j++)
+      for (int j = 0; j < a.cols (); j++)
 	os << " " /* setw (field_width) */ << a.elem (i, j);
       os << "\n";
     }
   return os;
 }
 
 istream&
 operator >> (istream& is, Matrix& a)
 {
   int nr = a.rows ();
-  int nc = a.columns ();
+  int nc = a.cols ();
 
   if (nr < 1 || nc < 1)
     is.clear (ios::badbit);
   else
     {
       double tmp;
       for (int i = 0; i < nr; i++)
 	for (int j = 0; j < nc; j++)
@@ -2308,232 +2304,39 @@ operator >> (istream& is, Matrix& a)
 
   return is;
 }
 
 /*
  * Complex Matrix class
  */
 
-ComplexMatrix::ComplexMatrix (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't construct matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = nr * nc;
-  if (len > 0)
-    data = new Complex [len];
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexMatrix::ComplexMatrix (int r, int c, double val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't construct matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = nr * nc;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexMatrix::ComplexMatrix (int r, int c, const Complex& val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't construct matrix with negative dimensions");
-      nr = 0;
-      nc = 0;
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  nr = r;
-  nc = c;
-  len = nr * nc;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
 ComplexMatrix::ComplexMatrix (const Matrix& a)
-{
-  nr = a.nr;
-  nc = a.nc;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexMatrix::ComplexMatrix (const ComplexMatrix& a)
-{
-  nr = a.nr;
-  nc = a.nc;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
+  : Array2<Complex> (a.rows (), a.cols ())
+{
+  for (int j = 0; j < cols (); j++)
+    for (int i = 0; i < rows (); i++)
+      elem (i, j) = a.elem (i, j);
 }
 
 ComplexMatrix::ComplexMatrix (const DiagMatrix& a)
-{
-  nr = a.nr;
-  nc = a.nc;
-  len = nr * nc;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, 0.0);
-      for (int i = 0; i < a.len; i++)
-	data[nr*i+i] = a.data[i];
-    }
-  else
-    data = (Complex *) NULL;
+  : Array2<Complex> (a.rows (), a.cols ())
+{
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) = a.elem (i, i);
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexDiagMatrix& a)
-{
-  nr = a.nr;
-  nc = a.nc;
-  len = nr * nc;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, 0.0);
-      for (int i = 0; i < a.len; i++)
-	data[nr*i+i] = a.data[i];
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexMatrix::ComplexMatrix (double a)
-{
-  nr = 1;
-  nc = 1;
-  len = 1;
-  data = new Complex [1];
-  data[0] = a;
-}
-
-ComplexMatrix::ComplexMatrix (const Complex& a)
-{
-  nr = 1;
-  nc = 1;
-  len = 1;
-  data = new Complex [1];
-  data[0] = Complex (a);
-}
-
-ComplexMatrix&
-ComplexMatrix::operator = (const Matrix& a)
-{
-  delete [] data;
-  nr = a.nr;
-  nc = a.nc;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::operator = (const ComplexMatrix& a)
-{
-  if (this != &a)
-    {
-      delete [] data;
-      nr = a.nr;
-      nc = a.nc;
-      len = a.len;
-      if (len > 0)
-	{
-	  data = new Complex [len];
-	  copy (data, a.data, len);
-	}
-      else
-	data = (Complex *) NULL;
-    }
-  return *this;
-}
-
-Complex&
-ComplexMatrix::checkelem (int r, int c)
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static Complex foo (0.0);
-      return foo;
-    }
-#endif
-
-  return elem (r, c);
-}
-
-Complex
-ComplexMatrix::checkelem (int r, int c) const
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return Complex (0.0);
-    }
-#endif
-
-  return elem (r, c);
-}
-
+  : Array2<Complex> (a.rows (), a.cols ())
+{
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) = a.elem (i, i);
+}
+
+#if 0
 ComplexMatrix&
 ComplexMatrix::resize (int r, int c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimensions");
       return *this;
@@ -2632,175 +2435,198 @@ ComplexMatrix::resize (int r, int c, con
   delete [] data;
   nr = r;
   nc = c;
   len = new_len;
   data = new_data;
 
   return *this;
 }
+#endif
 
 int
 ComplexMatrix::operator == (const ComplexMatrix& a) const
 {
-  if (nr != a.nr || nc != a.nc)
+  if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
-  return equal (data, a.data, len);
+  return equal (data (), a.data (), length ());
 }
 
 int
 ComplexMatrix::operator != (const ComplexMatrix& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexMatrix&
 ComplexMatrix::insert (const Matrix& a, int r, int c)
 {
-  if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (r < 0 || r + a_nr - 1 > rows () || c < 0 || c + a_nc - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int j = 0; j < a.nc; j++)
-    for (int i = 0; i < a.nr; i++)
+  for (int j = 0; j < a_nc; j++)
+    for (int i = 0; i < a_nr; i++)
       elem (r+i, c+j) = a.elem (i, j);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const RowVector& a, int r, int c)
 {
-  if (r < 0 || r >= nr || c < 0 || c + a.len - 1 > nc)
+  int a_len = a.length ();
+  if (r < 0 || r >= rows () || c < 0 || c + a_len - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r, c+i) = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ColumnVector& a, int r, int c)
 {
-  if (r < 0 || r + a.len - 1 > nr || c < 0 || c >= nc)
+  int a_len = a.length ();
+  if (r < 0 || r + a_len - 1 > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r+i, c) = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r+i, c) = a.elem (i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const DiagMatrix& a, int r, int c)
 {
-  if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
+  if (r < 0 || r + a.rows () - 1 > rows ()
+      || c < 0 || c + a.cols () - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r+i, c+i) = a.data[i];
+  for (int i = 0; i < a.length (); i++)
+    elem (r+i, c+i) = a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexMatrix& a, int r, int c)
 {
-  if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (r < 0 || r + a_nr - 1 > rows () || c < 0 || c + a_nc - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int j = 0; j < a.nc; j++)
-    for (int i = 0; i < a.nr; i++)
+  for (int j = 0; j < a_nc; j++)
+    for (int i = 0; i < a_nr; i++)
       elem (r+i, c+j) = a.elem (i, j);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexRowVector& a, int r, int c)
 {
-  if (r < 0 || r >= nr || c < 0 || c + a.len - 1 > nc)
+  int a_len = a.length ();
+  if (r < 0 || r >= rows () || c < 0 || c + a_len - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r, c+i) = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexColumnVector& a, int r, int c)
 {
-  if (r < 0 || r + a.len - 1 > nr || c < 0 || c >= nc)
+  int a_len = a.length ();
+  if (r < 0 || r + a_len - 1 > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r+i, c) = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (r+i, c) = a.elem (i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexDiagMatrix& a, int r, int c)
 {
-  if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
+  if (r < 0 || r + a.rows () - 1 > rows ()
+      || c < 0 || c + a.cols () - 1 > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    elem (r+i, c+i) = a.data[i];
+  for (int i = 0; i < a.length (); i++)
+    elem (r+i, c+i) = a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (double val)
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nr > 0 && nc > 0)
-    copy (data, len, val);
+    for (int j = 0; j < nc; j++)
+      for (int i = 0; i < nr; i++)
+	elem (i, j) = val;
+
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (const Complex& val)
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nr > 0 && nc > 0)
-    copy (data, len, val);
+    for (int j = 0; j < nc; j++)
+      for (int i = 0; i < nr; i++)
+	elem (i, j) = val;
+
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (double val, int r1, int c1, int r2, int c2)
 {
+  int nr = rows ();
+  int nc = rows ();
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
@@ -2811,16 +2637,18 @@ ComplexMatrix::fill (double val, int r1,
       elem (i, j) = val;
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (const Complex& val, int r1, int c1, int r2, int c2)
 {
+  int nr = rows ();
+  int nc = rows ();
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
@@ -2831,328 +2659,368 @@ ComplexMatrix::fill (const Complex& val,
       elem (i, j) = val;
 
   return *this;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const Matrix& a) const
 {
-  if (nr != a.nr)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
-  ComplexMatrix retval (nr, nc + a.nc);
+  ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const RowVector& a) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
-  ComplexMatrix retval (nr, nc + a.len);
+  ComplexMatrix retval (nr, nc + a.length ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ColumnVector& a) const
 {
-  if (nr != a.len)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.length ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const DiagMatrix& a) const
 {
-  if (nr != a.nr)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
-  ComplexMatrix retval (nr, nc + a.nc);
+  ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexMatrix& a) const
 {
-  if (nr != a.nr)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
-  ComplexMatrix retval (nr, nc + a.nc);
+  ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexRowVector& a) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
-  ComplexMatrix retval (nr, nc + a.len);
+  ComplexMatrix retval (nr, nc + a.length ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexColumnVector& a) const
 {
-  if (nr != a.len)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.length ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexDiagMatrix& a) const
 {
-  if (nr != a.nr)
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
   int nc_insert = nc;
-  ComplexMatrix retval (nr, nc + a.nc);
+  ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const Matrix& a) const
 {
-  if (nc != a.nc)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
   int nr_insert = nr;
-  ComplexMatrix retval (nr + a.nr, nc);
+  ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const RowVector& a) const
 {
-  if (nc != a.len)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ColumnVector& a) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
   int nr_insert = nr;
-  ComplexMatrix retval (nr + a.len, nc);
+  ComplexMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const DiagMatrix& a) const
 {
-  if (nc != a.nc)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
   int nr_insert = nr;
-  ComplexMatrix retval (nr + a.nr, nc);
+  ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexMatrix& a) const
 {
-  if (nc != a.nc)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
   int nr_insert = nr;
-  ComplexMatrix retval (nr + a.nr, nc);
+  ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexRowVector& a) const
 {
-  if (nc != a.len)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexColumnVector& a) const
 {
+  int nr = rows ();
+  int nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
   int nr_insert = nr;
-  ComplexMatrix retval (nr + a.len, nc);
+  ComplexMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexDiagMatrix& a) const
 {
-  if (nc != a.nc)
+  int nr = rows ();
+  int nc = cols ();
+  if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
   int nr_insert = nr;
-  ComplexMatrix retval (nr + a.nr, nc);
+  ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::hermitian (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   ComplexMatrix result;
-  if (len > 0)
+  if (length () > 0)
     {
       result.resize (nc, nr);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.data[nc*i+j] = conj (data[nr*j+i]);
+	  result.elem (j, i) = conj (elem (i, j));
     }
   return result;
 }
 
 ComplexMatrix
 ComplexMatrix::transpose (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   ComplexMatrix result (nc, nr);
-  if (len > 0)
+  if (length () > 0)
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result.data[nc*i+j] = data[nr*j+i];
+	  result.elem (j, i) = elem (i, j);
     }
   return result;
 }
 
 Matrix
 real (const ComplexMatrix& a)
 {
+  int a_len = a.length ();
   Matrix retval;
-  if (a.len > 0)
-    retval = Matrix (real_dup (a.data, a.len), a.nr, a.nc);
+  if (a_len > 0)
+    retval = Matrix (real_dup (a.data (), a_len), a.rows (), a.cols ());
   return retval;
 }
 
 Matrix
 imag (const ComplexMatrix& a)
 {
+  int a_len = a.length ();
   Matrix retval;
-  if (a.len > 0)
-    retval = Matrix (imag_dup (a.data, a.len), a.nr, a.nc);
+  if (a_len > 0)
+    retval = Matrix (imag_dup (a.data (), a_len), a.rows (), a.cols ());
   return retval;
 }
 
 ComplexMatrix
 conj (const ComplexMatrix& a)
 {
+  int a_len = a.length ();
   ComplexMatrix retval;
-  if (a.len > 0)
-    retval = ComplexMatrix (conj_dup (a.data, a.len), a.nr, a.nc);
+  if (a_len > 0)
+    retval = ComplexMatrix (conj_dup (a.data (), a_len), a.rows (),
+			    a.cols ());
   return retval;
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexMatrix
 ComplexMatrix::extract (int r1, int c1, int r2, int c2) const
 {
@@ -3161,34 +3029,35 @@ ComplexMatrix::extract (int r1, int c1, 
 
   int new_r = r2 - r1 + 1;
   int new_c = c2 - c1 + 1;
 
   ComplexMatrix result (new_r, new_c);
 
   for (int j = 0; j < new_c; j++)
     for (int i = 0; i < new_r; i++)
-      result.data[new_r*j+i] = elem (r1+i, c1+j);
+      result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // extract row or column i.
 
 ComplexRowVector
 ComplexMatrix::row (int i) const
 {
-  if (i < 0 || i >= nr)
+  int nc = cols ();
+  if (i < 0 || i >= rows ())
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 
   ComplexRowVector retval (nc);
-  for (int j = 0; j < nc; j++)
+  for (int j = 0; j < cols (); j++)
     retval.elem (j) = elem (i, j);
 
   return retval;
 }
 
 ComplexRowVector
 ComplexMatrix::row (char *s) const
 {
@@ -3197,28 +3066,29 @@ ComplexMatrix::row (char *s) const
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (0);
   else if (c == 'l' || c == 'L')
-    return row (nr - 1);
+    return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 }
 
 ComplexColumnVector
 ComplexMatrix::column (int i) const
 {
-  if (i < 0 || i >= nc)
+  int nr = rows ();
+  if (i < 0 || i >= cols ())
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector ();
     }
 
   ComplexColumnVector retval (nr);
   for (int j = 0; j < nr; j++)
     retval.elem (j) = elem (j, i);
@@ -3234,122 +3104,128 @@ ComplexMatrix::column (char *s) const
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
-    return column (nc - 1);
+    return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector ();
     }
 }
 
 ComplexMatrix
+ComplexMatrix::inverse (void) const
+{
+  int info;
+  double rcond; return inverse (info, rcond);
+}
+
+ComplexMatrix
+ComplexMatrix::inverse (int& info) const
+{
+  double rcond;
+  return inverse (info, rcond);
+}
+
+ComplexMatrix
 ComplexMatrix::inverse (int& info, double& rcond) const
 {
+  int nr = rows ();
+  int nc = cols ();
+  int len = length ();
   if (nr != nc)
     {
       (*current_liboctave_error_handler) ("inverse requires square matrix");
       return ComplexMatrix ();
     }
 
   info = 0;
 
   int *ipvt = new int [nr];
   Complex *z = new Complex [nr];
-  Complex *tmp_data = dup (data, len);
+  Complex *tmp_data = dup (data (), len);
 
   F77_FCN (zgeco) (tmp_data, &nr, &nc, ipvt, &rcond, z);
 
   if (rcond + 1.0 == 1.0)
     {
       info = -1;
-      copy (tmp_data, data, len);  // Restore contents.
+      copy (tmp_data, data (), len);  // Restore contents.
     }
   else
     {
       int job = 1;
       Complex dummy;
 
       F77_FCN (zgedi) (tmp_data, &nr, &nc, ipvt, &dummy, z, &job);
     }
 
   delete [] ipvt;
   delete [] z;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
 ComplexMatrix
-ComplexMatrix::inverse (int& info) const
-{
-  double rcond;
-  return inverse (info, rcond);
-}
-
-ComplexMatrix
-ComplexMatrix::inverse (void) const
-{
-  int info;
-  double rcond;
-  return inverse (info, rcond);
-}
-
-ComplexMatrix
 ComplexMatrix::fourier (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   int npts, nsamples;
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
-  Complex *tmp_data = dup (data, len);
+  Complex *tmp_data = dup (data (), length ());
 
   F77_FCN (cffti) (&npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftf) (&npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   int npts, nsamples;
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
-  Complex *tmp_data = dup (data, len);
+  Complex *tmp_data = dup (data (), length ());
 
   F77_FCN (cffti) (&npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftb) (&npts, &tmp_data[npts*j], wsave);
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
@@ -3374,29 +3250,31 @@ ComplexMatrix::determinant (int& info) c
   return determinant (info, rcond);
 }
 
 ComplexDET
 ComplexMatrix::determinant (int& info, double& rcond) const
 {
   ComplexDET retval;
 
+  int nr = rows ();
+  int nc = cols ();
   if (nr == 0 || nc == 0)
     {
       Complex d[2];
       d[0] = 1.0;
       d[1] = 0.0;
       return ComplexDET (d);
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
-  Complex *tmp_data = dup (data, len);
+  Complex *tmp_data = dup (data (), length ());
 
   F77_FCN (zgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
 
   if (rcond + 1.0 == 1.0)
     {
       info = -1;
     }
   else
@@ -3445,83 +3323,64 @@ ComplexMatrix::solve (const ComplexMatri
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, int& info) const
 {
   double rcond;
   return solve (b, info, rcond);
 }
-
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, int& info, double& rcond) const
 {
   ComplexMatrix retval;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.nr)
+  int nr = rows ();
+  int nc = cols ();
+  int b_nr = b.rows ();
+  int b_nc = b.cols ();
+  if (nr == 0 || nc == 0 || nr != nc || nr != b_nr)
     {
       (*current_liboctave_error_handler)
 	("matrix dimension mismatch in solution of linear equations");
       return ComplexMatrix ();
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
-  Complex *tmp_data = dup (data, len);
+  Complex *tmp_data = dup (data (), length ());
 
   F77_FCN (zgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
 
   if (rcond + 1.0 == 1.0)
     {
       info = -2;
     }
   else
     {
       int job = 0;
 
-      Complex *result = dup (b.data, b.len);
-
-      for (int j = 0; j < b.nc; j++)
+      Complex *result = dup (b.data (), b.length ());
+
+      for (int j = 0; j < b_nc; j++)
 	F77_FCN (zgesl) (tmp_data, &nr, &nr, ipvt, &result[nr*j], &job);
 
-      retval = ComplexMatrix (result, b.nr, b.nc);
+      retval = ComplexMatrix (result, b_nr, b_nc);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
   return retval;
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b) const
-{
-  int info;
-  double rcond;
-  return solve (b, info, rcond);
-}
-
-ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, int& info) const
-{
-  double rcond;
-  return solve (b, info, rcond);
-}
-
-ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, int& info, double& rcond) const
-{
-  ComplexColumnVector tmp (b);
-  return solve (tmp, info, rcond);
-}
-
-ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   int info;
   double rcond;
   return solve (b, info, rcond);
 }
 
 ComplexColumnVector
@@ -3532,76 +3391,57 @@ ComplexMatrix::solve (const ComplexColum
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, int& info,
 		      double& rcond) const
 {
   ComplexColumnVector retval;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.len)
+  int nr = rows ();
+  int nc = cols ();
+  int b_len = b.length ();
+  if (nr == 0 || nc == 0 || nr != nc || nr != b_len)
     {
       (*current_liboctave_error_handler)
 	("matrix dimension mismatch in solution of linear equations");
       return ComplexColumnVector ();
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
-  Complex *tmp_data = dup (data, len);
+  Complex *tmp_data = dup (data (), length ());
 
   F77_FCN (zgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
 
   if (rcond + 1.0 == 1.0)
     {
       info = -2;
     }
   else
     {
       int job = 0;
 
-      Complex *result = dup (b.data, b.len);
+      Complex *result = dup (b.data (), b_len);
 
       F77_FCN (zgesl) (tmp_data, &nr, &nr, ipvt, result, &job);
 
-      retval = ComplexColumnVector (result, b.len);
+      retval = ComplexColumnVector (result, b_len);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
   return retval;
 }
 
 ComplexMatrix
-ComplexMatrix::lssolve (const Matrix& b) const
-{
-  int info;
-  int rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexMatrix
-ComplexMatrix::lssolve (const Matrix& b, int& info) const
-{
-  int rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexMatrix
-ComplexMatrix::lssolve (const Matrix& b, int& info, int& rank) const
-{
-  ComplexMatrix tmp (b);
-  return lssolve (tmp, info, rank);
-}
-
-ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b) const
 {
   int info;
   int rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
@@ -3609,29 +3449,29 @@ ComplexMatrix::lssolve (const ComplexMat
 {
   int rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, int& info, int& rank) const
 {
-  int nrhs = b.nc;
-
-  int m = nr;
-  int n = nc;
-
-  if (m == 0 || n == 0 || m != b.nr)
+  int nrhs = b.cols ();
+
+  int m = rows ();
+  int n = cols ();
+
+  if (m == 0 || n == 0 || m != b.rows ())
     {
       (*current_liboctave_error_handler)
 	("matrix dimension mismatch solution of linear equations");
       return Matrix ();
     }
 
-  Complex *tmp_data = dup (data, len);
+  Complex *tmp_data = dup (data (), length ());
 
   int nrr = m > n ? m : n;
   ComplexMatrix result (nrr, nrhs);
 
   int i, j;
   for (j = 0; j < nrhs; j++)
     for (i = 0; i < m; i++)
       result.elem (i, j) = b.elem (i, j);
@@ -3665,38 +3505,16 @@ ComplexMatrix::lssolve (const ComplexMat
   delete [] s;
   delete [] work;
   delete [] rwork;
 
   return retval;
 }
 
 ComplexColumnVector
-ComplexMatrix::lssolve (const ColumnVector& b) const
-{
-  int info;
-  int rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexColumnVector
-ComplexMatrix::lssolve (const ColumnVector& b, int& info) const
-{
-  int rank;
-  return lssolve (b, info, rank);
-}
-
-ComplexColumnVector
-ComplexMatrix::lssolve (const ColumnVector& b, int& info, int& rank) const
-{
-  ComplexColumnVector tmp (b);
-  return lssolve (tmp, info, rank);
-}
-
-ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b) const
 {
   int info;
   int rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
@@ -3707,27 +3525,27 @@ ComplexMatrix::lssolve (const ComplexCol
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, int& info,
 			int& rank) const
 {
   int nrhs = 1;
 
-  int m = nr;
-  int n = nc;
-
-  if (m == 0 || n == 0 || m != b.len)
+  int m = rows ();
+  int n = cols ();
+
+  if (m == 0 || n == 0 || m != b.length ())
     {
       (*current_liboctave_error_handler)
 	("matrix dimension mismatch solution of least squares problem");
       return ComplexColumnVector ();
     }
 
-  Complex *tmp_data = dup (data, len);
+  Complex *tmp_data = dup (data (), length ());
 
   int nrr = m > n ? m : n;
   ComplexColumnVector result (nrr);
 
   int i;
   for (i = 0; i < m; i++)
     result.elem (i) = b.elem (i);
 
@@ -3758,129 +3576,259 @@ ComplexMatrix::lssolve (const ComplexCol
   delete [] tmp_data;
   delete [] s;
   delete [] work;
   delete [] rwork;
 
   return retval;
 }
 
+// matrix by diagonal matrix -> matrix operations
+
+ComplexMatrix&
+ComplexMatrix::operator += (const DiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return ComplexMatrix ();
+    }
+
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) += a.elem (i, i);
+
+  return *this;
+}
+
+ComplexMatrix&
+ComplexMatrix::operator -= (const DiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return ComplexMatrix ();
+    }
+
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) -= a.elem (i, i);
+
+  return *this;
+}
+
+ComplexMatrix&
+ComplexMatrix::operator += (const ComplexDiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return ComplexMatrix ();
+    }
+
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) += a.elem (i, i);
+
+  return *this;
+}
+
+ComplexMatrix&
+ComplexMatrix::operator -= (const ComplexDiagMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return ComplexMatrix ();
+    }
+
+  for (int i = 0; i < a.length (); i++)
+    elem (i, i) -= a.elem (i, i);
+
+  return *this;
+}
+
+// matrix by matrix -> matrix operations
+
+ComplexMatrix&
+ComplexMatrix::operator += (const Matrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), length ());
+  return *this;
+}
+
+ComplexMatrix&
+ComplexMatrix::operator -= (const Matrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), length ());
+  return *this;
+}
+
+ComplexMatrix&
+ComplexMatrix::operator += (const ComplexMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), length ());
+  return *this;
+}
+
+ComplexMatrix&
+ComplexMatrix::operator -= (const ComplexMatrix& a)
+{
+  int nr = rows ();
+  int nc = cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
+
+  if (nr == 0 || nc == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), length ());
+  return *this;
+}
+
+// unary operations
+
+Matrix
+ComplexMatrix::operator ! (void) const
+{
+  return Matrix (not (data (), length ()), rows (), cols ());
+}
+
 // matrix by scalar -> matrix operations
 
 ComplexMatrix
-ComplexMatrix::operator + (double s) const
-{
-  return ComplexMatrix (add (data, len, s), nr, nc);
-}
-
-ComplexMatrix
-ComplexMatrix::operator - (double s) const
-{
-  return ComplexMatrix (subtract (data, len, s), nr, nc);
-}
-
-ComplexMatrix
-ComplexMatrix::operator * (double s) const
-{
-  return ComplexMatrix (multiply (data, len, s), nr, nc);
+operator + (const ComplexMatrix& a, double s)
+{
+  return ComplexMatrix (add (a.data (), a.length (), s),
+			a.rows (), a.cols ());
 }
 
 ComplexMatrix
-ComplexMatrix::operator / (double s) const
-{
-  return ComplexMatrix (divide (data, len, s), nr, nc);
-}
-
-ComplexMatrix
-ComplexMatrix::operator + (const Complex& s) const
-{
-  return ComplexMatrix (add (data, len, s), nr, nc);
+operator - (const ComplexMatrix& a, double s)
+{
+  return ComplexMatrix (subtract (a.data (), a.length (), s),
+			a.rows (), a.cols ());
 }
 
 ComplexMatrix
-ComplexMatrix::operator - (const Complex& s) const
-{
-  return ComplexMatrix (subtract (data, len, s), nr, nc);
+operator * (const ComplexMatrix& a, double s)
+{
+  return ComplexMatrix (multiply (a.data (), a.length (), s),
+			a.rows (), a.cols ());
 }
 
 ComplexMatrix
-ComplexMatrix::operator * (const Complex& s) const
-{
-  return ComplexMatrix (multiply (data, len, s), nr, nc);
-}
-
-ComplexMatrix
-ComplexMatrix::operator / (const Complex& s) const
-{
-  return ComplexMatrix (divide (data, len, s), nr, nc);
+operator / (const ComplexMatrix& a, double s)
+{
+  return ComplexMatrix (divide (a.data (), a.length (), s),
+			a.rows (), a.cols ());
 }
 
 // scalar by matrix -> matrix operations
 
 ComplexMatrix
 operator + (double s, const ComplexMatrix& a)
 {
-  return ComplexMatrix (add (a.data, a.len, s), a.nr, a.nc);
+  return ComplexMatrix (add (a.data (), a.length (), s), a.rows (),
+			a.cols ());
 }
 
 ComplexMatrix
 operator - (double s, const ComplexMatrix& a)
 {
-  return ComplexMatrix (subtract (s, a.data, a.len), a.nr, a.nc);
+  return ComplexMatrix (subtract (s, a.data (), a.length ()),
+			a.rows (), a.cols ());
 }
 
 ComplexMatrix
 operator * (double s, const ComplexMatrix& a)
 {
-  return ComplexMatrix (multiply (a.data, a.len, s), a.nr, a.nc);
+  return ComplexMatrix (multiply (a.data (), a.length (), s),
+			a.rows (), a.cols ());
 }
 
 ComplexMatrix
 operator / (double s, const ComplexMatrix& a)
 {
-  return ComplexMatrix (divide (s, a.data, a.len), a.nr, a.nc);
-}
-
-ComplexMatrix
-operator + (const Complex& s, const ComplexMatrix& a)
-{
-  return ComplexMatrix (add (s, a.data, a.len), a.nr, a.nc);
-}
-
-ComplexMatrix
-operator - (const Complex& s, const ComplexMatrix& a)
-{
-  return ComplexMatrix (subtract (s, a.data, a.len), a.nr, a.nc);
-}
-
-ComplexMatrix
-operator * (const Complex& s, const ComplexMatrix& a)
-{
-  return ComplexMatrix (multiply (s, a.data, a.len), a.nr, a.nc);
-}
-
-ComplexMatrix
-operator / (const Complex& s, const ComplexMatrix& a)
-{
-  return ComplexMatrix (divide (s, a.data, a.len), a.nr, a.nc);
+  return ComplexMatrix (divide (s, a.data (), a.length ()),
+			a.rows (), a.cols ());
 }
 
 // matrix by column vector -> column vector operations
 
 ComplexColumnVector
-ComplexMatrix::operator * (const ColumnVector& a) const
+operator * (const ComplexMatrix& m, const ColumnVector& a)
 {
   ComplexColumnVector tmp (a);
-  return *this * tmp;
+  return m * tmp;
 }
 
 ComplexColumnVector
-ComplexMatrix::operator * (const ComplexColumnVector& a) const
-{
-  if (nc != a.len)
+operator * (const ComplexMatrix& m, const ComplexColumnVector& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
@@ -3888,540 +3836,359 @@ ComplexMatrix::operator * (const Complex
   char trans = 'N';
   int ld = nr;
   Complex alpha (1.0);
   Complex beta (0.0);
   int i_one = 1;
 
   Complex *y = new Complex [nr];
 
-  F77_FCN (zgemv) (&trans, &nr, &nc, &alpha, data, &ld, a.data,
+  F77_FCN (zgemv) (&trans, &nr, &nc, &alpha, m.data (), &ld, a.data (),
 		   &i_one, &beta, y, &i_one, 1L); 
 
   return ComplexColumnVector (y, nr);
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 ComplexMatrix
-ComplexMatrix::operator + (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator + (const ComplexMatrix& m, const DiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  ComplexMatrix result (*this);
-  for (int i = 0; i < a.len; i++)
-    result.elem (i, i) += a.data[i];
+  ComplexMatrix result (m);
+  for (int i = 0; i < a.length (); i++)
+    result.elem (i, i) += a.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-ComplexMatrix::operator - (const DiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator - (const ComplexMatrix& m, const DiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  ComplexMatrix result (*this);
-  for (int i = 0; i < a.len; i++)
-    result.elem (i, i) -= a.data[i];
+  ComplexMatrix result (m);
+  for (int i = 0; i < a.length (); i++)
+    result.elem (i, i) -= a.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-ComplexMatrix::operator * (const DiagMatrix& a) const
-{
-  if (nc != a.nr)
+operator * (const ComplexMatrix& m, const DiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nc = a.cols ();
+  if (nc != a.rows ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexMatrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
+  if (nr == 0 || nc == 0 || a_nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
-  Complex *c = new Complex [nr*a.nc];
+  Complex *c = new Complex [nr*a_nc];
   Complex *ctmp = (Complex *) NULL;
 
-  for (int j = 0; j < a.len; j++)
+  for (int j = 0; j < a.length (); j++)
     {
       int idx = j * nr;
       ctmp = c + idx;
-      if (a.data[j] == 1.0)
+      if (a.elem (j, j) == 1.0)
 	{
 	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = elem (i, j);
+	    ctmp[i] = m.elem (i, j);
 	}
-      else if (a.data[j] == 0.0)
+      else if (a.elem (j, j) == 0.0)
 	{
 	  for (int i = 0; i < nr; i++)
 	    ctmp[i] = 0.0;
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = a.data[j] * elem (i, j);
+	    ctmp[i] = a.elem (j, j) * m.elem (i, j);
 	}
     }
 
-  if (a.nr < a.nc)
+  if (a.rows () < a_nc)
     {
-      for (int i = nr * nc; i < nr * a.nc; i++)
+      for (int i = nr * nc; i < nr * a_nc; i++)
 	ctmp[i] = 0.0;
     }
 
-  return ComplexMatrix (c, nr, a.nc);
+  return ComplexMatrix (c, nr, a_nc);
 }
 
 ComplexMatrix
-ComplexMatrix::operator + (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator + (const ComplexMatrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  ComplexMatrix result (*this);
-  for (int i = 0; i < a.len; i++)
-    result.elem (i, i) += a.data[i];
+  ComplexMatrix result (m);
+  for (int i = 0; i < a.length (); i++)
+    result.elem (i, i) += a.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-ComplexMatrix::operator - (const ComplexDiagMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator - (const ComplexMatrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  ComplexMatrix result (*this);
-  for (int i = 0; i < a.len; i++)
-    result.elem (i, i) -= a.data[i];
+  ComplexMatrix result (m);
+  for (int i = 0; i < a.length (); i++)
+    result.elem (i, i) -= a.elem (i, i);
 
   return result;
 }
 
 ComplexMatrix
-ComplexMatrix::operator * (const ComplexDiagMatrix& a) const
-{
-  if (nc != a.nr)
+operator * (const ComplexMatrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nc = a.cols ();
+  if (nc != a.rows ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexMatrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
+  if (nr == 0 || nc == 0 || a_nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
-  Complex *c = new Complex [nr*a.nc];
+  Complex *c = new Complex [nr*a_nc];
   Complex *ctmp = (Complex *) NULL;
 
-  for (int j = 0; j < a.len; j++)
+  for (int j = 0; j < a.length (); j++)
     {
       int idx = j * nr;
       ctmp = c + idx;
-      if (a.data[j] == 1.0)
+      if (a.elem (j, j) == 1.0)
 	{
 	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = elem (i, j);
+	    ctmp[i] = m.elem (i, j);
 	}
-      else if (a.data[j] == 0.0)
+      else if (a.elem (j, j) == 0.0)
 	{
 	  for (int i = 0; i < nr; i++)
 	    ctmp[i] = 0.0;
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = a.data[j] * elem (i, j);
+	    ctmp[i] = a.elem (j, j) * m.elem (i, j);
 	}
     }
 
-  if (a.nr < a.nc)
+  if (a.rows () < a_nc)
     {
-      for (int i = nr * nc; i < nr * a.nc; i++)
+      for (int i = nr * nc; i < nr * a_nc; i++)
 	ctmp[i] = 0.0;
     }
 
-  return ComplexMatrix (c, nr, a.nc);
-}
-
-ComplexMatrix&
-ComplexMatrix::operator += (const DiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return ComplexMatrix ();
-    }
-
-  for (int i = 0; i < a.len; i++)
-    elem (i, i) += a.data[i];
-
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::operator -= (const DiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
-      return ComplexMatrix ();
-    }
-
-  for (int i = 0; i < a.len; i++)
-    elem (i, i) -= a.data[i];
-
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::operator += (const ComplexDiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return ComplexMatrix ();
-    }
-
-  for (int i = 0; i < a.len; i++)
-    elem (i, i) += a.data[i];
-
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::operator -= (const ComplexDiagMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
-      return ComplexMatrix ();
-    }
-
-  for (int i = 0; i < a.len; i++)
-    elem (i, i) -= a.data[i];
-
-  return *this;
+  return ComplexMatrix (c, nr, a_nc);
 }
 
 // matrix by matrix -> matrix operations
 
 ComplexMatrix
-ComplexMatrix::operator + (const Matrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (add (data, a.data, len), nr, nc);
-}
-
-ComplexMatrix
-ComplexMatrix::operator - (const Matrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (subtract (data, a.data, len), nr, nc);
-}
-
-ComplexMatrix
-ComplexMatrix::operator * (const Matrix& a) const
-{
-  ComplexMatrix tmp (a);
-  return *this * tmp;
-}
-
-ComplexMatrix
-ComplexMatrix::operator + (const ComplexMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator + (const ComplexMatrix& m, const Matrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  return ComplexMatrix (add (data, a.data, len), nr, nc);
+  return ComplexMatrix (add (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexMatrix
-ComplexMatrix::operator - (const ComplexMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+operator - (const ComplexMatrix& m, const Matrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  return ComplexMatrix (subtract (data, a.data, len), nr, nc);
+  return ComplexMatrix (subtract (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexMatrix
-ComplexMatrix::operator * (const ComplexMatrix& a) const
-{
-  if (nc != a.nr)
+operator * (const ComplexMatrix& m, const Matrix& a)
+{
+  ComplexMatrix tmp (a);
+  return m * tmp;
+}
+
+ComplexMatrix
+operator * (const ComplexMatrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nc = a.cols ();
+  if (nc != a.rows ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexMatrix ();
     }
 
-  if (nr == 0 || nc == 0 || a.nc == 0)
+  if (nr == 0 || nc == 0 || a_nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
   char trans  = 'N';
   char transa = 'N';
 
   int ld  = nr;
-  int lda = a.nr;
+  int lda = a.rows ();
 
   Complex alpha (1.0);
   Complex beta (0.0);
-  int anc = a.nc;
-
-  Complex *c = new Complex [nr*a.nc];
-
-  F77_FCN (zgemm) (&trans, &transa, &nr, &anc, &nc, &alpha, data, &ld,
-		   a.data, &lda, &beta, c, &nr, 1L, 1L);
-
-  return ComplexMatrix (c, nr, a.nc);
+
+  Complex *c = new Complex [nr*a_nc];
+
+  F77_FCN (zgemm) (&trans, &transa, &nr, &a_nc, &nc, &alpha, m.data (),
+		   &ld, a.data (), &lda, &beta, c, &nr, 1L, 1L);
+
+  return ComplexMatrix (c, nr, a_nc);
 }
 
 ComplexMatrix
-ComplexMatrix::product (const Matrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix product attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (multiply (data, a.data, len), nr, nc);
-}
-
-ComplexMatrix
-ComplexMatrix::quotient (const Matrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix quotient attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (divide (data, a.data, len), nr, nc);
-}
-
-ComplexMatrix
-ComplexMatrix::product (const ComplexMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+product (const ComplexMatrix& m, const Matrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix product attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  return ComplexMatrix (multiply (data, a.data, len), nr, nc);
+  return ComplexMatrix (multiply (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexMatrix
-ComplexMatrix::quotient (const ComplexMatrix& a) const
-{
-  if (nr != a.nr || nc != a.nc)
+quotient (const ComplexMatrix& m, const Matrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix quotient attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
-  return ComplexMatrix (divide (data, a.data, len), nr, nc);
-}
-
-ComplexMatrix&
-ComplexMatrix::operator += (const Matrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::operator -= (const Matrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::operator += (const ComplexMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix += operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::operator -= (const ComplexMatrix& a)
-{
-  if (nr != a.nr || nc != a.nc)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix -= operation attempted");
-      return *this;
-    }
-
-  if (nr == 0 || nc == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
-}
-
-// unary operations
-
-ComplexMatrix
-ComplexMatrix::operator - (void) const
-{
-  return ComplexMatrix (negate (data, len), nr, nc);
-}
-
-Matrix
-ComplexMatrix::operator ! (void) const
-{
-  return Matrix (not (data, len), nr, nc);
+  return ComplexMatrix (divide (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 // other operations
 
 ComplexMatrix
 map (c_c_Mapper f, const ComplexMatrix& a)
 {
   ComplexMatrix b (a);
   b.map (f);
   return b;
 }
 
 Matrix
 map (d_c_Mapper f, const ComplexMatrix& a)
 {
-  Matrix b (a.nr, a.nc);
-  for (int j = 0; j < a.nc; j++)
-    for (int i = 0; i < a.nr; i++)
+  int a_nc = a.cols ();
+  int a_nr = a.rows ();
+  Matrix b (a_nr, a_nc);
+  for (int j = 0; j < a_nc; j++)
+    for (int i = 0; i < a_nr; i++)
       b.elem (i, j) = f (a.elem (i, j));
   return b;
 }
 
 void
 ComplexMatrix::map (c_c_Mapper f)
 {
-  for (int i = 0; i < len; i++)
-    data[i] = f (data[i]);
+  for (int j = 0; j < cols (); j++)
+    for (int i = 0; i < rows (); i++)
+      elem (i, j) = f (elem (i, j));
 }
 
 Matrix
 ComplexMatrix::all (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   Matrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, 1);
 	  retval.elem (0, 0) = 1.0;
 	  for (int j = 0; j < nc; j++)
@@ -4464,16 +4231,18 @@ ComplexMatrix::all (void) const
 	}
     }
   return retval;
 }
 
 Matrix
 ComplexMatrix::any (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   Matrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, 1);
 	  retval.elem (0, 0) = 0.0;
 	  for (int j = 0; j < nc; j++)
@@ -4516,16 +4285,18 @@ ComplexMatrix::any (void) const
 	}
     }
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::cumprod (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   ComplexMatrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, nc);
 	  Complex prod = elem (0, 0);
 	  for (int j = 0; j < nc; j++)
@@ -4562,16 +4333,18 @@ ComplexMatrix::cumprod (void) const
 	}
     }
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::cumsum (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   ComplexMatrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, nc);
 	  Complex sum = elem (0, 0);
 	  for (int j = 0; j < nc; j++)
@@ -4608,16 +4381,18 @@ ComplexMatrix::cumsum (void) const
 	}
     }
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::prod (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   ComplexMatrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, 1);
 	  retval.elem (0, 0) = 1.0;
 	  for (int j = 0; j < nc; j++)
@@ -4642,16 +4417,18 @@ ComplexMatrix::prod (void) const
 	}
     }
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::sum (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   ComplexMatrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, 1);
 	  retval.elem (0, 0) = 0.0;
 	  for (int j = 0; j < nc; j++)
@@ -4676,16 +4453,18 @@ ComplexMatrix::sum (void) const
 	}
     }
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::sumsq (void) const
 {
+  int nr = rows ();
+  int nc = cols ();
   ComplexMatrix retval;
   if (nr > 0 && nc > 0)
     {
       if (nr == 1)
 	{
 	  retval.resize (1, 1);
 	  retval.elem (0, 0) = 0.0;
 	  for (int j = 0; j < nc; j++)
@@ -4725,18 +4504,18 @@ ComplexColumnVector
 ComplexMatrix::diag (void) const
 {
   return diag (0);
 }
 
 ComplexColumnVector
 ComplexMatrix::diag (int k) const
 {
-  int nnr = nr;
-  int nnc = nc;
+  int nnr = rows ();
+  int nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ComplexColumnVector d;
 
   if (nnr > 0 && nnc > 0)
@@ -4767,16 +4546,18 @@ ComplexMatrix::diag (int k) const
   return d;
 }
 
 ComplexColumnVector
 ComplexMatrix::row_min (void) const
 {
   ComplexColumnVector result;
 
+  int nr = rows ();
+  int nc = cols ();
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
 
       for (int i = 0; i < nr; i++)
 	{
 	  Complex res = elem (i, 0);
 	  double absres = abs (res);
@@ -4793,16 +4574,19 @@ ComplexMatrix::row_min (void) const
   return result;
 }
 
 ComplexColumnVector
 ComplexMatrix::row_min_loc (void) const
 {
   ComplexColumnVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
           Complex res = 0;
           double absres = abs (elem (i, 0));
@@ -4819,16 +4603,19 @@ ComplexMatrix::row_min_loc (void) const
   return result;
 }
 
 ComplexColumnVector
 ComplexMatrix::row_max (void) const
 {
   ComplexColumnVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
 
       for (int i = 0; i < nr; i++)
 	{
 	  Complex res = elem (i, 0);
 	  double absres = abs (res);
@@ -4845,16 +4632,19 @@ ComplexMatrix::row_max (void) const
   return result;
 }
 
 ComplexColumnVector
 ComplexMatrix::row_max_loc (void) const
 {
   ComplexColumnVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
           Complex res = 0;
           double absres = abs (elem (i, 0));
@@ -4871,16 +4661,19 @@ ComplexMatrix::row_max_loc (void) const
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_min (void) const
 {
   ComplexRowVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
 	{
 	  Complex res = elem (0, j);
 	  double absres = abs (res);
@@ -4897,16 +4690,19 @@ ComplexMatrix::column_min (void) const
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_min_loc (void) const
 {
   ComplexRowVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
           Complex res = 0;
           double absres = abs (elem (0, j));
@@ -4923,16 +4719,19 @@ ComplexMatrix::column_min_loc (void) con
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_max (void) const
 {
   ComplexRowVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
 	{
 	  Complex res = elem (0, j);
 	  double absres = abs (res);
@@ -4949,16 +4748,19 @@ ComplexMatrix::column_max (void) const
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_max_loc (void) const
 {
   ComplexRowVector result;
 
+  int nr = rows ();
+  int nc = cols ();
+
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
           Complex res = 0;
           double absres = abs (elem (0, j));
@@ -4976,30 +4778,30 @@ ComplexMatrix::column_max_loc (void) con
 }
 
 // i/o
 
 ostream&
 operator << (ostream& os, const ComplexMatrix& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.nr; i++)
+  for (int i = 0; i < a.rows (); i++)
     {
-      for (int j = 0; j < a.nc; j++)
+      for (int j = 0; j < a.cols (); j++)
 	os << " " /* setw (field_width) */ << a.elem (i, j);
       os << "\n";
     }
   return os;
 }
 
 istream&
 operator >> (istream& is, ComplexMatrix& a)
 {
   int nr = a.rows ();
-  int nc = a.columns ();
+  int nc = a.cols ();
 
   if (nr < 1 || nc < 1)
     is.clear (ios::badbit);
   else
     {
       Complex tmp;
       for (int i = 0; i < nr; i++)
 	for (int j = 0; j < nc; j++)
diff --git a/liboctave/Matrix.h b/liboctave/Matrix.h
--- a/liboctave/Matrix.h
+++ b/liboctave/Matrix.h
@@ -26,41 +26,39 @@ Software Foundation, 675 Mass Ave, Cambr
 Should probably say something here about why these classes are not
 represented by some sort of inheritance tree...
 
 */
 
 #if !defined (_Matrix_h)
 #define _Matrix_h 1
 
-// I\'m not sure how this is supposed to work if the .h file declares
-// several classes, each of which is defined in a separate file...
-//
-// #ifdef __GNUG__
-// #pragma interface
-// #endif
-
 #include <stdlib.h>
 #include <stddef.h>
 #include <math.h>
 #include <values.h>
 #include <assert.h>
 #include <iostream.h>
 // #include <iomanip.h>  // We don\'t use this yet.
 #include <Complex.h>
 
+class ostream;
+class istream;
+
 #ifndef MAPPER_FCN_TYPEDEFS
 #define MAPPER_FCN_TYPEDEFS 1
 
 typedef double (*d_d_Mapper)(double);
 typedef double (*d_c_Mapper)(const Complex&);
 typedef Complex (*c_c_Mapper)(const Complex&);
 
 #endif
 
+#include "Array.h"
+
 // Classes we declare.
 
 class Matrix;
 class ColumnVector;
 class RowVector;
 class DiagMatrix;
 class ComplexMatrix;
 class ComplexColumnVector;
@@ -84,72 +82,34 @@ class LU;
 class ComplexLU;
 class QR;
 class ComplexQR;
 
 /*
  * Matrix class
  */
 
-class Matrix
+class Matrix : public Array2<double>
 {
-friend class RowVector;
-friend class DiagMatrix;
-friend class ComplexMatrix;
-friend class ComplexDiagMatrix;
-friend class AEPBALANCE;
-friend class CHOL;
-friend class EIG;
-friend class GEPBALANCE;
-friend class HESS;
-friend class SCHUR;
+friend class LU;
 friend class SVD;
-friend class LU;
-friend class QR;
 
 public:
-  Matrix (void);
-  Matrix (int r, int c);
-  Matrix (int r, int c, double val);
-  Matrix (const Matrix& a);
+
+  Matrix (void) : Array2<double> () { }
+  Matrix (int r, int c) : Array2<double> (r, c) { }
+  Matrix (int r, int c, double val) : Array2<double> (r, c, val) { }
+  Matrix (const Array2<double>& a) : Array2<double> (a) { }
+  Matrix (const Matrix& a) : Array2<double> (a) { }
+  Matrix (const DiagArray<double>& a) : Array2<double> (a) { }
   Matrix (const DiagMatrix& a);
-  Matrix (double a);
- ~Matrix (void);
-
-#if defined (MDEBUG)
-  void *operator new (size_t size)
-    {
-      Matrix *p = ::new Matrix;
-      cerr << "Matrix::new(): " << p << "\n";
-      return p;
-    }
-
-  void operator delete (void *p, size_t size)
-    {
-      cerr << "Matrix::delete(): " << p << "\n";
-      ::delete p;
-    }
-#endif
-
-  Matrix& operator = (const Matrix& a);
-
-  int rows (void) const;
-  int cols (void) const;
-  int columns (void) const;
-
-  double& elem (int r, int c);
-  double& checkelem (int r, int c);
-  double& operator () (int r, int c);
-
-  double elem (int r, int c) const; // const access
-  double checkelem (int r, int c) const;
-  double operator () (int r, int c) const;
-
-  Matrix& resize (int r, int c);
-  Matrix& resize (int r, int c, double val);
+//  Matrix (double a) : Array2<double> (1, 1, a) { }
+
+  Matrix& operator = (const Matrix& a)
+    { return Array2<double>::operator = (a); }
 
   int operator == (const Matrix& a) const;
   int operator != (const Matrix& a) const;
 
 // destructive insert/delete/reorder operations
 
   Matrix& insert (const Matrix& a, int r, int c);
   Matrix& insert (const RowVector& a, int r, int c);
@@ -178,19 +138,19 @@ public:
 // extract row or column i.
 
   RowVector row (int i) const;
   RowVector row (char *s) const;
 
   ColumnVector column (int i) const;
   ColumnVector column (char *s) const;
 
-  Matrix inverse (int& info, double& rcond) const;
+  Matrix inverse (void) const;
   Matrix inverse (int& info) const;
-  Matrix inverse (void) const;
+  Matrix inverse (int& info, double& rcond) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   DET determinant (void) const;
   DET determinant (int& info) const;
   DET determinant (int& info, double& rcond) const;
 
@@ -224,77 +184,69 @@ public:
   ColumnVector lssolve (const ColumnVector& b, int& info) const;
   ColumnVector lssolve (const ColumnVector& b, int& info, int& rank) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
 			       int& rank) const;
 
-// matrix by scalar -> matrix operations
-
-  Matrix operator + (double s) const;
-  Matrix operator - (double s) const;
-  Matrix operator * (double s) const;
-  Matrix operator / (double s) const;
-
-  ComplexMatrix operator + (const Complex& s) const;
-  ComplexMatrix operator - (const Complex& s) const;
-  ComplexMatrix operator * (const Complex& s) const;
-  ComplexMatrix operator / (const Complex& s) const;
-
-// scalar by matrix -> matrix operations
-
-  friend Matrix operator + (double s, const Matrix& a);
-  friend Matrix operator - (double s, const Matrix& a);
-  friend Matrix operator * (double s, const Matrix& a);
-  friend Matrix operator / (double s, const Matrix& a);
-
-// matrix by column vector -> column vector operations
-
-  ColumnVector operator * (const ColumnVector& a) const;
-
-  ComplexColumnVector operator * (const ComplexColumnVector& a) const;
-
-// matrix by diagonal matrix -> matrix operations
-
-  Matrix operator + (const DiagMatrix& a) const;
-  Matrix operator - (const DiagMatrix& a) const;
-  Matrix operator * (const DiagMatrix& a) const;
-
-  ComplexMatrix operator + (const ComplexDiagMatrix& a) const;
-  ComplexMatrix operator - (const ComplexDiagMatrix& a) const;
-  ComplexMatrix operator * (const ComplexDiagMatrix& a) const;
+  Matrix& operator += (const Matrix& a);
+  Matrix& operator -= (const Matrix& a);
 
   Matrix& operator += (const DiagMatrix& a);
   Matrix& operator -= (const DiagMatrix& a);
 
+// unary operations
+
+  Matrix operator ! (void) const;
+
+// matrix by scalar -> matrix operations
+
+  friend ComplexMatrix operator + (const Matrix& a, const Complex& s);
+  friend ComplexMatrix operator - (const Matrix& a, const Complex& s);
+  friend ComplexMatrix operator * (const Matrix& a, const Complex& s);
+  friend ComplexMatrix operator / (const Matrix& a, const Complex& s);
+
+// scalar by matrix -> matrix operations
+
+  friend ComplexMatrix operator + (const Complex& s, const Matrix& a);
+  friend ComplexMatrix operator - (const Complex& s, const Matrix& a);
+  friend ComplexMatrix operator * (const Complex& s, const Matrix& a);
+  friend ComplexMatrix operator / (const Complex& s, const Matrix& a);
+
+// matrix by column vector -> column vector operations
+
+  friend ColumnVector operator * (const Matrix& a, const ColumnVector& b);
+  friend ComplexColumnVector operator * (const Matrix& a,
+					 const ComplexColumnVector& b);
+
+// matrix by diagonal matrix -> matrix operations
+
+  friend Matrix operator + (const Matrix& a, const DiagMatrix& b);
+  friend Matrix operator - (const Matrix& a, const DiagMatrix& b);
+  friend Matrix operator * (const Matrix& a, const DiagMatrix& b);
+
+  friend ComplexMatrix operator + (const Matrix& a,
+				   const ComplexDiagMatrix& b); 
+  friend ComplexMatrix operator - (const Matrix& a,
+				   const ComplexDiagMatrix& b);
+  friend ComplexMatrix operator * (const Matrix& a,
+				   const ComplexDiagMatrix& b);
+
 // matrix by matrix -> matrix operations
 
-  Matrix operator + (const Matrix& a) const;
-  Matrix operator - (const Matrix& a) const;
-  Matrix operator * (const Matrix& a) const;
-
-  ComplexMatrix operator + (const ComplexMatrix& a) const;
-  ComplexMatrix operator - (const ComplexMatrix& a) const;
-  ComplexMatrix operator * (const ComplexMatrix& a) const;
-
-  Matrix product (const Matrix& a) const;    // element by element
-  Matrix quotient (const Matrix& a) const;   // element by element
-
-  ComplexMatrix product (const ComplexMatrix& a) const;  // element by element
-  ComplexMatrix quotient (const ComplexMatrix& a) const; // element by element
-
-  Matrix& operator += (const Matrix& a);
-  Matrix& operator -= (const Matrix& a);
-
-// unary operations
-
-  Matrix operator - (void) const;
-  Matrix operator ! (void) const;
+  friend Matrix operator * (const Matrix& a, const Matrix& b);
+  friend ComplexMatrix operator * (const Matrix& a, const ComplexMatrix& b);
+
+  friend ComplexMatrix operator + (const Matrix& a, const ComplexMatrix& b);
+  friend ComplexMatrix operator - (const Matrix& a, const ComplexMatrix& b);
+
+  friend ComplexMatrix product (const Matrix& a, const ComplexMatrix& b);
+  friend ComplexMatrix quotient (const Matrix& a, const ComplexMatrix& b);
 
 // other operations
 
   friend Matrix map (d_d_Mapper f, const Matrix& a);
   void map (d_d_Mapper f);
 
   Matrix all (void) const;
   Matrix any (void) const;
@@ -320,88 +272,50 @@ public:
   RowVector column_max (void) const;
   RowVector column_max_loc (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const Matrix& a);
   friend istream& operator >> (istream& is, Matrix& a);
 
-// conversions
-
-  double *fortran_vec (void) const;
+// Until templates really work with g++:
+
+#define KLUDGE_MATRICES
+#define TYPE double
+#define KL_MAT_TYPE Matrix
+#include "mx-kludge.h"
+#undef KLUDGE_MATRICES
+#undef TYPE
+#undef KL_MAT_TYPE
 
 private:
-  int nr;
-  int nc;
-  int len;
-  double *data;
-
-  Matrix (double *d, int r, int c);
+
+  Matrix (double *d, int r, int c) : Array2<double> (d, r, c) { }
 };
 
-inline Matrix::Matrix (void) { nr = 0; nc = 0; len = 0; data = 0; }
-
-inline Matrix::Matrix (double *d, int r, int c)
-  { nr = r; nc = c; len = nr*nc; data = d; }
-
-inline Matrix::~Matrix (void) { delete [] data; data = 0; }
-
-inline int Matrix::rows (void) const { return nr; }
-inline int Matrix::cols (void) const { return nc; }
-inline int Matrix::columns (void) const { return nc; } 
-
-inline double& Matrix::elem (int r, int c) { return data[nr*c+r]; }
-
-inline double& Matrix::operator () (int r, int c)
-  { return checkelem (r, c); }
-
-inline double Matrix::elem (int r, int c) const { return data[nr*c+r]; }
-
-inline double Matrix::operator () (int r, int c) const
-  { return checkelem (r, c); }
-
-inline double *Matrix::fortran_vec (void) const { return data; }
-
 /*
  * Column Vector class
  */
 
-class ColumnVector
+class ColumnVector : public Array<double>
 {
-friend class Matrix;
-friend class RowVector;
-friend class DiagMatrix;
-friend class ComplexMatrix;
-friend class ComplexColumnVector;
-friend class ComplexDiagMatrix;
-
 public:
-  ColumnVector (void);
-  ColumnVector (int n);
-  ColumnVector (int n, double val);
-  ColumnVector (const ColumnVector& a);
-  ColumnVector (double a);
- ~ColumnVector (void);
-
-  ColumnVector& operator = (const ColumnVector& a);
-
-  int capacity (void) const;
-  int length (void) const;
-
-  double& elem (int n);
-  double& checkelem (int n);
-  double& operator () (int n);
-
-  double elem (int n) const; // const access
-  double checkelem (int n) const;
-  double operator () (int n) const;
-
-  ColumnVector& resize (int n);
-  ColumnVector& resize (int n, double val);
+
+  ColumnVector (void) : Array<double> () { }
+  ColumnVector (int n) : Array<double> (n) { }
+  ColumnVector (int n, double val) : Array<double> (n, val) { }
+  ColumnVector (const Array<double>& a) : Array<double> (a) { }
+  ColumnVector (const ColumnVector& a) : Array<double> (a) { }
+//  ColumnVector (double a) : Array<double> (1, a) { }
+
+  ColumnVector& operator = (const ColumnVector& a)
+    { return Array<double>::operator = (a); }
+
+//  operator Array<double>& () const { return *this; }
 
   int operator == (const ColumnVector& a) const;
   int operator != (const ColumnVector& a) const;
 
 // destructive insert/delete/reorder operations
 
   ColumnVector& insert (const ColumnVector& a, int r);
 
@@ -411,136 +325,108 @@ public:
   ColumnVector stack (const ColumnVector& a) const;
 
   RowVector transpose (void) const;
 
 // resize is the destructive equivalent for this one
 
   ColumnVector extract (int r1, int r2) const;
 
-// column vector by scalar -> column vector operations
-
-  ColumnVector operator + (double s) const;
-  ColumnVector operator - (double s) const;
-  ColumnVector operator * (double s) const;
-  ColumnVector operator / (double s) const;
-
-  ComplexColumnVector operator + (const Complex& s) const;
-  ComplexColumnVector operator - (const Complex& s) const;
-  ComplexColumnVector operator * (const Complex& s) const;
-  ComplexColumnVector operator / (const Complex& s) const;
-
-// scalar by column vector -> column vector operations
-
-  friend ColumnVector operator + (double s, const ColumnVector& a);
-  friend ColumnVector operator - (double s, const ColumnVector& a);
-  friend ColumnVector operator * (double s, const ColumnVector& a);
-  friend ColumnVector operator / (double s, const ColumnVector& a);
-
-// column vector by row vector -> matrix operations
-
-  Matrix operator * (const RowVector& a) const;
-
-  ComplexMatrix operator * (const ComplexRowVector& a) const;
-
 // column vector by column vector -> column vector operations
 
-  ColumnVector operator + (const ColumnVector& a) const;
-  ColumnVector operator - (const ColumnVector& a) const;
-
-  ComplexColumnVector operator + (const ComplexColumnVector& a) const;
-  ComplexColumnVector operator - (const ComplexColumnVector& a) const;
-
-  ColumnVector product (const ColumnVector& a) const;  // element by element
-  ColumnVector quotient (const ColumnVector& a) const; // element by element
-
-  ComplexColumnVector product (const ComplexColumnVector& a) const;
-  ComplexColumnVector quotient (const ComplexColumnVector& a) const;
-
   ColumnVector& operator += (const ColumnVector& a);
   ColumnVector& operator -= (const ColumnVector& a);
 
-// unary operations
-
-  ColumnVector operator - (void) const;
+// column vector by scalar -> column vector operations
+
+  friend ComplexColumnVector operator + (const ColumnVector& a,
+					 const Complex& s);  
+  friend ComplexColumnVector operator - (const ColumnVector& a,
+					 const Complex& s);
+  friend ComplexColumnVector operator * (const ColumnVector& a,
+					 const Complex& s);
+  friend ComplexColumnVector operator / (const ColumnVector& a,
+					 const Complex& s);
+
+// scalar by column vector -> column vector operations
+
+  friend ComplexColumnVector operator + (const Complex& s,
+					 const ColumnVector& a); 
+  friend ComplexColumnVector operator - (const Complex& s,
+					 const ColumnVector& a);
+  friend ComplexColumnVector operator * (const Complex& s,
+					 const ColumnVector& a);
+  friend ComplexColumnVector operator / (const Complex& s,
+					 const ColumnVector& a);
+
+// column vector by row vector -> matrix operations
+
+  friend Matrix operator * (const ColumnVector& a, const RowVector& a);
+
+  friend ComplexMatrix operator * (const ColumnVector& a,
+				   const ComplexRowVector& b);
+
+// column vector by column vector -> column vector operations
+
+  friend ComplexColumnVector operator + (const ComplexColumnVector& a,
+					 const ComplexColumnVector& b);
+
+  friend ComplexColumnVector operator - (const ComplexColumnVector& a,
+					 const ComplexColumnVector& b); 
+
+  friend ComplexColumnVector product (const ComplexColumnVector& a,
+				      const ComplexColumnVector& b); 
+
+  friend ComplexColumnVector quotient (const ComplexColumnVector& a,
+				       const ComplexColumnVector& b); 
+
+// other operations
 
   friend ColumnVector map (d_d_Mapper f, const ColumnVector& a);
   void map (d_d_Mapper f);
 
   double min (void) const;
   double max (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const ColumnVector& a);
 
-// conversions
-
-  double *fortran_vec (void) const;
+#define KLUDGE_VECTORS
+#define TYPE double
+#define KL_VEC_TYPE ColumnVector
+#include "mx-kludge.h"
+#undef KLUDGE_VECTORS
+#undef TYPE
+#undef KL_VEC_TYPE
 
 private:
-  int len;
-  double *data;
-
-  ColumnVector (double *d, int l);
+
+  ColumnVector (double *d, int l) : Array<double> (d, l) { }
 };
 
-inline ColumnVector::ColumnVector (void) { len = 0; data = 0; }
-inline ColumnVector::ColumnVector (double *d, int l) { len = l; data = d; }
-inline ColumnVector::~ColumnVector (void) { delete [] data; data = 0; }
-
-inline int ColumnVector::capacity (void) const { return len; }
-inline int ColumnVector::length (void) const { return len; }
-
-inline double& ColumnVector::elem (int n) { return data[n]; }
-
-inline double& ColumnVector::operator () (int n) { return checkelem (n); }
-
-inline double ColumnVector::elem (int n) const { return data[n]; }
-
-inline double ColumnVector::operator () (int n) const { return checkelem (n); }
-
-inline double *ColumnVector::fortran_vec (void) const { return data; }
-
 /*
  * Row Vector class
  */
 
-class RowVector
+class RowVector : public Array<double>
 {
-friend class Matrix;
-friend class DiagMatrix;
-friend class ColumnVector;
-friend class ComplexMatrix;
-friend class ComplexRowVector;
-friend class ComplexDiagMatrix;
-
 public:
-  RowVector (void);
-  RowVector (int n);
-  RowVector (int n, double val);
-  RowVector (const RowVector& a);
-  RowVector (double a);
- ~RowVector (void);
-
-  RowVector& operator = (const RowVector& a);
-
-  int capacity (void) const;
-  int length (void) const;
-
-  double& elem (int n);
-  double& checkelem (int n);
-  double& operator () (int n);
-
-  double elem (int n) const; // const access
-  double checkelem (int n) const;
-  double operator () (int n) const;
-
-  RowVector& resize (int n);
-  RowVector& resize (int n, double val);
+
+  RowVector (void) : Array<double> () { }
+  RowVector (int n) : Array<double> (n) { }
+  RowVector (int n, double val) : Array<double> (n, val) { }
+  RowVector (const Array<double>& a) : Array<double> (a) { }
+  RowVector (const RowVector& a) : Array<double> (a) { }
+//  RowVector (double a) : Array<double> (1, a) { }
+
+  RowVector& operator = (const RowVector& a)
+    { return Array<double>::operator = (a); }
+
+//  operator Array<double>& () const { return *this; }
 
   int operator == (const RowVector& a) const;
   int operator != (const RowVector& a) const;
 
 // destructive insert/delete/reorder operations
 
   RowVector& insert (const RowVector& a, int c);
 
@@ -550,144 +436,111 @@ public:
   RowVector append (const RowVector& a) const;
 
   ColumnVector transpose (void) const;
 
 // resize is the destructive equivalent for this one
 
   RowVector extract (int c1, int c2) const;
 
-// row vector by scalar -> row vector operations
-
-  RowVector operator + (double s) const;
-  RowVector operator - (double s) const;
-  RowVector operator * (double s) const;
-  RowVector operator / (double s) const;
-
-  ComplexRowVector operator + (const Complex& s) const;
-  ComplexRowVector operator - (const Complex& s) const;
-  ComplexRowVector operator * (const Complex& s) const;
-  ComplexRowVector operator / (const Complex& s) const;
-
-// scalar by row vector -> row vector operations
-
-  friend RowVector operator + (double s, const RowVector& a);
-  friend RowVector operator - (double s, const RowVector& a);
-  friend RowVector operator * (double s, const RowVector& a);
-  friend RowVector operator / (double s, const RowVector& a);
-
-// row vector by column vector -> scalar
-
-  double operator * (const ColumnVector& a) const;
-
-  Complex operator * (const ComplexColumnVector& a) const;
-
-// row vector by matrix -> row vector
-
-  RowVector operator * (const Matrix& a) const;
-
-  ComplexRowVector operator * (const ComplexMatrix& a) const;
-
 // row vector by row vector -> row vector operations
 
-  RowVector operator + (const RowVector& a) const;
-  RowVector operator - (const RowVector& a) const;
-
-  ComplexRowVector operator + (const ComplexRowVector& a) const;
-  ComplexRowVector operator - (const ComplexRowVector& a) const;
-
-  RowVector product (const RowVector& a) const;  // element by element
-  RowVector quotient (const RowVector& a) const; // element by element
-
-  ComplexRowVector product (const ComplexRowVector& a) const;  // el by el
-  ComplexRowVector quotient (const ComplexRowVector& a) const; // el by el
-
   RowVector& operator += (const RowVector& a);
   RowVector& operator -= (const RowVector& a);
 
-// unary operations
-
-  RowVector operator - (void) const;
+// row vector by scalar -> row vector operations
+
+  friend ComplexRowVector operator + (const RowVector& a, const Complex& s);
+  friend ComplexRowVector operator - (const RowVector& a, const Complex& s);
+  friend ComplexRowVector operator * (const RowVector& a, const Complex& s);
+  friend ComplexRowVector operator / (const RowVector& a, const Complex& s);
+
+// scalar by row vector -> row vector operations
+
+  friend ComplexRowVector operator + (const Complex& s, const RowVector& a);
+  friend ComplexRowVector operator - (const Complex& s, const RowVector& a);
+  friend ComplexRowVector operator * (const Complex& s, const RowVector& a);
+  friend ComplexRowVector operator / (const Complex& s, const RowVector& a);
+
+// row vector by column vector -> scalar
+
+  friend double operator * (const RowVector& a, ColumnVector& b);
+
+  friend Complex operator * (const RowVector& a, const ComplexColumnVector& b);
+
+// row vector by matrix -> row vector
+
+  friend RowVector operator * (const RowVector& a, const Matrix& b);
+
+  friend ComplexRowVector operator * (const RowVector& a,
+				      const ComplexMatrix& b);
+
+// row vector by row vector -> row vector operations
+
+  friend ComplexRowVector operator + (const RowVector& a,
+				      const ComplexRowVector& b);
+  friend ComplexRowVector operator - (const RowVector& a,
+				      const ComplexRowVector& b);
+
+  friend ComplexRowVector product (const RowVector& a,
+				   const ComplexRowVector& b);
+  friend ComplexRowVector quotient (const RowVector& a,
+				    const ComplexRowVector& b);
+
+// other operations
 
   friend RowVector map (d_d_Mapper f, const RowVector& a);
   void map (d_d_Mapper f);
 
   double min (void) const;
   double max (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const RowVector& a);
 
-// conversions
-
-  double *fortran_vec (void) const;
+#define KLUDGE_VECTORS
+#define TYPE double
+#define KL_VEC_TYPE RowVector
+#include "mx-kludge.h"
+#undef KLUDGE_VECTORS
+#undef TYPE
+#undef KL_VEC_TYPE
 
 private:
-  int len;
-  double *data;
-
-  RowVector (double *d, int l);
+
+  RowVector (double *d, int l) : Array<double> (d, l) { }
 };
 
-inline RowVector::RowVector (void) { len = 0; data = 0; }
-inline RowVector::RowVector (double *d, int l) { len = l; data = d; }
-inline RowVector::~RowVector (void) { delete [] data; data = 0; }
-
-inline int RowVector::capacity (void) const { return len; }
-inline int RowVector::length (void) const { return len; }
-
-inline double& RowVector::elem (int n) { return data[n]; }
-
-inline double& RowVector::operator () (int n) { return checkelem (n); }
-
-inline double RowVector::elem (int n) const { return data[n]; }
-
-inline double RowVector::operator () (int n) const { return checkelem (n); }
-
-inline double *RowVector::fortran_vec (void) const { return data; }
-
 /*
  * Diagonal Matrix class
  */
 
-class DiagMatrix
+class DiagMatrix : public DiagArray<double>
 {
-friend class Matrix;
-friend class ComplexMatrix;
-friend class ComplexDiagMatrix;
+friend class SVD;
+friend class ComplexSVD;
 
 public:
-  DiagMatrix (void);
-  DiagMatrix (int n);
-  DiagMatrix (int n, double val);
-  DiagMatrix (int r, int c);
-  DiagMatrix (int r, int c, double val);
-  DiagMatrix (const RowVector& a);
-  DiagMatrix (const ColumnVector& a);
-  DiagMatrix (const DiagMatrix& a);
-  DiagMatrix (double a);
- ~DiagMatrix (void);
-
-  DiagMatrix& operator = (const DiagMatrix& a);
-
-  int rows (void) const;
-  int cols (void) const;
-  int columns (void) const;
-
-  double& elem (int r, int c);
-  double& checkelem (int r, int c);
-  double& operator () (int r, int c);
-
-  double elem (int r, int c) const; // const access
-  double checkelem (int r, int c) const;
-  double operator () (int r, int c) const;
-
-  DiagMatrix& resize (int r, int c);
-  DiagMatrix& resize (int r, int c, double val);
+
+  DiagMatrix (void) : DiagArray<double> () { }
+  DiagMatrix (int n) : DiagArray<double> (n) { }
+  DiagMatrix (int n, double val) : DiagArray<double> (n, val) { }
+  DiagMatrix (int r, int c) : DiagArray<double> (r, c) { }
+  DiagMatrix (int r, int c, double val) : DiagArray<double> (r, c, val) { }
+  DiagMatrix (const RowVector& a) : DiagArray<double> (a) { }
+  DiagMatrix (const ColumnVector& a) : DiagArray<double> (a) { }
+  DiagMatrix (const DiagArray<double>& a) : DiagArray<double> (a) { }
+  DiagMatrix (const DiagMatrix& a) : DiagArray<double> (a) { }
+//  DiagMatrix (double a) : DiagArray<double> (1, a) { }
+
+  DiagMatrix& operator = (const DiagMatrix& a)
+    { return DiagArray<double>::operator = (a); }
+
+//  operator DiagArray<double>& () const { return *this; }
 
   int operator == (const DiagMatrix& a) const;
   int operator != (const DiagMatrix& a) const;
 
   DiagMatrix& fill (double val);
   DiagMatrix& fill (double val, int beg, int end);
   DiagMatrix& fill (const ColumnVector& a);
   DiagMatrix& fill (const RowVector& a);
@@ -703,176 +556,129 @@ public:
 // extract row or column i.
 
   RowVector row (int i) const;
   RowVector row (char *s) const;
 
   ColumnVector column (int i) const;
   ColumnVector column (char *s) const;
 
+  DiagMatrix inverse (void) const;
   DiagMatrix inverse (int& info) const;
-  DiagMatrix inverse (void) const;
+
+// diagonal matrix by diagonal matrix -> diagonal matrix operations
+
+  DiagMatrix& operator += (const DiagMatrix& a);
+  DiagMatrix& operator -= (const DiagMatrix& a);
 
 // diagonal matrix by scalar -> matrix operations
 
-  Matrix operator + (double s) const;
-  Matrix operator - (double s) const;
-
-  ComplexMatrix operator + (const Complex& s) const;
-  ComplexMatrix operator - (const Complex& s) const;
+  friend Matrix operator + (const DiagMatrix& a, double s);
+  friend Matrix operator - (const DiagMatrix& a, double s);
+
+  friend ComplexMatrix operator + (const DiagMatrix& a, const Complex& s);
+  friend ComplexMatrix operator - (const DiagMatrix& a, const Complex& s);
 
 // diagonal matrix by scalar -> diagonal matrix operations
 
-  DiagMatrix operator * (double s) const;
-  DiagMatrix operator / (double s) const;
-
-  ComplexDiagMatrix operator * (const Complex& s) const;
-  ComplexDiagMatrix operator / (const Complex& s) const;
+  friend ComplexDiagMatrix operator * (const DiagMatrix& a, const Complex& s);
+  friend ComplexDiagMatrix operator / (const DiagMatrix& a, const Complex& s);
 
 // scalar by diagonal matrix -> matrix operations
 
   friend Matrix operator + (double s, const DiagMatrix& a);
   friend Matrix operator - (double s, const DiagMatrix& a);
 
+  friend ComplexMatrix operator + (const Complex& s, const DiagMatrix& a);
+  friend ComplexMatrix operator - (const Complex& s, const DiagMatrix& a);
+
 // scalar by diagonal matrix -> diagonal matrix operations
 
-  friend DiagMatrix operator * (double s, const DiagMatrix& a);
-  friend DiagMatrix operator / (double s, const DiagMatrix& a);
+  friend ComplexDiagMatrix operator * (const Complex& s, const DiagMatrix& a);
 
 // diagonal matrix by column vector -> column vector operations
 
-  ColumnVector operator * (const ColumnVector& a) const;
-
-  ComplexColumnVector operator * (const ComplexColumnVector& a) const;
+  friend ColumnVector operator * (const DiagMatrix& a, const ColumnVector& b);
+
+  friend ComplexColumnVector operator * (const DiagMatrix& a, const
+					 ComplexColumnVector& b);
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
-  DiagMatrix operator + (const DiagMatrix& a) const;
-  DiagMatrix operator - (const DiagMatrix& a) const;
-  DiagMatrix operator * (const DiagMatrix& a) const;
-
-  ComplexDiagMatrix operator + (const ComplexDiagMatrix& a) const;
-  ComplexDiagMatrix operator - (const ComplexDiagMatrix& a) const;
-  ComplexDiagMatrix operator * (const ComplexDiagMatrix& a) const;
-
-  DiagMatrix product (const DiagMatrix& a) const;    // element by element
-  DiagMatrix quotient (const DiagMatrix& a) const;   // element by element
-
-  ComplexDiagMatrix product (const ComplexDiagMatrix& a) const;  // el by el
-  ComplexDiagMatrix quotient (const ComplexDiagMatrix& a) const; // el by el
-
-  DiagMatrix& operator += (const DiagMatrix& a);
-  DiagMatrix& operator -= (const DiagMatrix& a);
+  friend ComplexDiagMatrix operator + (const DiagMatrix& a,
+				       const ComplexDiagMatrix& b);
+  friend ComplexDiagMatrix operator - (const DiagMatrix& a,
+				       const ComplexDiagMatrix& b);
+
+  friend ComplexDiagMatrix product (const DiagMatrix& a,
+				    const ComplexDiagMatrix& b);
 
 // diagonal matrix by matrix -> matrix operations
 
-  Matrix operator + (const Matrix& a) const;
-  Matrix operator - (const Matrix& a) const;
-  Matrix operator * (const Matrix& a) const;
-
-  ComplexMatrix operator + (const ComplexMatrix& a) const;
-  ComplexMatrix operator - (const ComplexMatrix& a) const;
-  ComplexMatrix operator * (const ComplexMatrix& a) const;
-
-// unary operations
-
-  DiagMatrix operator - (void) const;
+  friend Matrix operator + (const DiagMatrix& a, const Matrix& b);
+  friend Matrix operator - (const DiagMatrix& a, const Matrix& b);
+  friend Matrix operator * (const DiagMatrix& a, const Matrix& b);
+
+  friend ComplexMatrix operator + (const DiagMatrix& a,
+				   const ComplexMatrix& b);
+  friend ComplexMatrix operator - (const DiagMatrix& a,
+				   const ComplexMatrix& b);
+  friend ComplexMatrix operator * (const DiagMatrix& a,
+				   const ComplexMatrix& b);
+
+// other operations
 
   ColumnVector diag (void) const;
   ColumnVector diag (int k) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const DiagMatrix& a);
 
+#define KLUDGE_DIAG_MATRICES
+#define TYPE double
+#define KL_DMAT_TYPE DiagMatrix
+#include "mx-kludge.h"
+#undef KLUDGE_DIAG_MATRICES
+#undef TYPE
+#undef KL_DMAT_TYPE
+
 private:
-  int nr;
-  int nc;
-  int len;
-  double *data;
-
-  DiagMatrix (double *d, int nr, int nc);
+
+  DiagMatrix (double *d, int nr, int nc) : DiagArray<double> (d, nr, nc) { }
 };
 
-inline DiagMatrix::DiagMatrix (void)
-  { nr = 0; nc = 0; len = 0; data = 0; }
-
-inline DiagMatrix::DiagMatrix (double *d, int r, int c)
-  { nr = r; nc = c; len = nr < nc ? nr : nc; data = d; }
-
-inline DiagMatrix::~DiagMatrix (void) { delete [] data; data = 0; }
-
-inline int DiagMatrix::rows (void) const { return nr; }
-inline int DiagMatrix::cols (void) const { return nc; }
-inline int DiagMatrix::columns (void) const { return nc; } 
-
-// Would be nice to be able to avoid compiler warning and make this
-// fail on assignment.
-inline double& DiagMatrix::elem (int r, int c)
-  { return (r == c) ? data[r] : 0; }
-
-inline double& DiagMatrix::operator () (int r, int c)
-  { return checkelem (r, c); }
-
-inline double DiagMatrix::elem (int r, int c) const
-  { return (r == c) ? data[r] : 0; }
-
-inline double DiagMatrix::operator () (int r, int c) const
-  { return checkelem (r, c); }
-
 /*
  * Complex Matrix class
  */
 
-class ComplexMatrix
+class ComplexMatrix : public Array2<Complex>
 {
-friend class Matrix;
-friend class DiagMatrix;
-friend class ComplexRowVector;
-friend class ComplexDiagMatrix;
-friend class ComplexAEPBALANCE;
-friend class ComplexCHOL;
-friend class EIG;
-friend class ComplexHESS;
+friend class ComplexLU;
 friend class ComplexSVD;
-friend class ComplexSCHUR;
-friend class ComplexLU;
-friend class ComplexQR;
 
 public:
-  ComplexMatrix (void);
-  ComplexMatrix (int r, int c);
-  ComplexMatrix (int r, int c, double val);
-  ComplexMatrix (int r, int c, const Complex& val);
+ 
+  ComplexMatrix (void) : Array2<Complex> () { }
+  ComplexMatrix (int r, int c) : Array2<Complex> (r, c) { }
+  ComplexMatrix (int r, int c, const Complex& val)
+    : Array2<Complex> (r, c, val) { }
   ComplexMatrix (const Matrix& a);
-  ComplexMatrix (const ComplexMatrix& a);
+  ComplexMatrix (const Array2<Complex>& a) : Array2<Complex> (a) { }
+  ComplexMatrix (const ComplexMatrix& a) : Array2<Complex> (a) { }
   ComplexMatrix (const DiagMatrix& a);
+  ComplexMatrix (const DiagArray<Complex>& a) : Array2<Complex> (a) { }
   ComplexMatrix (const ComplexDiagMatrix& a);
-  ComplexMatrix (double a);
-  ComplexMatrix (const Complex& a);
- ~ComplexMatrix (void);
-
-  ComplexMatrix& operator = (const Matrix& a);
-  ComplexMatrix& operator = (const ComplexMatrix& a);
-
-  int rows (void) const;
-  int cols (void) const;
-  int columns (void) const;
-
-  Complex& elem (int r, int c);
-  Complex& checkelem (int r, int c);
-  Complex& operator () (int r, int c);
-
-  Complex elem (int r, int c) const; // const access
-  Complex checkelem (int r, int c) const;
-  Complex operator () (int r, int c) const;
-
-  ComplexMatrix& resize (int r, int c);
-  ComplexMatrix& resize (int r, int c, double val);
-  ComplexMatrix& resize (int r, int c, const Complex& val);
+//  ComplexMatrix (double a) : Array2<Complex> (1, 1, a) { }
+//  ComplexMatrix (const Complex& a) : Array2<Complex> (1, 1, a) { }
+
+  ComplexMatrix& operator = (const ComplexMatrix& a)
+    { return Array2<Complex>::operator = (a); }
+
+//  operator Array2<Complex>& () const { return *this; }
 
   int operator == (const ComplexMatrix& a) const;
   int operator != (const ComplexMatrix& a) const;
 
 // destructive insert/delete/reorder operations
 
   ComplexMatrix& insert (const Matrix& a, int r, int c);
   ComplexMatrix& insert (const RowVector& a, int r, int c);
@@ -923,137 +729,120 @@ public:
 // extract row or column i.
 
   ComplexRowVector row (int i) const;
   ComplexRowVector row (char *s) const;
 
   ComplexColumnVector column (int i) const;
   ComplexColumnVector column (char *s) const;
 
-  ComplexMatrix inverse (int& info, double& rcond) const;
+  ComplexMatrix inverse (void) const;
   ComplexMatrix inverse (int& info) const;
-  ComplexMatrix inverse (void) const;
+  ComplexMatrix inverse (int& info, double& rcond) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (int& info) const;
   ComplexDET determinant (int& info, double& rcond) const;
 
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, int& info) const;
   ComplexMatrix solve (const Matrix& b, int& info, double& rcond) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, int& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond) const;
 
-  ComplexColumnVector solve (const ColumnVector& b) const;
-  ComplexColumnVector solve (const ColumnVector& b, int& info) const;
-  ComplexColumnVector solve (const ColumnVector& b, int& info,
-			     double& rcond) const;
-
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, int& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
 			     double& rcond) const;
 
-  ComplexMatrix lssolve (const Matrix& b) const;
-  ComplexMatrix lssolve (const Matrix& b, int& info) const;
-  ComplexMatrix lssolve (const Matrix& b, int& info, int& rank) const;
-
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, int& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, int& info,
 			 int& rank) const;
 
-  ComplexColumnVector lssolve (const ColumnVector& b) const;
-  ComplexColumnVector lssolve (const ColumnVector& b, int& info) const;
-  ComplexColumnVector lssolve (const ColumnVector& b, int& info,
-			       int& rank) const;
-
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
 			       int& rank) const;
 
-// matrix by scalar -> matrix operations
-
-  ComplexMatrix operator + (double s) const;
-  ComplexMatrix operator - (double s) const;
-  ComplexMatrix operator * (double s) const;
-  ComplexMatrix operator / (double s) const;
-
-  ComplexMatrix operator + (const Complex& s) const;
-  ComplexMatrix operator - (const Complex& s) const;
-  ComplexMatrix operator * (const Complex& s) const;
-  ComplexMatrix operator / (const Complex& s) const;
-
-// scalar by matrix -> matrix operations
-
-  friend ComplexMatrix operator + (double s, const ComplexMatrix& a);
-  friend ComplexMatrix operator - (double s, const ComplexMatrix& a);
-  friend ComplexMatrix operator * (double s, const ComplexMatrix& a);
-  friend ComplexMatrix operator / (double s, const ComplexMatrix& a);
-
-  friend ComplexMatrix operator + (const Complex& s, const ComplexMatrix& a);
-  friend ComplexMatrix operator - (const Complex& s, const ComplexMatrix& a);
-  friend ComplexMatrix operator * (const Complex& s, const ComplexMatrix& a);
-  friend ComplexMatrix operator / (const Complex& s, const ComplexMatrix& a);
-
-// matrix by column vector -> column vector operations
-
-  ComplexColumnVector operator * (const ColumnVector& a) const;
-
-  ComplexColumnVector operator * (const ComplexColumnVector& a) const;
-
 // matrix by diagonal matrix -> matrix operations
 
-  ComplexMatrix operator + (const DiagMatrix& a) const;
-  ComplexMatrix operator - (const DiagMatrix& a) const;
-  ComplexMatrix operator * (const DiagMatrix& a) const;
-
-  ComplexMatrix operator + (const ComplexDiagMatrix& a) const;
-  ComplexMatrix operator - (const ComplexDiagMatrix& a) const;
-  ComplexMatrix operator * (const ComplexDiagMatrix& a) const;
-
   ComplexMatrix& operator += (const DiagMatrix& a);
   ComplexMatrix& operator -= (const DiagMatrix& a);
 
   ComplexMatrix& operator += (const ComplexDiagMatrix& a);
   ComplexMatrix& operator -= (const ComplexDiagMatrix& a);
 
 // matrix by matrix -> matrix operations
 
-  ComplexMatrix operator + (const Matrix& a) const;
-  ComplexMatrix operator - (const Matrix& a) const;
-  ComplexMatrix operator * (const Matrix& a) const;
-
-  ComplexMatrix operator + (const ComplexMatrix& a) const;
-  ComplexMatrix operator - (const ComplexMatrix& a) const;
-  ComplexMatrix operator * (const ComplexMatrix& a) const;
-
-  ComplexMatrix product (const Matrix& a) const;    // element by element
-  ComplexMatrix quotient (const Matrix& a) const;   // element by element
-
-  ComplexMatrix product (const ComplexMatrix& a) const;  // element by element
-  ComplexMatrix quotient (const ComplexMatrix& a) const; // element by element
-
   ComplexMatrix& operator += (const Matrix& a);
   ComplexMatrix& operator -= (const Matrix& a);
 
   ComplexMatrix& operator += (const ComplexMatrix& a);
   ComplexMatrix& operator -= (const ComplexMatrix& a);
 
 // unary operations
 
-  ComplexMatrix operator - (void) const;
   Matrix operator ! (void) const;
 
+// matrix by scalar -> matrix operations
+
+  friend ComplexMatrix operator + (const ComplexMatrix& a, double s);
+  friend ComplexMatrix operator - (const ComplexMatrix& a, double s);
+  friend ComplexMatrix operator * (const ComplexMatrix& a, double s);
+  friend ComplexMatrix operator / (const ComplexMatrix& a, double s);
+
+// scalar by matrix -> matrix operations
+
+  friend ComplexMatrix operator + (double s, const ComplexMatrix& a);
+  friend ComplexMatrix operator - (double s, const ComplexMatrix& a);
+  friend ComplexMatrix operator * (double s, const ComplexMatrix& a);
+  friend ComplexMatrix operator / (double s, const ComplexMatrix& a);
+
+// matrix by column vector -> column vector operations
+
+  friend ComplexColumnVector operator * (const ComplexMatrix& a,
+					 const ColumnVector& b);
+
+  friend ComplexColumnVector operator * (const ComplexMatrix& a,
+					 const ComplexColumnVector& b);
+
+// matrix by diagonal matrix -> matrix operations
+
+  friend ComplexMatrix operator + (const ComplexMatrix& a,
+				   const DiagMatrix& b);
+  friend ComplexMatrix operator - (const ComplexMatrix& a,
+				   const DiagMatrix& b);
+  friend ComplexMatrix operator * (const ComplexMatrix& a,
+				   const DiagMatrix& b);
+
+  friend ComplexMatrix operator + (const ComplexMatrix& a,
+				   const ComplexDiagMatrix& b);
+  friend ComplexMatrix operator - (const ComplexMatrix& a,
+				   const ComplexDiagMatrix& b);
+  friend ComplexMatrix operator * (const ComplexMatrix& a,
+				   const ComplexDiagMatrix& b);
+
+// matrix by matrix -> matrix operations
+
+  friend ComplexMatrix operator + (const ComplexMatrix& a, const Matrix& b);
+  friend ComplexMatrix operator - (const ComplexMatrix& a, const Matrix& b);
+
+  friend ComplexMatrix operator * (const ComplexMatrix& a, const Matrix& b);
+  friend ComplexMatrix operator * (const ComplexMatrix& a,
+				   const ComplexMatrix& b);
+
+  friend ComplexMatrix product (const ComplexMatrix& a, const Matrix& b);
+  friend ComplexMatrix quotient (const ComplexMatrix& a, const Matrix& b);
+
 // other operations
 
   friend ComplexMatrix map (c_c_Mapper f, const ComplexMatrix& a);
   friend Matrix map (d_c_Mapper f, const ComplexMatrix& a);
   void map (c_c_Mapper f);
 
   Matrix all (void) const;
   Matrix any (void) const;
@@ -1079,93 +868,51 @@ public:
   ComplexRowVector column_max (void) const;
   ComplexRowVector column_max_loc (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const ComplexMatrix& a);
   friend istream& operator >> (istream& is, ComplexMatrix& a);
 
-// conversions
-
-  Complex *fortran_vec (void) const;
+#define KLUDGE_MATRICES
+#define TYPE Complex
+#define KL_MAT_TYPE ComplexMatrix
+#include "mx-kludge.h"
+#undef KLUDGE_MATRICES
+#undef TYPE
+#undef KL_MAT_TYPE
 
 private:
-  int nr;
-  int nc;
-  int len;
-  Complex *data;
-
-  ComplexMatrix (Complex *d, int r, int c);
+
+  ComplexMatrix (Complex *d, int r, int c) : Array2<Complex> (d, r, c) { }
 };
 
-inline ComplexMatrix::ComplexMatrix (void)
-   { nr = 0; nc = 0; len = 0; data = 0; }
-
-inline ComplexMatrix::ComplexMatrix (Complex *d, int r, int c)
-  { nr = r; nc = c; len = nr*nc; data = d; }
-
-inline ComplexMatrix::~ComplexMatrix (void) { delete [] data; data = 0; }
-
-inline int ComplexMatrix::rows (void) const { return nr; }
-inline int ComplexMatrix::cols (void) const { return nc; }
-inline int ComplexMatrix::columns (void) const { return nc; } 
-
-inline Complex& ComplexMatrix::elem (int r, int c) { return data[nr*c+r]; }
-
-inline Complex& ComplexMatrix::operator () (int r, int c)
-  { return checkelem (r, c); }
-
-inline Complex ComplexMatrix::elem (int r, int c) const
-  { return data[nr*c+r]; }
-
-inline Complex ComplexMatrix::operator () (int r, int c) const
-  { return checkelem (r, c); }
-
-inline Complex *ComplexMatrix::fortran_vec (void) const { return data; }
-
 /*
  * Complex Column Vector class
  */
 
-class ComplexColumnVector
+class ComplexColumnVector : public Array<Complex>
 {
-friend class DiagMatrix;
-friend class ComplexMatrix;
-friend class ColumnVector;
-friend class ComplexDiagMatrix;
-
 public:
-  ComplexColumnVector (void);
-  ComplexColumnVector (int n);
-  ComplexColumnVector (int n, double val);
-  ComplexColumnVector (int n, const Complex& val);
+
+  ComplexColumnVector (void) : Array<Complex> () { }
+  ComplexColumnVector (int n) : Array<Complex> (n) { }
+  ComplexColumnVector (int n, const Complex& val)
+    : Array<Complex> (n, val) { }
   ComplexColumnVector (const ColumnVector& a);
-  ComplexColumnVector (const ComplexColumnVector& a);
-  ComplexColumnVector (double a);
-  ComplexColumnVector (const Complex& a);
- ~ComplexColumnVector (void);
-
-  ComplexColumnVector& operator = (const ColumnVector& a);
-  ComplexColumnVector& operator = (const ComplexColumnVector& a);
-
-  int capacity (void) const;
-  int length (void) const;
-
-  Complex& elem (int n);
-  Complex& checkelem (int n);
-  Complex& operator () (int n);
-
-  Complex elem (int n) const; // const access
-  Complex checkelem (int n) const;
-  Complex operator () (int n) const;
-
-  ComplexColumnVector& resize (int n);
-  ComplexColumnVector& resize (int n, double val);
-  ComplexColumnVector& resize (int n, const Complex& val);
+  ComplexColumnVector (const Array<Complex>& a) : Array<Complex> (a) { }
+  ComplexColumnVector (const ComplexColumnVector& a) : Array<Complex> (a) { }
+//  ComplexColumnVector (double a) : Array<Complex> (1, a) { }
+//  ComplexColumnVector (const Complex& a) : Array<Complex> (1, a) { }
+
+  ComplexColumnVector& operator = (const ComplexColumnVector& a)
+    { return Array<Complex>::operator = (a); }
+
+//  operator Array<Complex>& () const { return *this; }
 
   int operator == (const ComplexColumnVector& a) const;
   int operator != (const ComplexColumnVector& a) const;
 
 // destructive insert/delete/reorder operations
 
   ComplexColumnVector& insert (const ColumnVector& a, int r);
   ComplexColumnVector& insert (const ComplexColumnVector& a, int r);
@@ -1184,160 +931,110 @@ public:
   friend ColumnVector real (const ComplexColumnVector& a);
   friend ColumnVector imag (const ComplexColumnVector& a);
   friend ComplexColumnVector conj (const ComplexColumnVector& a);
 
 // resize is the destructive equivalent for this one
 
   ComplexColumnVector extract (int r1, int r2) const;
 
+// column vector by column vector -> column vector operations
+
+  ComplexColumnVector& operator += (const ColumnVector& a);
+  ComplexColumnVector& operator -= (const ColumnVector& a);
+
+  ComplexColumnVector& operator += (const ComplexColumnVector& a);
+  ComplexColumnVector& operator -= (const ComplexColumnVector& a);
+
 // column vector by scalar -> column vector operations
 
-  ComplexColumnVector operator + (double s) const;
-  ComplexColumnVector operator - (double s) const;
-  ComplexColumnVector operator * (double s) const;
-  ComplexColumnVector operator / (double s) const;
-
-  ComplexColumnVector operator + (const Complex& s) const;
-  ComplexColumnVector operator - (const Complex& s) const;
-  ComplexColumnVector operator * (const Complex& s) const;
-  ComplexColumnVector operator / (const Complex& s) const;
+  friend ComplexColumnVector operator + (const ComplexColumnVector& a,
+					 double s);
+  friend ComplexColumnVector operator - (const ComplexColumnVector& a,
+					 double s);
+  friend ComplexColumnVector operator * (const ComplexColumnVector& a,
+					 double s);
+  friend ComplexColumnVector operator / (const ComplexColumnVector& a,
+					 double s);
 
 // scalar by column vector -> column vector operations
 
   friend ComplexColumnVector operator + (double s,
 					 const ComplexColumnVector& a); 
   friend ComplexColumnVector operator - (double s,
 					 const ComplexColumnVector& a);
   friend ComplexColumnVector operator * (double s,
 					 const ComplexColumnVector& a);
   friend ComplexColumnVector operator / (double s,
 					 const ComplexColumnVector& a);
 
-  friend ComplexColumnVector operator + (const Complex& s,
-					 const ComplexColumnVector& a);
-  friend ComplexColumnVector operator - (const Complex& s,
-					 const ComplexColumnVector& a);
-  friend ComplexColumnVector operator * (const Complex& s,
-					 const ComplexColumnVector& a);
-  friend ComplexColumnVector operator / (const Complex& s,
-					 const ComplexColumnVector& a);
-
 // column vector by row vector -> matrix operations
 
-  ComplexMatrix operator * (const RowVector& a) const;
-
-  ComplexMatrix operator * (const ComplexRowVector& a) const;
+  friend ComplexMatrix operator * (const ComplexColumnVector& a,
+				   const ComplexRowVector& b);
 
 // column vector by column vector -> column vector operations
 
-  ComplexColumnVector operator + (const ColumnVector& a) const;
-  ComplexColumnVector operator - (const ColumnVector& a) const;
-
-  ComplexColumnVector operator + (const ComplexColumnVector& a) const;
-  ComplexColumnVector operator - (const ComplexColumnVector& a) const;
-
-  ComplexColumnVector product (const ColumnVector& a) const;  // el by el
-  ComplexColumnVector quotient (const ColumnVector& a) const; // el by el
-
-  ComplexColumnVector product (const ComplexColumnVector& a) const;
-  ComplexColumnVector quotient (const ComplexColumnVector& a) const;
-
-  ComplexColumnVector& operator += (const ColumnVector& a);
-  ComplexColumnVector& operator -= (const ColumnVector& a);
-
-  ComplexColumnVector& operator += (const ComplexColumnVector& a);
-  ComplexColumnVector& operator -= (const ComplexColumnVector& a);
-
-// unary operations
-
-  ComplexColumnVector operator - (void) const;
+  friend ComplexColumnVector operator + (const ComplexColumnVector& a,
+					 const ColumnVector& b);
+  friend ComplexColumnVector operator - (const ComplexColumnVector& a,
+					 const ColumnVector& b);
+
+  friend ComplexColumnVector product (const ComplexColumnVector& a,
+				      const ColumnVector& b);
+  friend ComplexColumnVector quotient (const ComplexColumnVector& a,
+				       const ColumnVector& b);
+
+// other operations
 
   friend ComplexColumnVector map (c_c_Mapper f, const ComplexColumnVector& a);
   friend ColumnVector map (d_c_Mapper f, const ComplexColumnVector& a);
   void map (c_c_Mapper f);
 
   Complex min (void) const;
   Complex max (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const ComplexColumnVector& a);
 
-// conversions
-
-  Complex *fortran_vec (void) const;
+#define KLUDGE_VECTORS
+#define TYPE Complex
+#define KL_VEC_TYPE ComplexColumnVector
+#include "mx-kludge.h"
+#undef KLUDGE_VECTORS
+#undef TYPE
+#undef KL_VEC_TYPE
 
 private:
-  int len;
-  Complex *data;
-
-  ComplexColumnVector (Complex *d, int l);
+
+  ComplexColumnVector (Complex *d, int l) : Array<Complex> (d, l) { }
 };
 
-inline ComplexColumnVector::ComplexColumnVector (void) { len = 0; data = 0; }
-inline ComplexColumnVector::ComplexColumnVector (Complex *d, int l)
-  { len = l; data = d; }
-inline ComplexColumnVector::~ComplexColumnVector (void)
-  { delete [] data; data = 0; }
-
-inline int ComplexColumnVector::capacity (void) const { return len; }
-inline int ComplexColumnVector::length (void) const { return len; }
-
-inline Complex& ComplexColumnVector::elem (int n) { return data[n]; }
-
-inline Complex& ComplexColumnVector::operator () (int n)
-  { return checkelem (n); }
-
-inline Complex ComplexColumnVector::elem (int n) const { return data[n]; }
-
-inline Complex ComplexColumnVector::operator () (int n) const
-  { return checkelem (n); }
-
-inline Complex *ComplexColumnVector::fortran_vec (void) const { return data; }
-
 /*
  * Complex Row Vector class
  */
 
-class ComplexRowVector
+class ComplexRowVector : public Array<Complex>
 {
-friend class RowVector;
-friend class ComplexMatrix;
-friend class ComplexColumnVector;
-friend class ComplexDiagMatrix;
-
 public:
-  ComplexRowVector (void);
-  ComplexRowVector (int n);
-  ComplexRowVector (int n, double val);
-  ComplexRowVector (int n, const Complex& val);
+
+  ComplexRowVector (void) : Array<Complex> () { }
+  ComplexRowVector (int n) : Array<Complex> (n) { }
+  ComplexRowVector (int n, const Complex& val) : Array<Complex> (n, val) { }
   ComplexRowVector (const RowVector& a);
-  ComplexRowVector (const ComplexRowVector& a);
-  ComplexRowVector (double a);
-  ComplexRowVector (const Complex& a);
- ~ComplexRowVector (void);
-
-  ComplexRowVector& operator = (const RowVector& a);
-  ComplexRowVector& operator = (const ComplexRowVector& a);
-
-  int capacity (void) const;
-  int length (void) const;
-
-  Complex& checkelem (int n);
-  Complex& elem (int n);
-  Complex& operator () (int n);
-
-  Complex checkelem (int n) const; // const access
-  Complex elem (int n) const;
-  Complex operator () (int n) const;
-
-  ComplexRowVector& resize (int n);
-  ComplexRowVector& resize (int n, double val);
-  ComplexRowVector& resize (int n, const Complex& val);
+  ComplexRowVector (const Array<Complex>& a) : Array<Complex> (a) { }
+  ComplexRowVector (const ComplexRowVector& a) : Array<Complex> (a) { }
+//  ComplexRowVector (double a) : Array<Complex> (1, a) { }
+//  ComplexRowVector (const Complex& a) : Array<Complex> (1, a) { }
+
+  ComplexRowVector& operator = (const ComplexRowVector& a)
+    { return Array<Complex>::operator = (a); }
+
+//  operator Array<Complex>& () const { return *this; }
 
   int operator == (const ComplexRowVector& a) const;
   int operator != (const ComplexRowVector& a) const;
 
 // destructive insert/delete/reorder operations
 
   ComplexRowVector& insert (const RowVector& a, int c);
   ComplexRowVector& insert (const ComplexRowVector& a, int c);
@@ -1356,167 +1053,118 @@ public:
   friend RowVector real (const ComplexRowVector& a);
   friend RowVector imag (const ComplexRowVector& a);
   friend ComplexRowVector conj (const ComplexRowVector& a);
 
 // resize is the destructive equivalent for this one
 
   ComplexRowVector extract (int c1, int c2) const;
 
+// row vector by row vector -> row vector operations
+
+  ComplexRowVector& operator += (const RowVector& a);
+  ComplexRowVector& operator -= (const RowVector& a);
+
+  ComplexRowVector& operator += (const ComplexRowVector& a);
+  ComplexRowVector& operator -= (const ComplexRowVector& a);
+
 // row vector by scalar -> row vector operations
 
-  ComplexRowVector operator + (double s) const;
-  ComplexRowVector operator - (double s) const;
-  ComplexRowVector operator * (double s) const;
-  ComplexRowVector operator / (double s) const;
-
-  ComplexRowVector operator + (const Complex& s) const;
-  ComplexRowVector operator - (const Complex& s) const;
-  ComplexRowVector operator * (const Complex& s) const;
-  ComplexRowVector operator / (const Complex& s) const;
+  friend ComplexRowVector operator + (const ComplexRowVector& a, double s);
+  friend ComplexRowVector operator - (const ComplexRowVector& a, double s);
+  friend ComplexRowVector operator * (const ComplexRowVector& a, double s);
+  friend ComplexRowVector operator / (const ComplexRowVector& a, double s);
 
 // scalar by row vector -> row vector operations
 
   friend ComplexRowVector operator + (double s, const ComplexRowVector& a);
   friend ComplexRowVector operator - (double s, const ComplexRowVector& a);
   friend ComplexRowVector operator * (double s, const ComplexRowVector& a);
   friend ComplexRowVector operator / (double s, const ComplexRowVector& a);
 
-  friend ComplexRowVector operator + (const Complex& s, const
-				      ComplexRowVector& a);
-  friend ComplexRowVector operator - (const Complex& s, const
-				      ComplexRowVector& a);
-  friend ComplexRowVector operator * (const Complex& s, const
-				      ComplexRowVector& a);
-  friend ComplexRowVector operator / (const Complex& s, const
-				      ComplexRowVector& a);
-
 // row vector by column vector -> scalar
 
-  Complex operator * (const ColumnVector& a) const;
-
-  Complex operator * (const ComplexColumnVector& a) const;
+  friend Complex operator * (const ComplexRowVector& a, const ColumnVector& b);
+
+  friend Complex operator * (const ComplexRowVector& a,
+			     const ComplexColumnVector& b);
 
 // row vector by matrix -> row vector
 
-  ComplexRowVector operator * (const Matrix& a) const;
-
-  ComplexRowVector operator * (const ComplexMatrix& a) const;
+  friend ComplexRowVector operator * (const ComplexRowVector& a,
+				      const ComplexMatrix& b);
 
 // row vector by row vector -> row vector operations
 
-  ComplexRowVector operator + (const RowVector& a) const;
-  ComplexRowVector operator - (const RowVector& a) const;
-
-  ComplexRowVector operator + (const ComplexRowVector& a) const;
-  ComplexRowVector operator - (const ComplexRowVector& a) const;
-
-  ComplexRowVector product (const RowVector& a) const;  // element by element
-  ComplexRowVector quotient (const RowVector& a) const; // element by element
-
-  ComplexRowVector product (const ComplexRowVector& a) const;  // el by el
-  ComplexRowVector quotient (const ComplexRowVector& a) const; // el by el
-
-  ComplexRowVector& operator += (const RowVector& a);
-  ComplexRowVector& operator -= (const RowVector& a);
-
-  ComplexRowVector& operator += (const ComplexRowVector& a);
-  ComplexRowVector& operator -= (const ComplexRowVector& a);
-
-// unary operations
-
-  ComplexRowVector operator - (void) const;
+  friend ComplexRowVector operator + (const ComplexRowVector& a,
+				      const RowVector& b);
+  friend ComplexRowVector operator - (const ComplexRowVector& a,
+				      const RowVector& b);
+
+  friend ComplexRowVector product (const ComplexRowVector& a,
+				   const RowVector& b);
+  friend ComplexRowVector quotient (const ComplexRowVector& a,
+				    const RowVector& b);
+
+// other operations
 
   friend ComplexRowVector map (c_c_Mapper f, const ComplexRowVector& a);
   friend RowVector map (d_c_Mapper f, const ComplexRowVector& a);
   void map (c_c_Mapper f);
 
   Complex min (void) const;
   Complex max (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const ComplexRowVector& a);
 
-// conversions
-
-  Complex *fortran_vec (void) const;
+#define KLUDGE_VECTORS
+#define TYPE Complex
+#define KL_VEC_TYPE ComplexRowVector
+#include "mx-kludge.h"
+#undef KLUDGE_VECTORS
+#undef TYPE
+#undef KL_VEC_TYPE
 
 private:
-  int len;
-  Complex *data;
-
-  ComplexRowVector (Complex *d, int l);
+
+  ComplexRowVector (Complex *d, int l) : Array<Complex> (d, l) { }
 };
 
-inline ComplexRowVector::ComplexRowVector (void) { len = 0; data = 0; }
-inline ComplexRowVector::ComplexRowVector (Complex *d, int l)
-  { len = l; data = d; }
-inline ComplexRowVector::~ComplexRowVector (void) { delete [] data; data = 0; }
-
-inline int ComplexRowVector::capacity (void) const { return len; }
-inline int ComplexRowVector::length (void) const { return len; }
-
-inline Complex& ComplexRowVector::elem (int n) { return data[n]; }
-
-inline Complex& ComplexRowVector::operator () (int n) { return checkelem (n); }
-
-inline Complex ComplexRowVector::elem (int n) const { return data[n]; }
-
-inline Complex ComplexRowVector::operator () (int n) const
-  { return checkelem (n); }
-
-inline Complex *ComplexRowVector::fortran_vec (void) const { return data; }
-
 /*
  * Complex Diagonal Matrix class
  */
 
-class ComplexDiagMatrix
+class ComplexDiagMatrix : public DiagArray<Complex>
 {
-friend class Matrix;
-friend class DiagMatrix;
-friend class ComplexMatrix;
-
 public:
-  ComplexDiagMatrix (void);
-  ComplexDiagMatrix (int n);
-  ComplexDiagMatrix (int n, double val);
-  ComplexDiagMatrix (int n, const Complex& val);
-  ComplexDiagMatrix (int r, int c);
-  ComplexDiagMatrix (int r, int c, double val);
-  ComplexDiagMatrix (int r, int c, const Complex& val);
+
+  ComplexDiagMatrix (void) : DiagArray<Complex> () { }
+  ComplexDiagMatrix (int n) : DiagArray<Complex> (n) { }
+  ComplexDiagMatrix (int n, const Complex& val)
+    : DiagArray<Complex> (n, val) { }
+  ComplexDiagMatrix (int r, int c) : DiagArray<Complex> (r, c) { }
+  ComplexDiagMatrix (int r, int c, const Complex& val)
+    : DiagArray<Complex> (r, c, val) { }
   ComplexDiagMatrix (const RowVector& a);
-  ComplexDiagMatrix (const ComplexRowVector& a);
+  ComplexDiagMatrix (const ComplexRowVector& a) : DiagArray<Complex> (a) { }
   ComplexDiagMatrix (const ColumnVector& a);
-  ComplexDiagMatrix (const ComplexColumnVector& a);
+  ComplexDiagMatrix (const ComplexColumnVector& a)
+    : DiagArray<Complex> (a) { }
   ComplexDiagMatrix (const DiagMatrix& a);
-  ComplexDiagMatrix (const ComplexDiagMatrix& a);
-  ComplexDiagMatrix (double a);
-  ComplexDiagMatrix (const Complex& a);
- ~ComplexDiagMatrix (void);
-
-  ComplexDiagMatrix& operator = (const DiagMatrix& a);
-  ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a);
-
-  int rows (void) const;
-  int cols (void) const;
-  int columns (void) const;
-
-  Complex& checkelem (int r, int c);
-  Complex& elem (int r, int c);
-  Complex& operator () (int r, int c);
-
-  Complex checkelem (int r, int c) const; // const access
-  Complex elem (int r, int c) const;
-  Complex operator () (int r, int c) const;
-
-  ComplexDiagMatrix& resize (int r, int c);
-  ComplexDiagMatrix& resize (int r, int c, double val);
-  ComplexDiagMatrix& resize (int r, int c, const Complex& val);
+  ComplexDiagMatrix (const DiagArray<Complex>& a)
+    : DiagArray<Complex> (a) { }
+  ComplexDiagMatrix (const ComplexDiagMatrix& a) : DiagArray<Complex> (a) { }
+//  ComplexDiagMatrix (const Complex& a) : DiagArray<Complex> (1, a) { }
+
+  ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a)
+    { return DiagArray<Complex>::operator = (a); }
+
+//  operator DiagArray<Complex>& () const { return *this; }
 
   int operator == (const ComplexDiagMatrix& a) const;
   int operator != (const ComplexDiagMatrix& a) const;
 
   ComplexDiagMatrix& fill (double val);
   ComplexDiagMatrix& fill (const Complex& val);
   ComplexDiagMatrix& fill (double val, int beg, int end);
   ComplexDiagMatrix& fill (const Complex& val, int beg, int end);
@@ -1546,158 +1194,133 @@ public:
   ComplexRowVector row (char *s) const;
 
   ComplexColumnVector column (int i) const;
   ComplexColumnVector column (char *s) const;
 
   ComplexDiagMatrix inverse (int& info) const;
   ComplexDiagMatrix inverse (void) const;
 
-// diagonal matrix by scalar -> matrix operations
-
-  ComplexMatrix operator + (double s) const;
-  ComplexMatrix operator - (double s) const;
-
-  ComplexMatrix operator + (const Complex& s) const;
-  ComplexMatrix operator - (const Complex& s) const;
-
-// diagonal matrix by scalar -> diagonal matrix operations
-
-  ComplexDiagMatrix operator * (double s) const;
-  ComplexDiagMatrix operator / (double s) const;
-
-  ComplexDiagMatrix operator * (const Complex& s) const;
-  ComplexDiagMatrix operator / (const Complex& s) const;
-
-// scalar by diagonal matrix -> matrix operations
-
-  friend ComplexMatrix operator + (double s, const ComplexDiagMatrix& a);
-  friend ComplexMatrix operator - (double s, const ComplexDiagMatrix& a);
-
-  friend ComplexMatrix operator + (const Complex& s, const
-				   ComplexDiagMatrix& a);
-  friend ComplexMatrix operator - (const Complex& s, const
-				   ComplexDiagMatrix& a);
-
-// scalar by diagonal matrix -> diagonal matrix operations
-
-  friend ComplexDiagMatrix operator * (double s, const ComplexDiagMatrix& a);
-  friend ComplexDiagMatrix operator / (double s, const ComplexDiagMatrix& a);
-
-  friend ComplexDiagMatrix operator * (const Complex& s, const
-				       ComplexDiagMatrix& a);
-  friend ComplexDiagMatrix operator / (const Complex& s, const
-				       ComplexDiagMatrix& a);
-
-// diagonal matrix by column vector -> column vector operations
-
-  ComplexColumnVector operator * (const ColumnVector& a) const;
-
-  ComplexColumnVector operator * (const ComplexColumnVector& a) const;
-
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
-  ComplexDiagMatrix operator + (const DiagMatrix& a) const;
-  ComplexDiagMatrix operator - (const DiagMatrix& a) const;
-  ComplexDiagMatrix operator * (const DiagMatrix& a) const;
-
-  ComplexDiagMatrix operator + (const ComplexDiagMatrix& a) const;
-  ComplexDiagMatrix operator - (const ComplexDiagMatrix& a) const;
-  ComplexDiagMatrix operator * (const ComplexDiagMatrix& a) const;
-
-  ComplexDiagMatrix product (const DiagMatrix& a) const;  // element by element
-  ComplexDiagMatrix quotient (const DiagMatrix& a) const; // element by element
-
-  ComplexDiagMatrix product (const ComplexDiagMatrix& a) const;  // el by el
-  ComplexDiagMatrix quotient (const ComplexDiagMatrix& a) const; // el by el
-
   ComplexDiagMatrix& operator += (const DiagMatrix& a);
   ComplexDiagMatrix& operator -= (const DiagMatrix& a);
 
   ComplexDiagMatrix& operator += (const ComplexDiagMatrix& a);
   ComplexDiagMatrix& operator -= (const ComplexDiagMatrix& a);
 
+// diagonal matrix by scalar -> matrix operations
+
+  friend ComplexMatrix operator + (const ComplexDiagMatrix& a, double s);
+  friend ComplexMatrix operator - (const ComplexDiagMatrix& a, double s);
+
+  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
+				   const Complex& s);
+  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
+				   const Complex& s);
+
+// diagonal matrix by scalar -> diagonal matrix operations
+
+  friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a, double s);
+  friend ComplexDiagMatrix operator / (const ComplexDiagMatrix& a, double s);
+
+// scalar by diagonal matrix -> matrix operations
+
+  friend ComplexMatrix operator + (double s, const ComplexDiagMatrix& a);
+  friend ComplexMatrix operator - (double s, const ComplexDiagMatrix& a);
+
+  friend ComplexMatrix operator + (const Complex& s,
+				   const ComplexDiagMatrix& a);
+  friend ComplexMatrix operator - (const Complex& s,
+				   const ComplexDiagMatrix& a);
+
+// scalar by diagonal matrix -> diagonal matrix operations
+
+  friend ComplexDiagMatrix operator * (double s, const ComplexDiagMatrix& a);
+
+// diagonal matrix by column vector -> column vector operations
+
+  friend ComplexColumnVector operator * (const ComplexDiagMatrix& a,
+					 const ColumnVector& b);
+
+  friend ComplexColumnVector operator * (const ComplexDiagMatrix& a,
+					 const ComplexColumnVector& b);
+
+// diagonal matrix by diagonal matrix -> diagonal matrix operations
+
+  friend ComplexDiagMatrix operator + (const ComplexDiagMatrix& a,
+				       const DiagMatrix& b);
+  friend ComplexDiagMatrix operator - (const ComplexDiagMatrix& a,
+				       const DiagMatrix& b);
+
+  friend ComplexDiagMatrix product (const ComplexDiagMatrix& a,
+				    const DiagMatrix& b); 
+
 // diagonal matrix by matrix -> matrix operations
 
-  ComplexMatrix operator + (const Matrix& a) const;
-  ComplexMatrix operator - (const Matrix& a) const;
-  ComplexMatrix operator * (const Matrix& a) const;
-
-  ComplexMatrix operator + (const ComplexMatrix& a) const;
-  ComplexMatrix operator - (const ComplexMatrix& a) const;
-  ComplexMatrix operator * (const ComplexMatrix& a) const;
-
-// unary operations
-
-  ComplexDiagMatrix operator - (void) const;
+  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
+				   const Matrix& b); 
+  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
+				   const Matrix& b);
+  friend ComplexMatrix operator * (const ComplexDiagMatrix& a,
+				   const Matrix& b);
+
+  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
+				   const ComplexMatrix& b);
+  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
+				   const ComplexMatrix& b);
+  friend ComplexMatrix operator * (const ComplexDiagMatrix& a,
+				   const ComplexMatrix& b);
+
+// other operations
 
   ComplexColumnVector diag (void) const;
   ComplexColumnVector diag (int k) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const ComplexDiagMatrix& a);
 
+#define KLUDGE_DIAG_MATRICES
+#define TYPE Complex
+#define KL_DMAT_TYPE ComplexDiagMatrix
+#include "mx-kludge.h"
+#undef KLUDGE_DIAG_MATRICES
+#undef TYPE
+#undef KL_DMAT_TYPE
+
 private:
-  int nr;
-  int nc;
-  int len;
-  Complex *data;
-
-  ComplexDiagMatrix (Complex *d, int nr, int nc);
+
+  ComplexDiagMatrix (Complex *d, int nr, int nc)
+    : DiagArray<Complex> (d, nr, nc) { }
 };
 
-inline ComplexDiagMatrix::ComplexDiagMatrix (void)
-  { nr = 0; nc = 0; len = 0; data = 0; }
-
-inline ComplexDiagMatrix::ComplexDiagMatrix (Complex *d, int r, int c)
-  { nr = r; nc = c; len = nr < nc ? nr : nc; data = d; }
-
-inline ComplexDiagMatrix::~ComplexDiagMatrix (void)
-  { delete [] data; data = 0; }
-
-inline int ComplexDiagMatrix::rows (void) const { return nr; }
-inline int ComplexDiagMatrix::cols (void) const { return nc; }
-inline int ComplexDiagMatrix::columns (void) const { return nc; } 
-
-// Would be nice to be able to avoid compiler warning and make this
-// fail on assignment.
-inline Complex& ComplexDiagMatrix::elem (int r, int c)
-  { Complex czero (0.0, 0.0); return (r == c) ? data[r] : czero; }
-
-inline Complex& ComplexDiagMatrix::operator () (int r, int c)
-  { return checkelem (r, c); }
-
-inline Complex ComplexDiagMatrix::elem (int r, int c) const
-  { Complex czero (0.0, 0.0); return (r == c) ? data[r] : czero; }
-
-inline Complex ComplexDiagMatrix::operator () (int r, int c) const
-  { return checkelem (r, c); }
-
 /*
  * Result of a AEP Balance operation
  */
 
 class AEPBALANCE
 {
 friend class Matrix;
 
 public:
+
   AEPBALANCE (void) {}
 
   AEPBALANCE (const Matrix& a, const char *balance_job);
 
   AEPBALANCE (const AEPBALANCE& a);
 
   AEPBALANCE& operator = (const AEPBALANCE& a);
   Matrix balanced_matrix (void) const;
   Matrix balancing_matrix (void) const;
   friend ostream& operator << (ostream& os, const AEPBALANCE& a);
 
 private:
+
   int init (const Matrix& a, const char * balance_job);
 
   Matrix balanced_mat;
   Matrix balancing_mat;
 };
 
 inline AEPBALANCE::AEPBALANCE (const Matrix& a,const char * balance_job) 
 {
@@ -1728,26 +1351,28 @@ inline Matrix AEPBALANCE::balancing_matr
  * Result of a Complex balancing operation
  */
 
 class ComplexAEPBALANCE
 {
 friend class ComplexMatrix;
 
 public:
+
   ComplexAEPBALANCE (void) {}
   ComplexAEPBALANCE (const ComplexMatrix& a, const char *balance_job);
   ComplexAEPBALANCE (const ComplexAEPBALANCE& a);
   ComplexAEPBALANCE& operator = (const ComplexAEPBALANCE& a);
   ComplexMatrix balanced_matrix (void) const;
   ComplexMatrix balancing_matrix (void) const;
 
   friend ostream& operator << (ostream& os, const ComplexAEPBALANCE& a);
 
 private:
+
   int init (const ComplexMatrix& a, const char * balance_job);
 
   ComplexMatrix balanced_mat;
   ComplexMatrix balancing_mat;
 };
 
 inline ComplexAEPBALANCE::ComplexAEPBALANCE (const ComplexMatrix& a,
 					     const char * balance_job)
@@ -1778,127 +1403,110 @@ inline ComplexMatrix ComplexAEPBALANCE::
 
 /*
  * Result of a Determinant calculation.
  */
 
 class DET
 {
 public:
+
   DET (void) {}
 
   DET (const DET& a);
 
   DET& operator = (const DET& a);
 
   int value_will_overflow (void) const;
   int value_will_underflow (void) const;
   double coefficient (void) const;
   int exponent (void) const;
   double value (void) const;
 
   friend ostream&  operator << (ostream& os, const DET& a);
 
 private:
+
   DET (const double *d);
 
   double det [2];
 };
 
 inline DET::DET (const DET& a) { det[0] = a.det[0]; det[1] = a.det[1]; }
 
 inline DET& DET::operator = (const DET& a)
   { det[0] = a.det[0]; det[1] = a.det[1]; return *this; }
 
-inline int DET::value_will_overflow (void) const
-  { return det[2] + 1 > log10 (MAXDOUBLE) ? 1 : 0; }
-
-inline int DET::value_will_underflow (void) const
-  { return det[2] - 1 < log10 (MINDOUBLE) ? 1 : 0; }
-
-inline double DET::coefficient (void) const { return det[0]; }
-inline int DET::exponent (void) const { return (int) det[1]; }
-inline double DET::value (void) const { return det[0] * pow (10.0, det[1]); }
-
 inline DET::DET (const double *d) { det[0] = d[0]; det[1] = d[1]; }
 
 /*
  * Result of a Determinant calculation.
  */
 
 class ComplexDET
 {
 public:
+
   ComplexDET (void) {}
 
   ComplexDET (const ComplexDET& a);
 
   ComplexDET& operator = (const ComplexDET& a);
 
   int value_will_overflow (void) const;
   int value_will_underflow (void) const;
   Complex coefficient (void) const;
   int exponent (void) const;
   Complex value (void) const;
 
   friend ostream&  operator << (ostream& os, const ComplexDET& a);
 
 private:
+
   ComplexDET (const Complex *d);
 
   Complex det [2];
 };
 
 inline ComplexDET::ComplexDET (const ComplexDET& a)
   { det[0] = a.det[0]; det[1] = a.det[1]; }
 
 inline ComplexDET& ComplexDET::operator = (const ComplexDET& a)
   { det[0] = a.det[0]; det[1] = a.det[1]; return *this; }
 
-inline int ComplexDET::value_will_overflow (void) const
-  { return real (det[2]) + 1 > log10 (MAXDOUBLE) ? 1 : 0; }
-
-inline int ComplexDET::value_will_underflow (void) const
-  { return real (det[2]) - 1 < log10 (MINDOUBLE) ? 1 : 0; }
-
-inline Complex ComplexDET::coefficient (void) const { return det[0]; }
-
-inline int ComplexDET::exponent (void) const { return (int) real (det[1]); }
-
-inline Complex ComplexDET::value (void) const
-  { return det[0] * pow (10.0, real (det[1])); }
-
 inline ComplexDET::ComplexDET (const Complex *d)
   { det[0] = d[0]; det[1] = d[1]; }
 
 /*
  * Result of a GEP Balance operation
  * Note: currenlty only do balancing on real data.  Complex balancing
  * done on magnitudes of complex data.
  */
 
 class GEPBALANCE
 {
 friend class Matrix;
 
 public:
+
   GEPBALANCE (void) {}
 
   GEPBALANCE (const Matrix& a, const Matrix &, const char *balance_job);
 
   GEPBALANCE (const GEPBALANCE& a);
 
   GEPBALANCE& operator = (const GEPBALANCE& a);
   Matrix balanced_a_matrix (void) const;
   Matrix balanced_b_matrix (void) const;
   Matrix left_balancing_matrix (void) const;
   Matrix right_balancing_matrix (void) const;
   friend ostream& operator << (ostream& os, const GEPBALANCE& a);
 
 private:
+
   int init (const Matrix& a, const Matrix& b, const char * balance_job);
 
   Matrix balanced_a_mat;
   Matrix balanced_b_mat;
   Matrix left_balancing_mat;
   Matrix right_balancing_mat;
 };
 
@@ -1943,28 +1551,30 @@ inline Matrix GEPBALANCE::right_balancin
  * Result of a Cholesky Factorization
  */
 
 class CHOL
 {
 friend class Matrix;
 
 public:
+
   CHOL (void) {}
 
   CHOL (const Matrix& a);
   CHOL (const Matrix& a, int& info);
 
   CHOL (const CHOL& a);
 
   CHOL& operator = (const CHOL& a);
   Matrix chol_matrix (void) const;
   friend ostream& operator << (ostream& os, const CHOL& a);
 
 private:
+
   int init (const Matrix& a);
 
   Matrix chol_mat;
 };
 
 inline CHOL::CHOL (const Matrix& a) {init (a); }
 inline CHOL::CHOL (const Matrix& a, int& info) { info = init (a); }
 inline CHOL::CHOL (const CHOL& a) { chol_mat = a.chol_mat; }
@@ -1983,26 +1593,28 @@ inline Matrix CHOL::chol_matrix (void) c
  * Result of a Cholesky Factorization
  */
 
 class ComplexCHOL
 {
 friend class ComplexMatrix;
 
 public:
+
   ComplexCHOL (void) {}
   ComplexCHOL (const ComplexMatrix& a);
   ComplexCHOL (const ComplexMatrix& a, int& info);
   ComplexCHOL (const ComplexCHOL& a);
   ComplexCHOL& operator = (const ComplexCHOL& a);
   ComplexMatrix chol_matrix (void) const;
 
   friend ostream& operator << (ostream& os, const ComplexCHOL& a);
 
 private:
+
   int init (const ComplexMatrix& a);
 
   ComplexMatrix chol_mat;
 };
 
 inline ComplexCHOL::ComplexCHOL (const ComplexMatrix& a) { init (a); }
 inline ComplexCHOL::ComplexCHOL (const ComplexMatrix& a, int& info)
   { info = init (a); }
@@ -2026,29 +1638,31 @@ inline ComplexMatrix ComplexCHOL::chol_m
  * Result of a Hessenberg Decomposition
  */
 
 class HESS
 {
 friend class Matrix;
 
 public:
+
   HESS (void) {}
 
   HESS (const Matrix& a);
   HESS (const Matrix&a, int& info);
 
   HESS (const HESS& a);
 
   HESS& operator = (const HESS& a);
   Matrix hess_matrix (void) const;
   Matrix unitary_hess_matrix (void) const;
   friend ostream& operator << (ostream& os, const HESS& a);
 
 private:
+
   int init (const Matrix& a);
 
   Matrix hess_mat;
   Matrix unitary_hess_mat;
 };
 
 inline HESS::HESS (const Matrix& a) {init (a); }
 inline HESS::HESS (const Matrix& a, int& info) { info = init(a); }
@@ -2075,27 +1689,29 @@ inline Matrix HESS::unitary_hess_matrix 
  * Result of a Hessenberg Decomposition
  */
 
 class ComplexHESS
 {
 friend class ComplexMatrix;
 
 public:
+
   ComplexHESS (void) {}
   ComplexHESS (const ComplexMatrix& a);
   ComplexHESS (const ComplexMatrix& a, int& info);
   ComplexHESS (const ComplexHESS& a);
   ComplexHESS& operator = (const ComplexHESS& a);
   ComplexMatrix hess_matrix (void) const;
   ComplexMatrix unitary_hess_matrix (void) const;
 
   friend ostream& operator << (ostream& os, const ComplexHESS& a);
 
 private:
+
   int init (const ComplexMatrix& a);
 
   ComplexMatrix hess_mat;
   ComplexMatrix unitary_hess_mat;
 };
 
 inline ComplexHESS::ComplexHESS (const ComplexMatrix& a) { init(a); }
 inline ComplexHESS::ComplexHESS (const ComplexMatrix& a, int& info)
@@ -2126,31 +1742,33 @@ inline ComplexMatrix ComplexHESS::unitar
  * Result of a Schur Decomposition
  */
 
 class SCHUR
 {
 friend class Matrix;
 
 public:
+
   SCHUR (void) {}
 
   SCHUR (const Matrix& a, const char *ord);
   SCHUR (const Matrix& a, const char *ord, int& info);
 
   SCHUR (const SCHUR& a, const char *ord);
 
-  SCHUR& operator = (const SCHUR& a, const char *ord);
+  SCHUR& operator = (const SCHUR& a);
 
   Matrix schur_matrix (void) const;
   Matrix unitary_matrix (void) const;
 
   friend ostream& operator << (ostream& os, const SCHUR& a);
 
 private:
+
   int init (const Matrix& a, const char *ord);
 
   Matrix schur_mat;
   Matrix unitary_mat;
 };
 
 inline SCHUR::SCHUR (const Matrix& a, const char *ord) { init (a, ord); }
 inline SCHUR::SCHUR (const Matrix& a, const char *ord, int& info) 
@@ -2158,17 +1776,17 @@ inline SCHUR::SCHUR (const Matrix& a, co
 
 inline SCHUR::SCHUR (const SCHUR& a, const char *ord)
 {
   schur_mat = a.schur_mat;
   unitary_mat = a.unitary_mat;
 }
 
 inline SCHUR&
-SCHUR::operator = (const SCHUR& a, const char *ord)
+SCHUR::operator = (const SCHUR& a)
 {
   schur_mat = a.schur_mat;
   unitary_mat = a.unitary_mat;
   
   return *this;
 }
 
 inline Matrix SCHUR::schur_matrix (void) const { return schur_mat; }
@@ -2178,31 +1796,33 @@ inline Matrix SCHUR::unitary_matrix (voi
  * Result of a Schur Decomposition
  */
 
 class ComplexSCHUR
 {
 friend class ComplexMatrix;
 
 public:
+
   ComplexSCHUR (void) {}
 
   ComplexSCHUR (const ComplexMatrix& a, const char *ord);
   ComplexSCHUR (const ComplexMatrix& a, const char *ord, int& info);
 
   ComplexSCHUR (const ComplexSCHUR& a, const char *ord);
 
-  ComplexSCHUR& operator = (const ComplexSCHUR& a, const char *ord);
+  ComplexSCHUR& operator = (const ComplexSCHUR& a);
 
   ComplexMatrix schur_matrix (void) const;
   ComplexMatrix unitary_matrix (void) const;
 
   friend ostream& operator << (ostream& os, const ComplexSCHUR& a);
 
 private:
+
   int init (const ComplexMatrix& a, const char *ord);
 
   ComplexMatrix schur_mat;
   ComplexMatrix unitary_mat;
 };
 
 inline ComplexSCHUR::ComplexSCHUR (const ComplexMatrix& a, const char *ord) 
   { init (a,ord); }
@@ -2213,17 +1833,17 @@ inline ComplexSCHUR::ComplexSCHUR (const
 
 inline ComplexSCHUR::ComplexSCHUR (const ComplexSCHUR& a, const char *ord)
 {
   schur_mat = a.schur_mat;
   unitary_mat = a.unitary_mat;
 }
 
 inline ComplexSCHUR&
-ComplexSCHUR::operator = (const ComplexSCHUR& a, const char *ord)
+ComplexSCHUR::operator = (const ComplexSCHUR& a)
 {
   schur_mat = a.schur_mat;
   unitary_mat = a.unitary_mat;
 
   return *this;
 }
 
 inline ComplexMatrix ComplexSCHUR::schur_matrix (void) const
@@ -2237,32 +1857,34 @@ inline ComplexMatrix ComplexSCHUR::unita
  * Result of a Singular Value Decomposition.
  */
 
 class SVD
 {
 friend class Matrix;
 
 public:
+
   SVD (void) {}
 
   SVD (const Matrix& a);
   SVD (const Matrix& a, int& info);
 
   SVD (const SVD& a);
 
   SVD& operator = (const SVD& a);
 
   DiagMatrix singular_values (void) const;
   Matrix left_singular_matrix (void) const;
   Matrix right_singular_matrix (void) const;
 
   friend ostream&  operator << (ostream& os, const SVD& a);
 
 private:
+
   int init (const Matrix& a);
 
   DiagMatrix sigma;
   Matrix left_sm;
   Matrix right_sm;
 };
 
 inline SVD::SVD (const Matrix& a) { init (a); }
@@ -2293,32 +1915,34 @@ inline Matrix SVD::right_singular_matrix
  * Result of a Singular Value Decomposition.
  */
 
 class ComplexSVD
 {
 friend class ComplexMatrix;
 
 public:
+
   ComplexSVD (void) {}
 
   ComplexSVD (const ComplexMatrix& a);
   ComplexSVD (const ComplexMatrix& a, int& info);
 
   ComplexSVD (const ComplexSVD& a);
 
   ComplexSVD& operator = (const ComplexSVD& a);
 
   DiagMatrix singular_values (void) const;
   ComplexMatrix left_singular_matrix (void) const;
   ComplexMatrix right_singular_matrix (void) const;
 
   friend ostream&  operator << (ostream& os, const ComplexSVD& a);
 
 private:
+
   int init (const ComplexMatrix& a);
 
   DiagMatrix sigma;
   ComplexMatrix left_sm;
   ComplexMatrix right_sm;
 };
 
 inline ComplexSVD::ComplexSVD (const ComplexMatrix& a) { init (a); }
@@ -2356,16 +1980,17 @@ inline ComplexMatrix ComplexSVD::right_s
  */
 
 class EIG
 {
 friend class Matrix;
 friend class ComplexMatrix;
 
 public:
+
   EIG (void) {}
 
   EIG (const Matrix& a);
   EIG (const Matrix& a, int& info);
 
   EIG (const ComplexMatrix& a);
   EIG (const ComplexMatrix& a, int& info);
 
@@ -2374,16 +1999,17 @@ public:
   EIG& operator = (const EIG& a);
 
   ComplexColumnVector eigenvalues (void) const;
   ComplexMatrix eigenvectors (void) const;
 
   friend ostream&  operator << (ostream& os, const EIG& a);
 
 private:
+
   int init (const Matrix& a);
   int init (const ComplexMatrix& a);
 
   ComplexColumnVector lambda;
   ComplexMatrix v;
 };
 
 inline EIG::EIG (const Matrix& a) { init (a); }
@@ -2405,16 +2031,17 @@ inline ComplexMatrix EIG::eigenvectors (
  * Result of an LU decomposition.
  */
 
 class LU
 {
 friend class Matrix;
 
 public:
+
   LU (void) {}
 
   LU (const Matrix& a);
 
   LU (const LU& a);
 
   LU& operator = (const LU& a);
 
@@ -2440,16 +2067,17 @@ inline Matrix LU::L (void) const { retur
 inline Matrix LU::U (void) const { return u; }
 inline Matrix LU::P (void) const { return p; }
 
 class ComplexLU
 {
 friend class ComplexMatrix;
 
 public:
+
   ComplexLU (void) {}
 
   ComplexLU (const ComplexMatrix& a);
 
   ComplexLU (const ComplexLU& a);
 
   ComplexLU& operator = (const ComplexLU& a);
 
@@ -2477,58 +2105,62 @@ inline Matrix ComplexLU::P (void) const 
 
 /*
  * Result of a QR decomposition.
  */
 
 class QR
 {
 public:
+
   QR (void) {}
 
   QR (const Matrix& A);
 
   QR (const QR& a);
 
   QR& operator = (const QR& a);
 
   Matrix Q (void) const;
   Matrix R (void) const;
 
   friend ostream&  operator << (ostream& os, const QR& a);
 
 private:
+
   Matrix q;
   Matrix r;
 };
 
 inline QR::QR (const QR& a) { q = a.q; r = a.r; }
 
 inline QR& QR::operator = (const QR& a) { q = a.q; r = a.r; return *this; }
 
 inline Matrix QR::Q (void) const { return q; }
 inline Matrix QR::R (void) const { return r; }
 
 class ComplexQR
 {
 public:
+
   ComplexQR (void) {}
 
   ComplexQR (const ComplexMatrix& A);
 
   ComplexQR (const ComplexQR& a);
 
   ComplexQR& operator = (const ComplexQR& a);
 
   ComplexMatrix Q (void) const;
   ComplexMatrix R (void) const;
 
   friend ostream&  operator << (ostream& os, const ComplexQR& a);
 
 private:
+
   ComplexMatrix q;
   ComplexMatrix r;
 };
 
 inline ComplexQR::ComplexQR (const ComplexQR& a) { q = a.q; r = a.r; }
 
 inline ComplexQR& ComplexQR::operator = (const ComplexQR& a)
   { q = a.q; r = a.r; return *this; }
diff --git a/liboctave/NLConst.cc b/liboctave/NLConst.cc
--- a/liboctave/NLConst.cc
+++ b/liboctave/NLConst.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "NLConst.h"
 
 NLConst::NLConst (void) : Bounds (), NLFunc ()
 {
 }
 
diff --git a/liboctave/NLConst.h b/liboctave/NLConst.h
--- a/liboctave/NLConst.h
+++ b/liboctave/NLConst.h
@@ -19,22 +19,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_NLConst_h)
 #define _NLConst_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
-#include <Bounds.h>
 #include "Matrix.h"
+#include "Bounds.h"
 #include "NLFunc.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class NLConst : public Bounds, public NLFunc
 {
diff --git a/liboctave/NLEqn.cc b/liboctave/NLEqn.cc
--- a/liboctave/NLEqn.cc
+++ b/liboctave/NLEqn.cc
@@ -16,22 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include <float.h>
+
 #include "NLEqn.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (hybrd1) (int (*)(), const int*, double*, double*,
 			const double*, int*, double*, const int*);
diff --git a/liboctave/NLEqn.h b/liboctave/NLEqn.h
--- a/liboctave/NLEqn.h
+++ b/liboctave/NLEqn.h
@@ -19,22 +19,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_NLEqn_h)
 #define _NLEqn_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
-#include <NLFunc.h>
 #include "Matrix.h"
+#include "NLFunc.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class NLEqn : public NLFunc
 {
  public:
diff --git a/liboctave/NLFunc.cc b/liboctave/NLFunc.cc
--- a/liboctave/NLFunc.cc
+++ b/liboctave/NLFunc.cc
@@ -16,21 +16,20 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include "NLFunc.h"
 
 NLFunc::NLFunc (void)
 {
   fun = NULL;
   jac = NULL;
 }
 
diff --git a/liboctave/NLFunc.h b/liboctave/NLFunc.h
--- a/liboctave/NLFunc.h
+++ b/liboctave/NLFunc.h
@@ -19,21 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_NLFunc_h)
 #define _NLFunc_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
-#include <iostream.h>
 #include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 typedef Vector (*nonlinear_fcn) (Vector&);
 typedef Matrix (*jacobian_fcn) (Vector&);
diff --git a/liboctave/NLP.h b/liboctave/NLP.h
--- a/liboctave/NLP.h
+++ b/liboctave/NLP.h
@@ -19,21 +19,21 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_NLP_h)
 #define _NLP_h 1
 
+#include "Matrix.h"
 #include "Objective.h"
 #include "Bounds.h"
 #include "LinConst.h"
 #include "NLConst.h"
-#include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class NLP
 {
  public:
diff --git a/liboctave/NPSOL.cc b/liboctave/NPSOL.cc
--- a/liboctave/NPSOL.cc
+++ b/liboctave/NPSOL.cc
@@ -16,24 +16,24 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <math.h>
+
 #ifndef NPSOL_MISSING
 
-#ifdef __GNUG__
-#pragma implementation
-#endif
-
-#include <iostream.h>
-#include <math.h>
 #include "NPSOL.h"
 #include "f77-uscore.h"
 #include "sun-utils.h"
 
 extern "C"
 {
   int F77_FCN (npoptn) (char *, long);
 
diff --git a/liboctave/NPSOL.h b/liboctave/NPSOL.h
--- a/liboctave/NPSOL.h
+++ b/liboctave/NPSOL.h
@@ -16,25 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifndef NPSOL_MISSING
-
 #if !defined (_NPSOL_h)
 #define _NPSOL_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
+#ifndef NPSOL_MISSING
 
+#include "Matrix.h"
 #include "NLP.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class NPSOL : public NLP
 {
@@ -109,18 +106,18 @@ NPSOL::operator = (const NPSOL& a)
 
   cerr << "warning: NPSOL options reset to default values\n";
 
   set_default_options ();
 
   return *this;
 }
 
-#endif
+#endif /* NPSOL_MISSING */
 
-#endif /* NPSOL_MISSING */
+#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/ODE.h b/liboctave/ODE.h
--- a/liboctave/ODE.h
+++ b/liboctave/ODE.h
@@ -19,23 +19,20 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_ODE_h)
 #define _ODE_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
+class ostream;
 
-#include <iostream.h>
+#include "Matrix.h"
 #include "ODEFunc.h"
-#include "Matrix.h"
 
 class ODE : public ODEFunc
 {
 public:
 
   ODE (void);
 
   ODE (int n);
diff --git a/liboctave/ODEFunc.cc b/liboctave/ODEFunc.cc
--- a/liboctave/ODEFunc.cc
+++ b/liboctave/ODEFunc.cc
@@ -16,21 +16,20 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include "ODEFunc.h"
 
 ODEFunc::ODEFunc (void)
 {
   fun = NULL;
   jac = NULL;
 }
 
diff --git a/liboctave/ODEFunc.h b/liboctave/ODEFunc.h
--- a/liboctave/ODEFunc.h
+++ b/liboctave/ODEFunc.h
@@ -19,21 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_ODEFunc_h)
 #define _ODEFunc_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
-#include <iostream.h>
 #include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 #ifndef _ODEFunc_typedefs
 #define _ODEFunc_typedefs 1
diff --git a/liboctave/Objective.cc b/liboctave/Objective.cc
--- a/liboctave/Objective.cc
+++ b/liboctave/Objective.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Objective.h"
 
 Objective::Objective (void)
 {
   phi = (objective_fcn) NULL;
   grad = (gradient_fcn) NULL;
diff --git a/liboctave/Objective.h b/liboctave/Objective.h
--- a/liboctave/Objective.h
+++ b/liboctave/Objective.h
@@ -19,21 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_Objective_h)
 #define _Objective_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
-#include <iostream.h>
 #include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 typedef double (*objective_fcn) (Vector&);
 typedef Vector (*gradient_fcn) (Vector&);
diff --git a/liboctave/QLD.cc b/liboctave/QLD.cc
--- a/liboctave/QLD.cc
+++ b/liboctave/QLD.cc
@@ -16,22 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include <math.h>
+
 #include "QLD.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
   int F77_FCN (qld) (int*, int*, int*, int*, int*, double*, double*,
 		     double*, double*, double*, double*, double*,
 		     double*, int*, int*, int*, double*, int*, int*,
diff --git a/liboctave/QLD.h b/liboctave/QLD.h
--- a/liboctave/QLD.h
+++ b/liboctave/QLD.h
@@ -19,20 +19,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_QLD_h)
 #define _QLD_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
+#include "Matrix.h"
 #include "QP.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class QLD : public QP
 {
diff --git a/liboctave/QP.cc b/liboctave/QP.cc
--- a/liboctave/QP.cc
+++ b/liboctave/QP.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "QP.h"
 
 QP::QP (void) {}
 
 QP::QP (const Vector& x0, const Matrix& H_arg) : x (x0), H (H_arg)
 {
diff --git a/liboctave/QP.h b/liboctave/QP.h
--- a/liboctave/QP.h
+++ b/liboctave/QP.h
@@ -19,23 +19,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_QP_h)
 #define _QP_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
+#include "Matrix.h"
 #include "Bounds.h"
 #include "LinConst.h"
-#include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class QP
 {
  public:
diff --git a/liboctave/QPSOL.cc b/liboctave/QPSOL.cc
--- a/liboctave/QPSOL.cc
+++ b/liboctave/QPSOL.cc
@@ -16,22 +16,24 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include <math.h>
+
+#ifndef QPSOL_MISSING
+
 #include "QPSOL.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
   int F77_FCN (qpsol) (int*, int*, int*, int*, int*, int*, int*, int*,
 		       double*, double*, double*, double*, double*,
 		       double*, double*, int (*)(), int*, int*, int*,
@@ -168,14 +170,16 @@ QPSOL::minimize (double& objf, int& info
 }
 
 void
 QPSOL::set_default_options (void)
 {
   iprint = 0;
 }
 
+#endif /* QPSOL_MISSING */
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/QPSOL.h b/liboctave/QPSOL.h
--- a/liboctave/QPSOL.h
+++ b/liboctave/QPSOL.h
@@ -19,20 +19,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_QPSOL_h)
 #define _QPSOL_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
+#ifndef QPSOL_MISSING
 
+#include "Matrix.h"
 #include "QP.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 class QPSOL : public QP
 {
@@ -87,16 +86,18 @@ QPSOL::operator = (const QPSOL& a)
   H = a.H;
   c = a.c;
   bnds = a.bnds;
   lc = a.lc;
   iprint = a.iprint;
   return *this;
 }
 
+#endif /* QPSOL_MISSING */
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -16,21 +16,20 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-#include <iostream.h>
 #include "Quad.h"
 #include "f77-uscore.h"
 #include "sun-utils.h"
 
 static integrand_fcn user_fcn;
 
 extern "C"
 {
diff --git a/liboctave/Quad.h b/liboctave/Quad.h
--- a/liboctave/Quad.h
+++ b/liboctave/Quad.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_Quad_h)
 #define _Quad_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include "Matrix.h"
 
 #ifndef Vector
 #define Vector ColumnVector
 #endif
 
 #ifndef _Quad_typedefs
 #define _Quad_typedefs 1
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -16,20 +16,21 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
+#include <iostream.h>
 #include <limits.h>
 
 #include "Range.h"
 
 // NOTE: max and min only return useful values if nelem > 0.
 
 double
 Range::min (void) const
diff --git a/liboctave/Range.h b/liboctave/Range.h
--- a/liboctave/Range.h
+++ b/liboctave/Range.h
@@ -19,21 +19,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_Range_h)
 #define _Range_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
-#include <iostream.h>
+class istream;
+class ostream;
 
 class Range
 {
  public:
   Range (void);
   Range (const Range& r);
   Range (double b, double l);
   Range (double b, double l, double i);
diff --git a/liboctave/RowVector.cc b/liboctave/RowVector.cc
--- a/liboctave/RowVector.cc
+++ b/liboctave/RowVector.cc
@@ -16,22 +16,19 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-// I\'m not sure how this is supposed to work if the .h file declares
-// several classes, each of which is defined in a separate file...
-//
-// #ifdef __GNUG__
-// #pragma implementation "Matrix.h"
-// #endif
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
@@ -65,121 +62,17 @@ extern "C"
 		       const Complex*, const int*, const Complex*,
 		       Complex*, const int*, long);
 }
 
 /*
  * Row Vector class.
  */
 
-RowVector::RowVector (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create vector with negative dimension");
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  len = n;
-  if (len > 0)
-    data = new double [len];
-  else
-    data = (double *) NULL;
-}
-
-RowVector::RowVector (int n, double val)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create vector with negative dimension");
-      len = 0;
-      data = (double *) NULL;
-      return;
-    }
-
-  len = n;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, len, val);
-    }
-  else
-    data = (double *) NULL;
-}
-
-RowVector::RowVector (const RowVector& a)
-{
-  len = a.len;
-  if (len > 0)
-    {
-      data = new double [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (double *) NULL;
-}
-
-RowVector::RowVector (double a)
-{
-  len = 1;
-  data = new double [1];
-  data[0] = a;
-}
-
-RowVector&
-RowVector::operator = (const RowVector& a)
-{
-  if (this != &a)
-    {
-      delete [] data;
-      len = a.len;
-      if (len > 0)
-	{
-	  data = new double [len];
-	  copy (data, a.data, len);
-	}
-      else
-	data = (double *) NULL;
-    }
-  return *this;
-}
-
-double&
-RowVector::checkelem (int n)
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static double foo = 0.0;
-      return foo;
-    }
-#endif
-
-  return elem (n);
-}
-
-double
-RowVector::checkelem (int n) const
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return 0.0;
-    }
-#endif
-
-  return elem (n);
-}
-
+#if 0
 RowVector&
 RowVector::resize (int n)
 {
   if (n < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return *this;
@@ -207,638 +100,414 @@ RowVector::resize (int n, double val)
 {
   int old_len = len;
   resize (n);
   for (int i = old_len; i < len; i++)
     data[i] = val;
 
   return *this;
 }
+#endif
 
 int
 RowVector::operator == (const RowVector& a) const
 {
-  if (len != a.len)
+  int len = length ();
+  if (len != a.length ())
     return 0;
-  return equal (data, a.data, len);
+  return equal (data (), a.data (), len);
 }
 
 int
 RowVector::operator != (const RowVector& a) const
 {
-  if (len != a.len)
-    return 1;
-  return !equal (data, a.data, len);
+  return !(*this == a);
 }
 
 RowVector&
 RowVector::insert (const RowVector& a, int c)
 {
-  if (c < 0 || c + a.len - 1 > len)
+  int a_len = a.length ();
+  if (c < 0 || c + a_len - 1 > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    data[c+i] = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (c+i) = a.elem (i);
 
   return *this;
 }
 
 RowVector&
 RowVector::fill (double val)
 {
+  int len = length ();
   if (len > 0)
-    copy (data, len, val);
+    for (int i = 0; i < len; i++)
+      elem (i) = val;
   return *this;
 }
 
 RowVector&
 RowVector::fill (double val, int c1, int c2)
 {
+  int len = length ();
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int i = c1; i <= c2; i++)
-    data[i] = val;
+    elem (i) = val;
 
   return *this;
 }
 
 RowVector
 RowVector::append (const RowVector& a) const
 {
+  int len = length ();
   int nc_insert = len;
-  RowVector retval (len + a.len);
+  RowVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ColumnVector
 RowVector::transpose (void) const
 {
-  return ColumnVector (dup (data, len), len);
+  int len = length ();
+  return ColumnVector (dup (data (), len), len);
 }
 
 RowVector
 RowVector::extract (int c1, int c2) const
 {
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   int new_c = c2 - c1 + 1;
 
   RowVector result (new_c);
 
   for (int i = 0; i < new_c; i++)
-    result.data[i] = elem (c1+i);
+    result.elem (i) = elem (c1+i);
 
   return result;
 }
 
+// row vector by row vector -> row vector operations
+
+RowVector&
+RowVector::operator += (const RowVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), len);
+  return *this;
+}
+
+RowVector&
+RowVector::operator -= (const RowVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  double *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), len);
+  return *this;
+}
+
 // row vector by scalar -> row vector operations
 
-RowVector
-RowVector::operator + (double s) const
-{
-  return RowVector (add (data, len, s), len);
-}
-
-RowVector
-RowVector::operator - (double s) const
+ComplexRowVector
+operator + (const RowVector& v, const Complex& s)
 {
-  return RowVector (subtract (data, len, s), len);
-}
-
-RowVector
-RowVector::operator * (double s) const
-{
-  return RowVector (multiply (data, len, s), len);
-}
-
-RowVector
-RowVector::operator / (double s) const
-{
-  return RowVector (divide (data, len, s), len);
+  int len = v.length ();
+  return ComplexRowVector (add (v.data (), len, s), len);
 }
 
 ComplexRowVector
-RowVector::operator + (const Complex& s) const
+operator - (const RowVector& v, const Complex& s)
 {
-  return ComplexRowVector (add (data, len, s), len);
+  int len = v.length ();
+  return ComplexRowVector (subtract (v.data (), len, s), len);
 }
 
 ComplexRowVector
-RowVector::operator - (const Complex& s) const
+operator * (const RowVector& v, const Complex& s)
 {
-  return ComplexRowVector (subtract (data, len, s), len);
+  int len = v.length ();
+  return ComplexRowVector (multiply (v.data (), len, s), len);
 }
 
 ComplexRowVector
-RowVector::operator * (const Complex& s) const
+operator / (const RowVector& v, const Complex& s)
 {
-  return ComplexRowVector (multiply (data, len, s), len);
-}
-
-ComplexRowVector
-RowVector::operator / (const Complex& s) const
-{
-  return ComplexRowVector (divide (data, len, s), len);
+  int len = v.length ();
+  return ComplexRowVector (divide (v.data (), len, s), len);
 }
 
 // scalar by row vector -> row vector operations
 
-RowVector
-operator + (double s, const RowVector& a)
+ComplexRowVector
+operator + (const Complex& s, const RowVector& a)
 {
-  return RowVector (add (a.data, a.len, s), a.len);
+  return ComplexRowVector ();
 }
 
-RowVector
-operator - (double s, const RowVector& a)
+ComplexRowVector
+operator - (const Complex& s, const RowVector& a)
 {
-  return RowVector (subtract (s, a.data, a.len), a.len);
+  return ComplexRowVector ();
 }
 
-RowVector
-operator * (double s, const RowVector& a)
+ComplexRowVector
+operator * (const Complex& s, const RowVector& a)
 {
-  return RowVector (multiply (a.data, a.len, s), a.len);
+  return ComplexRowVector ();
 }
 
-RowVector
-operator / (double s, const RowVector& a)
+ComplexRowVector
+operator / (const Complex& s, const RowVector& a)
 {
-  return RowVector (divide (s, a.data, a.len), a.len);
+  return ComplexRowVector ();
 }
 
 // row vector by column vector -> scalar
 
 double
-RowVector::operator * (const ColumnVector& a) const
+operator * (const RowVector& v, const ColumnVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return 0.0;
     }
 
   int i_one = 1;
-  return F77_FCN (ddot) (&len, data, &i_one, a.data, &i_one);
+  return F77_FCN (ddot) (&len, v.data (), &i_one, a.data (), &i_one);
 }
 
 Complex
-RowVector::operator * (const ComplexColumnVector& a) const
+operator * (const RowVector& v, const ComplexColumnVector& a)
 {
-  ComplexRowVector tmp (*this);
+  ComplexRowVector tmp (v);
   return tmp * a;
 }
 
 // row vector by matrix -> row vector
 
 RowVector
-RowVector::operator * (const Matrix& a) const
+operator * (const RowVector& v, const Matrix& a)
 {
-  if (a.nr != len)
+  int len = v.length ();
+  if (a.rows () != len)
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return RowVector ();
     }
 
-  if (len == 0 || a.nc == 0)
+  if (len == 0 || a.cols () == 0)
     return RowVector (0);
 
 // Transpose A to form A'*x == (x'*A)'
 
-  int anr = a.nr;
-  int anc = a.nc;
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
 
   char trans = 'T';
-  int ld = anr;
+  int ld = a_nr;
   double alpha = 1.0;
   double beta  = 0.0;
   int i_one = 1;
 
   double *y = new double [len];
 
-  F77_FCN (dgemv) (&trans, &anc, &anr, &alpha, a.data, &ld, data,
-		   &i_one, &beta, y, &i_one, 1L); 
+  F77_FCN (dgemv) (&trans, &a_nc, &a_nr, &alpha, a.data (), &ld,
+		   v.data (), &i_one, &beta, y, &i_one, 1L); 
 
   return RowVector (y, len);
 }
 
 ComplexRowVector
-RowVector::operator * (const ComplexMatrix& a) const
+operator * (const RowVector& v, const ComplexMatrix& a)
 {
-  ComplexRowVector tmp (*this);
+  ComplexRowVector tmp (v);
   return tmp * a;
 }
 
 // row vector by row vector -> row vector operations
 
-RowVector
-RowVector::operator + (const RowVector& a) const
+ComplexRowVector
+operator + (const RowVector& v, const ComplexRowVector& a)
 {
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
-      return RowVector ();
-    }
-
-  if (len == 0)
-    return RowVector (0);
-
-  return RowVector (add (data, a.data, len), len);
-}
-
-RowVector
-RowVector::operator - (const RowVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
-      return RowVector ();
-    }
-
-  if (len == 0)
-    return RowVector (0);
-
-  return RowVector (subtract (data, a.data, len), len);
-}
-
-ComplexRowVector
-RowVector::operator + (const ComplexRowVector& a) const
-{
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector addition attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
-  return ComplexRowVector (add (data, a.data, len), len);
+  return ComplexRowVector (add (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
-RowVector::operator - (const ComplexRowVector& a) const
+operator - (const RowVector& v, const ComplexRowVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector subtraction attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
-  return ComplexRowVector (subtract (data, a.data, len), len);
-}
-
-RowVector
-RowVector::product (const RowVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
-      return RowVector ();
-    }
-
-  if (len == 0)
-    return RowVector (0);
-
-  return RowVector (multiply (data, a.data, len), len);
-}
-
-RowVector
-RowVector::quotient (const RowVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
-      return RowVector ();
-    }
-
-  if (len == 0)
-    return RowVector (0);
-
-  return RowVector (divide (data, a.data, len), len);
+  return ComplexRowVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
-RowVector::product (const ComplexRowVector& a) const
+product (const RowVector& v, const ComplexRowVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector product attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
-  return ComplexRowVector (multiply (data, a.data, len), len);
+  return ComplexRowVector (multiply (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
-RowVector::quotient (const ComplexRowVector& a) const
+quotient (const RowVector& v, const ComplexRowVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector quotient attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
-  return ComplexRowVector (divide (data, a.data, len), len);
-}
-
-RowVector&
-RowVector::operator += (const RowVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
+  return ComplexRowVector (divide (v.data (), a.data (), len), len);
 }
 
-RowVector&
-RowVector::operator -= (const RowVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
-}
-
-// unary operations
-
-RowVector
-RowVector::operator - (void) const
-{
-  if (len == 0)
-    return RowVector (0);
-
-  return RowVector (negate (data, len), len);
-}
+// other operations
 
 RowVector
 map (d_d_Mapper f, const RowVector& a)
 {
   RowVector b (a);
   b.map (f);
   return b;
 }
 
 void
 RowVector::map (d_d_Mapper f)
 {
-  for (int i = 0; i < len; i++)
-    data[i] = f (data[i]);
+  for (int i = 0; i < length (); i++)
+    elem (i) = f (elem (i));
 }
 
 double
 RowVector::min (void) const
 {
+  int len = length ();
   if (len == 0)
     return 0;
 
-  double res = data[0];
+  double res = elem (0);
 
   for (int i = 1; i < len; i++)
-    if (data[i] < res)
-      res = data[i];
+    if (elem (i) < res)
+      res = elem (i);
 
   return res;
 }
 
 double
 RowVector::max (void) const
 {
+  int len = length ();
   if (len == 0)
     return 0;
 
-  double res = data[0];
+  double res = elem (0);
 
   for (int i = 1; i < len; i++)
-    if (data[i] > res)
-      res = data[i];
+    if (elem (i) > res)
+      res = elem (i);
 
   return res;
 }
 
 ostream&
 operator << (ostream& os, const RowVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.len; i++)
-    os << " " /* setw (field_width) */ << a.data[i];
+  for (int i = 0; i < a.length (); i++)
+    os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 /*
  * Complex Row Vector class
  */
 
-ComplexRowVector::ComplexRowVector (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create vector with negative dimension");
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  len = n;
-  if (len > 0)
-    data = new Complex [len];
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexRowVector::ComplexRowVector (int n, double val)
+ComplexRowVector::ComplexRowVector (const RowVector& a)
+  : Array<Complex> (a.length ())
 {
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create vector with negative dimension");
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  len = n;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexRowVector::ComplexRowVector (int n, const Complex& val)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't create vector with negative dimension");
-      len = 0;
-      data = (Complex *) NULL;
-      return;
-    }
-
-  len = n;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, len, val);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexRowVector::ComplexRowVector (const RowVector& a)
-{
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
+  for (int i = 0; i < length (); i++)
+    elem (i) = a.elem (i);
 }
 
-ComplexRowVector::ComplexRowVector (const ComplexRowVector& a)
-{
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-}
-
-ComplexRowVector::ComplexRowVector (double a)
-{
-  len = 1;
-  data = new Complex [1];
-  data[0] = a;
-}
-
-ComplexRowVector::ComplexRowVector (const Complex& a)
-{
-  len = 1;
-  data = new Complex [1];
-  data[0] = Complex (a);
-}
-
-ComplexRowVector&
-ComplexRowVector::operator = (const RowVector& a)
-{
-  delete [] data;
-  len = a.len;
-  if (len > 0)
-    {
-      data = new Complex [len];
-      copy (data, a.data, len);
-    }
-  else
-    data = (Complex *) NULL;
-
-  return *this;
-}
-
-ComplexRowVector&
-ComplexRowVector::operator = (const ComplexRowVector& a)
-{
-  if (this != &a)
-    {
-      delete [] data;
-      len = a.len;
-      if (len > 0)
-	{
-	  data = new Complex [len];
-	  copy (data, a.data, len);
-	}
-      else
-	data = (Complex *) NULL;
-    }
-  return *this;
-}
-
-Complex&
-ComplexRowVector::checkelem (int n)
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      static Complex foo (0.0);
-      return foo;
-    }
-#endif
-
-  return elem (n);
-}
-
-Complex
-ComplexRowVector::checkelem (int n) const
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    {
-      (*current_liboctave_error_handler) ("range error");
-      return Complex (0.0);
-    }
-#endif
-
-  return elem (n);
-}
-
+#if 0
 ComplexRowVector&
 ComplexRowVector::resize (int n)
 {
   if (n < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return *this;
@@ -877,630 +546,546 @@ ComplexRowVector::resize (int n, const C
 {
   int old_len = len;
   resize (n);
   for (int i = old_len; i < len; i++)
     data[i] = val;
 
   return *this;
 }
+#endif
 
 int
 ComplexRowVector::operator == (const ComplexRowVector& a) const
 {
-  if (len != a.len)
+  int len = length ();
+  if (len != a.length ())
     return 0;
-  return equal (data, a.data, len);
+  return equal (data (), a.data (), len);
 }
 
 int
 ComplexRowVector::operator != (const ComplexRowVector& a) const
 {
-  if (len != a.len)
-    return 1;
-  return !equal (data, a.data, len);
+  return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexRowVector&
 ComplexRowVector::insert (const RowVector& a, int c)
 {
-  if (c < 0 || c + a.len - 1 > len)
+  int a_len = a.length ();
+  if (c < 0 || c + a_len - 1 > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    data[c+i] = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (c+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::insert (const ComplexRowVector& a, int c)
 {
-  if (c < 0 || c + a.len - 1 > len)
+  int a_len = a.length ();
+  if (c < 0 || c + a_len - 1 > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a.len; i++)
-    data[c+i] = a.data[i];
+  for (int i = 0; i < a_len; i++)
+    elem (c+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val)
 {
+  int len = length ();
   if (len > 0)
-    copy (data, len, val);
+    for (int i = 0; i < len; i++)
+      elem (i) = val;
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val)
 {
+  int len = length ();
   if (len > 0)
-    copy (data, len, val);
+    for (int i = 0; i < len; i++)
+      elem (i) = val;
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val, int c1, int c2)
 {
+  int len = length ();
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int i = c1; i <= c2; i++)
-    data[i] = val;
+    elem (i) = val;
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val, int c1, int c2)
 {
+  int len = length ();
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int i = c1; i <= c2; i++)
-    data[i] = val;
+    elem (i) = val;
 
   return *this;
 }
 
 ComplexRowVector
 ComplexRowVector::append (const RowVector& a) const
 {
+  int len = length ();
   int nc_insert = len;
-  ComplexRowVector retval (len + a.len);
+  ComplexRowVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ComplexRowVector
 ComplexRowVector::append (const ComplexRowVector& a) const
 {
+  int len = length ();
   int nc_insert = len;
-  ComplexRowVector retval (len + a.len);
+  ComplexRowVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ComplexColumnVector
 ComplexRowVector::hermitian (void) const
 {
-  return ComplexColumnVector (conj_dup (data, len), len);
+  int len = length ();
+  return ComplexColumnVector (conj_dup (data (), len), len);
 }
 
 ComplexColumnVector
 ComplexRowVector::transpose (void) const
 {
-  return ComplexColumnVector (dup (data, len), len);
+  int len = length ();
+  return ComplexColumnVector (dup (data (), len), len);
 }
 
 RowVector
 real (const ComplexRowVector& a)
 {
+  int a_len = a.length ();
   RowVector retval;
-  if (a.len > 0)
-    retval = RowVector (real_dup (a.data, a.len), a.len);
+  if (a_len > 0)
+    retval = RowVector (real_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 RowVector
 imag (const ComplexRowVector& a)
 {
+  int a_len = a.length ();
   RowVector retval;
-  if (a.len > 0)
-    retval = RowVector (imag_dup (a.data, a.len), a.len);
+  if (a_len > 0)
+    retval = RowVector (imag_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 ComplexRowVector
 conj (const ComplexRowVector& a)
 {
+  int a_len = a.length ();
   ComplexRowVector retval;
-  if (a.len > 0)
-    retval = ComplexRowVector (conj_dup (a.data, a.len), a.len);
+  if (a_len > 0)
+    retval = ComplexRowVector (conj_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexRowVector
 ComplexRowVector::extract (int c1, int c2) const
 {
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   int new_c = c2 - c1 + 1;
 
   ComplexRowVector result (new_c);
 
   for (int i = 0; i < new_c; i++)
-    result.data[i] = elem (c1+i);
+    result.elem (i) = elem (c1+i);
 
   return result;
 }
 
+// row vector by row vector -> row vector operations
+
+ComplexRowVector&
+ComplexRowVector::operator += (const RowVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), len);
+  return *this;
+}
+
+ComplexRowVector&
+ComplexRowVector::operator -= (const RowVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), len);
+  return *this;
+}
+
+ComplexRowVector&
+ComplexRowVector::operator += (const ComplexRowVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  add2 (d, a.data (), len);
+  return *this;
+}
+
+ComplexRowVector&
+ComplexRowVector::operator -= (const ComplexRowVector& a)
+{
+  int len = length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
+
+  if (len == 0)
+    return *this;
+
+  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
+
+  subtract2 (d, a.data (), len);
+  return *this;
+}
+
 // row vector by scalar -> row vector operations
 
 ComplexRowVector
-ComplexRowVector::operator + (double s) const
-{
-  return ComplexRowVector (add (data, len, s), len);
-}
-
-ComplexRowVector
-ComplexRowVector::operator - (double s) const
+operator + (const ComplexRowVector& v, double s)
 {
-  return ComplexRowVector (subtract (data, len, s), len);
-}
-
-ComplexRowVector
-ComplexRowVector::operator * (double s) const
-{
-  return ComplexRowVector (multiply (data, len, s), len);
+  int len = v.length ();
+  return ComplexRowVector (add (v.data (), len, s), len);
 }
 
 ComplexRowVector
-ComplexRowVector::operator / (double s) const
+operator - (const ComplexRowVector& v, double s)
 {
-  return ComplexRowVector (divide (data, len, s), len);
-}
-
-ComplexRowVector
-ComplexRowVector::operator + (const Complex& s) const
-{
-  return ComplexRowVector (add (data, len, s), len);
+  int len = v.length ();
+  return ComplexRowVector (subtract (v.data (), len, s), len);
 }
 
 ComplexRowVector
-ComplexRowVector::operator - (const Complex& s) const
+operator * (const ComplexRowVector& v, double s)
 {
-  return ComplexRowVector (subtract (data, len, s), len);
+  int len = v.length ();
+  return ComplexRowVector (multiply (v.data (), len, s), len);
 }
 
 ComplexRowVector
-ComplexRowVector::operator * (const Complex& s) const
+operator / (const ComplexRowVector& v, double s)
 {
-  return ComplexRowVector (multiply (data, len, s), len);
-}
-
-ComplexRowVector
-ComplexRowVector::operator / (const Complex& s) const
-{
-  return ComplexRowVector (divide (data, len, s), len);
+  int len = v.length ();
+  return ComplexRowVector (divide (v.data (), len, s), len);
 }
 
 // scalar by row vector -> row vector operations
 
 ComplexRowVector
 operator + (double s, const ComplexRowVector& a)
 {
-  return ComplexRowVector (add (a.data, a.len, s), a.len);
+  int a_len = a.length ();
+  return ComplexRowVector (add (a.data (), a_len, s), a_len);
 }
 
 ComplexRowVector
 operator - (double s, const ComplexRowVector& a)
 {
-  return ComplexRowVector (subtract (s, a.data, a.len), a.len);
+  int a_len = a.length ();
+  return ComplexRowVector (subtract (s, a.data (), a_len), a_len);
 }
 
 ComplexRowVector
 operator * (double s, const ComplexRowVector& a)
 {
-  return ComplexRowVector (multiply (a.data, a.len, s), a.len);
+  int a_len = a.length ();
+  return ComplexRowVector (multiply (a.data (), a_len, s), a_len);
 }
 
 ComplexRowVector
 operator / (double s, const ComplexRowVector& a)
 {
-  return ComplexRowVector (divide (s, a.data, a.len), a.len);
-}
-
-ComplexRowVector
-operator + (const Complex& s, const ComplexRowVector& a)
-{
-  return ComplexRowVector (add (a.data, a.len, s), a.len);
-}
-
-ComplexRowVector
-operator - (const Complex& s, const ComplexRowVector& a)
-{
-  return ComplexRowVector (subtract (s, a.data, a.len), a.len);
-}
-
-ComplexRowVector
-operator * (const Complex& s, const ComplexRowVector& a)
-{
-  return ComplexRowVector (multiply (a.data, a.len, s), a.len);
-}
-
-ComplexRowVector
-operator / (const Complex& s, const ComplexRowVector& a)
-{
-  return ComplexRowVector (divide (s, a.data, a.len), a.len);
+  int a_len = a.length ();
+  return ComplexRowVector (divide (s, a.data (), a_len), a_len);
 }
 
 // row vector by column vector -> scalar
 
 Complex
-ComplexRowVector::operator * (const ColumnVector& a) const
+operator * (const ComplexRowVector& v, const ColumnVector& a)
 {
   ComplexColumnVector tmp (a);
-  return *this * tmp;
+  return v * tmp;
 }
 
 Complex
-ComplexRowVector::operator * (const ComplexColumnVector& a) const
+operator * (const ComplexRowVector& v, const ComplexColumnVector& a)
 {
 // XXX FIXME XXX -- need function body
   assert (0);
-  return Complex (0.0, 0.0);
+  return Complex ();
 }
 
 // row vector by matrix -> row vector
 
 ComplexRowVector
-ComplexRowVector::operator * (const Matrix& a) const
+operator * (const ComplexRowVector& v, const ComplexMatrix& a)
 {
-  ComplexMatrix tmp (a);
-  return *this * tmp;
-}
-
-ComplexRowVector
-ComplexRowVector::operator * (const ComplexMatrix& a) const
-{
-  if (a.nr != len)
+  int len = v.length ();
+  if (a.rows () != len)
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return ComplexRowVector ();
     }
 
-  if (len == 0 || a.nc == 0)
+  if (len == 0 || a.cols () == 0)
     return ComplexRowVector (0);
 
 // Transpose A to form A'*x == (x'*A)'
 
-  int anr = a.nr;
-  int anc = a.nc;
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
 
   char trans = 'T';
-  int ld = anr;
+  int ld = a_nr;
   Complex alpha (1.0);
   Complex beta (0.0);
   int i_one = 1;
 
   Complex *y = new Complex [len];
 
-  F77_FCN (zgemv) (&trans, &anc, &anr, &alpha, a.data, &ld, data,
-		   &i_one, &beta, y, &i_one, 1L); 
+  F77_FCN (zgemv) (&trans, &a_nc, &a_nr, &alpha, a.data (), &ld,
+		   v.data (), &i_one, &beta, y, &i_one, 1L); 
 
   return ComplexRowVector (y, len);
 }
 
 // row vector by row vector -> row vector operations
 
 ComplexRowVector
-ComplexRowVector::operator + (const RowVector& a) const
+operator + (const ComplexRowVector& v, const RowVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector addition attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
-  return ComplexRowVector (add (data, a.data, len), len);
+  return ComplexRowVector (add (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
-ComplexRowVector::operator - (const RowVector& a) const
+operator - (const ComplexRowVector& v, const RowVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector subtraction attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
-  return ComplexRowVector (subtract (data, a.data, len), len);
-}
-
-ComplexRowVector
-ComplexRowVector::operator + (const ComplexRowVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
-      return ComplexRowVector ();
-    }
-
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (add (data, a.data, len), len);
-}
-
-ComplexRowVector
-ComplexRowVector::operator - (const ComplexRowVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
-      return ComplexRowVector ();
-    }
-
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (subtract (data, a.data, len), len);
+  return ComplexRowVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
-ComplexRowVector::product (const RowVector& a) const
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
-      return ComplexRowVector ();
-    }
-
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (multiply (data, a.data, len), len);
-}
-
-ComplexRowVector
-ComplexRowVector::quotient (const RowVector& a) const
+product (const ComplexRowVector& v, const RowVector& a)
 {
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
-      return ComplexRowVector ();
-    }
-
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (divide (data, a.data, len), len);
-}
-
-ComplexRowVector
-ComplexRowVector::product (const ComplexRowVector& a) const
-{
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector product attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
-  return ComplexRowVector (multiply (data, a.data, len), len);
+  return ComplexRowVector (multiply (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
-ComplexRowVector::quotient (const ComplexRowVector& a) const
+quotient (const ComplexRowVector& v, const RowVector& a)
 {
-  if (len != a.len)
+  int len = v.length ();
+  if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector quotient attempted");
       return ComplexRowVector ();
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
-  return ComplexRowVector (divide (data, a.data, len), len);
-}
-
-ComplexRowVector&
-ComplexRowVector::operator += (const RowVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-ComplexRowVector&
-ComplexRowVector::operator -= (const RowVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
+  return ComplexRowVector (divide (v.data (), a.data (), len), len);
 }
 
-ComplexRowVector&
-ComplexRowVector::operator += (const ComplexRowVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector += operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  add2 (data, a.data, len);
-  return *this;
-}
-
-ComplexRowVector&
-ComplexRowVector::operator -= (const ComplexRowVector& a)
-{
-  if (len != a.len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector -= operation attempted");
-      return *this;
-    }
-
-  if (len == 0)
-    return *this;
-
-  subtract2 (data, a.data, len);
-  return *this;
-}
-
-// unary operations
-
-ComplexRowVector
-ComplexRowVector::operator - (void) const
-{
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (negate (data, len), len);
-}
+// other operations
 
 ComplexRowVector
 map (c_c_Mapper f, const ComplexRowVector& a)
 {
   ComplexRowVector b (a);
   b.map (f);
   return b;
 }
 
 RowVector
 map (d_c_Mapper f, const ComplexRowVector& a)
 {
-  RowVector b (a.len);
-  for (int i = 0; i < a.len; i++)
+  int a_len = a.length ();
+  RowVector b (a_len);
+  for (int i = 0; i < a_len; i++)
     b.elem (i) = f (a.elem (i));
   return b;
 }
 
 void
 ComplexRowVector::map (c_c_Mapper f)
 {
-  for (int i = 0; i < len; i++)
-    data[i] = f (data[i]);
+  for (int i = 0; i < length (); i++)
+    elem (i) = f (elem (i));
 }
 
 Complex
 ComplexRowVector::min (void) const
 {
+  int len = length ();
   if (len == 0)
     return Complex (0.0);
 
-  Complex res = data[0];
+  Complex res = elem (0);
   double absres = abs (res);
 
   for (int i = 1; i < len; i++)
-    if (abs (data[i]) < absres)
+    if (abs (elem (i)) < absres)
       {
-	res = data[i];
+	res = elem (i);
 	absres = abs (res);
       }
 
   return res;
 }
 
 Complex
 ComplexRowVector::max (void) const
 {
+  int len = length ();
   if (len == 0)
     return Complex (0.0);
 
-  Complex res = data[0];
+  Complex res = elem (0);
   double absres = abs (res);
 
   for (int i = 1; i < len; i++)
-    if (abs (data[i]) > absres)
+    if (abs (elem (i)) > absres)
       {
-	res = data[i];
+	res = elem (i);
 	absres = abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 ostream&
 operator << (ostream& os, const ComplexRowVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.len; i++)
-    os << " " /* setw (field_width) */ << a.data[i];
+  for (int i = 0; i < a.length (); i++)
+    os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/f77-fcn.h b/liboctave/f77-fcn.h
--- a/liboctave/f77-fcn.h
+++ b/liboctave/f77-fcn.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_f77_uscore_h)
 #define _f77_uscore_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #if defined (F77_APPEND_UNDERSCORE)
 #define F77_FCN(f) f##_
 #else
 #define F77_FCN(f) f
 #endif
 
 #endif
 
diff --git a/liboctave/lo-error.h b/liboctave/lo-error.h
--- a/liboctave/lo-error.h
+++ b/liboctave/lo-error.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_liboctave_error_h)
 #define _liboctave_error_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 // Tell g++ that fatal doesn't return;
 
 #ifdef __GNUG__
 typedef void v_fcn_cpc_x (const char *, ...);
 volatile v_fcn_cpc_x fatal;
 #endif
 
 extern void liboctave_fatal (const char *fmt, ...);
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -16,170 +16,166 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
-#endif
-
 // But first, some helper functions...
 
 static inline double *
-add (double *d, int len, double s)
+add (const double *d, int len, double s)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] + s;
     }
   return result;
 }
 
 static inline double *
-subtract (double *d, int len, double s)
+subtract (const double *d, int len, double s)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] - s;
     }
   return result;
 }
 
 static inline double *
-subtract (double s, double *d, int len)
+subtract (double s, const double *d, int len)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = s - d[i];
     }
   return result;
 }
 
 static inline double *
-multiply (double *d, int len, double s)
+multiply (const double *d, int len, double s)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] * s;
     }
   return result;
 }
 
 static inline double *
-divide (double *d, int len, double s)
+divide (const double *d, int len, double s)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] / s;
     }
   return result;
 }
 
 static inline double *
-divide (double s, double *d, int len)
+divide (double s, const double *d, int len)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = s / d[i];
     }
   return result;
 }
 
 static inline double *
-add (double *x, double *y, int len)
+add (const double *x, const double *y, int len)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] + y[i];
     }
   return result;
 }
 
 static inline double *
-subtract (double *x, double *y, int len)
+subtract (const double *x, const double *y, int len)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] - y[i];
     }
   return result;
 }
 
 static inline double *
-multiply (double *x, double *y, int len)
+multiply (const double *x, const double *y, int len)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] * y[i];
     }
   return result;
 }
 
 static inline double *
-divide (double *x, double *y, int len)
+divide (const double *x, const double *y, int len)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] / y[i];
     }
   return result;
 }
 
 static inline double *
-add2 (double *x, double *y, int len)
+add2 (double *x, const double *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] += y[i];
   return x;
 }
 
 static inline double *
-subtract2 (double *x, double *y, int len)
+subtract2 (double *x, const double *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] -= y[i];
   return x;
 }
 
 static inline double *
-negate (double *d, int len)
+negate (const double *d, int len)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = -d[i];
     }
@@ -189,233 +185,233 @@ negate (double *d, int len)
 static inline void
 copy (double *d, int len, double s)
 {
   for (int i = 0; i < len; i++)
     d[i] = s;
 }
 
 static inline void
-copy (double *x, double *y, int len)
+copy (double *x, const double *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] = y[i];
 }
 
 static inline double *
-dup (double *x, int len)
+dup (const double *x, int len)
 {
-  double *retval = (double *) NULL;
+  double *retval = 0;
   if (len > 0)
     {
       retval = new double [len];
       for (int i = 0; i < len; i++)
 	retval[i] = x[i];
     }
   return retval;
 }
 
 static inline int
-equal (double *x, double *y, int len)
+equal (const double *x, const double *y, int len)
 {
   for (int i = 0; i < len; i++)
     if (x[i] != y[i])
       return 0;
   return 1;
 }
 
 // And some for Complex too...
 
 static inline Complex *
-add (Complex *d, int len, Complex s)
+add (const Complex *d, int len, Complex s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] + s;
     }
   return result;
 }
 
 static inline Complex *
-add (Complex s, Complex *d, int len)
+add (Complex s, const Complex *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s + d[i];
     }
   return result;
 }
 
 static inline Complex *
-subtract (Complex *d, int len, Complex s)
+subtract (const Complex *d, int len, Complex s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] - s;
     }
   return result;
 }
 
 static inline Complex *
-subtract (Complex s, Complex *d, int len)
+subtract (Complex s, const Complex *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s - d[i];
     }
   return result;
 }
 
 static inline Complex *
-multiply (Complex *d, int len, Complex s)
+multiply (const Complex *d, int len, Complex s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] * s;
     }
   return result;
 }
 
 static inline Complex *
-multiply (Complex s, Complex *d, int len)
+multiply (Complex s, const Complex *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s * d[i];
     }
   return result;
 }
 
 static inline Complex *
-divide (Complex *d, int len, Complex s)
+divide (const Complex *d, int len, Complex s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] / s;
     }
   return result;
 }
 
 static inline Complex *
-divide (Complex s, Complex *d, int len)
+divide (Complex s, const Complex *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s / d[i];
     }
   return result;
 }
 
 static inline Complex *
-add (Complex *x, Complex *y, int len)
+add (const Complex *x, const Complex *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] + y[i];
     }
   return result;
 }
 
 static inline Complex *
-subtract (Complex *x, Complex *y, int len)
+subtract (const Complex *x, const Complex *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] - y[i];
     }
   return result;
 }
 
 static inline Complex *
-multiply (Complex *x, Complex *y, int len)
+multiply (const Complex *x, const Complex *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] * y[i];
     }
   return result;
 }
 
 static inline Complex *
-divide (Complex *x, Complex *y, int len)
+divide (const Complex *x, const Complex *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] / y[i];
     }
   return result;
 }
 
 static inline Complex *
-add2 (Complex *x, Complex *y, int len)
+add2 (Complex *x, const Complex *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] += y[i];
   return x;
 }
 
 static inline Complex *
-subtract2 (Complex *x, Complex *y, int len)
+subtract2 (Complex *x, const Complex *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] -= y[i];
   return x;
 }
 
 static inline Complex *
-negate (Complex *d, int len)
+negate (const Complex *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = -d[i];
     }
   return result;
 }
 
 static inline double *
-not (Complex *d, int len)
+not (const Complex *d, int len)
 {
   double *result = 0;
   if (len > 0)
     {
       result = new double [len];
       for (int i = 0; i < len; i++)
 	result[i] = (d[i] == 0.0);
     }
@@ -425,409 +421,409 @@ not (Complex *d, int len)
 static inline void
 copy (Complex *d, int len, Complex s)
 {
   for (int i = 0; i < len; i++)
     d[i] = s;
 }
 
 static inline void
-copy (Complex *x, Complex *y, int len)
+copy (Complex *x, const Complex *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] = y[i];
 }
 
 static inline Complex *
-dup (Complex *x, int len)
+dup (const Complex *x, int len)
 {
-  Complex *retval = (Complex *) NULL;
+  Complex *retval = 0;
   if (len > 0)
     {
       retval = new Complex [len];
       for (int i = 0; i < len; i++)
 	retval[i] = x[i];
     }
   return retval;
 }
 
 static inline Complex *
-make_complex (double *x, int len)
+make_complex (const double *x, int len)
 {
-  Complex *retval = (Complex *) NULL;
+  Complex *retval = 0;
   if (len > 0)
     {
       retval = new Complex [len];
       for (int i = 0; i < len; i++)
 	retval[i] = x[i];
     }
   return retval;
 }
 
 static inline Complex *
-conj_dup (Complex *x, int len)
+conj_dup (const Complex *x, int len)
 {
-  Complex *retval = (Complex *) NULL;
+  Complex *retval = 0;
   if (len > 0)
     {
       retval = new Complex [len];
       for (int i = 0; i < len; i++)
 	retval[i] = conj (x[i]);
     }
   return retval;
 }
 
 static inline double *
-real_dup (Complex *x, int len)
+real_dup (const Complex *x, int len)
 {
-  double *retval = (double *) NULL;
+  double *retval = 0;
   if (len > 0)
     {
       retval = new double [len];
       for (int i = 0; i < len; i++)
 	retval[i] = real (x[i]);
     }
   return retval;
 }
 
 static inline double *
-imag_dup (Complex *x, int len)
+imag_dup (const Complex *x, int len)
 {
-  double *retval = (double *) NULL;
+  double *retval = 0;
   if (len > 0)
     {
       retval = new double [len];
       for (int i = 0; i < len; i++)
 	retval[i] = imag (x[i]);
     }
   return retval;
 }
 
 static inline int
-equal (Complex *x, Complex *y, int len)
+equal (const Complex *x, const Complex *y, int len)
 {
   for (int i = 0; i < len; i++)
     if (x[i] != y[i])
       return 0;
   return 1;
 }
 
 // And still some more for mixed Complex/double operations...
 
 static inline Complex *
-add (Complex *d, int len, double s)
+add (const Complex *d, int len, double s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] + s;
     }
   return result;
 }
 
 static inline Complex *
-add (double *d, int len, Complex s)
+add (const double *d, int len, Complex s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] + s;
     }
   return result;
 }
 
 static inline Complex *
-add (double s, Complex *d, int len)
+add (double s, const Complex *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s + d[i];
     }
   return result;
 }
 
 static inline Complex *
-add (Complex s, double *d, int len)
+add (Complex s, const double *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s + d[i];
     }
   return result;
 }
 
 static inline Complex *
-subtract (Complex *d, int len, double s)
+subtract (const Complex *d, int len, double s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] - s;
     }
   return result;
 }
 
 static inline Complex *
-subtract (double *d, int len, Complex s)
+subtract (const double *d, int len, Complex s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] - s;
     }
   return result;
 }
 
 static inline Complex *
-subtract (double s, Complex *d, int len)
+subtract (double s, const Complex *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s - d[i];
     }
   return result;
 }
 
 static inline Complex *
-subtract (Complex s, double *d, int len)
+subtract (Complex s, const double *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s - d[i];
     }
   return result;
 }
 
 static inline Complex *
-multiply (Complex *d, int len, double s)
+multiply (const Complex *d, int len, double s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] * s;
     }
   return result;
 }
 
 static inline Complex *
-multiply (double *d, int len, Complex s)
+multiply (const double *d, int len, Complex s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] * s;
     }
   return result;
 }
 
 static inline Complex *
-divide (Complex *d, int len, double s)
+divide (const Complex *d, int len, double s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] / s;
     }
   return result;
 }
 
 static inline Complex *
-divide (double *d, int len, Complex s)
+divide (const double *d, int len, Complex s)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = d[i] / s;
     }
   return result;
 }
 
 static inline Complex *
-divide (double s, Complex *d, int len)
+divide (double s, const Complex *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s / d[i];
     }
   return result;
 }
 
 static inline Complex *
-divide (Complex s, double *d, int len)
+divide (Complex s, const double *d, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = s / d[i];
     }
   return result;
 }
 
 static inline Complex *
-add (Complex *x, double *y, int len)
+add (const Complex *x, const double *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] + y[i];
     }
   return result;
 }
 
 static inline Complex *
-add (double *x, Complex *y, int len)
+add (const double *x, const Complex *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] + y[i];
     }
   return result;
 }
 
 static inline Complex *
-subtract (Complex *x, double *y, int len)
+subtract (const Complex *x, const double *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] - y[i];
     }
   return result;
 }
 
 static inline Complex *
-subtract (double *x, Complex *y, int len)
+subtract (const double *x, const Complex *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] - y[i];
     }
   return result;
 }
 
 static inline Complex *
-multiply (Complex *x, double *y, int len)
+multiply (const Complex *x, const double *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] * y[i];
     }
   return result;
 }
 
 static inline Complex *
-multiply (double *x, Complex *y, int len)
+multiply (const double *x, const Complex *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] * y[i];
     }
   return result;
 }
 
 static inline Complex *
-divide (Complex *x, double *y, int len)
+divide (const Complex *x, const double *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] / y[i];
     }
   return result;
 }
 
 static inline Complex *
-divide (double *x, Complex *y, int len)
+divide (const double *x, const Complex *y, int len)
 {
   Complex *result = 0;
   if (len > 0)
     {
       result = new Complex [len];
       for (int i = 0; i < len; i++)
 	result[i] = x[i] / y[i];
     }
   return result;
 }
 
 static inline Complex *
-add2 (Complex *x, double *y, int len)
+add2 (Complex *x, const double *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] += y[i];
   return x;
 }
 
 static inline Complex *
-subtract2 (Complex *x, double *y, int len)
+subtract2 (Complex *x, const double *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] -= y[i];
   return x;
 }
 
 static inline void
 copy (Complex *d, int len, double s)
 {
   for (int i = 0; i < len; i++)
     d[i] = s;
 }
 
 static inline void
-copy (Complex *x, double *y, int len)
+copy (Complex *x, const double *y, int len)
 {
   for (int i = 0; i < len; i++)
     x[i] = y[i];
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/sun-utils.cc b/liboctave/sun-utils.cc
--- a/liboctave/sun-utils.cc
+++ b/liboctave/sun-utils.cc
@@ -18,20 +18,16 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef sun
 
-#ifdef __GNUG__
-#pragma implementation
-#endif
-
 #include <assert.h>
 
 /*
  * I think that this is really only needed if linking to Fortran
  * compiled libraries on a Sun.  It should never be called.
  * There should probably be a sysdep.cc file, eh?
  */
 
diff --git a/liboctave/sun-utils.h b/liboctave/sun-utils.h
--- a/liboctave/sun-utils.h
+++ b/liboctave/sun-utils.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_sun_utils_h)
 #define _sun_utils_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #ifdef sun
 
 /*
  * I think that this is really only needed if linking to Fortran
  * compiled libraries on a Sun.  It should never be called.
  * There should probably be a sysdep.cc file, eh?
  */
 
diff --git a/liboctave/utils.cc b/liboctave/utils.cc
--- a/liboctave/utils.cc
+++ b/liboctave/utils.cc
@@ -16,16 +16,20 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <sys/types.h>
 #include <unistd.h>
 #include <signal.h>
 #include <stdlib.h>
 
 #include "f77-uscore.h"
 
 /*
