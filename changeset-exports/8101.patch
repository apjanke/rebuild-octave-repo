# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1221166632 14400
#      Thu Sep 11 16:57:12 2008 -0400
# Node ID 86955a1559c50528aacb41d2a78a32d5551f6281
# Parent  da2fbd22d67240470fca097d6a80a867bc529537
improve speed of cell2mat
* * *
trivial fix for previous cell2mat change

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,34 @@
+2008-09-11  David Bateman  <dbateman@free.fr>
+
+	* image/__img__.m: Manually set the limits of th eimage
+	* plot/__go_draw_axes__.m: Base window position in the axis
+	position property and not the outerposition property. Remove
+	colorbar code based on the gnuplot colorbox. Allow images to be a
+	vector to support image based colorbars. Also check labelmode for
+	manual tics.
+	* plot/__go_draw_figure__.m: Remove gnuplot colorbox based
+	colorbar code.
+	* plot/colorbar.m: Rewrite to use an image and callbacks to link
+	it to the principal axis.
+	* plot/legend.m: Support an axis handle as the first
+	argument. Support hggroups.
+	* plot/pareto.m: Don't support an axis handle as the first
+	argument as the plotyy command in fact needs two axis handles.
+	* plot/plotyy.m: Rewrite to use listeners and callbacks to
+	synchronize the two axes.
+	* plot/subplot.m: Also skip axes that are tagged as being a
+	colorbar. Don't break in search of overlapping axes to delete. Set
+	both the position and the outerposition.
+	
+2008-09-09  David Bateman  <dbateman@free.fr>
+
+	* general/cell2mat.m: Improve the speed..
+	
 2008-09-09  John W. Eaton  <jwe@octave.org>
 
 	* time/datestr.m: Convert format and use strftime to do most of
 	the actual conversion.
 
 2008-09-08  Tatsuro MATSUOKA  <tmacchant@yahoo.co.jp>
 
 	* plot/plot.m: Doc fix.
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -43,30 +43,56 @@ function m = cell2mat (c)
     elt = c{1};
     if (isnumeric (elt) || ischar (elt) || islogical (elt))
       m = elt;
     elseif (iscell (elt))
       m = cell2mat (elt);
     else
       error ("cell2mat: all elements of cell array must be numeric, logical or char");
     endif
+  elseif (ndims (c) == 2)
+    nr = rows (c);
+    c1 = cell (nr, 1);
+    for i = 1 : nr
+      c1{i} = [c{i : nr : end}];
+    endfor
+    ## This is faster than "c = cat(1, c{:})"
+    m = [cellfun(@(x) x.', c1, "UniformOutput", false){:}].';
   else
-    ## n dimensions case
-    for k = ndims (c):-1:2,
+   nd = ndims (c);
+   for k = nd : -1 : 2
       sz = size (c);
+      if (k > ndims (c) || sz(end) == 1)
+	continue;
+      endif
       sz(end) = 1;
       c1 = cell (sz);
-      for i = 1:(prod (sz))
-        c1{i} = cat (k, c{i:(prod (sz)):end});
-      endfor
+      sz = prod (sz);
+      if (k == 2)
+        for i = 1 : sz
+	  c1{i} = [c{i : sz : end}];
+        endfor
+      else
+        ## This is faster than
+        ##   for i = 1:sz, c1{i} = cat (k, c{i:(prod (sz)):end}); endfor
+	idx = [1, k, (3 : (k - 1)), 2, ((k + 1): nd)];
+        c = cellfun(@(x) permute (x, idx), c, "UniformOutput", false);
+        for i = 1: sz
+	  c1{i} = ipermute ([c{i : sz : end}], idx);
+        endfor
+      endif
       c = c1;
     endfor
-    m = cat (1, c1{:});
+    if (numel (c) > 1)
+      idx = [2, 1, 3 : nd];
+      m = ipermute([cellfun(@(x) permute (x, idx), c, "UniformOutput", false){:}], idx);
+    else
+      m = c{1};
+    endif
   endif
-
 endfunction
 
 ## Tests
 %!shared C, D, E, F
 %! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
 %! D = C; D(:,:,2) = C;
 %! E = [1 2 3 4; 5 6 7 8; 9 10 11 12];
 %! F = E; F(:,:,2) = E;
diff --git a/scripts/image/__img__.m b/scripts/image/__img__.m
--- a/scripts/image/__img__.m
+++ b/scripts/image/__img__.m
@@ -60,17 +60,18 @@ function h = __img__ (x, y, img, varargi
     if (isinteger (img))
       c = class (img);
       mn = intmin (c);
       mx = intmax (c);
       set (ca, "clim", double ([mn, mx]));
     endif
   endif
 
-  set (ca, "view", [0, 90]);
+  set (ca, "view", [0, 90], "xlimmode", "manual", "ylimmode", "manual",
+       "xlim", xlim, "ylim", ylim);
 
   if (strcmp (get (ca, "nextplot"), "replace"))
     set (ca, "ydir", "reverse");
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -26,37 +26,27 @@ function __go_draw_axes__ (h, plot_strea
 
     axis_obj = __get__ (h);
 
     parent_figure_obj = get (axis_obj.parent);
 
     persistent have_newer_gnuplot ...
       = compare_versions (__gnuplot_version__ (), "4.0", ">");
 
-    ## Set axis properties here?
-    pos = [0, 0, 1, 1];
-    if (strcmpi (axis_obj.activepositionproperty, "outerposition"))
-      ymirror = true;
-      if (! isempty (axis_obj.outerposition))
-	pos = axis_obj.outerposition;
-      endif
-    else
+    pos = axis_obj.position;
+    fprintf (plot_stream, "set tmargin 0;\n");
+    fprintf (plot_stream, "set bmargin 0;\n");
+    fprintf (plot_stream, "set lmargin 0;\n");
+    fprintf (plot_stream, "set rmargin 0;\n");
+
+    ## Set to false for plotyy axes.
+    if (strcmp (axis_obj.tag, "plotyy"))
       ymirror = false;
-      if (! isempty (axis_obj.position))
-	pos = axis_obj.position;
-	fprintf (plot_stream, "set tmargin 0;\n");
-	fprintf (plot_stream, "set bmargin 0;\n");
-	fprintf (plot_stream, "set lmargin 0;\n");
-	fprintf (plot_stream, "set rmargin 0;\n");
-      endif
-    endif
-
-    if (! strcmpi (get (h, "__colorbar__"), "none"))
-      [pos, cbox_orient, cbox_size, cbox_origin, cbox_mirror] = ...
-	  gnuplot_position_colorbox (pos, get (h, "__colorbar__"), axis_obj);
+    else
+      ymirror = true;
     endif
 
     fprintf (plot_stream, "set origin %.15g, %.15g;\n", pos(1), pos(2));
     fprintf (plot_stream, "set size %.15g, %.15g;\n", pos(3), pos(4));
 
     if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
       r = axis_obj.dataaspectratio;
       fprintf (plot_stream, "set size ratio %.15g;\n", -r(2)/r(1));
@@ -353,22 +343,26 @@ function __go_draw_axes__ (h, plot_strea
 	    is_image_data(data_idx) = true;
 	    parametric(data_idx) = false;
 	    have_cdata(data_idx) = false;
 
 	    [y_dim, x_dim] = size (img_data(:,:,1));
 	    if (x_dim > 1)
 	      dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
 	    else
-	      dx = 1;
+	      x_dim = 2;
+	      img_data = [img_data, img_data];
+	      dx = abs (img_xdata(2)-img_xdata(1));
 	    endif
 	    if (y_dim > 1)
 	      dy = abs (img_ydata(2)-img_ydata(1))/(y_dim-1);
 	    else
-	      dy = 1;
+	      y_dim = 2;
+	      img_data = [img_data; img_data];
+	      dy = abs (img_ydata(2)-img_ydata(1));
 	    endif
 	    x_origin = min (img_xdata);
 	    y_origin = min (img_ydata);
 
 	    if (ndims (img_data) == 3)
 	      data{data_idx} = permute (img_data, [3, 1, 2])(:);
 	      format = "1:2:3";
 	      imagetype = "rgbimage";
@@ -1022,37 +1016,37 @@ function __go_draw_axes__ (h, plot_strea
     if (isnan(hidden_removal) || hidden_removal)
       fputs (plot_stream, "set hidden3d;\n");
     else
       fputs (plot_stream, "unset hidden3d;\n");
     endif
 
     have_data = (! (isempty (data) || all (cellfun (@isempty, data))));
 
+    ## Note we don't use the [xy]2range of gnuplot as we don't use the
+    ## dual axis plotting features of gnuplot
     if (isempty (xlim))
       return;
     endif
     if (strcmpi (axis_obj.xdir, "reverse"))
       xdir = "reverse";
     else
       xdir = "noreverse";
     endif
-    fprintf (plot_stream, "set %srange [%.15e:%.15e] %s;\n",
-	     xaxisloc, xlim, xdir);
+    fprintf (plot_stream, "set xrange [%.15e:%.15e] %s;\n", xlim, xdir);
 
     if (isempty (ylim))
       return;
     endif
     if (strcmpi (axis_obj.ydir, "reverse"))
       ydir = "reverse";
     else
       ydir = "noreverse";
     endif
-    fprintf (plot_stream, "set %srange [%.15e:%.15e] %s;\n",
-	     yaxisloc, ylim, ydir);
+    fprintf (plot_stream, "set yrange [%.15e:%.15e] %s;\n", ylim, ydir);
 
     if (nd == 3)
       if (isempty (zlim))
 	return;
       endif
       if (strcmpi (axis_obj.zdir, "reverse"))
 	zdir = "reverse";
       else
@@ -1204,26 +1198,18 @@ function __go_draw_axes__ (h, plot_strea
 	  else
 	    fputs (plot_stream, sprintf(", %d \"#%02X%02X%02X\"", i - 1, 
 					col(1), col(2), col(3)));
 	  endif
 	endfor
 	fputs (plot_stream, ");\n");
       endif
     endif
-	    
-    if (strcmpi (get (h, "__colorbar__"), "none"))
-      fputs (plot_stream, "unset colorbox;\n");
-    else
-      ## FIXME If cbox_mirror is true we want to invert the tic labels
-      ## but gnuplot doesn't allow that
-      fputs (plot_stream, 
-	     sprintf ("set colorbox %s user origin %f,%f size %f,%f;\n",
-		      cbox_orient, cbox_origin, cbox_size));
-    endif
+
+    fputs (plot_stream, "unset colorbox;\n");
 
     if (have_data)
       if (nd == 2)
 	plot_cmd = "plot";
       else
 	plot_cmd = "splot";
 	rot_x = 90 - axis_obj.view(2);
 	rot_z = axis_obj.view(1);
@@ -1544,30 +1530,31 @@ function do_tics (obj, plot_stream, ymir
   do_tics_1 (obj.ztickmode, obj.ztick, obj.zticklabelmode, obj.zticklabel,
 	     obj.zcolor, "z", plot_stream, true, mono, "border",
 	     obj.tickdir);
 endfunction
 
 function do_tics_1 (ticmode, tics, labelmode, labels, color, ax,
 		    plot_stream, mirror, mono, axispos, tickdir)
   colorspec = get_text_colorspec (color, mono);
-  if (strcmpi (ticmode, "manual"))
+  if (strcmpi (ticmode, "manual") || strcmpi (labelmode, "manual"))
     if (isempty (tics))
       fprintf (plot_stream, "unset %stics;\n", ax);
     elseif (strcmpi (labelmode, "manual") && ! isempty (labels))
       if (ischar (labels))
 	labels = cellstr (labels);
       endif
       if (iscellstr (labels))
 	k = 1;
 	ntics = numel (tics);
 	nlabels = numel (labels);
 	fprintf (plot_stream, "set format %s \"%%s\";\n", ax);
 	if (mirror)
-	  fprintf (plot_stream, "set %stics %s %s (", ax, tickdir, axispos);
+	  fprintf (plot_stream, "set %stics %s %s mirror (", ax, 
+		   tickdir, axispos);
 	else
 	  fprintf (plot_stream, "set %stics %s %s nomirror (", ax,
 		   tickdir, axispos);
 	endif
 	labels = regexprep(labels, "%", "%%");
 	for i = 1:ntics
 	  fprintf (plot_stream, " \"%s\" %g", labels{k++}, tics(i));
 	  if (i < ntics)
@@ -1579,29 +1566,30 @@ function do_tics_1 (ticmode, tics, label
 	endfor
 	fprintf (plot_stream, ") %s;\n", colorspec);
       else
 	error ("unsupported type of ticklabel");
       endif
     else
       fprintf (plot_stream, "set format %s \"%%g\";\n", ax);
       if (mirror)
-	fprintf (plot_stream, "set %stics %s %s (", ax, tickdir, axispos );
+	fprintf (plot_stream, "set %stics %s %s mirror (", ax, 
+		 tickdir, axispos );
       else
 	fprintf (plot_stream, "set %stics %s %s nomirror (", ax, tickdir,
 		 axispos);
       endif
       fprintf (plot_stream, " %g,", tics(1:end-1));
       fprintf (plot_stream, " %g);\n", tics(end));
     endif
   else
     fprintf (plot_stream, "set format %s \"%%g\";\n", ax);
     if (mirror)
-      fprintf (plot_stream, "set %stics %s %s %s;\n", ax, axispos, tickdir,
-	       colorspec);
+      fprintf (plot_stream, "set %stics %s %s mirror %s;\n", ax, 
+	       axispos, tickdir, colorspec);
     else
       fprintf (plot_stream, "set %stics %s %s nomirror %s;\n", ax, 
 	       tickdir, axispos, colorspec);
     endif
   endif
 endfunction
 
 function colorspec = get_text_colorspec (color, mono)
@@ -1982,115 +1970,16 @@ function sym = __setup_sym_table__ ()
   sym.copyright = '{/Symbol \343}';
   sym.lfloor = '{/Symbol \353}';
   sym.lceil  = '{/Symbol \351}';
   sym.rfloor = '{/Symbol \373}';
   sym.rceil  = '{/Symbol \371}';
   sym.int = '{/Symbol \362}';
 endfunction
 
-function [pos, orient, sz, origin, mirr] = gnuplot_position_colorbox (pos, cbox, obj)
-  ## This is an emprically derived function that attempts to find a good
-  ## size for the colorbox even for subplots and strange aspect ratios.
-
-  if (strncmp (cbox, "north", 5) || strncmp (cbox, "south", 5))
-    scl = pos([2,4]);
-  else
-    scl = pos([1,3]);
-  endif
-
-  if (length(cbox) > 7 && strncmp (cbox(end-6:end), "outside", 7))
-    scl(2) -= 0.2 * scl(2);
-    if (strncmp (cbox, "west", 4) || strncmp (cbox, "south", 5))
-      scl(1) += 0.2 * scl(2);
-    endif
-  endif
-
-  if (strcmpi (obj.dataaspectratiomode, "manual"))
-    sz = min(pos(3:4))([1,1]);
-    r = obj.dataaspectratio;
-    if (pos(3) > pos(4))
-      switch (cbox)
-	case {"north", "northoutside"}
-	  off = 4 / 3 * [(pos(3) - pos(4)) ./ (r(2)/r(1)), pos(4) / pos(3) / 2];
-	  sz = 2 * sz / 3;
-	case {"south", "southoutside"}
-	  off = 4 / 3 * [(pos(3) - pos(4)) ./ (r(2)/r(1)), 0];
-	  sz = 2 * sz / 3;
-	otherwise
-	  off = [(pos(3) - pos(4)) ./ (r(2)/r(1)), 0];	  
-      endswitch
-    else
-      switch (cbox)
-	case {"north", "northoutside"}
-	  off = 1.5 * [0, (pos(4) - pos(3)) ./ (r(1) / r(2))];
-	case {"south", "southoutside"}
-	  off = 0.5 * [0, (pos(4) - pos(3)) ./ (r(1) / r(2))];
-	otherwise
-	  off = [0, (pos(4) - pos(3)) ./ (r(1) / r(2))];
-      endswitch
-    endif
-    off = off / 2;
-  else
-    sz = pos(3:4);
-    off = 0;
-  endif
-  switch (cbox)
-    case "northoutside"
-      sz = sz - 0.08;
-      origin = [0.05, 0.06] + [0.00, 0.88] .* sz + pos(1:2) + off;
-      mirr = true;
-      orient = "horizontal";
-    case "north"
-      sz = sz - 0.16;
-      origin = [0.09, 0.09] + [0.00, 0.94] .* sz + pos(1:2) + off;
-      mirr = false;
-      orient = "horizontal";
-    case "southoutside"
-      sz = sz - 0.08;
-      origin = [0.05, 0.06] + [0.00, 0.00] .* sz + pos(1:2) + off;
-      mirr = false;
-      orient = "horizontal";
-    case "south"
-      sz = sz - 0.16;
-      origin = [0.08, 0.09] + [0.03, 0.05] .* sz + pos(1:2) + off;
-      mirr = true;
-      orient = "horizontal";
-    case "eastoutside"
-      sz = sz - 0.08;
-      origin = [0.00, 0.06] + [0.94, 0.00] .* sz + pos(1:2) + off;
-      mirr = false;
-      orient = "vertical";
-    case "east"
-      sz = sz - 0.16;
-      origin = [0.09, 0.10] + [0.91, 0.01] .* sz + pos(1:2) + off;
-      mirr = true;
-      orient = "vertical";
-    case "westoutside"
-      sz = sz - 0.08;
-      origin = [0.00, 0.06] + [0.06, 0.00] .* sz + pos(1:2) + off;
-      mirr = true;
-      orient = "vertical";
-    case "west"
-      sz = sz - 0.16;
-      origin = [0.06, 0.09] + [0.04, 0.03] .* sz + pos(1:2) + off;
-      mirr = false;
-      orient = "vertical";
-  endswitch
-
-  if (strncmp (cbox, "north", 5) || strncmp (cbox, "south", 5))
-    sz = sz .* [1, 0.07];
-    pos([2,4]) = scl;
-  else
-    sz = sz .* [0.07, 1];
-    pos([1,3]) = scl;
-  endif
-
-endfunction
-
 function retval = __do_enhanced_option__ (enhanced, obj)
   retval = "";
   if (enhanced)
     if (strcmpi (obj.interpreter, "none"))
       retval = "noenhanced";
     else
       retval = "enhanced";
     endif
diff --git a/scripts/plot/__go_draw_figure__.m b/scripts/plot/__go_draw_figure__.m
--- a/scripts/plot/__go_draw_figure__.m
+++ b/scripts/plot/__go_draw_figure__.m
@@ -32,20 +32,16 @@ function __go_draw_figure__ (f, plot_str
 
       if (nkids > 0)
 	axes_count = 0;
 	for i = 1:nkids
 	  obj = __get__ (kids(i));
 	  switch (obj.type)
 	    case "axes"
 	      axes_count++;
-	      ## Force multiplot with a colorbar to ensure colorbar on the page
-	      if (!strcmp (obj.__colorbar__, "none"))
-		axes_count++;
-	      endif
 	  endswitch
 	endfor
 
 	fputs (plot_stream, "\nreset;\n");
 	fputs (plot_stream, "set autoscale fix;\n");
 
 	multiplot_mode = axes_count > 1;
 
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007 David Bateman
+## Copyright (C) 2008 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -42,61 +42,314 @@
 ## Remove any existing colorbar from the plot.
 ## @end table
 ##
 ## If the argument 'peer' is given, then the following argument is treated
 ## as the axes handle on which to add the colorbar.
 ## @end deftypefn
 
 
-## PKG_ADD: mark_as_command colorbar
+function h = colorbar (varargin)
+  ax = [];
+  loc = "eastoutside";
+  args = {};
+  deleting = false;
+
+  i = 1;
+  while (i <= nargin)
+    arg = varargin {i++};
 
-function colorbar (varargin)
-  
-  if (nargin > 0 && strcmpi(varargin{1}, "peer"))
-    if (nargin > 1)
-      ax = varargin{2};
-      if (!isscalar (ax) || ! ishandle (ax)
-	  || strcmp (get (ax, "type"), "axes"))
-	error ("colorbar: expecting an axes handle following 'peer'");
+    if (ischar(arg))
+      if (strcmpi (arg, "peer"))
+	if (i > nargin)
+	  error ("colorbar: missing axes handle after 'peer'");
+	else
+	  ax = vargin{i++}
+	  if (!isscalar (ax) || ! ishandle (ax)
+	      || strcmp (get (ax, "type"), "axes"))
+	    error ("colorbar: expecting an axes handle following 'peer'");
+	  endif
+	endif
+      elseif (strcmpi (arg, "north") || strcmpi (arg, "south")
+	      || strcmpi (arg, "east") || strcmpi (arg, "west")
+	      || strcmpi (arg, "northoutside") || strcmpi (arg, "southoutside")
+	      || strcmpi (arg, "eastoutside") || strcmpi (arg, "westoutside"))
+	loc = arg;
+      elseif (strcmpi (arg, "off") || strcmpi (arg, "none"))
+	deleting = true;
+      else
+	args{end+1} = arg;
       endif
     else
-      error ("colorbar: misisng axes handle after 'peer'");
+      args{end+1} = arg;
     endif
+  endwhile
+
+  if (isempty (ax))
+    ax = gca ();
+  endif
+  obj = get (ax);
+
+  if (deleting)
+    objs = findobj (get (ax, "parent"), "type", "axes");
+    for i = 1 : length (objs)
+      if (strcmp (get (objs(i), "tag"), "colorbar") &&
+	  get (objs(i), "axes") == ax)
+	delete (objs(i));
+      endif
+    endfor
   else
-    ax = gca ();
+    position = obj.position;
+    clen = rows (get (get (ax, "parent"), "colormap"));
+    cext = get (ax, "clim");
+    cdiff = (cext(2) - cext(1)) / clen / 2;
+    cmin = cext(1) + cdiff;
+    cmax = cext(2) - cdiff;
+
+    orig_pos = obj.position;
+    orig_opos = obj.outerposition;
+    [pos, cpos, vertical, mirror, aspect] =  ...
+	__position_colorbox__ (loc, obj, ancestor (ax, "figure"));
+    set (ax, "activepositionproperty", "position", "position", pos);
+
+    cax = __go_axes__ (get (ax, "parent"), "tag", "colorbar", 
+		       "handlevisibility", "off", 
+		       "activepositionproperty", "position", 
+		       "position", cpos);
+    addproperty ("location", cax, "radio",
+		 "eastoutside|east|westoutside|west|northoutside|north|southoutside|south",
+		 loc);
+    addproperty ("axes", cax, "handle", ax);
+
+    if (vertical)
+      hi = image (cax, [0,1], [cmin, cmax], [1 : clen]');
+      if (mirror)
+	set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
+	     "ylim", cext, "ylimmode", "manual",
+	     "yaxislocation", "right", args{:});
+      else
+	set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
+	     "ylim", cext, "ylimmode", "manual",
+	     "yaxislocation", "left", args{:});
+      endif
+    else
+      hi = image (cax, [cmin, cmax], [0,1], [1 : clen]);
+      if (mirror)
+	set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
+	     "xlim", cext, "xlimmode", "manual",
+	     "xaxislocation", "top", args{:});
+      else
+	set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
+	     "xlim", cext, "xlimmode", "manual",
+	     "xaxislocation", "bottom", args{:});
+      endif
+    endif
+
+    if (! isnan (aspect))
+      set (cax, "dataaspectratio", aspect);
+    endif
+
+    ctext = text (0, 0, "", "tag", "colorbar","visible", "off", 
+		  "handlevisibility", "off", "xliminclude", "off",  
+		  "yliminclude", "off", "zliminclude", "off",
+		  "deletefcn", {@deletecolorbar, cax, orig_pos, orig_opos});
+
+    set (cax, "deletefcn", {@resetaxis, orig_pos, orig_opos});
+
+    addlistener (ax, "clim", {@update_colorbar_clim, hi, vertical})
+    addlistener (ax, "dataaspectratio", {@update_colorbar_axis, cax})
+    addlistener (ax, "position", {@update_colorbar_axis, cax})
+
   endif
 
-  pos = "eastoutside";
-  for i = 1 : length (varargin)
-    arg = varargin{i};
-    if (length(arg) < 1)
-      pos = "eastoutside";
-    elseif (ischar (arg))
-      arg = tolower (arg);
-      if (strcmp (arg, "off") || strcmp (arg, "none"))
-	pos = "none";
-      elseif (strcmp (arg, "north") || strcmp (arg, "south")
-	      || strcmp (arg, "east") || strcmp (arg, "west")
-	      || strcmp (arg, "northoutside") || strcmp (arg, "southoutside")
-	      || strcmp (arg, "eastoutside") || strcmp (arg, "westoutside"))
-	pos = arg;
+  if (nargout > 0)
+    h = cax;
+  endif
+endfunction
+
+function deletecolorbar (h, d, hc, pos, opos)
+  ## Don't delete the colorbar and reset the axis size if the
+  ## parent figure is being deleted.
+  if (ishandle (hc) && strcmp (get (hc, "type"), "axes") && 
+      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+    if (strcmp (get (hc, "beingdeleted"), "off"))
+      delete (hc);
+    endif
+    if (!isempty (ancestor (h, "axes")) &&
+	strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
+      #set (ancestor (h, "axes"), "position", pos, "outerposition", opos);
+    endif
+  endif
+endfunction
+
+function resetaxis (h, d, pos, opos)
+  if (ishandle (h) && strcmp (get (h, "type"), "axes") && 
+      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
+      ishandle (get (h, "axes")))
+    #set (get (h, "axes"), "position", pos, "outerposition", opos);
+  endif
+endfunction
+
+function update_colorbar_clim (h, d, hi, vert)
+  if (ishandle (h) && strcmp (get (h, "type"), "image") && 
+      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+    clen = rows (get (get (h, "parent"), "colormap"));
+    cext = get (h, "clim");
+    cdiff = (cext(2) - cext(1)) / clen / 2;
+    cmin = cext(1) + cdiff;
+    cmax = cext(2) - cdiff;
+
+    if (vert)
+      set (hi, "ydata", [cmin, cmax]);
+      set (get (hi, "parent"), "ylim", cext);
+    else
+      set (hi, "xdata", [cmin, cmax]);
+      set (get (hi, "parent"), "xlim", cext);
+    endif
+  endif
+endfunction
+
+function update_colorbar_axis (h, d, cax)
+  if (ishandle (cax) && strcmp (get (cax, "type"), "axes") && 
+      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+    loc = get (cax, "location");
+    obj = get (h);
+    [pos, cpos, vertical, mirror, aspect] =  ...
+	__position_colorbox__ (loc, obj, ancestor (h, "figure"));
+
+    if (vertical)
+      if (mirror)
+	set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
+	     "yaxislocation", "right", "position", cpos);
       else
-	error ("colorbar: unrecognized position argument");
+	set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
+	     "yaxislocation", "left", "position", cpos);
       endif
     else
-      error ("colorbar: expecting string arguments");
+      if (mirror)
+	set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
+	     "xaxislocation", "top", "position", cpos);
+      else
+	set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
+	     "xaxislocation", "bottom", "position", cpos);
+      endif
+    endif
+
+    if (! isnan (aspect))
+      aspect
+      set (cax, "dataaspectratio", aspect);
+    endif
+  endif
+endfunction
+
+function [pos, cpos, vertical, mirr, aspect] = __position_colorbox__ (cbox, obj, cf)
+
+  pos = obj.position;
+  sz = pos(3:4);
+
+  off = 0;
+  if (strcmpi (obj.dataaspectratiomode, "manual"))
+    r = obj.dataaspectratio;
+    if (pos(3) > pos(4))
+      switch (cbox)
+	case {"east", "eastoutside", "west", "westoutside"}
+	  off = [(pos(3) - pos(4)) ./ (r(2) / r(1)), 0];	  
+      endswitch
+    else
+      switch (cbox)
+	case {"north", "northoutside", "south", "southoutside"}
+	  off = [0, (pos(4) - pos(3)) ./ (r(1) / r(2))];
+	  ## This shouldn't be here except that gnuplot doesn't have a
+	  ## square window and so a square aspect ratio is not square.
+	  ## The corrections are empirical.
+	  if (strcmp (get (cf, "__backend__"), "gnuplot"))
+	    if (length (cbox) > 7 && strcmp (cbox(end-6:end),"outside"))
+	      off = off / 2;
+	    else
+	      off = off / 1.7;
+	    endif
+	  endif
+      endswitch
     endif
-  endfor
+    off = off / 2;
+  endif
 
-  set (ax, "__colorbar__", pos);
+  switch (cbox)
+    case "northoutside"
+      origin = pos(1:2) + [0., 0.9] .* sz + [1, -1] .* off;
+      sz = sz .* [1.0, 0.06];
+      pos(4) = 0.8 * pos(4);
+      mirr = true;
+      vertical = false;
+    case "north"
+      origin = pos(1:2) + [0.05, 0.9] .* sz + [1, -1] .* off;
+      sz = sz .* [1.0, 0.06] * 0.9;
+      mirr = false;
+      vertical = false;
+    case "southoutside"
+      origin = pos(1:2) + off;
+      sz = sz .* [1.0, 0.06];
+      pos(2) = pos(2) + pos(4) * 0.2;
+      pos(4) = 0.8 * pos(4);
+      mirr = false;
+      vertical = false;
+    case "south"
+      origin = pos(1:2) + [0.05, 0.05] .* sz + off;
+      sz = sz .* [1.0, 0.06] * 0.9;
+      mirr = true;
+      vertical = false;
+    case "eastoutside"
+      origin = pos(1:2) + [0.9, 0] .* sz + [-1, 1] .* off;
+      sz = sz .* [0.06, 1.0];
+      pos(3) = 0.8 * pos(3);
+      mirr = true;
+      vertical = true;
+    case "east"
+      origin = pos(1:2) + [0.9, 0.05] .* sz + [-1, 1] .* off;
+      sz = sz .* [0.06, 1.0] * 0.9;
+      mirr = false;
+      vertical = true;
+    case "westoutside"
+      origin = pos(1:2) + off;
+      sz = sz .* [0.06, 1.0];
+      pos(1) = pos(1) + pos(3) * 0.2;
+      pos(3) = 0.8 * pos(3);
+      mirr = false;
+      vertical = true;
+    case "west"
+      origin = pos(1:2) + [0.05, 0.05] .* sz + off;
+      sz = sz .* [0.06, 1.0] .* 0.9;
+      mirr = true;
+      vertical = true;
+  endswitch
+
+  cpos = [origin, sz];
+
+  if (strcmpi (obj.dataaspectratiomode, "manual"))
+    r = obj.dataaspectratio;
+
+    if (pos(3) > pos(4))
+      if (vertical)
+	aspect = [1, 0.21, 1];
+      else
+	aspect = [0.21, 1, 1];
+      endif
+    else
+      if (vertical)
+	aspect = [1, 0.21, 1];
+      else
+	aspect = [0.21, 1, 1];
+      endif
+    endif
+  else
+    aspect = NaN;
+  endif
 
 endfunction
 
-
 %!demo
 %! hold off;
 %! close all;
 %! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
 %! imagesc(x)
 %! colorbar();
 
 %!demo
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -75,20 +75,19 @@
 ##   Text is to the right of the keys
 ## @end table
 ## @end deftypefn
 
 ## PKG_ADD mark_as_command legend
 
 function legend (varargin)
 
+  [ca, varargin, nargin] = __plt_get_axis_arg__ ("legend", varargin{:});
   nargs = nargin;
 
-  ca = gca ();
-
   if (nargs > 0)
     pos = varargin{nargs};
     if (isnumeric (pos) && isscalar (pos) && round (pos) == pos)
       if (pos >= -1 && pos <= 4)
 	set (ca, "keypos", pos);
 	nargs--;
       else
 	error ("legend: invalid position specified");
@@ -127,22 +126,35 @@ function legend (varargin)
 	    else
 	      set (ca, "key", "on");
 	    endif
 	  case "boxon"
 	    set (ca, "key", "on", "keybox", "on");
 	  case "boxoff"
 	    set (ca, "keybox", "off");
 	  otherwise
-	    while (k <= nkids && ! strcmp (get (kids(k), "type"), "line"))
+	    typ = get (kids (k), "type");
+	    while (k <= nkids && ! strcmp (typ, "line") &&
+		   ! strcmp (typ, "hggroup"))
 	      k++;
 	    endwhile
 	    if (k <= nkids)
 	      turn_on_legend = true;
-	      set (kids(k), "keylabel", arg);
+	      if (strcmp (typ, "hggroup"))
+		hgkids = get (kids(k), "children");
+		for j = 1 : length (hgkids)
+		  hgobj = get (hgkids (j));
+		  if (isfield (hgobj, "keylabel"))
+		    set (hgkids(j), "keylabel", arg);
+		    break;
+		  endif
+		endfor
+	      else
+		set (kids(k), "keylabel", arg);
+	      endif
 	    else
 	      warning ("legend: ignoring extra labels");
 	    endif
 	endswitch
 	nargs--;
       else
 	varargin = cellstr (arg);
 	nargs = numel (varargin);
@@ -155,45 +167,61 @@ function legend (varargin)
     endif
   endif
 
   if (nargs > 0)
     have_data = false;
     for i = 1:nkids
       if (strcmp (get (kids(k), "type"), "line")
 	  || strcmp (get (kids(k), "type"), "surface")
-	  || strcmp (get (kids(k), "type"), "patch"))
+	  || strcmp (get (kids(k), "type"), "patch")
+	  || strcmp (get (kids(k), "type"), "hggroup"))
 	have_data = true;
 	break;
       endif
     endfor
     if (! have_data)
       warning ("legend: plot data is empty; setting key labels has no effect");
     endif
   endif
 
   warned = false;
   for i = 1:nargs
     arg = varargin{i};
     if (ischar (arg))
       while (k <= nkids
 	     && ! (strcmp (get (kids(k), "type"), "line")
 		   || strcmp (get (kids(k), "type"), "surface")
-		   || strcmp (get (kids(k), "type"), "patch")))
+		   || strcmp (get (kids(k), "type"), "patch")
+		   || strcmp (get (kids(k), "type"), "hggroup")))
 	k++;
       endwhile
       if (k <= nkids)
-	set (kids(k), "keylabel", arg);
+	if (strcmp (get (kids(k), "type"), "hggroup"))
+	  hgkids = get (kids(k), "children");
+	  for j = 1 : length (hgkids)
+	    hgobj = get (hgkids (j));
+	    if (isfield (hgobj, "keylabel"))
+	      set (hgkids(j), "keylabel", arg);
+	      break;
+	    endif
+	  endfor
+	else
+	  set (kids(k), "keylabel", arg);
+	endif
 	turn_on_legend = true;
 	k++;
       elseif (! warned)
 	warned = true;
 	warning ("legend: ignoring extra labels");
       endif
     else
+      arg
+      get(kids(k),"type")
+      k
       error ("legend: expecting argument to be a character string");
     endif
   endfor
 
   if (turn_on_legend)
     set (ca, "key", "on");
   endif
 
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -44,13 +44,18 @@ function newplot ()
       case "add"
       case "replacechildren"
       case "replace"
 	__go_axes_init__ (ca, "replace");
 	__request_drawnow__ ();
       otherwise
 	error ("newplot: unrecognized nextplot property for current axes");
     endswitch
+
+    yt = get (ca, "ylabel");
+    if (! strcmp (get (yt, "type"), "text"))
+      disp("BAD!!!!!");
+      get(yt)
+    endif
   else
     print_usage ();
   endif
-
 endfunction
diff --git a/scripts/plot/pareto.m b/scripts/plot/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/pareto.m
@@ -50,18 +50,16 @@
 ## Sold = [105, 30, 70, 10, 15, 20];
 ## pareto(Sold, Cheese);
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function h = pareto (varargin)
 
-  [ax, varargin, nargin] = __plt_get_axis_arg__ ("pareto", varargin{:});
-
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   x = varargin {1}(:).';
   if (nargin == 2)
     y = varargin {2}(:).';
     if (! iscell (y))
@@ -79,17 +77,17 @@ function h = pareto (varargin)
   [x, idx] = sort (x, "descend");
   y = y (idx);
   cdf = cumsum (x);
   maxcdf = max(cdf);
   cdf = cdf ./ maxcdf;
   cdf95 = cdf - 0.95;
   idx95 = find(sign(cdf95(1:end-1)) != sign(cdf95(2:end)))(1);
 
-  [ax, hbar, hline] = plotyy (ax, 1 : idx95, x (1 : idx95), 
+  [ax, hbar, hline] = plotyy (1 : idx95, x (1 : idx95), 
 			      1 : length(cdf), 100 .* cdf, 
 			      @bar, @plot);
 
   axis (ax(1), [1 - 0.6, idx95 + 0.6, 0, maxcdf]);
   axis (ax(2), [1 - 0.6, idx95 + 0.6, 0, 100]);
   set (ax(2), "ytick", [0, 20, 40, 60, 80, 100], 
        "yticklabel", {"0%", "20%", "40%", "60%", "80%", "100%"});
   set (ax(1), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -72,20 +72,24 @@ function [Ax, H1, H2] = plotyy (varargin
     endif
   else
     f = get (0, "currentfigure");
     if (isempty (f))
       ax(1) = axes ();
       ax(2) = axes ();
     else
       ax = get (f, "children");
-      for i = 3 : length (ax)
-	delete (ax (i));
-      endfor
-      ax = ax(1:2);
+      if (length (ax) > 2)
+	for i = 3 : length (ax)
+	  delete (ax (i));
+	endfor
+	ax = ax(1:2);
+      elseif (length (ax) == 1)
+        ax(2) = axes ();
+      endif
     endif
     if (nargin < 2)
       varargin = {};
     endif
   endif 
 
   if (nargin < 4)
     print_usage ();
@@ -120,50 +124,99 @@ function [ax, h1, h2] = __plotyy__ (ax, 
 
   xlim = [min([x1(:); x2(:)]), max([x1(:); x2(:)])];
 
   axes (ax(1));
   newplot ();
   h1 = feval (fun1, x1, y1);
 
   set (ax(1), "ycolor", getcolor (h1(1)));
-  set (ax(1), "position", [0.11 0.13 0.78 0.73]);
-  set (ax(1), "activepositionproperty", "position");
   set (ax(1), "xlim", xlim);
 
   cf = gcf ();
   set (cf, "nextplot", "add");
   axes (ax(2));
   newplot ();
 
   colors = get (ax(1), "colororder");
   set (ax(2), "colororder", [colors(2:end,:); colors(1,:)]);
 
   h2 = feval (fun2, x2, y2);
   set (ax(2), "yaxislocation", "right");
   set (ax(2), "ycolor", getcolor (h2(1)));
   set (ax(2), "position", get (ax(1), "position"));
-  set (ax(2), "activepositionproperty", "position");
   set (ax(2), "xlim", xlim);
   set (ax(2), "color", "none");
+
+  ## Add invisible text objects that when destroyed, 
+  ## also remove the other axis
+  t1 = text (0, 0, "", "parent", ax(1), "tag", "plotyy", 
+	     "handlevisibility", "off", "visible", "off",
+	     "xliminclude", "off", "yliminclude", "off");
+  t2 = text (0, 0, "", "parent", ax(2), "tag", "plotyy", 
+	     "handlevisibility", "off", "visible", "off",
+	     "xliminclude", "off", "yliminclude", "off");
+
+  set (t1, "deletefcn", {@deleteplotyy, ax(2), t2});
+  set (t2, "deletefcn", {@deleteplotyy, ax(1), t1});
+
+  addlistener (ax(1), "position", {@update_position, ax(2)});
+  addlistener (ax(2), "position", {@update_position, ax(1)});
+  addlistener (ax(1), "view", {@update_position, ax(2)});
+  addlistener (ax(2), "view", {@update_position, ax(1)});
+
+  ## Tag the plotyy axes, so we can use that information
+  ## not to mirror the y axis tick marks
+  set (ax, "tag", "plotyy")
+
+endfunction
+
+%!demo
+%! x = 0:0.1:2*pi; 
+%! y1 = sin (x);
+%! y2 = exp (x - 1);
+%! ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
+%! xlabel ("X");
+%! ylabel (ax(1), "Axis 1");
+%! ylabel (ax(2), "Axis 2");
+
+function deleteplotyy (h, d, ax2, t2)
+  if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes") && 
+      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
+      strcmp (get (ax2, "beingdeleted"), "off"))
+    set (t2, "deletefcn", []);
+    delete (ax2);
+  endif
+endfunction
+
+function update_position (h, d, ax2)
+  persistent recursion = false;
+
+  ## Don't allow recursion
+  if (! recursion)
+    unwind_protect
+      recursion = true;
+      position = get (h, "position");
+      view = get (h, "view");
+      oldposition = get (ax2, "position");
+      oldview = get (ax2, "view");
+      if (! (isequal (position, oldposition) && isequal (view, oldview)))
+	set (ax2, "position", position, "view", view);
+      endif
+    unwind_protect_cleanup
+      recursion = false;
+    end_unwind_protect
+  endif  
 endfunction
 
 function color = getcolor (ax)
   obj = get (ax);
   if (isfield (obj, "color"))
     color = obj.color;
   elseif (isfield (obj, "facecolor") && ! ischar (obj.facecolor))
     color = obj.facecolor;
   elseif (isfield (obj, "edgecolor") && !  ischar (obj.edgecolor))
     color = obj.edgecolor;
   else
     color = [0, 0, 0];
   endif
 endfunction
 
-%!demo
-%! x = 0:0.1:2*pi; 
-%! y1 = sin (x);
-%! y2 = exp (x - 1);
-%! ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
-%! xlabel ("X");
-%! ylabel (ax(1), "Axis 1");
-%! ylabel (ax(2), "Axis 2");
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -121,27 +121,27 @@ function h = subplot (rows, columns, ind
     ## Check whether this child is still valid; this might not be the
     ## case anymore due to the deletion of previous children (due to
     ## "deletefcn" callback or for legends/colorbars that are deleted
     ## with their corresponding axes).
     if (! ishandle (child))
       continue;
     endif
     if (strcmp (get (child, "type"), "axes"))
-      ## Skip legend objects.
-      if (strcmp (get (child, "tag"), "legend"))
+      ## Skip legend and colorbar objects.
+      if (strcmp (get (child, "tag"), "legend") || 
+	  strcmp (get (child, "tag"), "colorbar"))
         continue;
       endif
       objpos = get (child, "outerposition");
       if (objpos == pos)
 	## If the new axes are in exactly the same position as an
 	## existing axes object, use the existing axes.
 	found = true;
 	tmp = child;
-	break;
       else
 	## If the new axes overlap an old axes object, delete the old
 	## axes.
 	objx0 = objpos(1);
 	objx1 = objx0 + objpos(3);
 	objy0 = objpos(2);
 	objy1 = objy0 + objpos(4);
 	if (! (x0 >= objx1 || x1 <= objx0 || y0 >= objy1 || y1 <= objy0))
@@ -149,16 +149,18 @@ function h = subplot (rows, columns, ind
 	endif
       endif
     endif
   endfor
 
   if (found)
     set (cf, "currentaxes", tmp);
   else
-    tmp = axes ("outerposition", pos);
+    border = [0.130, 0.110, 0.225, 0.185] .* [xsize, ysize, xsize, ysize];
+    pos2 = [pos(1:2) + border(1:2), pos(3:4) - border(1:2) - border(3:4)];
+    tmp = axes ("outerposition", pos, "position", pos2);
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,13 +1,26 @@
 2008-09-10  John W. Eaton  <jwe@octave.org>
 
 	* octave.cc (octave_main): Make all command-line arguments
 	available to startup scripts and PKG_ADD files.
 
+2008-09-10  David Bateman  <dbateman@free.fr>
+
+	* graphics.h.in (radio_property axes::properties::__colorbar__):
+	Delete.
+	* graphics.cc (void axes::properties::sync_positions (void)):
+	Disable code synchronizing outerposiiton and position.
+	(void axes::properties::set_defaults (base_graphics_object&,
+	const std::string&): Remove __colorbar__.
+	(F__go_delete__): Don't delete if already being deleting to avoid
+	recursion in callback functions.
+	(F__go_axes_init__): Flag error if handle is deleted during
+	initialization due.
+	
 2008-09-09  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/regexp.cc (octregexp_list): Distinguish between
 	matlab named tokens and perl lookbehind expressions. For
 	lookbehind expression replace "*" and "+" with a limited number of
 	fixed length expressions to simulate arbitrary length look behind.
 
 2008-09-08  Michael Goffioul  <michael.goffioul@gmail.com>
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1296,18 +1296,19 @@ gh_manager::do_free (const graphics_hand
 
 	      p->second.get_properties ().set_beingdeleted (true);
 	      p->second.get_properties ().execute_deletefcn ();
 
 	      // notify backend
 	      graphics_backend backend = p->second.get_backend ();
 	      if (backend)
                 backend.object_destroyed (p->second);
-                 // note - this will be valid only for first explicitly deleted object.
-                 // All his children will have unknown backend then.
+                 // note - this will be valid only for first explicitly 
+                 // deleted object. All its children will then have an
+	         // unknown backend.
                  
 	      handle_map.erase (p);
 
 	      if (h.value () < 0)
 		handle_free_list.insert (h);
 	    }
 	  else
 	    error ("graphics_handle::free: invalid object %g", h.value ());
@@ -1708,18 +1709,25 @@ base_properties::update_axis_limits (con
     obj.update_axis_limits (axis_type);
 }
 
 void
 base_properties::delete_children (void)
 {
   octave_idx_type n = children.numel ();
 
+  // A callback function might have already deleted the child,
+  // so check before deleting
   for (octave_idx_type i = 0; i < n; i++)
-    gh_manager::free (children(i));
+    {
+      graphics_object go = gh_manager::get_object (children(i));
+
+      if (go.valid_object ())
+	gh_manager::free (children(i));
+    }
 }
 
 graphics_backend
 base_properties::get_backend (void) const
 {
   graphics_object go = gh_manager::get_object (get_parent ());
 
   if (go)
@@ -2075,18 +2083,22 @@ figure::get_default (const caseless_str&
   return retval;
 }
 
 // ---------------------------------------------------------------------
 
 void 
 axes::properties::sync_positions (void)
 {
+#if 0
   // FIXME -- this should take font metrics into consideration,
-  // for now we'll just make it position 90% of outerposition
+  // and also the fact that the colorbox leaves the outerposition
+  // alone but alters the position. For now just don't adjust the
+  // positions relative to each other.
+
   if (activepositionproperty.is ("outerposition"))
     {
       Matrix outpos = outerposition.get ().matrix_value ();
       Matrix defpos = default_axes_position ();
       Matrix pos(outpos);
       pos(0) = outpos(0) + defpos(0) * outpos(2);
       pos(1) = outpos(1) + defpos(1) * outpos(3);
       pos(2) = outpos(2) * defpos(2);
@@ -2097,16 +2109,17 @@ axes::properties::sync_positions (void)
     {
       Matrix pos = position.get ().matrix_value ();
       pos(0) -= pos(2)*0.05;
       pos(1) -= pos(3)*0.05;
       pos(2) *= 1.1;
       pos(3) *= 1.1;
       outerposition = pos;
     }
+#endif
 
   update_transform ();
 }
 
 void
 axes::properties::set_title (const octave_value& v)
 {
   graphics_handle val = ::reparent (v, "set", "title", __myhandle__, false);
@@ -2153,17 +2166,24 @@ axes::properties::set_zlabel (const octa
       zlabel = val;
     }
 }
 
 void
 axes::properties::set_defaults (base_graphics_object& obj,
 				const std::string& mode)
 {
+  gh_manager::free (title.handle_value ());
   title = graphics_handle ();
+
+  if (! title.handle_value ().ok ()) 
+    std::cerr << "set_defaults not ok\n";
+  else
+    std::cerr << "set_defaults ok " << title.handle_value().value () << "\n";
+
   box = "on";
   key = "off";
   keybox = "off";
   keypos = 1.0;
   colororder = default_colororder ();
   dataaspectratio = Matrix (1, 3, 1.0);
   dataaspectratiomode = "auto";
   layer = "bottom";
@@ -2177,19 +2197,24 @@ axes::properties::set_defaults (base_gra
   Matrix cl (1, 2, 0);
   cl(1) = 1;
   clim = cl;
   
   xlimmode = "auto";
   ylimmode = "auto";
   zlimmode = "auto";
   climmode = "auto";
+
+  gh_manager::free (xlabel.handle_value ());
+  gh_manager::free (ylabel.handle_value ());
+  gh_manager::free (zlabel.handle_value ());
   xlabel = graphics_handle ();
   ylabel = graphics_handle ();
   zlabel = graphics_handle ();
+
   xgrid = "off";
   ygrid = "off";
   zgrid = "off";
   xminorgrid = "off";
   yminorgrid = "off";
   zminorgrid = "off";
   xtick = Matrix ();
   ytick = Matrix ();
@@ -2260,32 +2285,42 @@ axes::properties::set_defaults (base_gra
       touterposition(2) = 1;
       touterposition(3) = 1;
       outerposition = touterposition;
 
       position = default_axes_position ();
     }
 
   activepositionproperty = "outerposition";
-  __colorbar__  = "none";
 
   delete_children ();
 
   children = Matrix ();
 
   update_transform ();
 
   override_defaults (obj);
 }
 
 graphics_handle
 axes::properties::get_title (void) const
 {
+  if (! title.handle_value ().ok ()) 
+    std::cerr << "get_title not ok\n";
+  else
+    std::cerr << "get_title ok " << title.handle_value().value () << "\n";
+
+    
   if (! title.handle_value ().ok ())
     title = gh_manager::make_graphics_handle ("text", __myhandle__);
+  
+  if (! title.handle_value ().ok ()) 
+    std::cerr << "get_title 2 not ok\n";
+  else
+    std::cerr << "get_title 2 ok " << title.handle_value().value () << "\n";
 
   return title.handle_value ();
 }
 
 graphics_handle
 axes::properties::get_xlabel (void) const
 {
   if (! xlabel.handle_value ().ok ())
@@ -4400,29 +4435,36 @@ Undocumented internal function.\n\
       if (! error_state)
 	{
 	  h = gh_manager::lookup (val);
 
 	  if (h.ok ())
 	    {
 	      graphics_object obj = gh_manager::get_object (h);
 
-	      graphics_handle parent_h = obj.get_parent ();
-
-	      graphics_object parent_obj = gh_manager::get_object (parent_h);
-
-              // NOTE: free the handle before removing it from its parent's
-              //       children, such that the object's state is correct when
-              //       the deletefcn callback is executed
-
-	      gh_manager::free (h);
-
-	      parent_obj.remove_child (h);
-
-	      Vdrawnow_requested = true;
+	      // Don't do recursive deleting, due to callbacks
+	      if (! obj.get_properties ().is_beingdeleted ())
+		{
+		  graphics_handle parent_h = obj.get_parent ();
+
+		  graphics_object parent_obj = 
+		    gh_manager::get_object (parent_h);
+
+		  // NOTE: free the handle before removing it from its parent's
+		  //       children, such that the object's state is correct
+		  //       when the deletefcn callback is executed
+
+		  gh_manager::free (h);
+
+		  // A callback function might have already deleted the parent
+		  if (parent_obj.valid_object ())
+		    parent_obj.remove_child (h);
+
+		  Vdrawnow_requested = true;
+		}
 	    }
 	  else
 	    error ("delete: invalid graphics object (= %g)", val);
 	}
       else
 	error ("delete: invalid graphics object");
     }
   else
@@ -4463,16 +4505,20 @@ Undocumented internal function.\n\
 	{
 	  h = gh_manager::lookup (val);
 
 	  if (h.ok ())
 	    {
 	      graphics_object obj = gh_manager::get_object (h);
 
 	      obj.set_defaults (mode);
+
+	      h = gh_manager::lookup (val);
+	      if (! h.ok ())
+		error ("__go_axes_init__: axis deleted during initialization (= %g)", val);
 	    }
 	  else
 	    error ("__go_axes_init__: invalid graphics object (= %g)", val);
 	}
       else
 	error ("__go_axes_init__: invalid graphics object");
     }
   else
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -2590,17 +2590,16 @@ public:
       radio_property ydir u , "{normal}|reverse"
       radio_property zdir u , "{normal}|reverse"
       radio_property yaxislocation , "{left}|right|zero"
       radio_property xaxislocation , "{bottom}|top|zero"
       array_property view u , Matrix ()
       radio_property nextplot , "add|replace_children|{replace}"
       array_property outerposition u , default_axes_outerposition ()
       radio_property activepositionproperty , "{outerposition}|position"
-      radio_property __colorbar__ h , "{none}|north|south|east|west|northoutside|southoutside|eastoutside|westoutside"
       color_property ambientlightcolor , color_values (1, 1, 1)
       array_property cameraposition m , Matrix (1, 3, 0.0)
       array_property cameratarget m , Matrix (1, 3, 0.0)
       array_property cameraupvector m , Matrix ()
       double_property cameraviewangle m , 10.0
       radio_property camerapositionmode , "{auto}|manual"
       radio_property cameratargetmode , "{auto}|manual"
       radio_property cameraupvectormode , "{auto}|manual"
