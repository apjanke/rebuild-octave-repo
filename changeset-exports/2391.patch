# HG changeset patch
# User jwe
# Date 845149392 0
#      Sat Oct 12 19:43:12 1996 +0000
# Node ID b12625d6fbcd01512cfbfaac2b9036d54d35f029
# Parent  c2c1482c34c895241b5f707b5697c9ce3271081a
[project @ 1996-10-12 19:35:37 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,23 @@
+Sat Oct 12 00:17:06 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* config.h.bot (STATIC_CAST, DYNAMIC_CAST, REINTERPRET_CAST):
+	New macros.
+
+Wed Sep 25 12:24:20 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in: Don't look in /usr/ucb/include to find getrusage
+	on Solaris systems since that just seems to cause trouble.
+	* Makeconf.in (UCB_INCFLAGS): Delete.
+
+Fri Aug 30 09:07:23 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in (TERMLIBS): Add check for ncurses.
+
 Tue Aug 20 21:40:26 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in: Always set FPICFLAG, CPICFLAG, CXXPICFLAG, SHLEXT,
 	RLD_FLAG, DLFCN_DIR, even if SHARED_LIBS is false.
 
 Thu Aug 15 14:39:07 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in (gxx_version, gcc_version): Strip out cygnus- from
diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,12 @@
+Sat Oct 12 13:38:49 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Makefile.in (maintainer-clean): Don't depend on distclean.
+
 Sat Jun 15 23:01:33 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* interpreter/Makefile.in (TEXINFO): Add audio.texi and emacs.texi.
 
 Fri May 17 03:02:37 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* interpreter/Makefile.in: Use man1dir instead of mandir, and
 	man1ext instead of manext.
diff --git a/examples/make_int.cc b/examples/make_int.cc
new file mode 100644
--- /dev/null
+++ b/examples/make_int.cc
@@ -0,0 +1,372 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#include <octave/config.h>
+
+#include <cstdlib>
+
+#include <string>
+
+class ostream;
+
+#include <octave/lo-utils.h>
+#include <octave/mx-base.h>
+#include <octave/str-vec.h>
+
+#include <octave/defun-dld.h>
+#include <octave/error.h>
+#include <octave/gripes.h>
+#include <octave/mappers.h>
+#include <octave/oct-obj.h>
+#include <octave/ops.h>
+#include <octave/ov-base.h>
+#include <octave/ov-typeinfo.h>
+#include <octave/ov.h>
+#include <octave/ov-scalar.h>
+#include <octave/pager.h>
+#include <octave/pr-output.h>
+#include <octave/symtab.h>
+#include <octave/variables.h>
+
+class Octave_map;
+class octave_value_list;
+
+class tree_walker;
+
+// Integer values.
+
+class
+octave_integer : public octave_base_value
+{
+public:
+
+  octave_integer (void)
+    : octave_base_value (), scalar (0) { }
+
+  octave_integer (int i)
+    : octave_base_value (), scalar (i) { }
+
+  octave_integer (const octave_integer& s)
+    : octave_base_value (), scalar (s.scalar) { }
+
+  ~octave_integer (void) { }
+
+  octave_value *clone (void) { return new octave_integer (*this); }
+
+#if 0
+  void *operator new (size_t size);
+  void operator delete (void *p, size_t size);
+#endif
+
+  idx_vector index_vector (void) const { return idx_vector ((double) scalar); }
+
+  int rows (void) const { return 1; }
+  int columns (void) const { return 1; }
+
+  bool is_defined (void) const { return true; }
+  bool is_real_scalar (void) const { return true; }
+
+  octave_value all (void) const { return (scalar != 0); }
+  octave_value any (void) const { return (scalar != 0); }
+
+  bool is_real_type (void) const { return true; }
+  bool is_scalar_type (void) const { return true; }
+  bool is_numeric_type (void) const { return true; }
+
+  bool valid_as_scalar_index (void) const
+    { return scalar == 1; }
+
+  bool valid_as_zero_index (void) const
+    { return scalar == 0; }
+
+  bool is_true (void) const { return (scalar != 0); }
+
+  double double_value (bool = false) const { return (double) scalar; }
+
+  int integer_value (bool = false) const { return scalar; }
+
+  Matrix matrix_value (bool = false) const { return Matrix (1, 1, scalar); }
+
+  Complex complex_value (bool = false) const { return scalar; }
+
+  ComplexMatrix complex_matrix_value (bool = false) const
+    { return  ComplexMatrix (1, 1, Complex (scalar)); }
+
+  octave_value not (void) const { return octave_value (! scalar); }
+
+  octave_value uminus (void) const { return octave_value (- scalar); }
+
+  octave_value transpose (void) const { return octave_value (scalar); }
+
+  octave_value hermitian (void) const { return octave_value (scalar); }
+
+  void increment (void) { ++scalar; }
+
+  void decrement (void) { --scalar; }
+
+  void print (ostream& os);
+
+  int type_id (void) const { return t_id; }
+
+  string type_name (void) const { return t_name; }
+
+  static int static_type_id (void) { return t_id; }
+
+  static void register_type (void)
+    { t_id = octave_value_typeinfo::register_type (t_name); }
+
+private:
+
+  int scalar;
+
+  static int t_id;
+
+  static const string t_name;
+};
+
+int octave_integer::t_id = -1;
+
+const string octave_integer::t_name ("integer");
+
+void
+octave_integer::print (ostream& os)
+{
+  octave_print_internal (os, scalar, false);
+}
+
+// integer by integer ops.
+
+static octave_value
+add (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () + v2.integer_value ());
+}
+
+static octave_value
+sub (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () - v2.integer_value ());
+}
+
+static octave_value
+mul (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () * v2.integer_value ());
+}
+
+static octave_value
+div (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  int d = v2.integer_value ();
+
+  if (d == 0)
+    gripe_divide_by_zero ();
+
+  return new octave_integer (v1.integer_value () / d);
+}
+
+static octave_value
+i_s_div (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_scalar&);
+
+  double d = v2.double_value ();
+
+  if (d == 0.0)
+    gripe_divide_by_zero ();
+
+  return new octave_scalar (v1.double_value () / d);
+}
+
+static octave_value
+ldiv (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  int d = v1.integer_value ();
+
+  if (d == 0)
+    gripe_divide_by_zero ();
+
+  return new octave_integer (v2.integer_value () / d);
+}
+
+static octave_value
+lt (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () < v2.integer_value ());
+}
+
+static octave_value
+le (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () <= v2.integer_value ());
+}
+
+static octave_value
+eq (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () == v2.integer_value ());
+}
+
+static octave_value
+ge (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () >= v2.integer_value ());
+}
+
+static octave_value
+gt (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () > v2.integer_value ());
+}
+
+static octave_value
+ne (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () != v2.integer_value ());
+}
+
+static octave_value
+el_mul (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () * v2.integer_value ());
+}
+
+static octave_value
+el_div (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  int d = v2.integer_value ();
+
+  if (d == 0)
+    gripe_divide_by_zero ();
+
+  return new octave_integer (v1.integer_value () / d);
+}
+
+static octave_value
+el_ldiv (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  int d = v1.integer_value ();
+
+  if (d == 0)
+    gripe_divide_by_zero ();
+
+  return new octave_integer (v2.integer_value () / d);
+}
+
+static octave_value
+el_and (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () && v2.integer_value ());
+}
+
+static octave_value
+el_or (const octave_value& a1, const octave_value& a2)
+{
+  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+
+  return new octave_integer (v1.integer_value () || v2.integer_value ());
+}
+
+DEFUN_DLD (make_int, args, ,
+  "int_val = make_int (val)\n\
+\n\
+Creates an integer variable from VAL.")
+{
+  static bool type_loaded = false;
+
+  if (! type_loaded)
+    {
+      octave_integer::register_type ();
+
+      cerr << "installing integer type at type-id = "
+	   << octave_integer::static_type_id () << "\n";
+
+      INSTALL_BINOP (add, octave_integer, octave_integer, add);
+      INSTALL_BINOP (sub, octave_integer, octave_integer, sub);
+      INSTALL_BINOP (mul, octave_integer, octave_integer, mul);
+      INSTALL_BINOP (div, octave_integer, octave_integer, div);
+      INSTALL_BINOP (ldiv, octave_integer, octave_integer, ldiv);
+      INSTALL_BINOP (lt, octave_integer, octave_integer, lt);
+      INSTALL_BINOP (le, octave_integer, octave_integer, le);
+      INSTALL_BINOP (eq, octave_integer, octave_integer, eq);
+      INSTALL_BINOP (ge, octave_integer, octave_integer, ge);
+      INSTALL_BINOP (gt, octave_integer, octave_integer, gt);
+      INSTALL_BINOP (ne, octave_integer, octave_integer, ne);
+      INSTALL_BINOP (el_mul, octave_integer, octave_integer, el_mul);
+      INSTALL_BINOP (el_div, octave_integer, octave_integer, el_div);
+      INSTALL_BINOP (el_ldiv, octave_integer, octave_integer, el_ldiv);
+      INSTALL_BINOP (el_and, octave_integer, octave_integer, el_and);
+      INSTALL_BINOP (el_or, octave_integer, octave_integer, el_or);
+
+      INSTALL_BINOP (div, octave_integer, octave_scalar, i_s_div);
+    }
+
+  octave_value retval;
+
+  if (args.length () == 1)
+    {
+      double d = args(0).double_value ();
+
+      if (! error_state)
+	retval = octave_value (new octave_integer (NINT (d)));
+    }
+  else
+    usage ("make_int");
+
+  return retval;
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/info/ChangeLog b/info/ChangeLog
--- a/info/ChangeLog
+++ b/info/ChangeLog
@@ -1,8 +1,16 @@
+Sat Oct 12 00:22:21 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in (TERMLIBS): Check for ncurses.
+
+Fri Aug 30 09:07:40 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in (TERMLIBS): Add check for ncurses.
+
 Fri May 24 01:16:46 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in (TERMLIBS): Check for tputs, not main.
 
 Mon May 13 02:36:00 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* info.c (main): On program exit, leave the cursor at the bottom
 	of the window and restore the terminal IO.
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,13 @@
+Sat Oct 12 00:20:41 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Makefile.in (maintainer-clean): Don't depend on distclean.
+	* Makerules.in (maintainer-clean): Ditto.
+
 Tue Aug 20 22:09:08 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makerules.in (stamp-picdir): Only create a pic subdirectory if
 	SHARED_LIBS is true AND FPICFLAG is not empty.
 
 Wed May 22 15:07:00 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (stamp-shared): Use CC, not CXX to create shared
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,47 @@
+Sat Oct 12 12:40:00 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* MArray-misc.cc: New file.
+	* Makefile.in (MATRIX_SRC): Add it to the list.
+
+	* mx-inlines.cc (equal): Return bool, not int.
+
+	* idx-vector.h (idx_vector (double)): New constructor.
+
+	* chMatrix.h, chMatrix.cc, CMatrix.h, CMatrix.cc, dMatrix.h,
+	dMatrix.cc, dDiagMatrix.h, dDiagMatrix.cc, dRowVector.h,
+	dRowVector.cc, dColVector.h, dColVector.cc, CColVector.h,
+	CColVector.cc, CDiagMatrix.h, CDiagMatrix.cc, CRowVector.h,
+	CRowVector.cc: Logical operators return bool, not int.
+
+	* CMatrix.h, CMatrix.cc (ComplexMatrix::any_element_is_inf_or_nan):
+	New function.
+
+	* dMatrix.h, dMatrix.cc (Matrix::any_element_is_negative,
+	Matrix::any_element_is_inf_or_nan, Matrix::abs,
+	Matrix::all_elements_are_inf_or_nan): New functions.
+
+	* Range.h, Range.cc (Range::all_elements_are_ints): New function.
+
+	* MArray.cc, MArray2.cc, MDiagArray2.cc: Call gripe_nonconformant
+	for errors.  Simplify macros by converting FCN to string for error
+	messages.
+
+	* Array-idx.h (Array<T>::index): New function.  Don't call
+	clear_index() here.
+	(Array<T>::value): Call it, do call clear_index() here.
+	* Array2-idx.h (Array<T>::value, Array<T>::index): Likewise, for
+	one and two arg index functions.
+
+Tue Sep 17 21:21:16 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* DAEFunc.h: Delete #pragma interface since there is no longer a
+	separate implementation file.
+
 Tue Aug 20 17:38:46 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (stamp-picdir): Only create a pic subdirectory if
 	SHARED_LIBS is true AND CPICFLAG or CXXPICFLAG is not empty.
 
 	* idx-vector.cc (IDX_VEC_REP::is_colon_equiv): Rename arg sort to
 	sort_uniq.  If sort_uniq is nonzero, sort the elements and make
 	them uniq.
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -86,16 +86,20 @@ public:
   friend MArray<T> operator - (const MArray<T>& a, const MArray<T>& b);
 
   friend MArray<T> product (const MArray<T>& a, const MArray<T>& b);
   friend MArray<T> quotient (const MArray<T>& a, const MArray<T>& b);
 
   friend MArray<T> operator - (const MArray<T>& a);
 };
 
+extern void
+gripe_nonconformant (const char *op, int op1_len, int op2_len);
+
+
 #define INSTANTIATE_MARRAY_FRIENDS(T) \
   template MArray<T>& operator += (MArray<T>& a, const T& s); \
   template MArray<T>& operator -= (MArray<T>& a, const T& s); \
   template MArray<T>& operator += (MArray<T>& a, const MArray<T>& b); \
   template MArray<T>& operator -= (MArray<T>& a, const MArray<T>& b); \
   template MArray<T> operator + (const MArray<T>& a, const T& s); \
   template MArray<T> operator - (const MArray<T>& a, const T& s); \
   template MArray<T> operator * (const MArray<T>& a, const T& s); \
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -85,16 +85,20 @@ public:
   friend MArray2<T> operator - (const MArray2<T>& a, const MArray2<T>& b);
 
   friend MArray2<T> product (const MArray2<T>& a, const MArray2<T>& b);
   friend MArray2<T> quotient (const MArray2<T>& a, const MArray2<T>& b);
 
   friend MArray2<T> operator - (const MArray2<T>& a);
 };
 
+extern void
+gripe_nonconformant (const char *op, int op1_nr, int op1_nc,
+		     int op2_nr, int op2_nc);
+
 #define INSTANTIATE_MARRAY2_FRIENDS(T) \
   template MArray2<T>& operator += (MArray2<T>& a, const T& s); \
   template MArray2<T>& operator -= (MArray2<T>& a, const T& s); \
   template MArray2<T>& operator += (MArray2<T>& a, const MArray2<T>& b); \
   template MArray2<T>& operator -= (MArray2<T>& a, const MArray2<T>& b); \
   template MArray2<T> operator + (const MArray2<T>& a, const T& s); \
   template MArray2<T> operator - (const MArray2<T>& a, const T& s); \
   template MArray2<T> operator * (const MArray2<T>& a, const T& s); \
diff --git a/readline/ChangeLog b/readline/ChangeLog
--- a/readline/ChangeLog
+++ b/readline/ChangeLog
@@ -1,8 +1,12 @@
+Fri Aug 30 09:07:57 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in (TERMLIBS): Add check for ncurses.
+
 Mon Jun 24 02:31:37 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (install): Use INSTALL_PROGRAM instead of
 	INSTALL_DATA for shared libs.
 
 Wed May 22 13:40:26 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in (TERMLIBS, SH_TERMLIBS): Set these variable
diff --git a/readline/configure.in b/readline/configure.in
--- a/readline/configure.in
+++ b/readline/configure.in
@@ -57,17 +57,17 @@ AC_CONFIG_HEADER(config.h)
 
 AC_PROG_CC
 AC_PROG_CPP
 AC_PROG_GCC_TRADITIONAL
 AC_PROG_INSTALL
 AC_PROG_RANLIB
 
 TERMLIBS=""
-for termlib in termcap terminfo curses termlib; do
+for termlib in termcap terminfo ncurses curses termlib; do
   AC_CHECK_LIB(${termlib}, tputs, [TERMLIBS="${TERMLIBS} -l${termlib}"])
   case "${TERMLIBS}" in
     *-l${termlib}*)
       AC_MSG_RESULT([defining TERMLIBS to be $TERMLIBS])
       break
     ;;
   esac
 done
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,164 @@
+Sat Oct 12 13:40:21 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	Changes for Octave's new type system:
+
+	* arith-ops.cc: Delete.
+	* pt-const.h, pt-const.cc: Massive changes.  Most functionality
+	moved to ov.h, ov.cc, and derived classes.
+
+	* variables.h, variables.cc (octave_variable_reference): New class
+	for getting references to variables and structure elements used in
+	assignments or value contexts.
+
+	* symtab.h, symtab.cc (symbol_record::define (const octave_value&),
+	symbol_record::variable_value, symbol_record::variable_reference):
+	New functions.
+	(symbol_record_info::type_name): Rename from type_as_string.
+
+	* pt-fvc-base.h, pt-fvc-base.cc (tree_fvc::increment,
+	tree_fvc::decrement): New functions to replace
+	tree_fvc::bump_value.
+	#if 0 assign and lookup_map_element functions.
+
+	* pt-mvr.cc (tree_multi_assignment_expression::eval):
+	Generated RHS value is now a tree_constant.
+
+	* pt-exp.h, pt-exp.cc (tree_boolean_expression): New class.
+	(tree_unary_expression, tree_binary_expression,
+	tree_boolean_expression): Move codes here from tree_expression.
+	(tree_simple_assignment_expression): Cope with changes to way of
+	doing assignments.
+
+	* pt-exp-base.h, pt-exp-base.cc (enum type): Delete codes for
+	unary and binary ops.
+	(tree_expression::expression_type): Delete.
+	(tree_expression::is_logically_true): Hand off to
+	octave_value::is_true to do real work.
+
+	* pr-output.h, pr-output.cc (any_element_is_inf_or_nan,
+	all_elements_are_ints): Delete.  Call member new functions for
+	these operations.
+	(free_format, plus_format, bank_format, hex_format,
+	compact_format, print_e, print_big_e): Use bool, not int.
+	(octave_print_internal): Hand off to scalar/real versions when
+	appropriate.
+
+	* octave.cc (main): Call initialize_types() and install_ops().
+	(verbose_usage): Add WWW address to output.
+
+	* parse.y (indirect_ref): Handle by making a tree instead of a
+	list using new version of tree_indirect_ref class.
+
+	* parse.y (make_boolean_op): New function.  Use it instead of
+	make_binary_op to create trees for && and || ops.
+	(make_binary_op): Codes come from tree_binary_expression now,
+	instead of tree_expression.
+	(make_unary_op): Codes come from tree_unary_expression now,
+	instead of tree_expression.
+	(make_boolean_op): Codes come from tree_boolean_expression.
+	
+	 *parse.y (tree_constant_type): Change type to tree_constant* from
+	octave_value*, and rename from octave_value_type.  Change uses.
+
+	* defun.h (DEFVAR_INT): Pass octave_value not pointer to
+	octave_value for defn when creating builtin_variable.
+
+	* gripes.h, gripes.cc (gripe_invalid_conversion): Args are
+	strings, not char*.
+	(gripe_implicit_conversion, gripe_divide_by_zero): New extern
+	gripe functions.
+
+	* mkbuiltins: For each file, create a separate static function to
+	install builtins, then create another single extern function to
+	call all of them.
+
+	* pt-fcn.cc (tree_function::bind_nargin_and_nargout):
+	Just pass doubles and let symbol_record::define handle creating
+	new value.
+
+	* pt-pr-code.cc, pt-pr-code.h (visit_constant): Renamed from
+	visit_octave_value.
+	(visit_unary_expression): Use tree_expression::is_prefix_op()
+	instead of switch on op types.
+
+	* pt-walk.h (visit_constant): Renamed from visit_octave_value.
+
+	* pt-misc.cc (initialize_undefined_elements): Get reference to
+	tmp, then assign.
+	* pt-cmd.cc (do_for_loop_once): Likewise, for loop identifier.
+
+	* input.cc (generate_struct_completions, looks_like_struct): Cast
+	tmp_fvc to tree_constant*, not octave_value*.
+	(get_user_input): Call print() on retval, not eval(1).
+
+	* help.cc (Ftype): Cast defn to tree_constant*, not octave_value*.
+
+	* balance.cc: Fix docstring.
+
+	* dassl.cc, fsolve.cc, load-save.cc, lsode.cc, npsol.cc, qpsol.cc,
+	quad.cc:
+	Include pt-fvc.h.
+
+	* data.cc (Fstruct_contains): call octave_value::struct_elt_val,
+	not octave_value::lookup_map_element.
+
+	* dirfns.cc (Fcd): Pass directory name as string directly to
+	bind_builtin_variable instead of creating new octave_value.
+
+	* toplev.cc: Include pt-fvc.h and lo-mappers.h
+
+	* data.cc, error.cc, file-io.cc, load-save.cc, pager.cc,
+	pt-mat.cc, pt-plot.cc, syscalls.cc, toplev.cc:
+	Include variables.h.
+
+	* Array-tc.cc, Map-tc.cc, SLList-misc.cc SLList-tc.cc, data.cc,
+	defaults.cc, dynamic-ld.cc, error.cc, gripes.cc, lex.l, octave.cc,
+	oct-map.h, oct-map.cc, oct-obj.h, pt-cmd.cc, pt-exp.cc, pt-fcn.cc,
+	pt-fvc-base.cc, pt-mat.cc, pt-misc.cc, pt-mvr-base.cc, pt-mvr.h,
+	resource.cc, strfns.cc, sysdep.cc, timefns.cc, toplev.cc:
+	Include ov.h instead of pt-const.h.
+
+	* xpow.cc (any_element_is_negative): Delete.
+	(xpow and elem_xpow functions): Check conformance here.
+
+	* xdiv.cc (mx_leftdiv_conform, mx_div_conform):
+	Now template-based, taking Matrices instead of dimensions as args.
+	Change all callers.
+
+	* op-cm-cm.cc, op-cm-cm.h, op-cm-cs.cc, op-cm-cs.h, op-cm-m.cc,
+ 	op-cm-m.h, op-cm-s.cc, op-cm-s.h, op-cs-cm.cc, op-cs-cm.h,
+ 	op-cs-cs.cc, op-cs-cs.h, op-cs-m.cc, op-cs-m.h, op-cs-s.cc,
+ 	op-cs-s.h, op-m-cm.cc, op-m-cm.h, op-m-cs.cc, op-m-cs.h, op-m-m.cc,
+	op-m-m.h, op-m-s.cc, op-m-s.h, op-s-cm.cc, op-s-cm.h, op-s-cs.cc,
+ 	op-s-cs.h, op-s-m.cc, op-s-m.h, op-s-s.cc, op-s-s.h,
+ 	op-str-str.cc, op-str-str.h, ops.cc, ops.h, ov-base.cc, ov-base.h,
+ 	ov-ch-mat.cc, ov-ch-mat.h, ov-colon.cc, ov-colon.h, ov-complex.cc,
+ 	ov-complex.h, ov-cx-mat.cc, ov-cx-mat.h, ov-range.cc, ov-range.h,
+ 	ov-re-mat.cc, ov-re-mat.h, ov-scalar.cc, ov-scalar.h, ov-str-mat.cc,
+	ov-str-mat.h, ov-struct.cc, ov-struct.h, ov-typeinfo.cc,
+ 	ov-typeinfo.h, ov-va-args.cc, ov-va-args.h, ov.cc, ov.h:
+ 	New files for Octave's new type system.
+	* Makefile.in: Add them to the appropriate lists.
+
+Sat Sep 14 21:58:33 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* mkbuiltins: Use .df instead of .def.
+	Write one function for each .df file, then call them
+	all in install_builtin_functions().
+	* Makefile.in: Handle .df instead of .def.
+
+	* balance.cc (balance): Fix typo in doc string.
+
+Wed Aug 28 21:01:49 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* octave.cc (verbose_usage): Include WWW address and bug-octave
+	mailing list address.
+
 Tue Aug 20 17:41:19 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in: Only define pattern rules for making .oct files if
 	OCTAVE_LITE is true.
 	Only add pic/ to $(TI_OBJ) if $(SHARED_LIBS) is true.
 	(stamp-picdir): Only create a pic subdirectory if SHARED_LIBS or
 	OCTAVE_LITE is true AND CPICFLAG or CXXPICFLAG is not empty.
 
diff --git a/src/pt-fvc.cc b/src/pt-fvc.cc
--- a/src/pt-fvc.cc
+++ b/src/pt-fvc.cc
@@ -31,16 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include <iostream.h>
 #include <strstream.h>
 
 #include <SLList.h>
 
 #include "dynamic-ld.h"
 #include "error.h"
 #include "gripes.h"
+#include "oct-map.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "symtab.h"
 #include "pt-const.h"
 #include "pt-fvc.h"
 #include "pt-walk.h"
 #include "utils.h"
 
@@ -97,17 +98,17 @@ tree_identifier::name (void) const
 {
   string retval;
   if (sym)
     retval = sym->name ();
   return retval;
 }
 
 tree_identifier *
-tree_identifier::define (octave_value *t)
+tree_identifier::define (tree_constant *t)
 {
   int status = sym->define (t);
   return status ? this : 0;
 }
 
 tree_identifier *
 tree_identifier::define (tree_function *t)
 {
@@ -118,17 +119,17 @@ tree_identifier::define (tree_function *
 void
 tree_identifier::document (const string& s)
 {
   if (sym)
     sym->document (s);
 }
 
 octave_value
-tree_identifier::assign (octave_value& rhs)
+tree_identifier::assign (const octave_value& rhs)
 {
   octave_value retval;
 
   if (rhs.is_defined ())
     {
       if (! sym->is_defined ())
 	{
 	  if (! (sym->is_formal_parameter ()
@@ -137,29 +138,30 @@ tree_identifier::assign (octave_value& r
 	      link_to_builtin_variable (sym);
 	    }
 	}
       else if (sym->is_function ())
 	{
 	  sym->clear ();
 	}
 
-      octave_value *tmp = new octave_value (rhs);
+      tree_constant *tmp = new tree_constant (rhs);
 
       if (sym->define (tmp))
 	retval = rhs;
       else
 	delete tmp;
     }
 
   return retval;
 }
 
 octave_value
-tree_identifier::assign (octave_value& rhs, const octave_value_list& args)
+tree_identifier::assign (const octave_value_list& args,
+			 const octave_value& rhs)
 {
   octave_value retval;
 
   if (rhs.is_defined ())
     {
       if (! sym->is_defined ())
 	{
 	  if (! (sym->is_formal_parameter ()
@@ -170,141 +172,162 @@ tree_identifier::assign (octave_value& r
 	}
       else if (sym->is_function ())
 	{
 	  sym->clear ();
 	}
 
       if (sym->is_variable () && sym->is_defined ())
 	{
-	  tree_fvc *tmp = sym->def ();
-	  retval = tmp->assign (rhs, args);
+	  tree_constant *tmp = (tree_constant *) sym->def ();
+	  retval = tmp->assign (args, rhs);
 	}
       else
 	{
 	  assert (! sym->is_defined ());
 
 	  if (! Vresize_on_range_error)
 	    {
 	      ::error ("indexed assignment to previously undefined variables");
 	      ::error ("is only possible when resize_on_range_error is true");
 	    }
 	  else
 	    {
-	      octave_value *tmp = new octave_value ();
-	      retval = tmp->assign (rhs, args);
+	      tree_constant *tmp = new tree_constant ();
+	      retval = tmp->assign (args, rhs);
 	      if (retval.is_defined ())
 		sym->define (tmp);
 	    }
 	}
     }
 
   return retval;
 }
 
+#if 0
 octave_value
-tree_identifier::assign (SLList<string> list, octave_value& rhs)
+tree_identifier::assign (SLList<string> list, const octave_value& rhs)
 {
   octave_value retval;
 
   if (rhs.is_defined ())
     {
       if (sym->is_function ())
 	sym->clear ();
 
       tree_fvc *curr_val = sym->def ();
 
-      octave_value *tmp = 0;
+      tree_constant *tmp = 0;
       if (curr_val && curr_val->is_constant ())
-	tmp = (octave_value *) curr_val;
+	tmp = (tree_constant *) curr_val;
       else
 	{
-	  tmp = new octave_value ();
+	  tmp = new tree_constant ();
 	  if (! sym->define (tmp))
 	    {
 	      delete tmp;
 	      tmp = 0;
 	    }
 	}
 
       if (tmp)
 	retval = tmp->assign_map_element (list, rhs);
     }
 
   return retval;
 }
 
 octave_value
-tree_identifier::assign (SLList<string> list, octave_value& rhs,
-			 const octave_value_list& args)
+tree_identifier::assign (SLList<string> list, const octave_value_list& args,
+			 const octave_value& rhs)
 {
   octave_value retval;
 
   if (rhs.is_defined ())
     {
       if (sym->is_function ())
 	sym->clear ();
 
       if (sym->is_variable () && sym->is_defined ())
 	{
 	  tree_fvc *curr_val = sym->def ();
 
-	  octave_value *tmp;
+	  tree_constant *tmp;
 	  if (curr_val && curr_val->is_constant ())
-	    tmp = (octave_value *) curr_val;
+	    tmp = (tree_constant *) curr_val;
 	  else
 	    panic_impossible ();
 
-	  retval = tmp->assign_map_element (list, rhs, args);
+	  retval = tmp->assign_map_element (list, args, rhs);
 	}
       else
 	{
 	  assert (! sym->is_defined ());
 
 	  if (! Vresize_on_range_error)
 	    {
 	      ::error ("indexed assignment to previously undefined variables");
 	      ::error ("is only possible when resize_on_range_error is true");
 	    }
 	  else
 	    {
-	      octave_value *tmp = new octave_value ();
+	      tree_constant *tmp = new tree_constant ();
 
-	      retval = tmp->assign_map_element (list, rhs, args);
+	      retval = tmp->assign_map_element (list, args, rhs);
 
 	      if (retval.is_defined ())
 		sym->define (tmp);
 	    }
 	}
     }
 
   return retval;
 }
+#endif
 
 bool
 tree_identifier::is_defined (void)
 {
   return (sym && sym->is_defined ());
 }
 
 void
-tree_identifier::bump_value (tree_expression::type etype)
+tree_identifier::increment (void)
 {
   if (sym)
     {
       if (sym->is_read_only ())
 	{
 	  ::error ("can't redefined read-only variable `%s'",
 		   name ().c_str ());
 	}
       else
 	{
 	  tree_fvc *tmp = sym->def ();
 	  if (tmp)
-	    tmp->bump_value (etype);
+	    tmp->increment ();
+	}
+    }
+}
+
+void
+tree_identifier::decrement (void)
+{
+  if (sym)
+    {
+      if (sym->is_read_only ())
+	{
+	  ::error ("can't redefined read-only variable `%s'",
+		   name ().c_str ());
+	}
+      else
+	{
+	  tree_fvc *tmp = sym->def ();
+	  if (tmp)
+	    tmp->decrement ();
 	}
     }
 }
 
 void
 tree_identifier::eval_undefined_error (void)
 {
   int l = line ();
@@ -443,155 +466,210 @@ tree_identifier::eval (bool print, int n
 }
 
 void
 tree_identifier::accept (tree_walker& tw)
 {
   tw.visit_identifier (*this);
 }
 
+octave_value
+tree_identifier::value (void) const
+{
+  return sym->variable_value ();
+}
+
+octave_value&
+tree_identifier::reference (void)
+{
+  return sym->variable_reference ();
+}
+
 // Indirect references to values (structure elements).
 
 tree_indirect_ref::~tree_indirect_ref (void)
 {
   if (! preserve_ident)
     delete id;
-}
 
-tree_indirect_ref *
-tree_indirect_ref::chain (const string& elt)
-{
-  refs.append (elt);
-  return this;
+  if (! preserve_indir)
+    delete indir;
 }
 
 string
 tree_indirect_ref::name (void) const
 {
-  string id_nm = id->name ();
+  string retval;
 
-  if (refs.empty ())
-    return id_nm;
+  if (is_identifier_only ())
+    retval = id->name ();
   else
     {
-      for (Pix p = refs.first (); p != 0; refs.next (p))
-	{
-	  id_nm.append (".");
-	  id_nm.append (refs (p));
-	}
+      if (id)
+	retval = id->name ();
+      else if (indir)
+	retval = indir->name ();
+      else
+	panic_impossible ();
 
-      return id_nm;
+      retval.append (".");
+      retval.append (nm);
     }
+	
+  return retval;
+}
+
+#if 0
+octave_value
+tree_indirect_ref::assign (const octave_value& t)
+{
+  octave_value& tmp = reference ();
+
+  return tmp = t;
 }
 
 octave_value
-tree_indirect_ref::assign (octave_value& t)
+tree_indirect_ref::assign (const octave_value_list& args,
+			   const octave_value& t)
 {
-  octave_value retval;
-
-  if (refs.empty ())
-    retval = id->assign (t);
-  else
-    retval = id->assign (refs, t);
-
-  return retval;
-}
+  octave_value& tmp = reference ();
 
-octave_value
-tree_indirect_ref::assign (octave_value& t, const octave_value_list& args)
-{
-  octave_value retval;
-
-  if (refs.empty ())
-    retval = id->assign (t, args);
-  else
-    retval = id->assign (refs, t, args);
-
-  return retval;
+  return tmp.assign (args, t);
 }
+#endif
 
 octave_value
 tree_indirect_ref::eval (bool print)
 {
   octave_value retval;
 
-  if (error_state)
-    return retval;
-
-  if (refs.empty ())
-    {
-      retval = id->eval (print);
-    }
+  if (is_identifier_only ())
+    retval = id->eval (print);
   else
     {
-      bool script_file_executed;
-
-      tree_fvc *object_to_eval = id->do_lookup (script_file_executed, 0);
+      retval = value ();
 
-      if (object_to_eval)
+      if (! error_state && retval.is_defined ())
 	{
-	  retval = object_to_eval->lookup_map_element (refs);
-
-	  if (! error_state && print)
+	  if (maybe_do_ans_assign)
+	    bind_ans (retval, print);
+	  else if (print)
 	    retval.print_with_name (name ());
 	}
-      else
-	id->eval_undefined_error ();
     }
 
   return retval;
 }
 
 octave_value_list
-tree_indirect_ref::eval (bool print, int nargout, const octave_value_list& args)
+tree_indirect_ref::eval (bool print, int nargout,
+			 const octave_value_list& args)
 {
   octave_value_list retval;
 
-  if (error_state)
-    return retval;
-
-  if (refs.empty ())
-    {
-      retval = id->eval (print, nargout, args);
-    }
+  if (is_identifier_only ())
+    retval = id->eval (print, nargout, args);
   else
     {
-      bool script_file_executed;
-
-      tree_fvc *object_to_eval = id->do_lookup (script_file_executed, 0);
+      octave_value tmp = value ();
 
-      if (object_to_eval)
+      if (! error_state && tmp.is_defined ())
 	{
-	  octave_value tmp = object_to_eval->lookup_map_element (refs);
+	  retval = tmp.index (args);
 
 	  if (! error_state)
 	    {
-	      retval = tmp.eval (0, nargout, args);
-
-	      if (! error_state && print)
-		{
-		  tmp = retval (0);
-		  if (tmp.is_defined ())
-		    tmp.print_with_name (name ());
-		}
+	      if (maybe_do_ans_assign && nargout == 1
+		  && retval.length () > 0 && retval(0).is_defined ())
+		bind_ans (retval(0), print);
 	    }
 	}
-      else
-	id->eval_undefined_error ();
     }
 
   return retval;
 }
 
 void
 tree_indirect_ref::accept (tree_walker& tw)
 {
   tw.visit_indirect_ref (*this);
 }
 
+octave_value
+tree_indirect_ref::value (void) const
+{
+  octave_value retval;
+
+  if (is_identifier_only ())
+    retval = id->value ();
+  else
+    {
+      if (id)
+	retval = id->value ();
+      else if (indir)
+	retval = indir->value ();
+      else
+	panic_impossible ();
+
+      if (! error_state)
+	retval = retval.struct_elt_val (nm);
+    }
+
+  return retval;
+}
+
+octave_value&
+tree_indirect_ref::reference (void)
+{
+  if (is_identifier_only ())
+    return id->reference ();
+  else
+    {
+      if (id)
+	{
+	  octave_value& tmp = id->reference ();
+	  if (tmp.is_undefined ())
+	    tmp = Octave_map ();
+	  return tmp.struct_elt_ref (nm);
+	}
+      else if (indir)
+	{
+	  octave_value& tmp = indir->reference ();
+	  if (tmp.is_undefined ())
+	    tmp = Octave_map ();
+	  return tmp.struct_elt_ref (nm);
+	}
+      else
+	{
+	  static octave_value foo;
+	  panic_impossible ();
+	  return foo;
+	}
+    }
+}
+
+#if 0
+ if (indir)
+    {
+      octave_value& retval = indir->reference ();
+
+      if (! error_state)
+	retval = retval.map_elt_reference (nm);
+
+      return retval;
+    }
+  else
+    {
+      static octave_value foo;
+      panic_impossible ();
+      return foo;
+    }
+}
+#endif
+
 // Builtin functions.
 
 tree_builtin::tree_builtin (const string& nm)
 {
   is_mapper = 0;
   fcn = 0;
   my_name = nm;
 }
diff --git a/src/pt-fvc.h b/src/pt-fvc.h
--- a/src/pt-fvc.h
+++ b/src/pt-fvc.h
@@ -27,16 +27,17 @@ Software Foundation, 59 Temple Place - S
 #pragma interface
 #endif
 
 class ostream;
 
 #include <SLList.h>
 
 class symbol_record;
+class tree_constant;
 class tree_function;
 
 class tree_walker;
 
 #include "mappers.h"
 #include "pt-fvc-base.h"
 #include "variables.h"
 
@@ -57,31 +58,35 @@ public:
 
   ~tree_identifier (void) { }
 
   bool is_identifier (void) const
     { return true; }
 
   string name (void) const;
 
-  tree_identifier *define (octave_value *t);
+  tree_identifier *define (tree_constant *t);
   tree_identifier *define (tree_function *t);
 
   void document (const string& s);
 
-  octave_value assign (octave_value& t);
-  octave_value assign (octave_value& t, const octave_value_list& args);
+  octave_value assign (const octave_value& t);
+  octave_value assign (const octave_value_list& args, const octave_value& t);
 
-  octave_value assign (SLList<string> list, octave_value& t);
-  octave_value assign (SLList<string> list, octave_value& t,
-			const octave_value_list& args); 
+#if 0
+  octave_value assign (SLList<string> list, const octave_value& t);
+  octave_value assign (SLList<string> list, const octave_value_list& args,
+		       const octave_value& t);
+#endif
 
   bool is_defined (void);
 
-  void bump_value (tree_expression::type);
+  void increment (void);
+
+  void decrement (void);
 
   tree_fvc *do_lookup (bool& script_file_executed, bool exec_script = true);
 
   void link_to_global (void);
 
   void mark_as_formal_parameter (void);
 
   void mark_for_possible_ans_assign (void)
@@ -90,16 +95,20 @@ public:
   octave_value eval (bool print);
 
   octave_value_list eval (bool print, int nargout, const octave_value_list& args);
 
   void eval_undefined_error (void);
 
   void accept (tree_walker& tw);
 
+  octave_value value (void) const;
+
+  octave_value& reference (void);
+
 private:
 
   // The symbol record that this identifier references.
   symbol_record *sym;
 
   // True if we should consider assigning the result of evaluating
   // this identifier to the built-in variable ans.
   bool maybe_do_ans_assign;
@@ -108,66 +117,100 @@ private:
 // Indirect references to values (structure references).
 
 class
 tree_indirect_ref : public tree_fvc
 {
 public:
 
   tree_indirect_ref (int l = -1, int c = -1)
-    : tree_fvc (l, c), id (0), preserve_ident (false) { }
+    : tree_fvc (l, c), id (0), indir (0), nm (),
+      preserve_ident (false), preserve_indir (false),
+      maybe_do_ans_assign (false) { }
 
   tree_indirect_ref (tree_identifier *i, int l = -1, int c = -1)
-    : tree_fvc (l, c), id (i), preserve_ident (false) { }
+    : tree_fvc (l, c), id (i), indir (0), nm (),
+      preserve_ident (false), preserve_indir (false),
+      maybe_do_ans_assign (false) { }
+
+  tree_indirect_ref (tree_indirect_ref *i, const string& n,
+		     int l = -1, int c = -1)
+    : tree_fvc (l, c), id (0), indir (i), nm (n),
+      preserve_ident (false), preserve_indir (false),
+      maybe_do_ans_assign (false) { }
 
   ~tree_indirect_ref (void);
 
-  tree_indirect_ref *chain (const string& s);
-
   bool is_indirect_ref (void) const
     { return true; }
 
   bool is_identifier_only (void) const
-    { return (id && refs.empty ()); }
+    { return (id && nm.empty ()); }
 
   tree_identifier *ident (void)
     { return id; }
 
+  tree_indirect_ref *indirect (void)
+    { return indir; }
+
   void preserve_identifier (void)
     { preserve_ident = true; }
 
+  void preserve_indirect (void)
+    { preserve_indir = true; }
+
+  void mark_for_possible_ans_assign (void)
+    {
+      maybe_do_ans_assign = true;
+
+      if (is_identifier_only ())
+	id->mark_for_possible_ans_assign ();
+    }
+
   string name (void) const;
 
-  octave_value assign (octave_value& t);
-  octave_value assign (octave_value& t, const octave_value_list& args);
-
-  void mark_for_possible_ans_assign (void)
-    { id->mark_for_possible_ans_assign (); }
+#if 0
+  octave_value& assign (const octave_value& t);
+  octave_value& assign (const octave_value_list& args, const octave_value& t);
+#endif
 
   octave_value eval (bool print);
 
   octave_value_list eval (bool print, int nargout,
 			  const octave_value_list& args);
 
-  SLList<string> references (void) { return refs; }
+  octave_value value (void) const;
+  octave_value& reference (void);
+
+  string elt_name (void)
+    { return nm; }
 
   void accept (tree_walker& tw);
 
 private:
 
   // The identifier for this structure reference.  For example, in
-  // a.b, a is the id.
+  // a.b.c, a is the id.
   tree_identifier *id;
 
-  // The list of sub-element names.  For example, in a.b.c, refs
-  // contains the strings b and c.
-  SLList<string> refs;
+  // This element just points to another indirect reference.
+  tree_indirect_ref *indir;
+
+  // The sub-element name.
+  string nm;
 
   // True if we should not delete the identifier.
   bool preserve_ident;
+
+  // True if we should not delete the indirect reference.
+  bool preserve_indir;
+
+  // True if we should consider assigning the result of evaluating
+  // this identifier to the built-in variable ans.
+  bool maybe_do_ans_assign;
 };
 
 // Builtin functions.
 
 class
 tree_builtin : public tree_fvc
 {
 public:
