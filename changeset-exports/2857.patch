# HG changeset patch
# User jwe
# Date 859791980 0
#      Mon Mar 31 07:06:20 1997 +0000
# Node ID 5448c8cba4023000cea98762d165c024db394998
# Parent  8c516da3c1f75aeef57e09413d5d6083266fab3d
[project @ 1997-03-31 07:06:10 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,12 +1,14 @@
 Mon Mar 31 00:37:48 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* symtab.h, symtab.cc: Use bool instead of int in more places.
 	* variables.h, variables.cc: Likewise.
+	* lex.h, lex.l: Likewise.
+	* parse.y: Likewise.
 	* help.cc, input.cc, lex.l, load-save.cc, parse.y, pt-fcn.cc:
 	Change callers of symbol_table::lookup to use bool instead of int,
 	and to make use of default arguments.
 
 Fri Mar 28 15:33:11 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* parse.y (Vwarn_comma_in_declaration): Delete.
 	(symbols_of_parse): Delete DEFVAR for warn_comma_in_declaration.
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_lex_h)
 #define octave_lex_h 1
 
 // Arrange to get input via readline.
 
 #ifdef YY_INPUT
 #undef YY_INPUT
 #endif
-#define YY_INPUT(buf,result,max_size) \
+#define YY_INPUT(buf, result, max_size) \
   if ((result = octave_read (buf, max_size)) < 0) \
     YY_FATAL_ERROR ("octave_read () in flex scanner failed");
 
 // Try to avoid crashing out completely on fatal scanner errors.
 
 #ifdef YY_FATAL_ERROR
 #undef YY_FATAL_ERROR
 #endif
@@ -44,41 +44,41 @@ Software Foundation, 59 Temple Place - S
       jump_to_top_level (); \
     } \
   while (0)
 
 #define TOK_RETURN(tok) \
   do \
     { \
       current_input_column += yyleng; \
-      lexer_flags.quote_is_transpose = 0; \
-      lexer_flags.cant_be_identifier = 0; \
-      lexer_flags.convert_spaces_to_comma = 1; \
+      lexer_flags.quote_is_transpose = false; \
+      lexer_flags.cant_be_identifier = false; \
+      lexer_flags.convert_spaces_to_comma = true; \
       return (tok); \
     } \
   while (0)
 
-#define TOK_PUSH_AND_RETURN(name,tok) \
+#define TOK_PUSH_AND_RETURN(name, tok) \
   do \
     { \
       yylval.tok_val = new token (name, input_line_number, \
 				  current_input_column); \
       token_stack.push (yylval.tok_val); \
       TOK_RETURN (tok); \
     } \
   while (0)
 
-#define BIN_OP_RETURN(tok,convert) \
+#define BIN_OP_RETURN(tok, convert) \
   do \
     { \
       yylval.tok_val = new token (input_line_number, current_input_column); \
       token_stack.push (yylval.tok_val); \
       current_input_column += yyleng; \
-      lexer_flags.quote_is_transpose = 0; \
-      lexer_flags.cant_be_identifier = 0; \
+      lexer_flags.quote_is_transpose = false; \
+      lexer_flags.cant_be_identifier = true; \
       lexer_flags.convert_spaces_to_comma = convert; \
       return (tok); \
     } \
   while (0)
 
 // XXX FIXME XXX -- these input buffer things should be members of an
 // parser input stream class.
 
@@ -114,79 +114,79 @@ class lexical_feedback
 public:
 
   lexical_feedback (void) { init (); }
 
   ~lexical_feedback (void) { }
 
   void init (void);
 
-  // Nonzero means we think we are looking at the beginning of a
-  // function definition.
-  int beginning_of_function;
-
   // Brace level count.
   int braceflag;
 
-  // Another context hack, this time for the plot command's `using',
-  // `title', and `with' keywords.
-  int cant_be_identifier;
-
-  // Nonzero means that we should convert spaces to a comma inside a
-  // matrix definition.
-  int convert_spaces_to_comma;
-
-  // Nonzero means we're in the middle of defining a function.
-  int defining_func;
-
-  // Nonzero means we're parsing the return list for a function.
-  int looking_at_return_list;
-
-  // Nonzero means we're parsing the parameter list for a function.
-  int looking_at_parameter_list;
-
-  // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
-  int do_comma_insert;
-
-  // Nonzero means we think we are looking at a set command.
-  int doing_set;
-
-  // Nonzero means we're looking at the range part of a plot command.
-  int in_plot_range;
-
-  // Nonzero means we're looking at the using part of a plot command.
-  int in_plot_using;
-
-  // Nonzero means we're looking at the style part of a plot command.
-  int in_plot_style;
-
-  // Nonzero means we're looking at an indirect reference to a
-  // structure element.
-  int looking_at_indirect_ref;
-
   // Nonzero means we're in the middle of defining a loop.
   int looping;
 
+  // Nonzero means we think we are looking at the beginning of a
+  // function definition.
+  bool beginning_of_function;
+
+  // Another context hack, this time for the plot command's `using',
+  // `title', and `with' keywords.
+  bool cant_be_identifier;
+
+  // Nonzero means that we should convert spaces to a comma inside a
+  // matrix definition.
+  bool convert_spaces_to_comma;
+
+  // Nonzero means we're in the middle of defining a function.
+  bool defining_func;
+
+  // Nonzero means we're parsing the return list for a function.
+  bool looking_at_return_list;
+
+  // Nonzero means we're parsing the parameter list for a function.
+  bool looking_at_parameter_list;
+
+  // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
+  bool do_comma_insert;
+
+  // Nonzero means we think we are looking at a set command.
+  bool doing_set;
+
+  // Nonzero means we're looking at the range part of a plot command.
+  bool in_plot_range;
+
+  // Nonzero means we're looking at the using part of a plot command.
+  bool in_plot_using;
+
+  // Nonzero means we're looking at the style part of a plot command.
+  bool in_plot_style;
+
+  // Nonzero means we're looking at an indirect reference to a
+  // structure element.
+  bool looking_at_indirect_ref;
+
   // Nonzero means we need to do some extra lookahead to avoid being
   // screwed by bogus function syntax.
-  int maybe_screwed;
+  bool maybe_screwed;
 
   // Nonzero means we need to do some extra lookahead to avoid being
   // screwed by bogus function syntax.
   int maybe_screwed_again;
 
   // Nonzero means we've seen something that means we must be past the
   // range part of a plot command.
-  int past_plot_range;
+  bool past_plot_range;
 
   // Nonzero means we're working on a plot command.
-  int plotting;
+  bool plotting;
 
   // Return transpose or start a string?
-  int quote_is_transpose;
+  bool quote_is_transpose;
 
 private:
 
   lexical_feedback (const lexical_feedback&);
 
   lexical_feedback& operator = (const lexical_feedback&);
 };
 
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -169,26 +169,26 @@ static int Vwhitespace_in_literal_matrix
 static void do_string_escapes (char *s);
 static void fixup_column_count (char *s);
 static void do_comma_insert_check (void);
 static int is_plot_keyword (const string& s);
 static int is_keyword (const string& s);
 static string plot_style_token (const string& s);
 static symbol_record *lookup_identifier (const string& s);
 static void grab_help_text (void);
-static int match_any (char c, const char *s);
-static int next_token_is_bin_op (int spc_prev, char *yytext);
-static int next_token_is_postfix_unary_op (int spc_prev, char *yytext);
+static bool match_any (char c, const char *s);
+static bool next_token_is_bin_op (int spc_prev, char *yytext);
+static bool next_token_is_postfix_unary_op (int spc_prev, char *yytext);
 static string strip_trailing_whitespace (char *s);
 static void handle_number (char *yytext);
 static int handle_string (char delim, int text_style = 0);
 static int handle_close_brace (int spc_gobbled);
 static int handle_identifier (const string& tok, int spc_gobbled);
-static int have_continuation (int trailing_comments_ok = 1);
-static int have_ellipsis_continuation (int trailing_comments_ok = 1);
+static bool have_continuation (int trailing_comments_ok = 1);
+static bool have_ellipsis_continuation (int trailing_comments_ok = 1);
 static yum_yum eat_whitespace (void);
 static yum_yum eat_continuation (void);
 
 %}
 
 D	[0-9]
 S	[ \t]
 NL	((\n)|(\r\n))
@@ -213,19 +213,19 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 // Help and other text-style functions are a pain in the ass.  This
 // stuff needs to be simplified.  May require some changes in the
 // parser too.
 %}
 
 <TEXT_FCN>{NL} {
     BEGIN 0;
     current_input_column = 1;
-    lexer_flags.quote_is_transpose = 0;
-    lexer_flags.cant_be_identifier = 0;
-    lexer_flags.convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = false;
+    lexer_flags.cant_be_identifier = false;
+    lexer_flags.convert_spaces_to_comma = true;
     return '\n';
   }
 
 <TEXT_FCN>[\;\,] {
     if (lexer_flags.doing_set && strcmp (yytext, ",") == 0)
       {
 	TOK_PUSH_AND_RETURN (yytext, TEXT);
       }
@@ -273,19 +273,19 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
 %}
 
 <MATRIX>{S}*\,{S}* {
     current_input_column += yyleng;
     int tmp = eat_continuation ();
-    lexer_flags.quote_is_transpose = 0;
-    lexer_flags.cant_be_identifier = 0;
-    lexer_flags.convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = false;
+    lexer_flags.cant_be_identifier = false;
+    lexer_flags.convert_spaces_to_comma = true;
     if (Vwhitespace_in_literal_matrix != 2
 	&& (tmp & ATE_NEWLINE) == ATE_NEWLINE)
       unput (';');
     return (',');
   }
 
 %{
 // In some cases, spaces in matrix constants can turn into commas.
@@ -301,55 +301,55 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 	int tmp = eat_continuation ();
 	int bin_op = next_token_is_bin_op (1, yytext);
 	int postfix_un_op = next_token_is_postfix_unary_op (1, yytext);
 
 	if (! (postfix_un_op || bin_op)
 	    && nesting_level.is_brace ()
 	    && lexer_flags.convert_spaces_to_comma)
 	  {
-	    lexer_flags.quote_is_transpose = 0;
-	    lexer_flags.cant_be_identifier = 0;
-	    lexer_flags.convert_spaces_to_comma = 1;
+	    lexer_flags.quote_is_transpose = false;
+	    lexer_flags.cant_be_identifier = false;
+	    lexer_flags.convert_spaces_to_comma = true;
 	    if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
 	      unput (';');
 	    return (',');
 	  }
       }
   }
 
 %{
 // Semicolons are handled as row seprators in matrix constants.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 %}
 
 <MATRIX>{SNLCMT}*;{SNLCMT}* {
     fixup_column_count (yytext);
     eat_whitespace ();
-    lexer_flags.quote_is_transpose = 0;
-    lexer_flags.cant_be_identifier = 0;
-    lexer_flags.convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = false;
+    lexer_flags.cant_be_identifier = false;
+    lexer_flags.convert_spaces_to_comma = true;
     return ';';
   }
 
 %{
 // In some cases, new lines can also become row separators.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 %}
 
 <MATRIX>{SNLCMT}*\n{SNLCMT}* {
     fixup_column_count (yytext);
     eat_whitespace ();
     if (Vwhitespace_in_literal_matrix != 2)
       {
-	lexer_flags.quote_is_transpose = 0;
-	lexer_flags.cant_be_identifier = 0;
-	lexer_flags.convert_spaces_to_comma = 1;
+	lexer_flags.quote_is_transpose = false;
+	lexer_flags.cant_be_identifier = false;
+	lexer_flags.convert_spaces_to_comma = true;
 
 	if (nesting_level.none ())
 	  return LEXICAL_ERROR;
 
 	if (nesting_level.is_brace ())
 	  return ';';
       }
   }
@@ -359,42 +359,42 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 // part of a plot command.
 //
 %}
 
 \[{S}* {
     nesting_level.brace ();
 
     current_input_column += yyleng;
-    lexer_flags.quote_is_transpose = 0;
-    lexer_flags.cant_be_identifier = 0;
-    lexer_flags.convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = false;
+    lexer_flags.cant_be_identifier = false;
+    lexer_flags.convert_spaces_to_comma = true;
 
     promptflag--;
     eat_whitespace ();
 
     if (lexer_flags.plotting && ! lexer_flags.past_plot_range)
       {
-	lexer_flags.in_plot_range = 1;
+	lexer_flags.in_plot_range = true;
 	return OPEN_BRACE;
       }
     else
       {
 	lexer_flags.braceflag++;
 	BEGIN MATRIX;
 	return '[';
       }
   }
 
 \] {
     nesting_level.remove ();
 
     if (lexer_flags.plotting && ! lexer_flags.past_plot_range)
       {
-	lexer_flags.in_plot_range = 0;
+	lexer_flags.in_plot_range = false;
 	TOK_RETURN (CLOSE_BRACE);
       }
     else
       TOK_RETURN (']');
   }
 
 %{
 // Imaginary numbers.
@@ -468,35 +468,35 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
     current_input_column = 1;
-    lexer_flags.quote_is_transpose = 0;
-    lexer_flags.cant_be_identifier = 0;
-    lexer_flags.convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = false;
+    lexer_flags.cant_be_identifier = false;
+    lexer_flags.convert_spaces_to_comma = true;
 
     if (nesting_level.none ())
       return '\n';
 
     if (nesting_level.is_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator. 
 %}
 
 "'" {
     current_input_column++;
-    lexer_flags.convert_spaces_to_comma = 1;
+    lexer_flags.convert_spaces_to_comma = true;
 
     if (lexer_flags.quote_is_transpose)
       {
 	do_comma_insert_check ();
 	return QUOTE;
       }
     else
       return handle_string ('\'');
@@ -514,115 +514,115 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 %{
 // The colon operator is handled differently if we are in the range
 // part of a plot command.
 %}
 
 ":" {
     if (lexer_flags.plotting
 	&& (lexer_flags.in_plot_range || lexer_flags.in_plot_using))
-      BIN_OP_RETURN (COLON, 1);
+      BIN_OP_RETURN (COLON, true);
     else
-      BIN_OP_RETURN (':', 0);
+      BIN_OP_RETURN (':', false);
   }
 
 %{
 // Gobble comments.  If closest nesting is inside parentheses, don't
 // return a new line.
 %} 
 
 {CCHAR} {
     if (help_buf.empty ()
 	&& lexer_flags.beginning_of_function
 	&& nesting_level.none ())
       {
 	grab_help_text ();
-	lexer_flags.beginning_of_function = 0;
+	lexer_flags.beginning_of_function = false;
       }
     else
       {
 	int c;
 	while ((c = yyinput ()) != EOF && c != '\n')
 	  ; // Eat comment.
       }
 
     current_input_column = 1;
-    lexer_flags.quote_is_transpose = 0;
-    lexer_flags.cant_be_identifier = 0;
-    lexer_flags.convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = false;
+    lexer_flags.cant_be_identifier = false;
+    lexer_flags.convert_spaces_to_comma = true;
 
     if (nesting_level.none ())
       return '\n';
     else if (nesting_level.is_brace ())
       return ';';
   }
 
 %{
 // Other operators.
 %}
 
-".+"		{ BIN_OP_RETURN (EPLUS, 0); }
-".-"		{ BIN_OP_RETURN (EMINUS, 0); }
-".*"		{ BIN_OP_RETURN (EMUL, 0); }
-"./"		{ BIN_OP_RETURN (EDIV, 0); }
-".\\"		{ BIN_OP_RETURN (ELEFTDIV, 0); }
-{EPOW}		{ BIN_OP_RETURN (EPOW, 0); }
-".'"		{ do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, 1); }
-"++"		{ do_comma_insert_check (); BIN_OP_RETURN (PLUS_PLUS, 1); }
-"--"		{ do_comma_insert_check (); BIN_OP_RETURN (MINUS_MINUS, 1); }
-"<="		{ BIN_OP_RETURN (EXPR_LE, 0); }
-"=="		{ BIN_OP_RETURN (EXPR_EQ, 0); }
-{NOTEQ}		{ BIN_OP_RETURN (EXPR_NE, 0); }
-">="		{ BIN_OP_RETURN (EXPR_GE, 0); }
-"|"		{ BIN_OP_RETURN (EXPR_OR, 0); }
-"&"		{ BIN_OP_RETURN (EXPR_AND, 0); }
-"<"		{ BIN_OP_RETURN (EXPR_LT, 0); }
-">"		{ BIN_OP_RETURN (EXPR_GT, 0); }
-"*"		{ BIN_OP_RETURN ('*', 0); }
-"/"		{ BIN_OP_RETURN ('/', 0); }
-"\\"		{ BIN_OP_RETURN (LEFTDIV, 0); }
-";"		{ BIN_OP_RETURN (';', 1); }
-","		{ BIN_OP_RETURN (',', 1); }
-{POW}		{ BIN_OP_RETURN (POW, 0); }
-"="		{ BIN_OP_RETURN ('=', 1); }
-"||"		{ BIN_OP_RETURN (EXPR_OR_OR, 0); }
-"&&"		{ BIN_OP_RETURN (EXPR_AND_AND, 0); }
+".+"	{ BIN_OP_RETURN (EPLUS, false); }
+".-"	{ BIN_OP_RETURN (EMINUS, false); }
+".*"	{ BIN_OP_RETURN (EMUL, false); }
+"./"	{ BIN_OP_RETURN (EDIV, false); }
+".\\"	{ BIN_OP_RETURN (ELEFTDIV, false); }
+{EPOW}	{ BIN_OP_RETURN (EPOW, false); }
+".'"	{ do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true); }
+"++"	{ do_comma_insert_check (); BIN_OP_RETURN (PLUS_PLUS, true); }
+"--"	{ do_comma_insert_check (); BIN_OP_RETURN (MINUS_MINUS, true); }
+"<="	{ BIN_OP_RETURN (EXPR_LE, false); }
+"=="	{ BIN_OP_RETURN (EXPR_EQ, false); }
+{NOTEQ}	{ BIN_OP_RETURN (EXPR_NE, false); }
+">="	{ BIN_OP_RETURN (EXPR_GE, false); }
+"|"	{ BIN_OP_RETURN (EXPR_OR, false); }
+"&"	{ BIN_OP_RETURN (EXPR_AND, false); }
+"<"	{ BIN_OP_RETURN (EXPR_LT, false); }
+">"	{ BIN_OP_RETURN (EXPR_GT, false); }
+"*"	{ BIN_OP_RETURN ('*', false); }
+"/"	{ BIN_OP_RETURN ('/', false); }
+"\\"	{ BIN_OP_RETURN (LEFTDIV, false); }
+";"	{ BIN_OP_RETURN (';', true); }
+","	{ BIN_OP_RETURN (',', true); }
+{POW}	{ BIN_OP_RETURN (POW, false); }
+"="	{ BIN_OP_RETURN ('=', true); }
+"||"	{ BIN_OP_RETURN (EXPR_OR_OR, false); }
+"&&"	{ BIN_OP_RETURN (EXPR_AND_AND, false); }
 
 {NOT} {
     if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
-      lexer_flags.past_plot_range = 1;
-    BIN_OP_RETURN (EXPR_NOT, 0);
+      lexer_flags.past_plot_range = true;
+    BIN_OP_RETURN (EXPR_NOT, false);
   }
 
 "+" { 
     if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
-      lexer_flags.past_plot_range = 1;
-    BIN_OP_RETURN ('+', 0);
+      lexer_flags.past_plot_range = true;
+    BIN_OP_RETURN ('+', false);
   }
 
 "-" { 
     if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
-      lexer_flags.past_plot_range = 1;
-    BIN_OP_RETURN ('-', 0);
+      lexer_flags.past_plot_range = true;
+    BIN_OP_RETURN ('-', false);
   }
 
 "(" {
     if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
-      lexer_flags.past_plot_range = 1;
+      lexer_flags.past_plot_range = true;
     nesting_level.paren ();
     promptflag--;
     TOK_RETURN ('(');
   }
 
 ")" {
     nesting_level.remove ();
 
     current_input_column++;
-    lexer_flags.cant_be_identifier = 1;
-    lexer_flags.quote_is_transpose = 1;
+    lexer_flags.cant_be_identifier = true;
+    lexer_flags.quote_is_transpose = true;
     lexer_flags.convert_spaces_to_comma = nesting_level.is_brace ();
     do_comma_insert_check ();
     return ')';
   }
 
 "." {
     TOK_RETURN ('.');
   }
@@ -903,22 +903,22 @@ is_plot_keyword (const string& s)
 {
   const char *t = s.c_str ();
   if (almost_match ("title", t))
     {
       return TITLE;
     }
   else if (almost_match ("using", t))
     {
-      lexer_flags.in_plot_using = 1;
+      lexer_flags.in_plot_using = true;
       return USING;
     }
   else if (almost_match ("with", t))
     {
-      lexer_flags.in_plot_style = 1;
+      lexer_flags.in_plot_style = true;
       return WITH;
     }
   else if (strcmp ("clear", t) == 0)
     {
       return CLEAR;
     }
   else
     {
@@ -932,17 +932,17 @@ static int
 is_keyword (const string& s)
 {
   if (lexer_flags.plotting && lexer_flags.in_plot_style)
     {
       string sty = plot_style_token (s);
 
       if (! sty.empty ())
 	{
-	  lexer_flags.in_plot_style = 0;
+	  lexer_flags.in_plot_style = false;
 	  yylval.tok_val = new token (sty);
 	  token_stack.push (yylval.tok_val);
 	  return STYLE;
 	}
     }
 
   int l = input_line_number;
   int c = current_input_column;
@@ -1012,27 +1012,27 @@ is_keyword (const string& s)
 	case if_kw:
 	case try_kw:
 	case switch_kw:
 	case unwind_protect_kw:
 	  promptflag--;
 	  break;
 
 	case gplot_kw:
-	  lexer_flags.plotting = 1;
+	  lexer_flags.plotting = true;
 	  yylval.tok_val = new token (token::two_dee, l, c);
 	  break;
 
 	case gsplot_kw:
-	  lexer_flags.plotting = 1;
+	  lexer_flags.plotting = true;
 	  yylval.tok_val = new token (token::three_dee, l, c);
 	  break;
 
 	case replot_kw:
-	  lexer_flags.plotting = 1;
+	  lexer_flags.plotting = true;
 	  yylval.tok_val = new token (token::replot, l, c);
 	  break;
 
 	case function_kw:
 	  if (lexer_flags.defining_func)
 	    {
 	      error ("function keyword invalid within a function body");
 
@@ -1045,19 +1045,19 @@ is_keyword (const string& s)
 		       input_line_number);
 
 	      return LEXICAL_ERROR;
 	    }
 	  else
 	    {
 	      tmp_local_sym_tab = new symbol_table ();
 	      curr_sym_tab = tmp_local_sym_tab;
-	      lexer_flags.defining_func = 1;
+	      lexer_flags.defining_func = true;
 	      promptflag--;
-	      lexer_flags.beginning_of_function = 1;
+	      lexer_flags.beginning_of_function = true;
 	      if (! (reading_fcn_file || reading_script_file))
 		input_line_number = 1;
 	    }
 	  break;
 
 	default:
 	  panic_impossible ();
 	}
@@ -1155,47 +1155,47 @@ grab_help_text (void)
 
   if (c)
     yyunput (c, yytext);
 }
 
 // Return 1 if the given character matches any character in the given
 // string.
 
-static int
+static bool
 match_any (char c, const char *s)
 {
   char tmp;
   while ((tmp = *s++) != '\0')
     {
       if (c == tmp)
-	return 1;
+	return true;
     }
-  return 0;
+  return false;
 }
 
 // Given information about the spacing surrounding an operator,
 // return 1 if it looks like it should be treated as a binary
 // operator.  For example,
 //
 //   [ 1 + 2 ]  or  [ 1+ 2]  or  [ 1+2 ]  ==> binary
 
-static int
+static bool
 looks_like_bin_op (int spc_prev, int spc_next)
 {
   return ((spc_prev && spc_next) || ! spc_prev);
 }
 
 // Try to determine if the next token should be treated as a postfix
 // unary operator.  This is ugly, but it seems to do the right thing.
 
-static int
+static bool
 next_token_is_postfix_unary_op (int spc_prev, char *yytext)
 {
-  int un_op = 0;
+  bool un_op = false;
 
   int c0 = yyinput ();
   int c1 = yyinput ();
 
   yyunput (c1, yytext);
   yyunput (c0, yytext);
 
   int transpose = (c0 == '.' && c1 == '\'');
@@ -1222,20 +1222,20 @@ next_token_is_postfix_unary_op (int spc_
 // eliminating the whitespace, putting the expression in parentheses,
 // or using `whitespace_in_literal_matrix = "ignored"', so I think it
 // is an acceptable change.  It would be quite a bit harder to `fix'
 // this.  (Well, maybe not.  the best fix would be to do away with the
 // specialness of whitespace inside of `[ ... ]').
 //
 // However, we still do check for `.+', `.*', etc.
 
-static int
+static bool
 next_token_is_bin_op (int spc_prev, char *yytext)
 {
-  int bin_op = 0;
+  bool bin_op = false;
 
   int c0 = yyinput ();
 
   switch (c0)
     {
     case '+':
     case '-':
       {
@@ -1261,17 +1261,17 @@ next_token_is_bin_op (int spc_prev, char
     case '&':
     case '*':
     case '|':
     case '<':
     case '>':
     case '~':
     case '!':
     case '=':
-      bin_op = 1;
+      bin_op = true;
       break;
 
     default:
       break;
     }
 
   yyunput (c0, yytext);
 
@@ -1300,38 +1300,38 @@ strip_trailing_whitespace (char *s)
 //  ATE_NOTHING      : no spaces to eat
 //  ATE_SPACE_OR_TAB : space or tab in input
 //  ATE_NEWLINE      : bare new line in input
 
 static yum_yum
 eat_whitespace (void)
 {
   yum_yum retval = ATE_NOTHING;
-  int in_comment = 0;
+  bool in_comment = false;
   int c;
   while ((c = yyinput ()) != EOF)
     {
       current_input_column++;
 
       switch (c)
 	{
 	case ' ':
 	case '\t':
 	  retval |= ATE_SPACE_OR_TAB;
 	  break;
 
 	case '\n':
 	  retval |= ATE_NEWLINE;
-	  in_comment = 0;
+	  in_comment = false;
 	  current_input_column = 0;
 	  break;
 
 	case '#':
 	case '%':
-	  in_comment = 1;
+	  in_comment = true;
 	  break;
 
 	case '.':
 	  if (in_comment)
 	    break;
 	  else
 	    {
 	      if (have_ellipsis_continuation ())
@@ -1405,92 +1405,92 @@ handle_number (char *yytext)
 // treated as a continuation character.  If so, this eats it, up to
 // and including the new line character.
 //
 // Match whitespace only, followed by a comment character or newline.
 // Once a comment character is found, discard all input until newline.
 // If non-whitespace characters are found before comment
 // characters, return 0.  Otherwise, return 1.
 
-static int
+static bool
 have_continuation (int trailing_comments_ok)
 {
   ostrstream buf;
 
-  int in_comment = 0;
+  bool in_comment = false;
   char c;
   while ((c = yyinput ()) != EOF)
     {
       buf << (char) c;
 
       switch (c)
 	{
 	case ' ':
 	case '\t':
 	  break;
 
 	case '%':
 	case '#':
 	  if (trailing_comments_ok)
-	    in_comment = 1;
+	    in_comment = true;
 	  else
 	    goto cleanup;
 	  break;
 
 	case '\n':
 	  current_input_column = 0;
 	  promptflag--;
-	  return 1;
+	  return true;
 
 	default:
 	  if (! in_comment)
 	    goto cleanup;
 	  break;
 	}
     }
 
   yyunput (c, yytext);
-  return 0;
+  return false;
 
  cleanup:
   buf << ends;
   char *s = buf.str ();
   if (s)
     {
       int len = strlen (s);
       while (len--)
 	yyunput (s[len], yytext);
     }
   delete [] s;
-  return 0;
+  return false;
 }
 
 // We have seen a `.' and need to see if it is the start of a
 // continuation.  If so, this eats it, up to and including the new
 // line character.
 
-static int
+static bool
 have_ellipsis_continuation (int trailing_comments_ok)
 {
   char c1 = yyinput ();
   if (c1 == '.')
     {
       char c2 = yyinput ();
       if (c2 == '.' && have_continuation (trailing_comments_ok))
-	return 1;
+	return true;
       else
 	{
 	  yyunput (c2, yytext);
 	  yyunput (c1, yytext);
 	}
     }
   else
     yyunput (c1, yytext);
 
-  return 0;
+  return false;
 }
 
 // See if we have a continuation line.  If so, eat it and the leading
 // whitespace on the next line.
 //
 // Return value is the same as described for eat_whitespace().
 
 static yum_yum
@@ -1575,19 +1575,19 @@ handle_string (char delim, int text_styl
 			  strcpy (tok+1, tmp);
 			  tok[len-2] = delim;
 			  tok[len-1] = '\0';
 			  delete [] tmp;
 			}
 		    }
 		  else
 		    {
-		      lexer_flags.quote_is_transpose = 1;
-		      lexer_flags.cant_be_identifier = 1;
-		      lexer_flags.convert_spaces_to_comma = 1;
+		      lexer_flags.quote_is_transpose = true;
+		      lexer_flags.cant_be_identifier = true;
+		      lexer_flags.convert_spaces_to_comma = true;
 		    }
 
 		  yylval.tok_val = new token (tok);
 		  delete [] tok;
 		  token_stack.push (yylval.tok_val);
 		  return TEXT;
 		}
 	    }
@@ -1613,19 +1613,19 @@ handle_close_brace (int spc_gobbled)
     }
 
   if (lexer_flags.braceflag == 0)
     BEGIN 0;
 
   int c1 = yyinput ();
   if (c1 == '=')
     {
-      lexer_flags.quote_is_transpose = 0;
-      lexer_flags.cant_be_identifier = 0;
-      lexer_flags.convert_spaces_to_comma = 1;
+      lexer_flags.quote_is_transpose = false;
+      lexer_flags.cant_be_identifier = false;
+      lexer_flags.convert_spaces_to_comma = true;
 
       int c2 = yyinput ();
       unput (c2);
       unput (c1);
 
       if (c2 != '=' && lexer_flags.maybe_screwed_again)
 	return SCREW_TWO;
       else
@@ -1648,19 +1648,19 @@ handle_close_brace (int spc_gobbled)
 	      && lexer_flags.convert_spaces_to_comma)
 	    {
 	      unput (',');
 	      return ']';
 	    }
 	}
     }
 
-  lexer_flags.quote_is_transpose = 1;
-  lexer_flags.cant_be_identifier = 0;
-  lexer_flags.convert_spaces_to_comma = 1;
+  lexer_flags.quote_is_transpose = true;
+  lexer_flags.cant_be_identifier = false;
+  lexer_flags.convert_spaces_to_comma = true;
   return ']';
 }
 
 static void
 maybe_unput_comma (int spc_gobbled)
 {
   if (Vwhitespace_in_literal_matrix != 2
       && nesting_level.is_brace ())
@@ -1691,69 +1691,69 @@ maybe_unput_comma (int spc_gobbled)
 
 static int
 handle_identifier (const string& tok, int spc_gobbled)
 {
   // It is almost always an error for an identifier to be followed
   // directly by another identifier.  Special cases are handled
   // below.
 
-  lexer_flags.cant_be_identifier = 1;
+  lexer_flags.cant_be_identifier = true;
 
   // If we are expecting a structure element, we just want to return
   // TEXT_ID, which is a string that is also a valid identifier.  But
   // first, we have to decide whether to insert a comma.
 
   if (lexer_flags.looking_at_indirect_ref)
     {
       maybe_unput_comma (spc_gobbled);
 
       yylval.tok_val = new token (tok, input_line_number,
 				  current_input_column);
 
       token_stack.push (yylval.tok_val);
 
-      lexer_flags.cant_be_identifier = 0;
-      lexer_flags.quote_is_transpose = 1;
-      lexer_flags.convert_spaces_to_comma = 1;
+      lexer_flags.cant_be_identifier = false;
+      lexer_flags.quote_is_transpose = true;
+      lexer_flags.convert_spaces_to_comma = true;
 
       current_input_column += yyleng;
 
       return TEXT_ID;
     }
 
   // If we have a regular keyword, or a plot STYLE, return it.
   // Keywords can be followed by identifiers (TOK_RETURN handles
   // that).
 
   int kw_token = is_keyword (tok);
   if (kw_token)
     {
       if (kw_token == STYLE)
 	{
 	  current_input_column += yyleng;
-	  lexer_flags.quote_is_transpose = 0;
-	  lexer_flags.convert_spaces_to_comma = 1;
+	  lexer_flags.quote_is_transpose = false;
+	  lexer_flags.convert_spaces_to_comma = true;
 	  return kw_token;
 	}
       else
 	TOK_RETURN (kw_token);
     }
 
   // See if we have a plot keyword (title, using, with, or clear).
 
   if (lexer_flags.plotting)
     {
       // Yes, we really do need both of these plot_range variables.
       // One is used to mark when we are past all possiblity of a plot
       // range, the other is used to mark when we are actually between
       // the square brackets that surround the range.
 
       if (! lexer_flags.in_plot_range)
-	lexer_flags.past_plot_range = 1;
+	lexer_flags.past_plot_range = true;
 
       // Option keywords can't appear in parentheses or braces.
 
       int plot_option_kw = 0;
       if (nesting_level.none ())
 	plot_option_kw = is_plot_keyword (tok);
 
       if (lexer_flags.cant_be_identifier && plot_option_kw)
@@ -1787,34 +1787,34 @@ handle_identifier (const string& tok, in
 	  || lexer_flags.looking_at_return_list
 	  || lexer_flags.looking_at_parameter_list)
 	{
 	  force_local_variable (tok);
 	}
       else if (! next_tok_is_paren)
 	{
 	  if (tok == "gset")
-	    lexer_flags.doing_set = 1;
+	    lexer_flags.doing_set = true;
 
 	  BEGIN TEXT_FCN;
 	}
     }
 
   // Find the token in the symbol table.
 
   yylval.tok_val = new token (lookup_identifier (tok),
 			      input_line_number,
 			      current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
-  lexer_flags.convert_spaces_to_comma = 1;
+  lexer_flags.convert_spaces_to_comma = true;
 
   // If we are defining a function and we have not seen the parameter
   // list yet and the next token is `=', return a token that
   // represents the only return value for the function.  For example,
   //
   //   function SCREW = f (args);
   //
   // The variable maybe_screwed is reset in parse.y.
@@ -1829,17 +1829,17 @@ handle_identifier (const string& tok, in
     }
 
   // At this point, we are only dealing with identifiers that are not
   // followed by `=' (if the next token is `=', there is no need to
   // check to see if we should insert a comma (invalid syntax), or
   // allow a following `'' to be treated as a transpose (the next
   // token is `=', so it can't be `''.
 
-  lexer_flags.quote_is_transpose = 1;
+  lexer_flags.quote_is_transpose = true;
   do_comma_insert_check ();
 
   maybe_unput_comma (spc_gobbled);
 
   current_input_column += yyleng;
   return NAME;
 }
 
@@ -1849,37 +1849,37 @@ handle_identifier (const string& tok, in
 
 void
 check_for_garbage_after_fcn_def (void)
 {
   // By making a newline be the next character to be read, we will
   // force the parser to return after reading the function.  Calling
   // yyunput with EOF seems not to work...
 
-  int in_comment = 0;
+  bool in_comment = false;
   int lineno = input_line_number;
   int c;
   while ((c = yyinput ()) != EOF)
     {
       switch (c)
 	{
 	case ' ':
 	case '\t':
 	case ';':
 	case ',':
 	  break;
 
 	case '\n':
 	  if (in_comment)
-	    in_comment = 0;
+	    in_comment = false;
 	  break;
 
 	case '%':
 	case '#':
-	  in_comment = 1;
+	  in_comment = true;
 	  break;
 
 	default:
 	  if (in_comment)
 	    break;
 	  else
 	    {
 	      warning ("ignoring trailing garbage after end of function\n\
@@ -1891,55 +1891,55 @@ check_for_garbage_after_fcn_def (void)
 	}
     }
   yyunput ('\n', yytext);
 }
 
 void
 lexical_feedback::init (void)
 {
-  // Not initially defining a function.
-  beginning_of_function = 0;
-  defining_func = 0;
-
-  // Not parsing a function return or parameter list.
-  looking_at_return_list = 0;
-  looking_at_parameter_list = 0;
-
   // Not initially defining a matrix list.
   braceflag = 0;
 
-  // Next token can be identifier.
-  cant_be_identifier = 0;
-
-  // No need to do comma insert or convert spaces to comma at
-  // beginning of input. 
-  convert_spaces_to_comma = 1;
-  do_comma_insert = 0;
-
-  // Not initially doing any plotting or setting of plot attributes.
-  doing_set = 0;
-  in_plot_range = 0;
-  in_plot_style = 0;
-  in_plot_using = 0;
-  past_plot_range = 0;
-  plotting = 0;
-
   // Not initially inside a loop or if statement.
   looping = 0;
 
+  // Not initially defining a function.
+  beginning_of_function = false;
+  defining_func = false;
+
+  // Not parsing a function return or parameter list.
+  looking_at_return_list = false;
+  looking_at_parameter_list = false;
+
+  // Next token can be identifier.
+  cant_be_identifier = false;
+
+  // No need to do comma insert or convert spaces to comma at
+  // beginning of input. 
+  convert_spaces_to_comma = true;
+  do_comma_insert = false;
+
+  // Not initially doing any plotting or setting of plot attributes.
+  doing_set = false;
+  in_plot_range = false;
+  in_plot_style = false;
+  in_plot_using = false;
+  past_plot_range = false;
+  plotting = false;
+
   // Not initially looking at indirect references.
-  looking_at_indirect_ref = 0;
+  looking_at_indirect_ref = false;
 
   // Not initially screwed by `function [...] = f (...)' syntax.
-  maybe_screwed = 0;
+  maybe_screwed = false;
   maybe_screwed_again = 0;
 
   // Quote marks strings intially.
-  quote_is_transpose = 0;
+  quote_is_transpose = false;
 }
 
 int
 whitespace_in_literal_matrix (void)
 {
   int pref = 0;
   string val = builtin_string_variable ("whitespace_in_literal_matrix");
   if (! val.empty ())
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -102,17 +102,17 @@ string help_buf;
 // Generic error messages.
 static void yyerror (const char *s);
 
 // Error mesages for mismatched end tokens.
 static void end_error
 	(const char *type, token::end_tok_type ettype, int l, int c);
 
 // Check to see that end tokens are properly matched.
-static int check_end (token *tok, token::end_tok_type expected);
+static bool end_token_ok (token *tok, token::end_tok_type expected);
 
 // Try to figure out early if an expression should become an
 // assignment to the built-in variable ans.
 static tree_expression *maybe_convert_to_ans_assign (tree_expression *expr);
 
 // Maybe print a warning if an assignment expression is used as the
 // test in a logical expression.
 static void maybe_warn_assign_as_truth_value (tree_expression *expr);
@@ -452,17 +452,17 @@ list		: list1 opt_sep
 		  {
 		    set_stmt_print_flag ($1, $2, true);
 		    $$ = $1;
 		  }
 		;
 
 list1		: statement
 		  {
-		    lexer_flags.beginning_of_function = 0;
+		    lexer_flags.beginning_of_function = false;
 		    $$ = new tree_statement_list ($1);
 		  }
 		| list1 sep statement
 		  {
 		    set_stmt_print_flag ($1, $2, true);
 		    $1->append ($3);
 		    $$ = $1;
 		  }
@@ -558,22 +558,22 @@ plot_options	: using
 		| style using title	 
 		  { $$ = new subplot ($2, $3, $1); }
 		| style title using	 
 		  { $$ = new subplot ($3, $2, $1); }
 		;
 
 using		: using1
 		  {
-		    lexer_flags.in_plot_using = 0;
+		    lexer_flags.in_plot_using = false;
 		    $$ = $1;
 		  }
 		| using1 expression
 		  {
-		    lexer_flags.in_plot_using = 0;
+		    lexer_flags.in_plot_using = false;
 		    $$ = $1->set_format ($2);
 		  }
 		;
 
 using1		: USING expression
 		  {
 		    subplot_using *tmp = new subplot_using ();
 		    $$ = tmp->add_qualifier ($2);
@@ -895,74 +895,74 @@ word_list	: TEXT
 
 // This is truly disgusting.
 
 g_symtab	: // empty
 		  { curr_sym_tab = global_sym_tab; }
 		;
 
 in_return_list	: // empty
-		  { lexer_flags.looking_at_return_list = 1; }
+		  { lexer_flags.looking_at_return_list = true; }
 		;
 
 local_symtab	: // empty
 		  { curr_sym_tab = tmp_local_sym_tab; }
 		;
 
 safe		: // empty
-		  { lexer_flags.maybe_screwed = 0; }
+		  { lexer_flags.maybe_screwed = false; }
 		;
 
 are_we_screwed	: // empty
-		  { lexer_flags.maybe_screwed = 1; }
+		  { lexer_flags.maybe_screwed = true; }
 		;
 
 func_def	: FCN g_symtab are_we_screwed func_def1
 		  {
 		    curr_sym_tab = top_level_sym_tab;
-		    lexer_flags.defining_func = 0;
+		    lexer_flags.defining_func = false;
 		    $$ = 0;
 		  }
 		| FCN g_symtab are_we_screwed func_def2
 		  {
 		    curr_sym_tab = top_level_sym_tab;
-		    lexer_flags.defining_func = 0;
+		    lexer_flags.defining_func = false;
 		    $$ = 0;
 		  }
 		;
 
 func_def1	: SCREW safe g_symtab '=' func_def2
 		  { $$ = finish_function_def ($1, $5); }
 		| return_list g_symtab '=' func_def2
 		  { $$ = finish_function_def ($1, $4); }
 		;
 
 return_list_x	: '[' safe local_symtab in_return_list
 		;
 
 return_list	: return_list_x ']'
 		  {
-		    lexer_flags.looking_at_return_list = 0;
+		    lexer_flags.looking_at_return_list = false;
 		    $$ = new tree_parameter_list ();
 		  }
 		| return_list_x ELLIPSIS ']'
 		  {
-		    lexer_flags.looking_at_return_list = 0;
+		    lexer_flags.looking_at_return_list = false;
 		    tree_parameter_list *tmp = new tree_parameter_list ();
 		    tmp->mark_varargs_only ();
 		    $$ = tmp;
 		  }
 		| return_list1 ']'
 		  {
-		    lexer_flags.looking_at_return_list = 0;
+		    lexer_flags.looking_at_return_list = false;
 		    $$ = $1;
 		  }
 		| return_list1 ',' ELLIPSIS ']'
 		  {
-		    lexer_flags.looking_at_return_list = 0;
+		    lexer_flags.looking_at_return_list = false;
 		    $1->mark_varargs ();
 		    $$ = $1;
 		  }
 		;
 
 return_list1	: return_list_x identifier
 		  { $$ = new tree_parameter_list ($2); }
 		| return_list_x error
@@ -988,42 +988,44 @@ func_def2	: identifier safe local_symtab
 func_def3	: param_list opt_sep opt_list fcn_end_or_eof
 		  { $$ = start_function_def ($1, $3); }
 		| opt_sep opt_list fcn_end_or_eof
 		  { $$ = start_function_def (0, $2); }
 		;
 
 fcn_end_or_eof	: END
 		  {
-		    if (check_end ($1, token::function_end))
+		    if (end_token_ok ($1, token::function_end))
+		      {
+			if (reading_fcn_file)
+			  check_for_garbage_after_fcn_def ();
+		      }
+		    else
 		      ABORT_PARSE;
-
-		    if (reading_fcn_file)
-		      check_for_garbage_after_fcn_def ();
 		  }
 		| END_OF_INPUT
 		  {
 		    if (! (reading_fcn_file || reading_script_file))
 		      YYABORT;
 		  }
 		;
 
 indirect_ref	: indirect_ref1
 		  {
-		    lexer_flags.looking_at_indirect_ref = 0;
+		    lexer_flags.looking_at_indirect_ref = false;
 		    $$ = $1;
 		  }
 
 indirect_ref1	: identifier
 		  {
 		    $$ = new tree_indirect_ref ($1, $1->line (),
 						$1->column ());
 		  }
 		| indirect_ref1 '.'
-		    { lexer_flags.looking_at_indirect_ref = 1; } TEXT_ID
+		    { lexer_flags.looking_at_indirect_ref = true; } TEXT_ID
 		  { $$ = new tree_indirect_ref ($1, $4->text ()); }
 		;
 
 variable	: indirect_ref
 		  { $$ = make_index_expression ($1, 0); }
 		| indirect_ref '(' ')'
 		  { $$ = make_index_expression ($1, 0); }
 		| indirect_ref '(' arg_list ')'
@@ -1033,44 +1035,44 @@ variable	: indirect_ref
 		    yyerror ("use `(\' and `)\' as index operators, not\
  `[\' and `]\'"); 
 		    $$ = 0;
 		    ABORT_PARSE;
 		  }
 		;
 
 param_list_beg	: '('
-		  { lexer_flags.looking_at_parameter_list = 1; }
+		  { lexer_flags.looking_at_parameter_list = true; }
 		;
 
 param_list_end	: ')'
-		  { lexer_flags.looking_at_parameter_list = 0; }
+		  { lexer_flags.looking_at_parameter_list = false; }
 		;
 
 param_list	: param_list_beg param_list_end
 		  {
-		    lexer_flags.quote_is_transpose = 0;
+		    lexer_flags.quote_is_transpose = false;
 		    $$ = 0;
 		  }
 		| param_list_beg ELLIPSIS param_list_end
 		  {
-		    lexer_flags.quote_is_transpose = 0;
+		    lexer_flags.quote_is_transpose = false;
 		    tree_parameter_list *tmp = new tree_parameter_list ();
 		    tmp->mark_varargs_only ();
 		    $$ = tmp;
 		  }
 		| param_list1 param_list_end
 		  {
-		    lexer_flags.quote_is_transpose = 0;
+		    lexer_flags.quote_is_transpose = false;
 		    $1->mark_as_formal_parameters ();
 		    $$ = $1;
 		  }
 		| param_list1 ',' ELLIPSIS param_list_end
 		  {
-		    lexer_flags.quote_is_transpose = 0;
+		    lexer_flags.quote_is_transpose = false;
 		    $1->mark_as_formal_parameters ();
 		    $1->mark_varargs ();
 		    $$ = $1;
 		  }
 		;
 
 param_list1	: param_list_beg identifier
 		  { $$ = new tree_parameter_list ($2); }
@@ -1293,22 +1295,27 @@ end_error (const char *type, token::end_
     default:
       panic_impossible ();
       break;
     }
 }
 
 // Check to see that end tokens are properly matched.
 
-static int
-check_end (token *tok, token::end_tok_type expected)
+static bool
+end_token_ok (token *tok, token::end_tok_type expected)
 {
+  bool retval = true;
+
   token::end_tok_type ettype = tok->ettype ();
+
   if (ettype != expected && ettype != token::simple_end)
     {
+      retval = false;
+
       yyerror ("parse error");
 
       int l = tok->line ();
       int c = tok->column ();
 
       switch (expected)
 	{
 	case token::for_end:
@@ -1338,20 +1345,19 @@ check_end (token *tok, token::end_tok_ty
 	case token::while_end:
 	  end_error ("while", ettype, l, c);
 	  break;
 
 	default:
 	  panic_impossible ();
 	  break;
 	}
-      return 1;
     }
-  else
-    return 0;
+
+  return retval;
 }
 
 // Try to figure out early if an expression should become an
 // assignment to the built-in variable ans.
 //
 // Need to make sure that the expression is not already an identifier
 // that has a name, or an assignment expression.
 //
@@ -1427,21 +1433,21 @@ make_plot_command (token *tok, plot_limi
 	}
     }
   else if (! list && tok->pttype () != token::replot)
     {
       yyerror ("must have something to plot");
       return 0;
     }
 
-  lexer_flags.plotting = 0;
-  lexer_flags.past_plot_range = 0;
-  lexer_flags.in_plot_range = 0;
-  lexer_flags.in_plot_using = 0;
-  lexer_flags.in_plot_style = 0;
+  lexer_flags.plotting = false;
+  lexer_flags.past_plot_range = false;
+  lexer_flags.in_plot_range = false;
+  lexer_flags.in_plot_using = false;
+  lexer_flags.in_plot_style = false;
   
   return new tree_plot_command (list, range, tok->pttype ());
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = 0;
@@ -1838,17 +1844,17 @@ make_unary_op (int op, tree_expression *
 // Build an unwind-protect command.
 
 static tree_command *
 make_unwind_command (token *unwind_tok, tree_statement_list *body,
 		     tree_statement_list *cleanup, token *end_tok)
 {
   tree_command *retval = 0;
 
-  if (! check_end (end_tok, token::unwind_protect_end))
+  if (end_token_ok (end_tok, token::unwind_protect_end))
     {
       int l = unwind_tok->line ();
       int c = unwind_tok->column ();
 
       retval = new tree_unwind_protect_command (body, cleanup, l, c);
     }
 
   return retval;
@@ -1857,17 +1863,17 @@ make_unwind_command (token *unwind_tok, 
 // Build a try-catch command.
 
 static tree_command *
 make_try_command (token *try_tok, tree_statement_list *body,
 		  tree_statement_list *cleanup, token *end_tok)
 {
   tree_command *retval = 0;
 
-  if (! check_end (end_tok, token::try_catch_end))
+  if (end_token_ok (end_tok, token::try_catch_end))
     {
       int l = try_tok->line ();
       int c = try_tok->column ();
 
       retval = new tree_try_catch_command (body, cleanup, l, c);
     }
 
   return retval;
@@ -1878,17 +1884,17 @@ make_try_command (token *try_tok, tree_s
 static tree_command *
 make_while_command (token *while_tok, tree_expression *expr,
 		    tree_statement_list *body, token *end_tok)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
-  if (! check_end (end_tok, token::while_end))
+  if (end_token_ok (end_tok, token::while_end))
     {
       lexer_flags.looping--;
 
       int l = while_tok->line ();
       int c = while_tok->column ();
 
       retval = new tree_while_command (expr, body, l, c);
     }
@@ -1900,17 +1906,17 @@ make_while_command (token *while_tok, tr
 
 static tree_command *
 make_for_command (token *for_tok, tree_index_expression *var,
 		  tree_expression *expr, tree_statement_list *body,
 		  token *end_tok)
 {
   tree_command *retval = 0;
 
-  if (! check_end (end_tok, token::for_end))
+  if (end_token_ok (end_tok, token::for_end))
     {
       lexer_flags.looping--;
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
       retval = new tree_for_command (var, expr, body, l, c);
     }
@@ -1922,17 +1928,17 @@ make_for_command (token *for_tok, tree_i
 
 static tree_command *
 make_for_command (token *for_tok, tree_matrix_row *mr,
 		  tree_expression *expr, tree_statement_list *body,
 		  token *end_tok)
 {
   tree_command *retval = 0;
 
-  if (! check_end (end_tok, token::for_end))
+  if (end_token_ok (end_tok, token::for_end))
     {
       lexer_flags.looping--;
 
       tree_return_list *id_list = mr->to_return_list ();
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
@@ -2011,17 +2017,17 @@ start_if_command (tree_expression *expr,
 // Finish an if command.
 
 static tree_if_command *
 finish_if_command (token *if_tok, tree_if_command_list *list,
 		   token *end_tok)
 {
   tree_if_command *retval = 0;
 
-  if (! check_end (end_tok, token::if_end))
+  if (end_token_ok (end_tok, token::if_end))
     {
       int l = if_tok->line ();
       int c = if_tok->column ();
 
       retval = new tree_if_command (list, l, c);
     }
 
   return retval;
@@ -2040,17 +2046,17 @@ make_elseif_clause (tree_expression *exp
 // Finish a switch command.
 
 static tree_switch_command *
 finish_switch_command (token *switch_tok, tree_expression *expr,
 		       tree_switch_case_list *list, token *end_tok)
 {
   tree_switch_command *retval = 0;
 
-  if (! check_end (end_tok, token::switch_end))
+  if (end_token_ok (end_tok, token::switch_end))
     {
       int l = switch_tok->line ();
       int c = switch_tok->column ();
 
       retval = new tree_switch_command (expr, list, l, c);
     }
 
   return retval;
