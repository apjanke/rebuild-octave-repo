# HG changeset patch
# User Rik <rik@octave.org>
# Date 1459376352 25200
#      Wed Mar 30 15:19:12 2016 -0700
# Node ID 6c2fd62db1f70ed5edcf53ed6d59d51ee5f8460f
# Parent  4abcc0969ebd840e6a14cd89d3ad1eb8d086a05a
maint: Eliminate accidental double spaces in code.

* make_int.cc, file-editor-tab.h, file-editor.cc, shortcut-manager.h,
__contourc__.cc, cellfun.cc, debug.cc, errwarn.h, graphics.in.h, jit-ir.h,
oct-stream.cc, quadcc.cc, qz.cc, sparse-xdiv.cc, symtab.cc, __init_fltk__.cc,
ov-class.cc, ov-float.h, ov-scalar.h, op-int.h, CNDArray.cc, CSparse.cc,
MSparse.cc, Sparse.cc, boolNDArray.cc, chNDArray.cc, dNDArray.cc, dSparse.cc,
fCNDArray.cc, fNDArray.cc, int16NDArray.cc, int32NDArray.cc, int64NDArray.cc,
int8NDArray.cc, intNDArray.cc, uint16NDArray.cc, uint32NDArray.cc,
uint64NDArray.cc, uint8NDArray.cc, randgamma.h, randmtzig.h, randpoisson.c,
randpoisson.h, Sparse-op-defs.h, oct-time.cc, kpse.cc, lo-array-errwarn.h,
lo-ieee.h, del2.m, num2str.m, __isequal__.m, lookfor.m, hsv2rgb.m,
colorspace_conversion_revert.m, fminbnd.m, create_pkgadddel.m, shading.m,
struct2hdl.m, gallery.m, discrete_cdf.m, kolmogorov_smirnov_test.m, assert.m,
datestr.m, classes.tst, jit.tst:
Eliminate accidental double spaces in code.

diff --git a/examples/code/make_int.cc b/examples/code/make_int.cc
--- a/examples/code/make_int.cc
+++ b/examples/code/make_int.cc
@@ -83,17 +83,17 @@ public:
 
   int integer_value (bool = false) const { return scalar; }
 
   Matrix matrix_value (bool = false) const { return Matrix (1, 1, scalar); }
 
   Complex complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
-  { return  ComplexMatrix (1, 1, Complex (scalar)); }
+  { return ComplexMatrix (1, 1, Complex (scalar)); }
 
   octave_value gnot (void) const { return octave_value ((double) ! scalar); }
 
   octave_value uminus (void) const { return new octave_integer (- scalar); }
 
   octave_value transpose (void) const { return new octave_integer (scalar); }
 
   octave_value hermitian (void) const { return new octave_integer (scalar); }
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -142,37 +142,40 @@ public slots:
   void file_has_changed (const QString& fileName);
 
   void handle_context_menu_edit (const QString&);
   void handle_context_menu_break_condition (int linenr);
 
   void handle_request_add_breakpoint (int line, const QString& cond);
   void handle_request_remove_breakpoint (int line);
 
-  void handle_octave_result (QObject *requester, QString& command, octave_value_list &result);
+  void handle_octave_result (QObject *requester, QString& command,
+                             octave_value_list &result);
 
 signals:
 
   void file_name_changed (const QString& fileName, const QString& toolTip);
   void editor_state_changed (bool copy_available, bool is_octave_file);
   void tab_remove_request ();
   void add_filename_to_list (const QString&, const QString&, QWidget *);
   void mru_add_file (const QString& file_name, const QString& encoding);
   void editor_check_conflict_save (const QString& saveFileName,
                                    bool remove_on_success);
   void run_file_signal (const QFileInfo& info);
   void request_open_file (const QString&);
-  void  edit_mfile_request (const QString&, const QString&,
-                            const QString&, int);
+  void edit_mfile_request (const QString&, const QString&,
+                           const QString&, int);
 
   void remove_breakpoint_via_debugger_linenr (int debugger_linenr);
   void request_remove_breakpoint_via_editor_linenr (int editor_linenr);
   void remove_all_breakpoints (void);
-  void find_translated_line_number (int original_linenr, int& translated_linenr, marker*&);
-  void find_linenr_just_before (int linenr, int& original_linenr, int& editor_linenr);
+  void find_translated_line_number (int original_linenr,
+                                    int& translated_linenr, marker*&);
+  void find_linenr_just_before (int linenr, int& original_linenr,
+                                int& editor_linenr);
   void report_marker_linenr (QIntList& lines, QStringList& conditions);
   void remove_position_via_debugger_linenr (int debugger_linenr);
   void remove_all_positions (void);
   // TODO: The following is similar to "process_octave_code" signal.  However,
   // currently that signal is connected to something that simply focuses a
   // window and not actually communicate with Octave.
   // void evaluate_octave_command (const QString& command);
 
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -2187,17 +2187,17 @@ file_editor::set_shortcuts ()
   shortcut_manager::set_shortcut (_move_tab_left_action, "editor_tabs:move_tab_left");
   shortcut_manager::set_shortcut (_move_tab_right_action, "editor_tabs:move_tab_right");
 
 }
 
 void
 file_editor::check_actions ()
 {
-  bool  have_tabs = _tab_widget->count () > 0;
+  bool have_tabs = _tab_widget->count () > 0;
 
   _edit_cmd_menu->setEnabled (have_tabs);
   _edit_fmt_menu->setEnabled (have_tabs);
   _edit_nav_menu->setEnabled (have_tabs);
 
   _comment_selection_action->setEnabled (have_tabs);
   _uncomment_selection_action->setEnabled (have_tabs);
   _indent_selection_action->setEnabled (have_tabs);
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 class enter_shortcut : public QLineEdit
 {
   Q_OBJECT
 
 public:
   enter_shortcut (QWidget *p = 0);
   ~enter_shortcut ();
 
-  virtual void  keyPressEvent (QKeyEvent *e);
+  virtual void keyPressEvent (QKeyEvent *e);
 
 public slots:
   void handle_direct_shortcut (int);
 
 private:
   bool _direct_shortcut;
 
 };
diff --git a/libinterp/corefcn/__contourc__.cc b/libinterp/corefcn/__contourc__.cc
--- a/libinterp/corefcn/__contourc__.cc
+++ b/libinterp/corefcn/__contourc__.cc
@@ -6,18 +6,18 @@ Copyright (C) 2004, 2007 Shai Ayal
 Adapted to an oct file from the stand alone contourl by Victro Munoz
 Copyright (C) 2004 Victor Munoz
 
 Based on contour plot routine (plcont.c) in PLPlot package
 http://plplot.org/
 
 Copyright (C) 1995, 2000, 2001 Maurice LeBrun
 Copyright (C) 2000, 2002 Joao Cardoso
-Copyright (C) 2000, 2001, 2002, 2004  Alan W. Irwin
-Copyright (C) 2004  Andrew Ross
+Copyright (C) 2000, 2001, 2002, 2004 Alan W. Irwin
+Copyright (C) 2004 Andrew Ross
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -135,38 +135,38 @@ try_cellfun_internal_ops (const octave_v
       BNDA result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
         result(count) = f_args.elem (count).is_empty ();
       retval(0) = result;
     }
   else if (name == "islogical")
     {
       BNDA result (f_args.dims ());
-      for (octave_idx_type  count= 0; count < k; count++)
+      for (octave_idx_type count= 0; count < k; count++)
         result(count) = f_args.elem (count).is_bool_type ();
       retval(0) = result;
     }
   else if (name == "isnumeric")
     {
       BNDA result (f_args.dims ());
-      for (octave_idx_type  count= 0; count < k; count++)
+      for (octave_idx_type count= 0; count < k; count++)
         result(count) = f_args.elem (count).is_numeric_type ();
       retval(0) = result;
     }
   else if (name == "isreal")
     {
       BNDA result (f_args.dims ());
-      for (octave_idx_type  count= 0; count < k; count++)
+      for (octave_idx_type count= 0; count < k; count++)
         result(count) = f_args.elem (count).is_real_type ();
       retval(0) = result;
     }
   else if (name == "length")
     {
       NDA result (f_args.dims ());
-      for (octave_idx_type  count= 0; count < k; count++)
+      for (octave_idx_type count= 0; count < k; count++)
         result(count) = static_cast<double> (f_args.elem (count).length ());
       retval(0) = result;
     }
   else if (name == "ndims")
     {
       NDA result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
         result(count) = static_cast<double> (f_args.elem (count).ndims ());
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -66,17 +66,17 @@ along with Octave; see the file COPYING.
 
 // Initialize the singleton object
 bp_table *bp_table::instance = 0;
 
 std::set<std::string> bp_table::errors_that_stop;
 std::set<std::string> bp_table::caught_that_stop;
 std::set<std::string> bp_table::warnings_that_stop;
 
-// Read entire file called  fname  and return the contents as a string
+// Read entire file called fname and return the contents as a string
 static std::string
 snarf_file (const std::string& fname)
 {
   std::string retval;
 
   file_stat fs (fname);
 
   if (fs)
@@ -203,20 +203,20 @@ get_user_code (const std::string& fname 
 #  include "sigfpe.cc"
 #endif
 
 enum
 dbstop_args {dbstop_in, dbstop_at, dbstop_if, dbstop_none};
 
 // Parse parameters (args) of dbstop and dbclear commands.
 // For dbstop, who=="dbstop"; for dbclear, who=="dbclear".
-// The syntax is  dbstop [[in] symbol] [[at] line [line [...]]] [if condition]
+// The syntax is: dbstop [[in] symbol] [[at] line [line [...]]] [if condition]
 // where the form of condition depends on whether or not a file or line has
 // been seen.
-// Also execute "if [error|warning|interrupt|naninf]" clauses
+// Also execute "if [error|warning|interrupt|naninf]" clauses.
 void
 parse_dbfunction_params (const char *who, const octave_value_list& args,
                          std::string& symbol_name, bp_table::intmap& lines,
                          std::string& cond)
 {
   int nargin = args.length ();
   int list_idx = 0;
   symbol_name = "";
@@ -432,18 +432,18 @@ parse_dbfunction_params (const char *who
 %! dbstop if error Octave:undefined-function
 %! s = dbstatus;
 %! dbclear all
 %! assert ({s.bkpt(:).name}, {"help", "help", "help>do_contents", "ls", "ls"});
 %! assert ([s.bkpt(:).line], [48, 100, 200, 58, 100]);
 %! assert (s.errs, {"Octave:undefined-function"});
 */
 
-// Return  true  if there is a valid breakpoint table, false otherwise.
-// If not table exists, one is created; false is only returned if this fails
+// Return true if there is a valid breakpoint table, false otherwise.
+// If no table exists, one is created; false is only returned if this fails.
 bool
 bp_table::instance_ok (void)
 {
   if (! instance)
     {
       instance = new bp_table ();
 
       if (instance)
@@ -551,17 +551,17 @@ bp_table::dbstop_process_map_args (const
 
   // process interrupt
   if (mv.isfield ("intr"))
     Vdebug_on_interrupt = 1;
 }
 
 
 // Insert a breakpoint in function fcn at line within file fname,
-// to stop only when  condition is true.
+// to stop only when condition is true.
 // Record in bp_set that fname contains a breakpoint.
 bool
 bp_table::do_add_breakpoint_1 (octave_user_code *fcn,
                                const std::string& fname,
                                const bp_table::intmap& line,
                                const std::string& condition,
                                bp_table::intmap& retval)
 {
@@ -591,17 +591,17 @@ bp_table::do_add_breakpoint_1 (octave_us
               break;
             }
         }
     }
 
   return found;
 }
 
-// Cursory check that  cond  is a valid condition to use for a breakpoint
+// Cursory check that cond is a valid condition to use for a breakpoint.
 // Currently allows conditions with side-effects, like 'y+=10' and 'y++';
 // it is odd that the former is not flagged by "is_assignment_expression".
 // Throws an exception if not valid.
 bool
 bp_table::condition_valid (const std::string& cond)
 {
   if (cond.length () > 0)
     {
@@ -630,19 +630,19 @@ bp_table::condition_valid (const std::st
               else
                 error ("dbstop: condition must be an expression");
             }
         }
     }
   return true;
 }
 
-// Given file name  fname,  find the subfunction at line  line  and create
+// Given file name fname, find the subfunction at line and create
 // a breakpoint there.  Put the system into debug_mode.
-// (FIXME: If  line  is multiple lines, what happens if they are in different
+// (FIXME: If line is multiple lines, what happens if they are in different
 //         functions?)
 bp_table::intmap
 bp_table::do_add_breakpoint (const std::string& fname,
                              const bp_table::intmap& line,
                              const std::string& condition)
 {
   octave_user_code *dbg_fcn = get_user_code (fname);
 
@@ -1165,17 +1165,17 @@ files.\n\
       if (symbol_name != "")
         bp_table::remove_breakpoint (symbol_name, lines);
     }
 
   return ovl ();
 }
 
 // Report the status of "dbstop if error ..." and "dbstop if warning ..."
-// If to_screen is true, the output goes to  octave_stdout; otherwise it is
+// If to_screen is true, the output goes to octave_stdout; otherwise it is
 // returned.
 // If dbstop if error is true but no explicit IDs are specified, the return
 // value will have an empty field called "errs".  If IDs are specified, the
 // "errs" field will have a row per ID.  If dbstop if error is false, there
 // is no "errs" field.  The "warn" field is set similarly by dbstop if warning
 octave_map
 bp_table::stop_on_err_warn_status (bool to_screen)
 {
diff --git a/libinterp/corefcn/errwarn.h b/libinterp/corefcn/errwarn.h
--- a/libinterp/corefcn/errwarn.h
+++ b/libinterp/corefcn/errwarn.h
@@ -130,17 +130,17 @@ OCTAVE_NORETURN OCTINTERP_API extern voi
 err_wrong_type_arg (const std::string& s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (octave_execution_exception& e, const std::string& s);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (const octave_value& tc);
 
-OCTAVE_NORETURN OCTINTERP_API extern  void
+OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg (octave_execution_exception& e, const octave_value& tc);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg_for_binary_op (const octave_value& op);
 
 OCTAVE_NORETURN OCTINTERP_API extern void
 err_wrong_type_arg_for_unary_op (const octave_value& op);
 
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -4766,17 +4766,17 @@ public:
             dp = 0.5;
           else
             dp = (limits(1) - limits(0))/2;
         }
       return dp;
     }
 
   public:
-    float  pixel_xsize (void)
+    float pixel_xsize (void)
     {
       return pixel_size ((get_cdata ().dims ())(1), xdata.get_limits ());
     }
 
     float pixel_ysize (void)
     {
       return pixel_size ((get_cdata ().dims ())(0), ydata.get_limits ());
     }
diff --git a/libinterp/corefcn/jit-ir.h b/libinterp/corefcn/jit-ir.h
--- a/libinterp/corefcn/jit-ir.h
+++ b/libinterp/corefcn/jit-ir.h
@@ -69,17 +69,17 @@ along with Octave; see the file COPYING.
 // forward declare all ir classes
 #define JIT_METH(cname)                         \
   class jit_ ## cname;
 
 JIT_VISIT_IR_NOTEMPLATE
 
 #undef JIT_METH
 
-// ABCs which aren't included in  JIT_VISIT_IR_ALL
+// ABCs which aren't included in JIT_VISIT_IR_ALL
 class jit_instruction;
 class jit_terminator;
 
 template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T = T,
           bool QUOTE=false>
 class jit_const;
 
 typedef jit_const<bool, jit_typeinfo::get_bool> jit_const_bool;
@@ -804,18 +804,18 @@ private:
 class
 jit_variable : public jit_value
 {
 public:
   jit_variable (const std::string& aname) : mname (aname), mlast_use (0) { }
 
   const std::string &name (void) const { return mname; }
 
-  // manipulate the value_stack, for use during SSA construction. The top of
-  // the  value stack represents the current value for this variable
+  // manipulate the value_stack, for use during SSA construction.  The top of
+  // the value stack represents the current value for this variable
   bool has_top (void) const
   {
     return ! value_stack.empty ();
   }
 
   jit_value *top (void) const
   {
     return value_stack.top ();
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3859,17 +3859,17 @@ textscan::lookahead (delimited_stream& i
 
   char *pos = is.tellg ();
 
   std::string tmp (max_len, '\0');
   char *look = is.read (&tmp[0], tmp.size (), pos);
 
   is.clear ();
   is.seekg (pos);              // reset to position before look-ahead
-                               // FIXME  pos may be corrupted by is.read
+                               // FIXME: pos may be corrupted by is.read
 
   int i;
   int (*compare)(const char *, const char *, size_t);
   compare = case_sensitive ? strncmp : strncasecmp;
 
   for (i = 0; i < targets.numel (); i++)
     {
       std::string s = targets (i).string_value ();
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "parse.h"
 #include "utils.h"
 #include "variables.h"
 
 // Extended debugging.
 #define DEBUG_QUADCC 0
 
 // Define the minimum size of the interval heap.
-#define MIN_CQUAD_HEAPSIZE  200
+#define MIN_CQUAD_HEAPSIZE 200
 
 // Data of a single interval.
 typedef struct
 {
   double a, b;
   double c[64];
   double fx[33];
   double igral, err;
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -226,22 +226,22 @@ extern "C"
   F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL,
                                const octave_idx_type&,
                                const octave_idx_type&, const double*,
                                const octave_idx_type&, double*, double&
                                F77_CHAR_ARG_LEN_DECL);
 }
 
 // fcrhp, fin, fout, folhp:
-// routines for ordering of generalized eigenvalues
-// return 1 if  test is passed, 0 otherwise
-//    fin: |lambda| < 1
-//    fout: |lambda| >= 1
-//    fcrhp: real(lambda) >= 0
-//    folhp: real(lambda) < 0
+// Routines for ordering of generalized eigenvalues.
+// Return 1 if test is passed, 0 otherwise.
+//   fin:  |lambda| < 1
+//   fout: |lambda| >= 1
+//   fcrhp: real(lambda) >= 0
+//   folhp: real(lambda) < 0
 
 static octave_idx_type
 fcrhp (const octave_idx_type& lsize, const double& alpha,
        const double& beta, const double& s, const double&)
 {
   if (lsize == 1)
     return (alpha * beta >= 0 ? 1 : -1);
   else
@@ -709,17 +709,17 @@ compatibility with @sc{matlab}.\n\
       std::cout << "qz: precursors done..." << std::endl;
 #endif
 
 #ifdef DEBUG
       std::cout << "qz: compq = " << compq << ", compz = " << compz
                 << std::endl;
 #endif
 
-      // Reduce  to generalized hessenberg form.
+      // Reduce to generalized Hessenberg form.
       F77_XFCN (dgghrd, DGGHRD,
                 (F77_CONST_CHAR_ARG2 (&compq, 1),
                  F77_CONST_CHAR_ARG2 (&compz, 1),
                  nn, ilo, ihi, aa.fortran_vec (),
                  nn, bb.fortran_vec (), nn, QQ.fortran_vec (), nn,
                  ZZ.fortran_vec (), nn, info
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)));
@@ -1057,17 +1057,17 @@ compatibility with @sc{matlab}.\n\
                      nn, CVL.fortran_vec (), nn, CVR.fortran_vec (), nn, nn,
                      m, cwork2.fortran_vec (), rwork2.fortran_vec (), info
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
         }
       else
         {
 #ifdef DEBUG
-          std::cout << "qz: computing  generalized eigenvectors" << std::endl;
+          std::cout << "qz: computing generalized eigenvectors" << std::endl;
 #endif
 
           VL = QQ;
           VR = ZZ;
           octave_idx_type m;
 
           F77_XFCN (dtgevc, DTGEVC,
                     (F77_CONST_CHAR_ARG2 (&side, 1),
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -393,17 +393,17 @@ x_el_div (double a, const SparseMatrix& 
 }
 
 ComplexMatrix
 x_el_div (double a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
-  ComplexMatrix  result (nr, nc, Complex (octave_NaN, octave_NaN));
+  ComplexMatrix result (nr, nc, Complex (octave_NaN, octave_NaN));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
         result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1112,17 +1112,17 @@ symbol_table::fcn_info::fcn_info_rep::fi
         package = octave_value (fcn);
     }
 
   return package;
 }
 
 // Insert INF_CLASS in the set of class names that are considered
 // inferior to SUP_CLASS.  Return FALSE if INF_CLASS is currently
-// marked as superior to  SUP_CLASS.
+// marked as superior to SUP_CLASS.
 
 bool
 symbol_table::set_class_relationship (const std::string& sup_class,
                                       const std::string& inf_class)
 {
   if (is_superiorto (inf_class, sup_class))
     return false;
 
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -2344,17 +2344,17 @@ public:
   }
 
 /*
   double get_screen_resolution (void) const
   {
     // FLTK doesn't give this info.
     return 72.0;
 
-    // FIXME: FLTK >= 1.3.0 could do this with  Fl::screen_dpi (h, v, n)
+    // FIXME: FLTK >= 1.3.0 could do this with Fl::screen_dpi (h, v, n)
     // but do we need it?
   }
 */
 
   Matrix get_screen_size (void) const
   {
     Matrix sz (1, 2, 0.0);
     sz(0) = Fl::w ();
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1109,18 +1109,18 @@ octave_class::reconstruct_parents (void)
 {
   bool retval = true;
   bool might_have_inheritance = false;
   std::string dbgstr = "dork";
 
   // First, check to see if there might be an issue with inheritance.
   for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
-      std::string  key = map.key (p);
-      Cell         val = map.contents (p);
+      std::string key = map.key (p);
+      Cell        val = map.contents (p);
       if (val(0).is_object ())
         {
           dbgstr = "blork";
           if (key == val(0).class_name ())
             {
               might_have_inheritance = true;
               dbgstr = "cork";
               break;
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -172,20 +172,20 @@ public:
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   Complex complex_value (bool = false) const { return scalar; }
 
   FloatComplex float_complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
-  { return  ComplexMatrix (1, 1, Complex (scalar)); }
+  { return ComplexMatrix (1, 1, Complex (scalar)); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-  { return  FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
+  { return FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
 
   ComplexNDArray complex_array_value (bool = false) const
   { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
   { return FloatComplexNDArray (dim_vector (1, 1), FloatComplex (scalar)); }
 
   charNDArray
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -171,20 +171,20 @@ public:
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   Complex complex_value (bool = false) const { return scalar; }
 
   FloatComplex float_complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
-  { return  ComplexMatrix (1, 1, Complex (scalar)); }
+  { return ComplexMatrix (1, 1, Complex (scalar)); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-  { return  FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
+  { return FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
 
   ComplexNDArray complex_array_value (bool = false) const
   { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
   { return FloatComplexNDArray (dim_vector (1, 1), FloatComplex (scalar)); }
 
   charNDArray
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -533,61 +533,61 @@ along with Octave; see the file COPYING.
 
 #define OCTAVE_MS_INT_ASSIGNEQ_OPS(PFX, TM) \
   DEFNDASSIGNOP_OP (PFX ## _assign_add, TM ## matrix, TM ## scalar, TM ## scalar, +=) \
   DEFNDASSIGNOP_OP (PFX ## _assign_sub, TM ## matrix, TM ## scalar, TM ## scalar, -=) \
   DEFNDASSIGNOP_OP (PFX ## _assign_mul, TM ## matrix, TM ## scalar, TM ## scalar, *=) \
   DEFNDASSIGNOP_OP (PFX ## _assign_div, TM ## matrix, TM ## scalar, TM ## scalar, /=)
 
 #define OCTAVE_MS_POW_OPS(T1, T2) \
-octave_value elem_xpow (T1 ## NDArray a, octave_ ## T2  b) \
+octave_value elem_xpow (T1 ## NDArray a, octave_ ## T2 b) \
 { \
   T1 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
-octave_value elem_xpow (T1 ## NDArray a, double  b) \
+octave_value elem_xpow (T1 ## NDArray a, double b) \
 { \
   T1 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
-octave_value elem_xpow (NDArray a, octave_ ## T2  b) \
+octave_value elem_xpow (NDArray a, octave_ ## T2 b) \
 { \
   T2 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = pow (a(i), b);               \
     } \
   return octave_value (result); \
 } \
 \
-octave_value elem_xpow (T1 ## NDArray a, float  b) \
+octave_value elem_xpow (T1 ## NDArray a, float b) \
 { \
   T1 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = powf (a(i), b);              \
     } \
   return octave_value (result); \
 } \
 \
-octave_value elem_xpow (FloatNDArray a, octave_ ## T2  b) \
+octave_value elem_xpow (FloatNDArray a, octave_ ## T2 b) \
 { \
   T2 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.numel (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = powf (a(i), b);              \
     } \
   return octave_value (result); \
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 1996-2015 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -7597,22 +7597,22 @@ min (const SparseComplexMatrix& a, const
   if (a_nr == b_nr && a_nc == b_nc)
     {
       r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx (i);
-          octave_idx_type  ja_max = a.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
-
-          octave_idx_type  jb = b.cidx (i);
-          octave_idx_type  jb_max = b.cidx (i+1);
+          octave_idx_type ja = a.cidx (i);
+          octave_idx_type ja_max = a.cidx (i+1);
+          bool ja_lt_max = ja < ja_max;
+
+          octave_idx_type jb = b.cidx (i);
+          octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   Complex tmp = xmin (a.data (ja), 0.);
@@ -7714,22 +7714,22 @@ max (const SparseComplexMatrix& a, const
   if (a_nr == b_nr && a_nc == b_nc)
     {
       r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx (i);
-          octave_idx_type  ja_max = a.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
-
-          octave_idx_type  jb = b.cidx (i);
-          octave_idx_type  jb_max = b.cidx (i+1);
+          octave_idx_type ja = a.cidx (i);
+          octave_idx_type ja_max = a.cidx (i+1);
+          bool ja_lt_max = ja < ja_max;
+
+          octave_idx_type jb = b.cidx (i);
+          octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   Complex tmp = xmax (a.data (ja), 0.);
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -40,22 +40,22 @@ plus_or_minus (MSparse<T>& a, const MSpa
   if (a_nr != b_nr || a_nc != b_nc)
     err_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
 
   r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
   octave_idx_type jx = 0;
   for (octave_idx_type i = 0 ; i < a_nc ; i++)
     {
-      octave_idx_type  ja = a.cidx (i);
-      octave_idx_type  ja_max = a.cidx (i+1);
-      bool ja_lt_max= ja < ja_max;
+      octave_idx_type ja = a.cidx (i);
+      octave_idx_type ja_max = a.cidx (i+1);
+      bool ja_lt_max = ja < ja_max;
 
-      octave_idx_type  jb = b.cidx (i);
-      octave_idx_type  jb_max = b.cidx (i+1);
+      octave_idx_type jb = b.cidx (i);
+      octave_idx_type jb_max = b.cidx (i+1);
       bool jb_lt_max = jb < jb_max;
 
       while (ja_lt_max || jb_lt_max)
         {
           octave_quit ();
           if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
             {
               r.ridx (jx) = a.ridx (ja);
@@ -310,22 +310,22 @@ plus_or_minus (const MSparse<T>& a, cons
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx (i);
-          octave_idx_type  ja_max = a.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
+          octave_idx_type ja = a.cidx (i);
+          octave_idx_type ja_max = a.cidx (i+1);
+          bool ja_lt_max = ja < ja_max;
 
-          octave_idx_type  jb = b.cidx (i);
-          octave_idx_type  jb_max = b.cidx (i+1);
+          octave_idx_type jb = b.cidx (i);
+          octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   r.ridx (jx) = a.ridx (ja);
@@ -431,22 +431,22 @@ product (const MSparse<T>& a, const MSpa
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () > b.nnz () ? a.nnz () : b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx (i);
-          octave_idx_type  ja_max = a.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
+          octave_idx_type ja = a.cidx (i);
+          octave_idx_type ja_max = a.cidx (i+1);
+          bool ja_lt_max = ja < ja_max;
 
-          octave_idx_type  jb = b.cidx (i);
-          octave_idx_type  jb_max = b.cidx (i+1);
+          octave_idx_type jb = b.cidx (i);
+          octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   ja++; ja_lt_max= ja < ja_max;
@@ -549,22 +549,22 @@ quotient (const MSparse<T>& a, const MSp
   else if (a_nr != b_nr || a_nc != b_nc)
     err_nonconformant ("quotient", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (Zero / Zero));
 
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx (i);
-          octave_idx_type  ja_max = a.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
+          octave_idx_type ja = a.cidx (i);
+          octave_idx_type ja_max = a.cidx (i+1);
+          bool ja_lt_max = ja < ja_max;
 
-          octave_idx_type  jb = b.cidx (i);
-          octave_idx_type  jb_max = b.cidx (i+1);
+          octave_idx_type jb = b.cidx (i);
+          octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   r.elem (a.ridx (ja),i) = a.data (ja) / Zero;
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -810,17 +810,17 @@ Sparse<T>::reshape (const dim_vector& ne
           octave_idx_type new_nr = dims2 (0);
           octave_idx_type new_nc = dims2 (1);
           octave_idx_type old_nr = rows ();
           octave_idx_type old_nc = cols ();
           retval = Sparse<T> (new_nr, new_nc, new_nnz);
 
           octave_idx_type kk = 0;
           retval.xcidx (0) = 0;
-          // quotient and remainder of  i * old_nr divided by new_nr
+          // Quotient and remainder of i * old_nr divided by new_nr.
           // Track them individually to avoid overflow (bug #42850).
           octave_idx_type i_old_qu = 0;
           octave_idx_type i_old_rm = static_cast<octave_idx_type> (-old_nr);
           for (octave_idx_type i = 0; i < old_nc; i++)
             {
               i_old_rm += old_nr;
               if (i_old_rm >= new_nr)
                 {
@@ -1775,17 +1775,17 @@ Sparse<T>::index (const idx_vector& idx_
               for (octave_idx_type i = 0; i < nzj; i++)
                 retval.xdata (li + i) = scb[rri[li + i]];
             }
         }
 
     }
   else if (idx_j.is_colon ())
     {
-      // This requires  uncompressing columns, which is generally costly,
+      // This requires uncompressing columns, which is generally costly,
       // so we rely on the efficient transpose to handle this.
       // It may still make sense to optimize some cases here.
       retval = transpose ();
       retval = retval.index (idx_vector::colon, idx_i);
       retval = retval.transpose ();
     }
   else
     {
diff --git a/liboctave/array/boolNDArray.cc b/liboctave/array/boolNDArray.cc
--- a/liboctave/array/boolNDArray.cc
+++ b/liboctave/array/boolNDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 1996-2015 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2003-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 1996-2015 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -766,22 +766,22 @@ atan2 (const SparseMatrix& x, const Spar
   SparseMatrix r;
 
   r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
 
   octave_idx_type jx = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0 ; i < x_nc ; i++)
     {
-      octave_idx_type  ja = x.cidx (i);
-      octave_idx_type  ja_max = x.cidx (i+1);
-      bool ja_lt_max= ja < ja_max;
-
-      octave_idx_type  jb = y.cidx (i);
-      octave_idx_type  jb_max = y.cidx (i+1);
+      octave_idx_type ja = x.cidx (i);
+      octave_idx_type ja_max = x.cidx (i+1);
+      bool ja_lt_max = ja < ja_max;
+
+      octave_idx_type jb = y.cidx (i);
+      octave_idx_type jb_max = y.cidx (i+1);
       bool jb_lt_max = jb < jb_max;
 
       while (ja_lt_max || jb_lt_max)
         {
           octave_quit ();
           if ((! jb_lt_max)
               || (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
             {
@@ -7705,22 +7705,22 @@ min (const SparseMatrix& a, const Sparse
   if (a_nr == b_nr && a_nc == b_nc)
     {
       r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx (i);
-          octave_idx_type  ja_max = a.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
-
-          octave_idx_type  jb = b.cidx (i);
-          octave_idx_type  jb_max = b.cidx (i+1);
+          octave_idx_type ja = a.cidx (i);
+          octave_idx_type ja_max = a.cidx (i+1);
+          bool ja_lt_max = ja < ja_max;
+
+          octave_idx_type jb = b.cidx (i);
+          octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   double tmp = xmin (a.data (ja), 0.);
@@ -7855,22 +7855,22 @@ max (const SparseMatrix& a, const Sparse
   if (a_nr == b_nr && a_nc == b_nc)
     {
       r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx (i);
-          octave_idx_type  ja_max = a.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
-
-          octave_idx_type  jb = b.cidx (i);
-          octave_idx_type  jb_max = b.cidx (i+1);
+          octave_idx_type ja = a.cidx (i);
+          octave_idx_type ja_max = a.cidx (i+1);
+          bool ja_lt_max = ja < ja_max;
+
+          octave_idx_type jb = b.cidx (i);
+          octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   double tmp = xmax (a.data (ja), 0.);
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 1996-2015 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 1996-2015 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
diff --git a/liboctave/array/int16NDArray.cc b/liboctave/array/int16NDArray.cc
--- a/liboctave/array/int16NDArray.cc
+++ b/liboctave/array/int16NDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/array/int32NDArray.cc b/liboctave/array/int32NDArray.cc
--- a/liboctave/array/int32NDArray.cc
+++ b/liboctave/array/int32NDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/array/int64NDArray.cc b/liboctave/array/int64NDArray.cc
--- a/liboctave/array/int64NDArray.cc
+++ b/liboctave/array/int64NDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/array/int8NDArray.cc b/liboctave/array/int8NDArray.cc
--- a/liboctave/array/int8NDArray.cc
+++ b/liboctave/array/int8NDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/array/intNDArray.cc b/liboctave/array/intNDArray.cc
--- a/liboctave/array/intNDArray.cc
+++ b/liboctave/array/intNDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
diff --git a/liboctave/array/uint16NDArray.cc b/liboctave/array/uint16NDArray.cc
--- a/liboctave/array/uint16NDArray.cc
+++ b/liboctave/array/uint16NDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/array/uint32NDArray.cc b/liboctave/array/uint32NDArray.cc
--- a/liboctave/array/uint32NDArray.cc
+++ b/liboctave/array/uint32NDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/array/uint64NDArray.cc b/liboctave/array/uint64NDArray.cc
--- a/liboctave/array/uint64NDArray.cc
+++ b/liboctave/array/uint64NDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/array/uint8NDArray.cc b/liboctave/array/uint8NDArray.cc
--- a/liboctave/array/uint8NDArray.cc
+++ b/liboctave/array/uint8NDArray.cc
@@ -1,9 +1,9 @@
-// N-D Array  manipulations.
+// N-D Array manipulations.
 /*
 
 Copyright (C) 2004-2015 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/liboctave/numeric/randgamma.h b/liboctave/numeric/randgamma.h
--- a/liboctave/numeric/randgamma.h
+++ b/liboctave/numeric/randgamma.h
@@ -23,24 +23,24 @@ along with Octave; see the file COPYING.
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
 #if ! defined (octave_randgamma_h)
 #define octave_randgamma_h 1
 
 #include "octave-config.h"
 
-#ifdef  __cplusplus
+#ifdef __cplusplus
 extern "C" {
 #endif
 
 extern OCTAVE_API double oct_randg (double a);
 extern OCTAVE_API void oct_fill_randg (double a, octave_idx_type n, double *p);
 
 extern OCTAVE_API float oct_float_randg (float a);
 extern OCTAVE_API void oct_fill_float_randg (float a, octave_idx_type n,
                                              float *p);
 
-#ifdef  __cplusplus
+#ifdef __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/numeric/randmtzig.h b/liboctave/numeric/randmtzig.h
--- a/liboctave/numeric/randmtzig.h
+++ b/liboctave/numeric/randmtzig.h
@@ -92,13 +92,13 @@ extern OCTAVE_API float oct_float_rande 
 extern OCTAVE_API void oct_fill_randu (octave_idx_type n, double *p);
 extern OCTAVE_API void oct_fill_randn (octave_idx_type n, double *p);
 extern OCTAVE_API void oct_fill_rande (octave_idx_type n, double *p);
 
 extern OCTAVE_API void oct_fill_float_randu (octave_idx_type n, float *p);
 extern OCTAVE_API void oct_fill_float_randn (octave_idx_type n, float *p);
 extern OCTAVE_API void oct_fill_float_rande (octave_idx_type n, float *p);
 
-#ifdef  __cplusplus
+#ifdef __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/numeric/randpoisson.c b/liboctave/numeric/randpoisson.c
--- a/liboctave/numeric/randpoisson.c
+++ b/liboctave/numeric/randpoisson.c
@@ -95,37 +95,37 @@ flogfak (double k)
     19.98721449566188615,  22.55216385312342289,  25.19122118273868150,
     27.89927138384089157,  30.67186010608067280,  33.50507345013688888,
     36.39544520803305358,  39.33988418719949404,  42.33561646075348503,
     45.38013889847690803,  48.47118135183522388,  51.60667556776437357,
     54.78472939811231919,  58.00360522298051994,  61.26170176100200198,
     64.55753862700633106,  67.88974313718153498,  71.25703896716800901
   };
 
-  double  r, rr;
+  double r, rr;
 
   if (k >= 30.0)
     {
       r  = 1.0 / k;
       rr = r * r;
       return ((k + 0.5)*log (k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
     }
   else
     return (logfak[(int)k]);
 }
 
 
 /******************************************************************
  *                                                                *
- * Poisson Distribution - Patchwork Rejection/Inversion  *
+ * Poisson Distribution - Patchwork Rejection/Inversion           *
  *                                                                *
  ******************************************************************
  *                                                                *
- * For parameter  my < 10  Tabulated Inversion is applied.        *
- * For my >= 10  Patchwork Rejection is employed:                 *
+ * For parameter my < 10, Tabulated Inversion is applied.         *
+ * For my >= 10, Patchwork Rejection is employed:                 *
  * The area below the histogram function f(x) is rearranged in    *
  * its body by certain point reflections. Within a large center   *
  * interval variates are sampled efficiently by rejection from    *
  * uniform hats. Rectangular immediate acceptance regions speed   *
  * up the generation. The remaining tails are covered by          *
  * exponential functions.                                         *
  *                                                                *
  ******************************************************************
diff --git a/liboctave/numeric/randpoisson.h b/liboctave/numeric/randpoisson.h
--- a/liboctave/numeric/randpoisson.h
+++ b/liboctave/numeric/randpoisson.h
@@ -23,29 +23,29 @@ along with Octave; see the file COPYING.
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
 #if ! defined (octave_randpoisson_h)
 #define octave_randpoisson_h 1
 
 #include "octave-config.h"
 
-#ifdef  __cplusplus
+#ifdef __cplusplus
 extern "C" {
 #endif
 
 extern OCTAVE_API double
 oct_randp (double L);
 
 extern OCTAVE_API void
 oct_fill_randp (double L, octave_idx_type n, double *p);
 
 extern OCTAVE_API float
 oct_float_randp (float L);
 
 extern OCTAVE_API void
 oct_fill_float_randp (float L, octave_idx_type n, float *p);
 
-#ifdef  __cplusplus
+#ifdef __cplusplus
 }
 #endif
 
 #endif
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -375,22 +375,22 @@ along with Octave; see the file COPYING.
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx (i); \
-            octave_idx_type  ja_max = m1.cidx (i+1); \
-            bool ja_lt_max= ja < ja_max; \
+            octave_idx_type ja = m1.cidx (i); \
+            octave_idx_type ja_max = m1.cidx (i+1); \
+            bool ja_lt_max = ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx (i); \
-            octave_idx_type  jb_max = m2.cidx (i+1); \
+            octave_idx_type jb = m2.cidx (i); \
+            octave_idx_type jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
@@ -483,22 +483,22 @@ along with Octave; see the file COPYING.
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx (i); \
-            octave_idx_type  ja_max = m1.cidx (i+1); \
-            bool ja_lt_max= ja < ja_max; \
+            octave_idx_type ja = m1.cidx (i); \
+            octave_idx_type ja_max = m1.cidx (i+1); \
+            bool ja_lt_max = ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx (i); \
-            octave_idx_type  jb_max = m2.cidx (i+1); \
+            octave_idx_type jb = m2.cidx (i); \
+            octave_idx_type jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
@@ -599,22 +599,22 @@ along with Octave; see the file COPYING.
     else \
       { \
  \
         /* FIXME: Kludge... Always double/Complex, so Complex () */ \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ())); \
         \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx (i); \
-            octave_idx_type  ja_max = m1.cidx (i+1); \
-            bool ja_lt_max= ja < ja_max; \
+            octave_idx_type ja = m1.cidx (i); \
+            octave_idx_type ja_max = m1.cidx (i+1); \
+            bool ja_lt_max = ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx (i); \
-            octave_idx_type  jb_max = m2.cidx (i+1); \
+            octave_idx_type jb = m2.cidx (i); \
+            octave_idx_type jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
@@ -1753,17 +1753,17 @@ along with Octave; see the file COPYING.
       retval.xcidx (0) = 0; \
       \
       octave_idx_type nel = 0; \
       \
       for (octave_idx_type i = 0; i < a_nc; i++) \
         { \
           for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
             { \
-              octave_idx_type  col = a.ridx (j); \
+              octave_idx_type col = a.ridx (j); \
               for (octave_idx_type k = m.cidx (col) ; k < m.cidx (col+1); k++) \
                 { \
                   if (w[m.ridx (k)] < i + 1) \
                     { \
                       w[m.ridx (k)] = i + 1; \
                       nel++; \
                     } \
                   octave_quit (); \
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -95,22 +95,22 @@ octave_time::stamp (void)
   gnulib::gettimeofday (&tp, 0);
 
   ot_unix_time = tp.tv_sec;
   ot_usec = tp.tv_usec;
 }
 
 // From the mktime() manual page:
 //
-//     The  mktime()  function converts a broken-down time structure,
+//     The mktime() function converts a broken-down time structure,
 //     expressed as local time, to calendar time representation.
 //
 //     <snip>
 //
-//     If structure members are outside  their  legal interval, they
+//     If structure members are outside their legal interval, they
 //     will be normalized (so that, e.g., 40 October is changed into
 //     9 November).
 //
 // So, we no longer check limits here.
 
 #define DEFINE_SET_FIELD_FCN(type, f, lo, hi) \
   octave_base_tm& \
   octave_base_tm::f (type v) \
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -1296,17 +1296,17 @@ kpse_expand_kpse_dot (const std::string&
   if (kpse_dot.empty ())
     return path;
 
   for (kpse_path_iterator pi (path); pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       /* We assume that the !! magic is only used on absolute components.
-         Single "." get special treatment, as does "./" or its  equivalent.  */
+         Single "." get special treatment, as does "./" or its equivalent.  */
 
       size_t elt_len = elt.length ();
 
       if (kpse_absolute_p (elt, false)
           || (elt_len > 1 && elt[0] == '!' && elt[1] == '!'))
         ret += elt + ENV_SEP_STRING;
       else if (elt_len == 1 && elt[0] == '.')
         ret += kpse_dot + ENV_SEP_STRING;
diff --git a/liboctave/util/lo-array-errwarn.h b/liboctave/util/lo-array-errwarn.h
--- a/liboctave/util/lo-array-errwarn.h
+++ b/liboctave/util/lo-array-errwarn.h
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include "dim-vector.h"
 #include "quit.h"
 
 // Exception thrown by err_invalid_index
 // This is thrown when the invalid index is detected, at which point nd and dim
 // are usually not known.  It is caught at the place they are known, where a
-// new  err_invalid_index  is called.
+// new err_invalid_index  is called.
 //
 // Typically, this should be caught after any call to
 // octave_value_list::index_vector()
 class index_exception : public octave_execution_exception
 {
 public:
 
   index_exception (const std::string& index_arg, octave_idx_type nd_arg = 0,
diff --git a/liboctave/util/lo-ieee.h b/liboctave/util/lo-ieee.h
--- a/liboctave/util/lo-ieee.h
+++ b/liboctave/util/lo-ieee.h
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_lo_ieee_h)
 #define octave_lo_ieee_h 1
 
 #include "octave-config.h"
 
-#ifdef  __cplusplus
+#ifdef __cplusplus
 extern "C" {
 #endif
 
 /*  Octave's idea of infinity.  */
 #define octave_Inf (lo_ieee_inf_value ())
 
 /* Octave's idea of a missing value.  */
 #define octave_NA (lo_ieee_na_value ())
@@ -91,17 +91,17 @@ extern OCTAVE_API int __lo_ieee_float_is
 extern OCTAVE_API int __lo_ieee_float_is_NA (float);
 
 extern OCTAVE_API float lo_ieee_float_inf_value (void);
 extern OCTAVE_API float lo_ieee_float_na_value (void);
 extern OCTAVE_API float lo_ieee_float_nan_value (void);
 
 extern OCTAVE_API int __lo_ieee_float_signbit (float);
 
-#ifdef  __cplusplus
+#ifdef __cplusplus
 }
 #endif
 
 #define lo_ieee_isnan(x) (sizeof (x) == sizeof (float) ? \
                          __lo_ieee_float_isnan (x) : __lo_ieee_isnan (x))
 #define lo_ieee_finite(x) (sizeof (x) == sizeof (float) ? \
                            __lo_ieee_float_finite (x) : __lo_ieee_finite (x))
 #define lo_ieee_isinf(x) (sizeof (x) == sizeof (float) ? \
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2000-2015 Kai Habel
-## Copyright (C) 2007  David Bateman
+## Copyright (C) 2007 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -188,17 +188,17 @@ function retval = num2str (x, arg)
   endif
 
 endfunction
 
 
 %!assert (num2str (123), "123")
 %!assert (num2str (1.23), "1.23")
 %!assert (num2str (123.456, 4), "123.5")
-%!assert (num2str ([1, 1.34; 3, 3.56], "%5.1f"),  ["1.0  1.3"; "3.0  3.6"])
+%!assert (num2str ([1, 1.34; 3, 3.56], "%5.1f"), ["1.0  1.3"; "3.0  3.6"])
 %!assert (num2str (1.234 + 27.3i), "1.234+27.3i")
 %!assert (num2str ([true false true]), "1  0  1")
 
 %!assert (num2str (19440606), "19440606")
 %!assert (num2str (2^33), "8589934592")
 %!assert (num2str (-2^33), "-8589934592")
 %!assert (num2str (2^33+1i), "8589934592+1i")
 %!assert (num2str (-2^33+1i), "-8589934592+1i")
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -39,17 +39,17 @@
 ##    arguments belong to a comparable "numeric" class which includes
 ##    numeric, logical, and character arrays.  Check that number of dimensions
 ##    and size of each dimension match.
 ## 3. For each argument after x, compare it for equality with x:
 ##    a. struct     compare each member by name, not by order (recursive)
 ##    b. object     convert to struct, and then compare as stated above
 ##    c. cell       compare each member by order (recursive)
 ##    d. char       compare each member with strcmp
-##    e  fcn_handle compare using overloade 'eq' operator
+##    e  fcn_handle compare using overloaded 'eq' operator
 ##    f. <other>    compare each nonzero member, and assume NaN == NaN
 ##                  if nans_compare_equal is nonzero.
 
 function t = __isequal__ (nans_compare_equal, x, varargin)
 
   l_v = nargin - 2;
 
   ## Generic tests.
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -72,17 +72,17 @@ function [fcn, help1str] = lookfor (str,
   endif
 
   ## Search functions in new path dirs.
   orig_path = ostrsplit (__pathorig__ (), pathsep ());
 
   ## ditto for path.
   new_path = ostrsplit (path (), pathsep ());
 
-  ## remove  directories already covered by orig_path.
+  ## remove directories already covered by orig_path.
   if (had_core_cache)
     new_path = setdiff (new_path, orig_path);
   endif
 
   for n = 1:numel (new_path)
     fcndir = new_path{n};
     cache_file = fullfile (fcndir, "doc-cache");
     if (exist (cache_file, "file"))
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -104,17 +104,17 @@ endfunction
 %!assert (hsv2rgb ([0 1 1]), [1 0 0])
 %!assert (hsv2rgb ([1 1 1]), [1 0 0])
 %!assert (hsv2rgb ([1/3 1 1]), [0 1 0])
 %!assert (hsv2rgb ([2/3 1 1]), [0 0 1])
 
 %!assert (hsv2rgb ([0 0.5 0.5]), hsv2rgb ([1 0.5 0.5]))
 
 ## Not Matlab compatible (Matlab would return [1/2  1/12  1/12]) but
-## it's also invalid input.  This is, however, the same output as python
+## it's also invalid input.  This is, however, the same output as Python
 ## colorsys module.
 %!assert (hsv2rgb ([0.5 -0.5 0.5]), [0.75 0.5 0.5])
 
 ## Not Matlab compatible.  Matlab returns NaN when hue is outside the
 ## [0 1] range.  But since it's an angle, we can manage it.
 %!assert (hsv2rgb ([0 0.5 0.5]), hsv2rgb ([2 0.5 0.5]))
 %!assert (hsv2rgb ([0.5 0.5 0.5]), hsv2rgb ([2.5 0.5 0.5]), eps)
 
diff --git a/scripts/image/private/colorspace_conversion_revert.m b/scripts/image/private/colorspace_conversion_revert.m
--- a/scripts/image/private/colorspace_conversion_revert.m
+++ b/scripts/image/private/colorspace_conversion_revert.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Private function the functions that convert between color spaces, i.e.,
 ## rgb2ntsc, rgb2hsv, hsv2rgb, and ntsc2rgb.  This reverts a colormap type
 ## into the same shape and class as it was in the input.  The flags are meant
-## to come from  complementary private function
+## to come from complementary private function
 ## colorspace_conversion_input_check()
 
 function rv = colorspace_conversion_revert (rv, sz, is_im, is_nd)
   if (is_im)
     if (is_nd)
       rv = reshape (rv, [sz(1:2) sz(4) sz(3)]);
       rv = permute (rv, [1 2 4 3]);
     else
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -175,17 +175,17 @@ function [x, fval, info, output] = fminb
     fu = fun (u);
 
     niter += 1;
 
     iter(niter).funccount = nfev++;
     iter(niter).x = u;
     iter(niter).fx = fu;
 
-    ## update  a, b, v, w, and x
+    ## update a, b, v, w, and x
 
     if (fu < fval)
       if (u < x)
         b = x;
       else
         a = x;
       endif
       v = w; fv = fw;
diff --git a/scripts/pkg/private/create_pkgadddel.m b/scripts/pkg/private/create_pkgadddel.m
--- a/scripts/pkg/private/create_pkgadddel.m
+++ b/scripts/pkg/private/create_pkgadddel.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {} {} create_pkgadddel (@var{desc}, @var{packdir}, @var{nm}, @var{global_install})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function create_pkgadddel (desc, packdir, nm, global_install)
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "at"); # append to support PKG_ADD at inst/
-  ## If it is exists, most of the  PKG_* file should go into the
+  ## If it is exists, most of the PKG_* file should go into the
   ## architecture dependent directory so that the autoload/mfilename
   ## commands work as expected. The only part that doesn't is the
   ## part in the main directory.
   archdir = fullfile (getarchprefix (desc, global_install),
                       [desc.name "-" desc.version], getarch ());
   if (exist (getarchdir (desc, global_install), "dir"))
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
diff --git a/scripts/plot/appearance/shading.m b/scripts/plot/appearance/shading.m
--- a/scripts/plot/appearance/shading.m
+++ b/scripts/plot/appearance/shading.m
@@ -52,17 +52,17 @@ function shading (varargin)
 
   mode = varargin{1};
 
   if (isempty (hax))
     hax = gca ();
   endif
 
   ## Find all patch and surface objects that are descendants of hax
-  ## and  which are not part of a contour plot hggroup.
+  ## and which are not part of a contour plot hggroup.
   hlist = [];
   kids = get (hax, "children");
   while (! isempty (kids))
     types = get (kids, "type");
     hlist = [hlist; kids(strcmp(types, "patch"))];
     hlist = [hlist; kids(strcmp(types, "surface"))];
     parents = kids(strcmp (types, "axes"));
     hglist = kids(strcmp (types, "hggroup"));
diff --git a/scripts/plot/util/struct2hdl.m b/scripts/plot/util/struct2hdl.m
--- a/scripts/plot/util/struct2hdl.m
+++ b/scripts/plot/util/struct2hdl.m
@@ -570,33 +570,33 @@ function setprops (s, h, p, hilev)
       fields = fieldnames (s.properties);
       vals = struct2cell (s.properties);
       idx = find (cellfun (@(x) valcomp(x, hdls) , vals));
       s.properties = rmfield (s.properties, fields(idx));
 
       ## set all properties but special handles
       set (h, s.properties);
 
-      ## find  props with val == (one of special handles)
+      ## find props with val == (one of special handles)
       nf = length (idx);
       fields = fields(idx);
       vals = vals(idx);
       while (nf)
         field = fields{nf};
         idx = find (hdls == vals{nf});
         spec = specs(idx);
         if (isprop (h, field))
            h2 = get (h , field);
            set (h2, spec.properties);
         endif
         nf -= 1;
       endwhile
 
-      ## If hggroup children  were created by high level functions,
-      ## copy only usefull properties.
+      ## If hggroup children were created by high level functions,
+      ## copy only useful properties.
       if (hilev)
         if (strcmp (s.type, "hggroup"))
           nold = numel (s.children);
           nnew = numel (get (h).children);
 
           if (nold == nnew)
             hnew = get (h).children;
             ii = 1;
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -499,37 +499,37 @@ function [varargout] = gallery (name, va
     case "wilk"        , [varargout{1:n_out}] = wilk        (varargin{:});
     otherwise
       error ("gallery: unknown matrix with NAME %s", name);
   endswitch
 
 endfunction
 
 function C = cauchy (x, y)
-  ##CAUCHY  Cauchy matrix.
-  ##  C = CAUCHY(X, Y), where X, Y are N-vectors, is the N-by-N matrix
-  ##  with C(i,j) = 1/(X(i)+Y(j)).   By default, Y = X.
-  ##  Special case: if X is a scalar CAUCHY(X) is the same as CAUCHY(1:X).
-  ##  Explicit formulas are known for DET(C) (which is nonzero if X and Y
-  ##  both have distinct elements) and the elements of INV(C).
-  ##  C is totally positive if 0 < X(1) < ... < X(N) and
-  ##  0 < Y(1) < ... < Y(N).
+  ## CAUCHY  Cauchy matrix.
+  ##   C = CAUCHY(X, Y), where X, Y are N-vectors, is the N-by-N matrix
+  ##   with C(i,j) = 1/(X(i)+Y(j)).   By default, Y = X.
+  ##   Special case: if X is a scalar CAUCHY(X) is the same as CAUCHY(1:X).
+  ##   Explicit formulas are known for DET(C) (which is nonzero if X and Y
+  ##   both have distinct elements) and the elements of INV(C).
+  ##   C is totally positive if 0 < X(1) < ... < X(N) and
+  ##   0 < Y(1) < ... < Y(N).
   ##
-  ##  References:
-  ##  N.J. Higham, Accuracy and Stability of Numerical Algorithms,
-  ##    Society for Industrial and Applied Mathematics, Philadelphia, PA,
-  ##    USA, 1996; sec. 26.1.
-  ##  D.E. Knuth, The Art of Computer Programming, Volume 1,
-  ##    Fundamental Algorithms, second edition, Addison-Wesley, Reading,
-  ##    Massachusetts, 1973, p. 36.
-  ##  E.E. Tyrtyshnikov, Cauchy-Toeplitz matrices and some applications,
-  ##    Linear Algebra and Appl., 149 (1991), pp. 1-18.
-  ##    O. Taussky and M. Marcus, Eigenvalues of finite matrices, in
-  ##    Survey of Numerical Analysis, J. Todd, ed., McGraw-Hill, New York,
-  ##    pp. 279-313, 1962. (States the totally positive property on p. 295.)
+  ##   References:
+  ##   N.J. Higham, Accuracy and Stability of Numerical Algorithms,
+  ##     Society for Industrial and Applied Mathematics, Philadelphia, PA,
+  ##     USA, 1996; sec. 26.1.
+  ##   D.E. Knuth, The Art of Computer Programming, Volume 1,
+  ##     Fundamental Algorithms, second edition, Addison-Wesley, Reading,
+  ##     Massachusetts, 1973, p. 36.
+  ##   E.E. Tyrtyshnikov, Cauchy-Toeplitz matrices and some applications,
+  ##     Linear Algebra and Appl., 149 (1991), pp. 1-18.
+  ##     O. Taussky and M. Marcus, Eigenvalues of finite matrices, in
+  ##     Survey of Numerical Analysis, J. Todd, ed., McGraw-Hill, New York,
+  ##     pp. 279-313, 1962. (States the totally positive property on p. 295.)
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for cauchy matrix.");
   elseif (! isnumeric (x))
     error ("gallery: X must be numeric for cauchy matrix.");
   elseif (nargin == 2 && ! isnumeric (y))
     error ("gallery: Y must be numeric for cauchy matrix.");
   endif
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -72,10 +72,10 @@ endfunction
 %!error discrete_cdf (1)
 %!error discrete_cdf (1,2)
 %!error discrete_cdf (1,2,3,4)
 %!error discrete_cdf (1, ones (2), ones (2,1))
 %!error discrete_cdf (1, [1 ; NaN], ones (2,1))
 %!error discrete_cdf (1, ones (2,1), ones (1,1))
 %!error discrete_cdf (1, ones (2,1), [1 -1])
 %!error discrete_cdf (1, ones (2,1), [1 NaN])
-%!error discrete_cdf (1, ones (2,1), [0  0])
+%!error discrete_cdf (1, ones (2,1), [0 0])
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -111,17 +111,17 @@ function [pval, ks] = kolmogorov_smirnov
 
 endfunction
 
 
 ## test for recognition of unifcdf function
 %!assert (kolmogorov_smirnov_test (0:100, "unif", 0, 100), 1.0, eps)
 ## test for recognition of logistic_cdf function
 %!assert (kolmogorov_smirnov_test (0:100, "logistic"), 0)
-## test for  F < G
+## test for F < G
 %!assert (kolmogorov_smirnov_test (50:100, "unif", 0, 50, "<"))
 
 %!error kolmogorov_smirnov_test (1)
 %!error <X must be a vector> kolmogorov_smirnov_test ({}, "unif", 2, 4)
 %!error <no not_a_distcdf or not_a_dist_cdf function found>
 %! kolmogorov_smirnov_test (1, "not_a_dist");
 %!error <alternative foo not recognized>
 %! kolmogorov_smirnov_test (1, "unif", 2, 4, "foo");
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -475,20 +475,20 @@ endfunction
 
 ## must give a small tolerance for floating point errors on relative
 %!assert (100+100*eps, 100, -2*eps)
 %!assert (100, 100+100*eps, -2*eps)
 %!error <Rel err .* exceeds tol> assert (100+300*eps, 100, -2*eps)
 %!error <Rel err .* exceeds tol> assert (100, 100+300*eps, -2*eps)
 
 ## test relative vs. absolute tolerances
-%!test  assert (0.1+eps, 0.1,  2*eps);
+%!test  assert (0.1+eps, 0.1, 2*eps);
 %!error <Rel err 2.2204e-0?15 exceeds tol> assert (0.1+eps, 0.1, -2*eps);
 %!test  assert (100+100*eps, 100, -2*eps);
-%!error <Abs err 2.8422e-0?14 exceeds tol> assert (100+100*eps, 100,  2*eps);
+%!error <Abs err 2.8422e-0?14 exceeds tol> assert (100+100*eps, 100, 2*eps);
 
 ## Corner case of relative tolerance with 0 divider
 %!error <Abs err 2 exceeds tol 0.1> assert (2, 0, -0.1)
 
 ## Extra checking of inputs when tolerance unspecified.
 %!error <Class single != double> assert (single (1), 1)
 %!error <Class uint8 != uint16> assert (uint8 (1), uint16 (1))
 %!error <sparse != non-sparse> assert (sparse([1]), [1])
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -103,17 +103,17 @@
 ##
 ## If a matrix or cell array of dates is given, a column vector of date strings
 ## is returned.
 ##
 ## @seealso{datenum, datevec, date, now, clock}
 ## @end deftypefn
 
 ## FIXME: parse arbitrary code strings.
-## e.g., for  Wednesday 2001-03-05 09:04:06 AM, use
+## e.g., for Wednesday 2001-03-05 09:04:06 AM, use
 ##     yy    01
 ##     yyyy  2001
 ##     m     M
 ##     mm    03
 ##     mmm   Mar
 ##     d     W
 ##     dd    05
 ##     ddd   Wed
diff --git a/test/classes/classes.tst b/test/classes/classes.tst
--- a/test/classes/classes.tst
+++ b/test/classes/classes.tst
@@ -326,17 +326,17 @@
 %!test x2 = [x1 x1];
 %!assert (isa (x2, 'Blork') && isequal (size (x2), [1 2]))
 %!test x2 = [x1 51];
 %!assert (isa (x2, 'Blork') && isequal (size (x2), [1 2]))
 %!test x3 = [x2; x2];
 %!assert (isa (x3, 'Blork') && isequal (size (x3), [2 2]))
 %!test x3 = [x2; [51 x1]];
 %!assert (isa (x3, 'Blork') && isequal (size (x3), [2 2]))
-%!error <dimension mismatch> x4 = [x1  x3];
+%!error <dimension mismatch> x4 = [x1, x3];
 %!error <dimension mismatch> x4 = [x1; x3];
 
 %%%%%%%%%%%%%%%%%%%%%%%%
 %% Testing precedence %%
 %%%%%%%%%%%%%%%%%%%%%%%%
 
 %% default: leftmost object wins
 %!shared A, B
diff --git a/test/jit.tst b/test/jit.tst
--- a/test/jit.tst
+++ b/test/jit.tst
@@ -419,17 +419,17 @@
 
 %!testif HAVE_LLVM
 %! jit_failcnt (0)
 %! m = [1 2 3];
 %! for i=1:1001
 %!   m = sin (m);
 %!   break;
 %! endfor
-%! assert (m == sin ([1  2 3]));
+%! assert (m == sin ([1 2 3]));
 %! assert (jit_failcnt, 0);
 
 %!testif HAVE_LLVM
 %! jit_failcnt (0)
 %! i = 0;
 %! while i < 10
 %!   i += 1;
 %! endwhile
