# HG changeset patch
# User jwe
# Date 1131658849 0
#      Thu Nov 10 21:40:49 2005 +0000
# Node ID 667ad2becb638b99f9d9cf82d11f61adb97edeb9
# Parent  8ad54ce6a831b9b38a4d7481f03e9aac08103492
[project @ 2005-11-10 21:40:48 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,13 @@
+2005-11-09  John W. Eaton  <jwe@octave.org>
+
+	* oct-inttypes.h (octave_int::operator char (void) const):
+	New conversion op.
+
 2005-11-01  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (distclean): Also remove oct-types.h.
 	From Quentin Spencer <qspencer@ieee.org>.
 
 2005-10-31  David Bateman  <dbateman@free.fr>
 
 	* dSparse.cc, CSparse.cc: Use C++ true/false instead of
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -252,16 +252,18 @@ public:
     // symmetric, which causes things like -intmin("int32") to be the
     // same as intmin("int32") instead of intmax("int32") (which is
     // what we should get with saturation semantics).
 
     return std::numeric_limits<T>::is_signed ?
       OCTAVE_INT_FIT_TO_RANGE (- static_cast<double> (ival), T) : 0;
   }
 
+  operator char (void) const { return static_cast<char> (value ()); }
+
   operator double (void) const { return static_cast<double> (value ()); }
 
   operator float (void) const { return static_cast<float> (value ()); }
 
   octave_int<T>& operator += (const octave_int<T>& x)
   {
     double t = static_cast<double> (value ());
     double tx = static_cast<double> (x.value ());
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,52 @@
+2005-11-10  John W. Eaton  <jwe@octave.org>
+
+	* ov-str-mat.h (octave_char_matrix_str::permute,
+	octave_char_matrix_str::resize): New functions.
+	(octave_char_matrix_sq_str::reshape,
+	octave_char_matrix_sq_str::permute,
+	octave_char_matrix_sq_str::resize): New functions.
+
+	* OPERATORS/op-str-str.cc, OPERATORS/op-str-s.cc,
+	OPERATORS/op-str-m.cc: Use DEFNDCHARCATOP_FN.
+
+	* data.cc (do_cat): No need to handle character arrays specially here.
+
+	* ops.h (DEFNDCHARCATOP_FN): New macro.
+	* OPERATORS/op-int.h (OCTAVE_INT_CHAR_CONCAT_FN, 
+	OCTAVE_CHAR_INT_CONCAT_FN, OCTAVE_INSTALL_INT_CHAR_CONCAT_FN,
+	OCTAVE_INSTALL_CHAR_INT_CONCAT_FN): New macros.
+	* OPERATORS/op-int-concat.cc: Use them do define char/int op functions.
+	(install_int_concat_ops): Install char/int concat ops.
+
+	* ov-scalar.h (class octave_scalar): Provide extractors
+	for all int array types and char array type.
+
+2005-11-09  John W. Eaton  <jwe@octave.org>
+
+	* ov-bool-mat.h (class octave_bool_matrix): Provide extractors
+	for all int array types and char array type.
+	* ov-bool.h (class octave_bool): Likewise.
+
+	* ov-intx.h (class OCTAVE_VALUE_INT_MATRIX_T): Provide extractors
+	for all int array types and char array type.
+	(class OCTAVE_VALUE_INT_SCALAR_T): Provide extractors for all int
+	scalar and array types and char array type.
+
+	* pt-mat.cc (tm_const::class_nm): New data member.
+	(tm_const::tm_const): Initialize it.
+	(tm_const::class_name): New function.
+	(tm_row_const::tm_row_const_rep::class_nm): New data member.
+	(tm_row_const::tm_row_const_rep::tm_row_const_rep): Initialize it.
+	(tm_row_const::class_name): New function.
+	(get_concat_class): New function.
+	(tm_row_const::tm_row_const_rep::do_init_element): Use it.
+	(tm_const::init): Use it.
+
 2005-11-07  John W. Eaton  <jwe@octave.org>
 
 	* strfns.cc (Fstrcmp): If args are not strings or cell arrays of
 	strings, return false.
 
 2005-11-01  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (oct-gperf.h): Avoid extra temporary file.
diff --git a/src/OPERATORS/op-int-concat.cc b/src/OPERATORS/op-int-concat.cc
--- a/src/OPERATORS/op-int-concat.cc
+++ b/src/OPERATORS/op-int-concat.cc
@@ -135,16 +135,36 @@ OCTAVE_DOUBLE_INT_CONCAT_FN (int16)
 OCTAVE_DOUBLE_INT_CONCAT_FN (int32)
 OCTAVE_DOUBLE_INT_CONCAT_FN (int64)
 	      	   
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint8)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint16)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint32)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint64)
 
+OCTAVE_INT_CHAR_CONCAT_FN (int8)
+OCTAVE_INT_CHAR_CONCAT_FN (int16)
+OCTAVE_INT_CHAR_CONCAT_FN (int32)
+OCTAVE_INT_CHAR_CONCAT_FN (int64)
+
+OCTAVE_INT_CHAR_CONCAT_FN (uint8)
+OCTAVE_INT_CHAR_CONCAT_FN (uint16)
+OCTAVE_INT_CHAR_CONCAT_FN (uint32)
+OCTAVE_INT_CHAR_CONCAT_FN (uint64)
+
+OCTAVE_CHAR_INT_CONCAT_FN (int8)
+OCTAVE_CHAR_INT_CONCAT_FN (int16)
+OCTAVE_CHAR_INT_CONCAT_FN (int32)
+OCTAVE_CHAR_INT_CONCAT_FN (int64)
+	      	   
+OCTAVE_CHAR_INT_CONCAT_FN (uint8)
+OCTAVE_CHAR_INT_CONCAT_FN (uint16)
+OCTAVE_CHAR_INT_CONCAT_FN (uint32)
+OCTAVE_CHAR_INT_CONCAT_FN (uint64)
+
 void
 install_int_concat_ops (void)
 {
   OCTAVE_INSTALL_CONCAT_FN2 (int8, int16);
   OCTAVE_INSTALL_CONCAT_FN2 (int8, int32);
   OCTAVE_INSTALL_CONCAT_FN2 (int8, int64);
 
   OCTAVE_INSTALL_CONCAT_FN2 (int8, uint8);
@@ -229,15 +249,35 @@ install_int_concat_ops (void)
   OCTAVE_INSTALL_DOUBLE_INT_CONCAT_FN (int16);
   OCTAVE_INSTALL_DOUBLE_INT_CONCAT_FN (int32);
   OCTAVE_INSTALL_DOUBLE_INT_CONCAT_FN (int64);
 
   OCTAVE_INSTALL_DOUBLE_INT_CONCAT_FN (uint8);
   OCTAVE_INSTALL_DOUBLE_INT_CONCAT_FN (uint16);
   OCTAVE_INSTALL_DOUBLE_INT_CONCAT_FN (uint32);
   OCTAVE_INSTALL_DOUBLE_INT_CONCAT_FN (uint64);
+
+  OCTAVE_INSTALL_INT_CHAR_CONCAT_FN (int8);
+  OCTAVE_INSTALL_INT_CHAR_CONCAT_FN (int16);
+  OCTAVE_INSTALL_INT_CHAR_CONCAT_FN (int32);
+  OCTAVE_INSTALL_INT_CHAR_CONCAT_FN (int64);
+
+  OCTAVE_INSTALL_INT_CHAR_CONCAT_FN (uint8);
+  OCTAVE_INSTALL_INT_CHAR_CONCAT_FN (uint16);
+  OCTAVE_INSTALL_INT_CHAR_CONCAT_FN (uint32);
+  OCTAVE_INSTALL_INT_CHAR_CONCAT_FN (uint64);
+
+  OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (int8);
+  OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (int16);
+  OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (int32);
+  OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (int64);
+
+  OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (uint8);
+  OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (uint16);
+  OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (uint32);
+  OCTAVE_INSTALL_CHAR_INT_CONCAT_FN (uint64);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -54,16 +54,39 @@ 02110-1301, USA.
   DEFNDCATOP_FN2 (TYPE ## _ ## double ## _m_m, TYPE ## _matrix, matrix, , TYPE ## NDArray, TYPE ## _array, array, concat)
 
 #define OCTAVE_INSTALL_INT_DOUBLE_CONCAT_FN(TYPE) \
   INSTALL_CATOP (octave_ ## TYPE ## _scalar, octave_scalar, TYPE ## _ ## double ## _s_s) \
   INSTALL_CATOP (octave_ ## TYPE ## _scalar, octave_matrix, TYPE ## _ ## double ## _s_m) \
   INSTALL_CATOP (octave_ ## TYPE ## _matrix, octave_scalar, TYPE ## _ ## double ## _m_s) \
   INSTALL_CATOP (octave_ ## TYPE ## _matrix, octave_matrix, TYPE ## _ ## double ## _m_m)
 
+// For compatibility, concatenation with a character always returns a
+// character.
+
+#define OCTAVE_CHAR_INT_CONCAT_FN(TYPE) \
+  DEFNDCHARCATOP_FN (char ## _ ## TYPE ## _m_s, char_matrix, TYPE ## _scalar, concat) \
+  DEFNDCHARCATOP_FN (char ## _ ## TYPE ## _m_m, char_matrix, TYPE ## _matrix, concat)
+
+#define OCTAVE_INSTALL_CHAR_INT_CONCAT_FN(TYPE) \
+  INSTALL_CATOP (octave_char_matrix_str, octave_ ## TYPE ## _scalar, char ## _ ## TYPE ## _m_s) \
+  INSTALL_CATOP (octave_char_matrix_str, octave_ ## TYPE ## _matrix, char ## _ ## TYPE ## _m_m) \
+  INSTALL_CATOP (octave_char_matrix_sq_str, octave_ ## TYPE ## _scalar, char ## _ ## TYPE ## _m_s) \
+  INSTALL_CATOP (octave_char_matrix_sq_str, octave_ ## TYPE ## _matrix, char ## _ ## TYPE ## _m_m)
+
+#define OCTAVE_INT_CHAR_CONCAT_FN(TYPE) \
+  DEFNDCHARCATOP_FN (TYPE ## _ ## char ## _s_m, TYPE ## _scalar, char_matrix, concat) \
+  DEFNDCHARCATOP_FN (TYPE ## _ ## char ## _m_m, TYPE ## _matrix, char_matrix, concat)
+
+#define OCTAVE_INSTALL_INT_CHAR_CONCAT_FN(TYPE) \
+  INSTALL_CATOP (octave_ ## TYPE ## _scalar, octave_char_matrix_str, TYPE ## _ ## char ## _s_m) \
+  INSTALL_CATOP (octave_ ## TYPE ## _matrix, octave_char_matrix_str, TYPE ## _ ## char ## _m_m) \
+  INSTALL_CATOP (octave_ ## TYPE ## _scalar, octave_char_matrix_sq_str, TYPE ## _ ## char ## _s_m) \
+  INSTALL_CATOP (octave_ ## TYPE ## _matrix, octave_char_matrix_sq_str, TYPE ## _ ## char ## _m_m)
+
 #define OCTAVE_CONCAT_FN(TYPE) \
   DEFNDCATOP_FN (TYPE ## _s_s, TYPE ## _scalar, TYPE ## _scalar, TYPE ## _array, TYPE ## _array, concat) \
   DEFNDCATOP_FN (TYPE ## _s_m, TYPE ## _scalar, TYPE ## _matrix, TYPE ## _array, TYPE ## _array, concat) \
   DEFNDCATOP_FN (TYPE ## _m_s, TYPE ## _matrix, TYPE ## _scalar, TYPE ## _array, TYPE ## _array, concat) \
   DEFNDCATOP_FN (TYPE ## _m_m, TYPE ## _matrix, TYPE ## _matrix, TYPE ## _array, TYPE ## _array, concat)
 
 #define OCTAVE_INSTALL_CONCAT_FN(TYPE) \
   INSTALL_CATOP (octave_ ## TYPE ## _scalar, octave_ ## TYPE ## _scalar, TYPE ## _s_s) \
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -120,17 +120,17 @@ DEFBINOP (el_ldiv, scalar, sparse_comple
 DEFBINOP_FN (el_and, scalar, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or, scalar, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (s_scm, scalar, sparse_compelx_matrix)
 {
   CAST_BINOP_ARGS (octave_scalar&, const octave_sparse_complex_matrix&);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value
-    (tmp. concat (v2.sparse_complex_matrix_value (), ra_idx));
+    (tmp.concat (v2.sparse_complex_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, scalar, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_sparse_complex_matrix 
     (SparseComplexMatrix (v.complex_matrix_value ()));
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -112,17 +112,17 @@ DEFBINOP (el_ldiv, scalar, sparse_matrix
 
 DEFBINOP_FN (el_and, scalar, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  scalar, sparse_matrix, mx_el_or)
 
 DEFCATOP (s_sm, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (octave_scalar&, const octave_sparse_matrix&);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
-  return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
+  return octave_value (tmp.concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_matrix_conv, scalar, sparse_matrix)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_sparse_matrix (SparseMatrix (v.matrix_value ()));
 }
diff --git a/src/OPERATORS/op-str-m.cc b/src/OPERATORS/op-str-m.cc
--- a/src/OPERATORS/op-str-m.cc
+++ b/src/OPERATORS/op-str-m.cc
@@ -42,39 +42,19 @@ DEFASSIGNOP (assign, char_matrix_str, oc
 				  a1.is_sq_string () ? '\'' : '"');
 
   if (! error_state)
     v1.assign (idx, tmp.char_matrix_value ());
 
   return octave_value ();
 }
 
-DEFCATOP (str_m, char_matrix_str, matrix)
-{
-  CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_matrix&);
-
-  if (Vwarn_num_to_str)
-    gripe_implicit_conversion (v2.type_name (), v1.type_name ());
-
-  return octave_value (v1.char_array_value (). concat (v2.array_value (), 
-						       ra_idx),
-		       true, a1.is_sq_string () ? '\'' : '"');
-}
+DEFNDCHARCATOP_FN (str_m, char_matrix_str, matrix, concat)
 
-DEFCATOP (m_str, matrix, char_matrix_str)
-{
-  CAST_BINOP_ARGS (octave_matrix&, const octave_char_matrix_str&);
-
-  if (Vwarn_num_to_str)
-    gripe_implicit_conversion (v1.type_name (), v2.type_name ());
-
-  return octave_value (v1.array_value (). concat (v2.char_array_value (), 
-						  ra_idx),
-		       true, a2.is_sq_string () ? '\'' : '"');
-}
+DEFNDCHARCATOP_FN (m_str, matrix, char_matrix_str, concat)
 
 void
 install_str_m_ops (void)
 {
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_matrix, assign);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_matrix, str_m);
diff --git a/src/OPERATORS/op-str-s.cc b/src/OPERATORS/op-str-s.cc
--- a/src/OPERATORS/op-str-s.cc
+++ b/src/OPERATORS/op-str-s.cc
@@ -42,39 +42,19 @@ DEFASSIGNOP (assign, char_matrix_str, oc
  				  a1.is_sq_string () ? '\'' : '"');
 
   if (! error_state)
     v1.assign (idx, tmp.char_matrix_value ());
 
   return octave_value ();
 }
 
-DEFCATOP (str_s, char_matrix_str, scalar)
-{
-  CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_scalar&);
-
-  if (Vwarn_num_to_str)
-    gripe_implicit_conversion (v2.type_name (), v1.type_name ());
-
-  return octave_value (v1.char_array_value (). concat (v2.array_value (),
-						       ra_idx),
-		       true, a1.is_sq_string () ? '\'' : '"');
-}
+DEFNDCHARCATOP_FN (str_s, char_matrix_str, scalar, concat)
 
-DEFCATOP (s_str, scalar, char_matrix_str)
-{
-  CAST_BINOP_ARGS (octave_scalar&, const octave_char_matrix_str&);
-
-  if (Vwarn_num_to_str)
-    gripe_implicit_conversion (v1.type_name (), v2.type_name ());
-
-  return octave_value (v1.array_value (). concat (v2.char_array_value (), 
-						  ra_idx),
-		       true, a2.is_sq_string () ? '\'' : '"');
-}
+DEFNDCHARCATOP_FN (s_str, scalar, char_matrix_str, concat)
 
 void
 install_str_s_ops (void)
 {
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_scalar, assign);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_scalar, str_s);
diff --git a/src/OPERATORS/op-str-str.cc b/src/OPERATORS/op-str-str.cc
--- a/src/OPERATORS/op-str-str.cc
+++ b/src/OPERATORS/op-str-str.cc
@@ -110,25 +110,17 @@ DEFBINOP (ne, char_matrix_str, char_matr
 DEFASSIGNOP (assign, char_matrix_str, char_matrix_str)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_char_matrix_str&);
 
   v1.assign (idx, v2.char_matrix_value ());
   return octave_value ();
 }
 
-DEFCATOP (str_str, char_matrix_str, char_matrix_str)
-{
-  CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_char_matrix_str&);
-  return octave_value (v1.char_array_value (). concat (v2.char_array_value (), 
-						       ra_idx),
-		       true,
-		       (a1.is_sq_string () && a2.is_sq_string ()
-			? '\'' : '"'));
-}
+DEFNDCHARCATOP_FN (str_str, char_matrix_str, char_matrix_str, concat)
 
 void
 install_str_str_ops (void)
 {
   INSTALL_UNOP (op_transpose, octave_char_matrix_str, transpose);
   INSTALL_UNOP (op_transpose, octave_char_matrix_sq_str, transpose);
 
   INSTALL_UNOP (op_hermitian, octave_char_matrix_str, transpose);
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -726,61 +726,51 @@ do_cat (const octave_value_list& args, s
 	  // It should be noted that resize operation is also significantly 
 	  // slower than the do_cat_op function, so it makes sense to have an
 	  // empty matrix and copy all data.
 	  //
 	  // We might also start with a empty octave_value using
 	  //   tmp = octave_value_typeinfo::lookup_type (args(1).type_name());
 	  // and then directly resize. However, for some types there might be
 	  // some additional setup needed, and so this should be avoided.
+
 	  octave_value tmp;
-          bool any_strings = false;
-          bool all_strings = true;
-	  bool first_non_empty_arg = true;
+
           for (int i = 1; i < n_args; i++)
-	    if (! args (i).all_zero_dims ())
-	      {
-		if (first_non_empty_arg)
-		  {
-		    first_non_empty_arg = false;
-		    tmp = args (i);
-		  }
+	    {
+	      if (! args (i).all_zero_dims ())
+		{
+		  tmp = args (i);
+		  break;
+		}
+	    }
 
-		if (args(i).is_string ())
-		  any_strings = true;
-		else
-		  all_strings = false;
-	      }
-
-	  if (all_strings)
-	    tmp = octave_value (charNDArray (dv, Vstring_fill_char), true);
-	  else
-	    tmp = tmp.resize (dim_vector (0,0)).resize (dv);
+	  tmp = tmp.resize (dim_vector (0,0)).resize (dv);
 
 	  if (error_state)
 	    return retval;
 
 	  Array<int> ra_idx (dv.length (), 0);
+
 	  for (int i = 1; i < n_args; i++)
 	    {
 	      tmp = do_cat_op (tmp, args (i), ra_idx);
 
 	      if (error_state)
 		return retval;
 
 	      dim_vector dv_tmp = args (i).dims ();
+
 	      ra_idx (dim) += (dim < dv_tmp.length () ? dv_tmp (dim) : 1);
 	    }
 
-          if (any_strings && !all_strings)
-            retval = tmp.convert_to_str ();
-          else
-	    retval = tmp;
+	  retval = tmp;
 	}
-      else print_usage (fname);
+      else
+	error ("%s: invalid dimension argument", fname.c_str ());
     }
   else
     print_usage (fname);
  
   return retval;
 }
 
 DEFUN (horzcat, args, ,
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -329,24 +329,34 @@ extern void install_ops (void);
   CATOPDECL (name, a1, a2)
 
 // XXX FIXME XXX -- in some cases, the constructor isn't necessary.
 
 #define DEFCATOP_FN(name, t1, t2, f) \
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (octave_ ## t1&, const octave_ ## t2&); \
-    return octave_value (v1.t1 ## _value (). f (v2.t2 ## _value (), ra_idx)); \
+    return octave_value (v1.t1 ## _value () . f (v2.t2 ## _value (), ra_idx)); \
   }
 
 #define DEFNDCATOP_FN(name, t1, t2, e1, e2, f) \
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (octave_ ## t1&, const octave_ ## t2&); \
-    return octave_value (v1.e1 ## _value (). f (v2.e2 ## _value (), ra_idx)); \
+    return octave_value (v1.e1 ## _value () . f (v2.e2 ## _value (), ra_idx)); \
+  }
+
+#define DEFNDCHARCATOP_FN(name, t1, t2, f) \
+  CATOPDECL (name, a1, a2) \
+  { \
+    CAST_BINOP_ARGS (octave_ ## t1&, const octave_ ## t2&); \
+ \
+    return octave_value (v1.char_array_value () . f (v2.char_array_value (), ra_idx), \
+			 true, ((a1.is_sq_string () || a2.is_sq_string ()) \
+				? '\'' : '"')); \
   }
 
 // For compatibility, the second arg is always converted to the type
 // of the first.  Hmm.
 
 #define DEFNDCATOP_FN2(name, t1, t2, tc1, tc2, e1, e2, f) \
   CATOPDECL (name, a1, a2) \
   { \
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -79,16 +79,40 @@ public:
   bool is_bool_matrix (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const;
 
+  int8NDArray
+  int8_array_value (void) const { return int8NDArray (matrix); }
+
+  int16NDArray
+  int16_array_value (void) const { return int16NDArray (matrix); }
+
+  int32NDArray
+  int32_array_value (void) const { return int32NDArray (matrix); }
+
+  int64NDArray
+  int64_array_value (void) const { return int64NDArray (matrix); }
+
+  uint8NDArray
+  uint8_array_value (void) const { return uint8NDArray (matrix); }
+
+  uint16NDArray
+  uint16_array_value (void) const { return uint16NDArray (matrix); }
+
+  uint32NDArray
+  uint32_array_value (void) const { return uint32NDArray (matrix); }
+
+  uint64NDArray
+  uint64_array_value (void) const { return uint64NDArray (matrix); }
+
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
     { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const
     { return Matrix (matrix.matrix_value ()); }
 
@@ -98,16 +122,29 @@ public:
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return ComplexMatrix (matrix.matrix_value ( )); }
 
   ComplexNDArray complex_array_value (bool = false) const
     { return ComplexNDArray (matrix); }
 
+  charNDArray
+  char_array_value (bool = false) const
+  {
+    charNDArray retval (dims ());
+
+    octave_idx_type nel = numel ();
+  
+    for (octave_idx_type i = 0; i < nel; i++)
+      retval(i) = static_cast<char>(matrix(i));
+
+    return retval;
+  }
+
   boolMatrix bool_matrix_value (void) const
     { return matrix.matrix_value (); }
 
   boolNDArray bool_array_value (void) const
     { return matrix; }
 
   SparseMatrix sparse_matrix_value (bool = false) const
   { return SparseMatrix (Matrix (matrix.matrix_value ())); }
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -78,16 +78,48 @@ public:
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const { return scalar; }
 
   bool valid_as_zero_index (void) const { return ! scalar; }
 
   bool is_true (void) const { return scalar; }
 
+  int8NDArray
+  int8_array_value (void) const
+    { return int8NDArray (dim_vector (1, 1), scalar); }
+
+  int16NDArray
+  int16_array_value (void) const
+    { return int16NDArray (dim_vector (1, 1), scalar); }
+
+  int32NDArray
+  int32_array_value (void) const
+    { return int32NDArray (dim_vector (1, 1), scalar); }
+
+  int64NDArray
+  int64_array_value (void) const
+    { return int64NDArray (dim_vector (1, 1), scalar); }
+
+  uint8NDArray
+  uint8_array_value (void) const
+    { return uint8NDArray (dim_vector (1, 1), scalar); }
+
+  uint16NDArray
+  uint16_array_value (void) const
+    { return uint16NDArray (dim_vector (1, 1), scalar); }
+
+  uint32NDArray
+  uint32_array_value (void) const
+    { return uint32NDArray (dim_vector (1, 1), scalar); }
+
+  uint64NDArray
+  uint64_array_value (void) const
+    { return uint64NDArray (dim_vector (1, 1), scalar); }
+
   double double_value (bool = false) const { return scalar; }
 
   double scalar_value (bool = false) const { return scalar; }
 
   Matrix matrix_value (bool = false) const
     { return Matrix (1, 1, scalar); }
 
   NDArray array_value (bool = false) const
@@ -96,16 +128,24 @@ public:
   Complex complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return  ComplexMatrix (1, 1, Complex (scalar)); }
 
   ComplexNDArray complex_array_value (bool = false) const
     { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
+  charNDArray
+  char_array_value (bool = false) const
+  {
+    charNDArray retval (dim_vector (1, 1));
+    retval(0) = static_cast<char> (scalar);
+    return retval;
+  }
+
   bool bool_value (void) const { return scalar; }
 
   boolMatrix bool_matrix_value (void) const
     { return boolMatrix (1, 1, scalar); }
 
   boolNDArray bool_array_value (void) const
     { return boolNDArray (dim_vector (1, 1), scalar); }
 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -53,19 +53,39 @@ public:
   ~OCTAVE_VALUE_INT_MATRIX_T (void) { }
 
   octave_value *clone (void) const
     { return new OCTAVE_VALUE_INT_MATRIX_T (*this); }
 
   octave_value *empty_clone (void) const
     { return new OCTAVE_VALUE_INT_MATRIX_T (); }
 
-  OCTAVE_INT_NDARRAY_T
-  OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (void) const
-    { return matrix; }
+  int8NDArray
+  int8_array_value (void) const { return int8NDArray (matrix); }
+
+  int16NDArray
+  int16_array_value (void) const { return int16NDArray (matrix); }
+
+  int32NDArray
+  int32_array_value (void) const { return int32NDArray (matrix); }
+
+  int64NDArray
+  int64_array_value (void) const { return int64NDArray (matrix); }
+
+  uint8NDArray
+  uint8_array_value (void) const { return uint8NDArray (matrix); }
+
+  uint16NDArray
+  uint16_array_value (void) const { return uint16NDArray (matrix); }
+
+  uint32NDArray
+  uint32_array_value (void) const { return uint32NDArray (matrix); }
+
+  uint64NDArray
+  uint64_array_value (void) const { return uint64NDArray (matrix); }
 
   double
   double_value (bool = false) const
     {
       double retval = lo_ieee_nan_value ();
 
       if (numel () > 0)
 	{
@@ -99,16 +119,29 @@ public:
     { 
       ComplexNDArray retval (matrix.dims ()); 
       int nel = matrix.numel ();
       for (int i = 0; i < nel; i++)
         retval(i) = Complex (double (matrix(i)));
       return retval;
     }
 
+  charNDArray
+  char_array_value (bool = false) const
+  {
+    charNDArray retval (dims ());
+
+    octave_idx_type nel = numel ();
+  
+    for (octave_idx_type i = 0; i < nel; i++)
+      retval(i) = static_cast<char>(matrix(i));
+
+    return retval;
+  }
+
   idx_vector index_vector (void) const { return idx_vector (matrix); }
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
 private:
@@ -161,52 +194,108 @@ public:
 	     (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION ())); 
 
 	  retval = tmp.do_index_op (idx, resize_ok);
 	}
 
       return retval;
     }
 
-  OCTAVE_INT_T
-  OCTAVE_VALUE_INT_SCALAR_EXTRACTOR_FUNCTION (void) const
-    { return scalar; }
+  octave_int8
+  int8_scalar_value (void) const { return octave_int8 (scalar); }
+
+  octave_int16
+  int16_scalar_value (void) const { return octave_int16 (scalar); }
+
+  octave_int32
+  int32_scalar_value (void) const { return octave_int32 (scalar); }
+
+  octave_int64
+  int64_scalar_value (void) const { return octave_int64 (scalar); }
+
+  octave_uint8
+  uint8_scalar_value (void) const { return octave_uint8 (scalar); }
+
+  octave_uint16
+  uint16_scalar_value (void) const { return octave_uint16 (scalar); }
+
+  octave_uint32
+  uint32_scalar_value (void) const { return octave_uint32 (scalar); }
+
+  octave_uint64
+  uint64_scalar_value (void) const { return octave_uint64 (scalar); }
+
+  int8NDArray
+  int8_array_value (void) const
+    { return int8NDArray (dim_vector (1, 1), scalar); }
 
-  OCTAVE_INT_NDARRAY_T
-  OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (void) const
-    { return OCTAVE_INT_NDARRAY_T (dim_vector (1, 1), scalar); }
+  int16NDArray
+  int16_array_value (void) const
+    { return int16NDArray (dim_vector (1, 1), scalar); }
+
+  int32NDArray
+  int32_array_value (void) const
+    { return int32NDArray (dim_vector (1, 1), scalar); }
+
+  int64NDArray
+  int64_array_value (void) const
+    { return int64NDArray (dim_vector (1, 1), scalar); }
+
+  uint8NDArray
+  uint8_array_value (void) const
+    { return uint8NDArray (dim_vector (1, 1), scalar); }
+
+  uint16NDArray
+  uint16_array_value (void) const
+    { return uint16NDArray (dim_vector (1, 1), scalar); }
+
+  uint32NDArray
+  uint32_array_value (void) const
+    { return uint32NDArray (dim_vector (1, 1), scalar); }
+
+  uint64NDArray
+  uint64_array_value (void) const
+    { return uint64NDArray (dim_vector (1, 1), scalar); }
 
   octave_value resize (const dim_vector& dv) const
     {
       OCTAVE_INT_NDARRAY_T retval (dv);
       if (dv.numel())
 	retval(0) = scalar;
       return retval;
     }
 
   double double_value (bool = false) const { return double (scalar); }
 
   double scalar_value (bool = false) const { return double (scalar); }
 
   NDArray
   array_value (bool = false) const
     { 
-      NDArray retval (dim_vector (1,1)); 
+      NDArray retval (dim_vector (1, 1)); 
       retval(0) = double (scalar);
       return retval;
     }
 
   ComplexNDArray
   complex_array_value (bool = false) const
     { 
-      ComplexNDArray retval (dim_vector (1,1)); 
+      ComplexNDArray retval (dim_vector (1, 1));
       retval(0) = Complex (double (scalar));
       return retval;
     }
 
+  charNDArray
+  char_array_value (bool = false) const
+  {
+    charNDArray retval (dim_vector (1, 1));
+    retval(0) = static_cast<char>(scalar);
+    return retval;
+  }
+
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, octave_idx_type skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (),
 		       block_size, output_type, skip, flt_fmt);
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -86,16 +86,40 @@ public:
   idx_vector index_vector (void) const { return idx_vector (matrix); }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const;
 
+  int8NDArray
+  int8_array_value (void) const { return int8NDArray (matrix); }
+
+  int16NDArray
+  int16_array_value (void) const { return int16NDArray (matrix); }
+
+  int32NDArray
+  int32_array_value (void) const { return int32NDArray (matrix); }
+
+  int64NDArray
+  int64_array_value (void) const { return int64NDArray (matrix); }
+
+  uint8NDArray
+  uint8_array_value (void) const { return uint8NDArray (matrix); }
+
+  uint16NDArray
+  uint16_array_value (void) const { return uint16NDArray (matrix); }
+
+  uint32NDArray
+  uint32_array_value (void) const { return uint32NDArray (matrix); }
+
+  uint64NDArray
+  uint64_array_value (void) const { return uint64NDArray (matrix); }
+
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
     { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -91,16 +91,48 @@ public:
 
   bool valid_as_zero_index (void) const
     {
       return (! xisnan (scalar)
 	      && D_NINT (scalar) == scalar
 	      && NINTbig (scalar) == 0);
     }
 
+  int8NDArray
+  int8_array_value (void) const
+    { return int8NDArray (dim_vector (1, 1), scalar); }
+
+  int16NDArray
+  int16_array_value (void) const
+    { return int16NDArray (dim_vector (1, 1), scalar); }
+
+  int32NDArray
+  int32_array_value (void) const
+    { return int32NDArray (dim_vector (1, 1), scalar); }
+
+  int64NDArray
+  int64_array_value (void) const
+    { return int64NDArray (dim_vector (1, 1), scalar); }
+
+  uint8NDArray
+  uint8_array_value (void) const
+    { return uint8NDArray (dim_vector (1, 1), scalar); }
+
+  uint16NDArray
+  uint16_array_value (void) const
+    { return uint16NDArray (dim_vector (1, 1), scalar); }
+
+  uint32NDArray
+  uint32_array_value (void) const
+    { return uint32NDArray (dim_vector (1, 1), scalar); }
+
+  uint64NDArray
+  uint64_array_value (void) const
+    { return uint64NDArray (dim_vector (1, 1), scalar); }
+
   double double_value (bool = false) const { return scalar; }
 
   double scalar_value (bool = false) const { return scalar; }
 
   Matrix matrix_value (bool = false) const
     { return Matrix (1, 1, scalar); }
 
   NDArray array_value (bool = false) const
@@ -119,16 +151,29 @@ public:
   Complex complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return  ComplexMatrix (1, 1, Complex (scalar)); }
 
   ComplexNDArray complex_array_value (bool = false) const
     { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
+  charNDArray
+  char_array_value (bool = false) const
+  {
+    charNDArray retval (dim_vector (1, 1));
+    retval(0) = static_cast<char> (scalar);
+    return retval;
+  }
+
+  bool bool_value (void) const { return scalar; }
+
+  boolNDArray bool_array_value (void) const
+    { return boolNDArray (dim_vector (1, 1), scalar); }
+
   std::streamoff streamoff_value (void) const;
 
   streamoff_array streamoff_array_value (void) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void increment (void) { ++scalar; }
 
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -88,16 +88,26 @@ public:
   octave_value do_index_op (const octave_value_list& idx, int resize_ok)
     { return do_index_op_internal (idx, resize_ok); }
 
   void assign (const octave_value_list& idx, const charMatrix& rhs);
 
   octave_value reshape (const dim_vector& new_dims) const
     { return octave_value (charNDArray (matrix.reshape (new_dims)), true); }
 
+  octave_value permute (const Array<int>& vec, bool inv = false) const
+    { return octave_value (charNDArray (matrix.permute (vec, inv)), true); }
+
+  octave_value resize (const dim_vector& dv) const
+    {
+      charNDArray retval (matrix);
+      retval.resize (dv);
+      return octave_value (retval, true);
+    }
+
   bool is_string (void) const { return true; }
 
   bool is_real_type (void) const { return false; }
 
   bool is_matrix_type (void) const { return false; }
 
   bool is_numeric_type (void) const { return false; }
 
@@ -190,16 +200,29 @@ public:
   octave_char_matrix_sq_str (const octave_char_matrix_sq_str& chms)
     : octave_char_matrix_str (chms) { }
 
   ~octave_char_matrix_sq_str (void) { }
 
   octave_value *clone (void) const { return new octave_char_matrix_sq_str (*this); }
   octave_value *empty_clone (void) const { return new octave_char_matrix_sq_str (); }
 
+  octave_value reshape (const dim_vector& new_dims) const
+    { return octave_value (charNDArray (matrix.reshape (new_dims)), true, '\''); }
+
+  octave_value permute (const Array<int>& vec, bool inv = false) const
+    { return octave_value (charNDArray (matrix.permute (vec, inv)), true, '\''); }
+
+  octave_value resize (const dim_vector& dv) const
+    {
+      charNDArray retval (matrix);
+      retval.resize (dv);
+      return octave_value (retval, true, '\'');
+    }
+
   bool is_sq_string (void) const { return true; }
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok)
     { return do_index_op_internal (idx, resize_ok, '\''); }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -65,38 +65,43 @@ private:
   tm_row_const_rep : public octave_base_list<octave_value>
   {
   public:
 
     tm_row_const_rep (void)
       : count (1), dv (0, 0), all_str (false),
 	all_sq_str (false), all_dq_str (false),
 	some_str (false), all_real (false), all_cmplx (false),
-	all_mt (true), ok (false) { }
+	all_mt (true), class_nm (octave_base_value::static_class_name ()),
+	ok (false)
+    { }
 
     tm_row_const_rep (const tree_argument_list& row)
       : count (1), dv (0, 0), all_str (false), all_sq_str (false),
 	some_str (false), all_real (false), all_cmplx (false),
-	all_mt (true), ok (false)
+	all_mt (true), class_nm (octave_base_value::static_class_name ()),
+	ok (false)
     { init (row); }
 
     ~tm_row_const_rep (void) { }
 
     int count;
 
     dim_vector dv;
 
     bool all_str;
     bool all_sq_str;
     bool all_dq_str;
     bool some_str;
     bool all_real;
     bool all_cmplx;
     bool all_mt;
 
+    std::string class_nm;
+
     bool ok;
 
     bool do_init_element (tree_expression *, const octave_value&, bool&);
 
     void init (const tree_argument_list&);
 
   private:
 
@@ -158,57 +163,128 @@ public:
   bool all_strings_p (void) const { return rep->all_str; }
   bool all_sq_strings_p (void) const { return rep->all_sq_str; }
   bool all_dq_strings_p (void) const { return rep->all_dq_str; }
   bool some_strings_p (void) const { return rep->some_str; }
   bool all_real_p (void) const { return rep->all_real; }
   bool all_complex_p (void) const { return rep->all_cmplx; }
   bool all_empty_p (void) const { return rep->all_mt; }
 
+  std::string class_name (void) const { return rep->class_nm; }
+
   operator bool () const { return (rep && rep->ok); }
 
   iterator begin (void) { return rep->begin (); }
   const_iterator begin (void) const { return rep->begin (); }
 
   iterator end (void) { return rep->end (); }
   const_iterator end (void) const { return rep->end (); }
 
 private:
 
   tm_row_const_rep *rep;
 };
 
+static std::string
+get_concat_class (const std::string& c1, const std::string& c2)
+{
+  std::string retval = octave_base_value::static_class_name ();
+
+  if (c1 == c2)
+    retval = c1;
+  else
+    {
+      bool c1_is_int = (c1 == "int8" || c1 == "uint8"
+			|| c1 == "int16" || c1 == "uint16"
+			|| c1 == "int32" || c1 == "uint32"
+			|| c1 == "int64" || c1 == "uint64");
+      bool c2_is_int = (c2 == "int8" || c2 == "uint8"
+			|| c2 == "int16" || c2 == "uint16"
+			|| c2 == "int32" || c2 == "uint32"
+			|| c2 == "int64" || c2 == "uint64");
+
+      bool c1_is_char = (c1 == "char");
+      bool c2_is_char = (c2 == "char");
+
+      bool c1_is_double = (c1 == "double");
+      bool c2_is_double = (c2 == "double");
+
+      bool c1_is_single = (c1 == "single");
+      bool c2_is_single = (c2 == "single");
+
+      bool c1_is_logical = (c1 == "logical");
+      bool c2_is_logical = (c2 == "logical");
+
+      bool c1_is_built_in_type
+	= (c1_is_int || c1_is_char || c1_is_double || c1_is_single
+	   || c1_is_logical);
+
+      bool c2_is_built_in_type
+	= (c2_is_int || c2_is_char ||  c2_is_double || c2_is_single
+	   || c2_is_logical);
+
+      // Order is important here...
+
+      if (c1_is_char && c2_is_built_in_type)
+	retval = c1;
+      else if (c2_is_char && c1_is_built_in_type)
+	retval = c2;
+      else if (c1_is_int && c2_is_built_in_type)
+	retval = c1;
+      else if (c2_is_int && c1_is_built_in_type)
+	retval = c2;
+      else if (c1_is_single && c2_is_built_in_type)
+	retval = c1;
+      else if (c2_is_single && c1_is_built_in_type)
+	retval = c2;
+      else if (c1_is_double && c2_is_built_in_type)
+	retval = c1;
+      else if (c2_is_double && c1_is_built_in_type)
+	retval = c2;
+      else if (c1_is_logical && c2_is_logical)
+	retval = c1;
+    }
+
+  return retval;    
+}
+
 bool
 tm_row_const::tm_row_const_rep::do_init_element (tree_expression *elt,
 						 const octave_value& val,
 						 bool& first_elem)
 {
   octave_idx_type this_elt_nr = val.rows ();
   octave_idx_type this_elt_nc = val.columns ();
 
+  std::string this_elt_class_nm = val.class_name ();
+
   dim_vector this_elt_dv = val.dims ();
 
   if (! this_elt_dv.all_zero ())
     {
       all_mt = false;
 
       if (first_elem)
 	{
 	  first_elem = false;
 
+	  class_nm = this_elt_class_nm;
+
 	  dv.resize (this_elt_dv.length ());
 	  for (int i = 2; i < dv.length (); i++)
 	    dv.elem (i) = this_elt_dv.elem (i);
 
 	  dv.elem (0) = this_elt_nr;
 
 	  dv.elem (1) = 0;
 	}
       else
 	{
+	  class_nm = get_concat_class (class_nm, this_elt_class_nm);
+
 	  int len = (this_elt_dv.length () < dv.length ()
 		     ? this_elt_dv.length () : dv.length ());
 
 	  if (this_elt_nr != dv (0))
 	    {
 	      eval_error ("number of rows must match",
 			  elt->line (), elt->column (), this_elt_nr, dv (0));
 	      return false;
@@ -351,48 +427,53 @@ tm_row_const::tm_row_const_rep::eval_war
 class
 tm_const : public octave_base_list<tm_row_const>
 {
 public:
 
   tm_const (const tree_matrix& tm)
     : dv (0, 0), all_str (false), all_sq_str (false), all_dq_str (false),
       some_str (false), all_real (false), all_cmplx (false),
-      all_mt (true), ok (false)
-      { init (tm); }
+      all_mt (true), class_nm (octave_base_value::static_class_name ()),
+      ok (false)
+  { init (tm); }
 
   ~tm_const (void) { }
 
   octave_idx_type rows (void) const { return dv.elem (0); }
   octave_idx_type cols (void) const { return dv.elem (1); }
 
   dim_vector dims (void) const { return dv; }
 
   bool all_strings_p (void) const { return all_str; }
   bool all_sq_strings_p (void) const { return all_sq_str; }
   bool all_dq_strings_p (void) const { return all_dq_str; }
   bool some_strings_p (void) const { return some_str; }
   bool all_real_p (void) const { return all_real; }
   bool all_complex_p (void) const { return all_cmplx; }
   bool all_empty_p (void) const { return all_mt; }
 
+  std::string class_name (void) const { return class_nm; }
+
   operator bool () const { return ok; }
 
 private:
 
   dim_vector dv;
 
   bool all_str;
   bool all_sq_str;
   bool all_dq_str;
   bool some_str;
   bool all_real;
   bool all_cmplx;
   bool all_mt;
 
+  std::string class_nm;
+
   bool ok;
 
   tm_const (void);
 
   tm_const (const tm_const&);
 
   tm_const& operator = (const tm_const&);
 
@@ -458,41 +539,49 @@ tm_const::init (const tree_matrix& tm)
 	{
 	  OCTAVE_QUIT;
 
 	  tm_row_const elt = *p;
 
 	  octave_idx_type this_elt_nr = elt.rows ();
 	  octave_idx_type this_elt_nc = elt.cols ();
 
+	  std::string this_elt_class_nm = elt.class_name ();
+
 	  dim_vector this_elt_dv = elt.dims ();
 
 	  if (!this_elt_dv.all_zero ())
 	    {
 	      all_mt = false;
 
 	      if (first_elem)
 		{
 		  first_elem = false;
 
+		  class_nm = this_elt_class_nm;
+
 		  dv.resize (this_elt_dv.length ());
 		  for (int i = 2; i < dv.length (); i++)
 		    dv.elem (i) = this_elt_dv.elem (i);
 
 		  dv.elem (0) = 0;
 
 		  dv.elem (1) = this_elt_nc;
 		}
 	      else if (all_str)
 		{
+		  class_nm = get_concat_class (class_nm, this_elt_class_nm);
+
 		  if (this_elt_nc > cols ())
 		    dv.elem (1) = this_elt_nc;
 		}
 	      else
 		{
+		  class_nm = get_concat_class (class_nm, this_elt_class_nm);
+
 		  bool get_out = false;
 		  int len = (this_elt_dv.length () < dv.length ()
 			     ? this_elt_dv.length () : dv.length ());
 
 		  for (int i = 1; i < len; i++)
 		    {
 		      if (i == 1 && this_elt_nc != dv (1))
 			{
@@ -638,16 +727,27 @@ maybe_warn_string_concat (bool all_dq_st
 	    } \
  \
 	  ra_idx(0) += row.rows (); \
 	  ra_idx(1) = 0; \
 	} \
     } \
  while (0)
 
+#define DO_SINGLE_TYPE_CONCAT(TYPE, EXTRACTOR) \
+  do \
+    { \
+      TYPE result (dv); \
+ \
+      SINGLE_TYPE_CONCAT(TYPE, EXTRACTOR); \
+ \
+      retval = result; \
+    } \
+  while (0)
+
 octave_value
 tree_matrix::rvalue (void)
 {
   octave_value retval;
 
   bool all_strings_p = false;
   bool all_sq_strings_p = false;
   bool all_dq_strings_p = false;
@@ -666,44 +766,58 @@ tree_matrix::rvalue (void)
       all_dq_strings_p = tmp.all_dq_strings_p ();
       all_empty_p = tmp.all_empty_p ();
       all_real_p = tmp.all_real_p ();
       all_complex_p = tmp.all_complex_p ();
       frc_str_conv = tmp.some_strings_p ();
 
       // Try to speed up the common cases.
 
-      if (all_strings_p)
+      std::string result_type = tmp.class_name ();
+
+      if (result_type == "double")
+	{
+	  if (all_real_p)
+	    DO_SINGLE_TYPE_CONCAT (NDArray, array_value);
+	  else
+	    DO_SINGLE_TYPE_CONCAT (ComplexNDArray, complex_array_value);
+	}
+#if 0
+      else if (result_type == "single")
+#endif
+      else if (result_type == "char")
 	{
 	  char type = all_sq_strings_p ? '\'' : '"';
 
 	  maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
 
 	  charNDArray result (dv, Vstring_fill_char);
 
 	  SINGLE_TYPE_CONCAT (charNDArray, char_array_value);
 
 	  retval = octave_value (result, true, type);
 	}
-      else if (all_real_p)
-	{
-	  NDArray result (dv);
-
-	  SINGLE_TYPE_CONCAT (NDArray, array_value);
-
-	  retval = result;
-	}
-      else if (all_complex_p)
-	{
-	  ComplexNDArray result (dv);
-
-	  SINGLE_TYPE_CONCAT (ComplexNDArray, complex_array_value);
-
-	  retval = result;
-	}
+      else if (result_type == "logical")
+	DO_SINGLE_TYPE_CONCAT (boolNDArray, bool_array_value);
+      else if (result_type == "int8")
+	DO_SINGLE_TYPE_CONCAT (int8NDArray, int8_array_value);
+      else if (result_type == "int16")
+	DO_SINGLE_TYPE_CONCAT (int16NDArray, int16_array_value);
+      else if (result_type == "int32")
+	DO_SINGLE_TYPE_CONCAT (int32NDArray, int32_array_value);
+      else if (result_type == "int64")
+	DO_SINGLE_TYPE_CONCAT (int64NDArray, int64_array_value);
+      else if (result_type == "uint8")
+	DO_SINGLE_TYPE_CONCAT (uint8NDArray, uint8_array_value);
+      else if (result_type == "uint16")
+	DO_SINGLE_TYPE_CONCAT (uint16NDArray, uint16_array_value);
+      else if (result_type == "uint32")
+	DO_SINGLE_TYPE_CONCAT (uint32NDArray, uint32_array_value);
+      else if (result_type == "uint64")
+	DO_SINGLE_TYPE_CONCAT (uint64NDArray, uint64_array_value);
       else
 	{
 	  // The line below might seem crazy, since we take a copy of
 	  // the first argument, resize it to be empty and then resize
 	  // it to be full. This is done since it means that there is
 	  // no recopying of data, as would happen if we used a single
 	  // resize.  It should be noted that resize operation is also
 	  // significantly slower than the do_cat_op function, so it
