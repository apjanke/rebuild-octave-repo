# HG changeset patch
# User Rik <rik@octave.org>
# Date 1386269417 28800
#      Thu Dec 05 10:50:17 2013 -0800
# Node ID 6a71e5030df5943979e4436f5545f30391d47469
# Parent  6c706a83070f3ee471c1639acf5d9f82ddb330f2
Follow coding convention of defining and initializing only 1 variable per line in liboctinterp.

* libinterp/corefcn/balance.cc, libinterp/corefcn/bsxfun.cc,
libinterp/corefcn/cellfun.cc, libinterp/corefcn/data.cc,
libinterp/corefcn/dlmread.cc, libinterp/corefcn/dot.cc,
libinterp/corefcn/eig.cc, libinterp/corefcn/find.cc, libinterp/corefcn/gcd.cc,
libinterp/corefcn/gl-render.cc, libinterp/corefcn/gl2ps-renderer.cc,
libinterp/corefcn/graphics.cc, libinterp/corefcn/kron.cc,
libinterp/corefcn/load-save.cc, libinterp/corefcn/lookup.cc,
libinterp/corefcn/ls-hdf5.cc, libinterp/corefcn/ls-mat5.cc,
libinterp/corefcn/lu.cc, libinterp/corefcn/max.cc,
libinterp/corefcn/oct-map.cc, libinterp/corefcn/oct-obj.cc,
libinterp/corefcn/oct-stream.cc, libinterp/corefcn/sparse.cc,
libinterp/corefcn/sqrtm.cc, libinterp/corefcn/str2double.cc,
libinterp/corefcn/strfind.cc, libinterp/corefcn/strfns.cc,
libinterp/corefcn/tril.cc, libinterp/corefcn/txt-eng-ft.cc,
libinterp/corefcn/variables.cc, libinterp/corefcn/xdiv.cc,
libinterp/dldfcn/__delaunayn__.cc, libinterp/dldfcn/qr.cc,
libinterp/dldfcn/symrcm.cc, libinterp/dldfcn/tsearch.cc,
libinterp/octave-value/ov-base-diag.cc, libinterp/octave-value/ov-base-int.cc,
libinterp/octave-value/ov-base-mat.cc, libinterp/octave-value/ov-bool-mat.cc,
libinterp/octave-value/ov-bool-sparse.cc, libinterp/octave-value/ov-bool.cc,
libinterp/octave-value/ov-cell.cc, libinterp/octave-value/ov-class.cc,
libinterp/octave-value/ov-complex.cc, libinterp/octave-value/ov-cx-diag.cc,
libinterp/octave-value/ov-cx-mat.cc, libinterp/octave-value/ov-cx-sparse.cc,
libinterp/octave-value/ov-fcn-handle.cc,
libinterp/octave-value/ov-fcn-inline.cc, libinterp/octave-value/ov-float.cc,
libinterp/octave-value/ov-flt-complex.cc,
libinterp/octave-value/ov-flt-cx-diag.cc,
libinterp/octave-value/ov-flt-cx-mat.cc,
libinterp/octave-value/ov-flt-re-diag.cc,
libinterp/octave-value/ov-flt-re-mat.cc, libinterp/octave-value/ov-java.cc,
libinterp/octave-value/ov-range.cc, libinterp/octave-value/ov-re-diag.cc,
libinterp/octave-value/ov-re-mat.cc, libinterp/octave-value/ov-re-sparse.cc,
libinterp/octave-value/ov-scalar.cc, libinterp/octave-value/ov-str-mat.cc,
libinterp/octave-value/ov-usr-fcn.cc, libinterp/parse-tree/pt-cbinop.cc,
libinterp/parse-tree/pt-eval.cc, libinterp/parse-tree/pt-mat.cc:
Follow coding convention of defining and initializing only 1 variable per line
in liboctinterp.

diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -139,17 +139,18 @@ Generalized eigenvalue problem balancing
 
   if (error_state)
     return retval;
 
   // Treat AEP/GEP cases.
   if (AEPcase)
     {
       // Algebraic eigenvalue problem.
-      bool noperm = false, noscal = false;
+      bool noperm = false;
+      bool noscal = false;
       if (nargin > 1)
         {
           std::string a1s = args(1).string_value ();
           noperm = a1s == "noperm" || a1s == "S";
           noscal = a1s == "noscal" || a1s == "P";
         }
 
       // balance the AEP
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -196,17 +196,18 @@ maybe_optimized_builtin (const std::stri
 {
   octave_value retval;
 
   maybe_fill_table ();
 
   bsxfun_builtin_op op = bsxfun_builtin_lookup (name);
   if (op != bsxfun_builtin_unknown)
     {
-      builtin_type_t btyp_a = a.builtin_type (), btyp_b = b.builtin_type ();
+      builtin_type_t btyp_a = a.builtin_type ();
+      builtin_type_t btyp_b = b.builtin_type ();
 
       // Simplify single/double combinations.
       if (btyp_a == btyp_float && btyp_b == btyp_double)
         btyp_b = btyp_float;
       else if (btyp_a == btyp_double && btyp_b == btyp_float)
         btyp_a = btyp_float;
       else if (btyp_a == btyp_float_complex && btyp_b == btyp_complex)
         btyp_b = btyp_float_complex;
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1778,17 +1778,18 @@ do_num2cell (const NDA& array, const Arr
       dim_vector celldv, arraydv;
       Array<int> perm;
       do_num2cell_helper (array.dims (), dimv, celldv, arraydv, perm);
       if (error_state)
         return Cell ();
 
       NDA parray = array.permute (perm);
 
-      octave_idx_type nela = arraydv.numel (), nelc = celldv.numel ();
+      octave_idx_type nela = arraydv.numel ();
+      octave_idx_type nelc = celldv.numel ();
       parray = parray.reshape (dim_vector (nela, nelc));
 
       Cell retval (celldv);
       for (octave_idx_type i = 0; i < nelc; i++)
         {
           retval.xelem (i) = NDA (parray.column (i).reshape (arraydv));
         }
 
@@ -2031,17 +2032,18 @@ do_mat2cell_2d (const Array2D& a, const 
   if (a.rows () > 1 && a.cols () == 1 && ncidx == 1)
     ivec = 0;
   else if (a.rows () == 1 && nridx == 1 && nd == 2)
     ivec = 1;
 
   if (ivec >= 0)
     {
       // Vector split. Use 1D indexing.
-      octave_idx_type l = 0, nidx = (ivec == 0 ? nridx : ncidx);
+      octave_idx_type l = 0;
+      octave_idx_type nidx = (ivec == 0 ? nridx : ncidx);
       for (octave_idx_type i = 0; i < nidx; i++)
         {
           octave_idx_type u = l + d[ivec](i);
           retval(i) = a.index (idx_vector (l, u));
           l = u;
         }
     }
   else
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -297,17 +297,18 @@ and orientation.\n\
 */
 
 
 static octave_value
 do_hypot (const octave_value& x, const octave_value& y)
 {
   octave_value retval;
 
-  octave_value arg0 = x, arg1 = y;
+  octave_value arg0 = x;
+  octave_value arg1 = y;
   if (! arg0.is_numeric_type ())
     gripe_wrong_type_arg ("hypot", arg0);
   else if (! arg1.is_numeric_type ())
     gripe_wrong_type_arg ("hypot", arg1);
   else
     {
       if (arg0.is_complex_type ())
         arg0 = arg0.abs ();
@@ -6703,17 +6704,18 @@ do_accumarray_minmax_fun (const octave_v
     {
       idx_vector idx = args(0).index_vector ();
       octave_idx_type n = -1;
       if (nargin == 4)
         n = args(3).idx_type_value (true);
 
       if (! error_state)
         {
-          octave_value vals = args(1), zero = args (2);
+          octave_value vals = args(1);
+          octave_value zero = args(2);
 
           switch (vals.builtin_type ())
             {
             case btyp_double:
               retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
                                              zero.double_value ());
               break;
             case btyp_float:
@@ -6785,17 +6787,18 @@ do_accumdim_sum (const idx_vector& idx, 
                  int dim = -1, octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
     error ("accumdim: index out of range");
 
-  dim_vector vals_dim = vals.dims (), rdv = vals_dim;
+  dim_vector vals_dim = vals.dims ();
+  dim_vector rdv = vals_dim;
 
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
   else if (dim >= rdv.length ())
     rdv.resize (dim+1, 1);
 
   rdv(dim) = n;
 
@@ -6864,34 +6867,37 @@ template <class NDT>
 static NDT
 do_merge (const Array<bool>& mask,
           const NDT& tval, const NDT& fval)
 {
   typedef typename NDT::element_type T;
   dim_vector dv = mask.dims ();
   NDT retval (dv);
 
-  bool tscl = tval.numel () == 1, fscl = fval.numel () == 1;
+  bool tscl = tval.numel () == 1;
+  bool fscl = fval.numel () == 1;
 
   if ((! tscl && tval.dims () != dv)
       || (! fscl && fval.dims () != dv))
     error ("merge: MASK, TVAL, and FVAL dimensions must match");
   else
     {
       T *rv = retval.fortran_vec ();
       octave_idx_type n = retval.numel ();
 
-      const T *tv = tval.data (), *fv = fval.data ();
+      const T *tv = tval.data ();
+      const T *fv = fval.data ();
       const bool *mv = mask.data ();
 
       if (tscl)
         {
           if (fscl)
             {
-              T ts = tv[0], fs = fv[0];
+              T ts = tv[0];
+              T fs = fv[0];
               for (octave_idx_type i = 0; i < n; i++)
                 rv[i] = mv[i] ? ts : fs;
             }
           else
             {
               T ts = tv[0];
               for (octave_idx_type i = 0; i < n; i++)
                 rv[i] = mv[i] ? ts : fv[i];
@@ -6958,17 +6964,18 @@ it is first converted to logical.\n\
     {
       octave_value mask_val = args(0);
 
       if (mask_val.is_scalar_type ())
         retval = mask_val.is_true () ? args(1) : args(2);
       else
         {
           boolNDArray mask = mask_val.bool_array_value ();
-          octave_value tval = args(1), fval = args(2);
+          octave_value tval = args(1);
+          octave_value fval = args(2);
           if (tval.is_double_type () && fval.is_double_type ())
             {
               if (tval.is_complex_type () || fval.is_complex_type ())
                 retval = do_merge (mask,
                                    tval.complex_array_value (),
                                    fval.complex_array_value ());
               else
                 retval = do_merge (mask,
@@ -7236,17 +7243,18 @@ an empty matrix is returned.\n\
 template <class T>
 static Array<T>
 do_repelems (const Array<T>& src, const Array<octave_idx_type>& rep)
 {
   Array<T> retval;
 
   assert (rep.ndims () == 2 && rep.rows () == 2);
 
-  octave_idx_type n = rep.columns (), l = 0;
+  octave_idx_type n = rep.columns ();
+  octave_idx_type l = 0;
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_idx_type k = rep(1, i);
       if (k < 0)
         {
           error ("repelems: second row must contain non-negative numbers");
           return retval;
         }
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -259,17 +259,20 @@ fill empty fields.  The default is zero.
       else
         sep = args(1).string_value ();
 
       if (error_state)
         return retval;
     }
 
   // Take a subset if a range was given.
-  octave_idx_type r0 = 0, c0 = 0, r1 = idx_max-1, c1 = idx_max-1;
+  octave_idx_type r0 = 0;
+  octave_idx_type c0 = 0;
+  octave_idx_type r1 = idx_max-1;
+  octave_idx_type c1 = idx_max-1;
   if (nargin > 2)
     {
       if (nargin == 3)
         {
           if (!parse_range_spec (args (2), r0, c0, r1, c1))
             error ("dlmread: error parsing RANGE");
         }
       else if (nargin == 4)
@@ -282,17 +285,22 @@ fill empty fields.  The default is zero.
         }
 
       if (r0 < 0 || c0 < 0)
         error ("dlmread: left & top must be positive");
     }
 
   if (!error_state)
     {
-      octave_idx_type i = 0, j = 0, r = 1, c = 1, rmax = 0, cmax = 0;
+      octave_idx_type i = 0;
+      octave_idx_type j = 0;
+      octave_idx_type r = 1;
+      octave_idx_type c = 1;
+      octave_idx_type rmax = 0;
+      octave_idx_type cmax = 0;
 
       Matrix rdata;
       ComplexMatrix cdata;
 
       bool iscmplx = false;
       bool sepflag = false;
 
       std::string line;
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -123,21 +123,23 @@ but avoids forming a temporary array and
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     {
       print_usage ();
       return retval;
     }
 
-  octave_value argx = args(0), argy = args(1);
+  octave_value argx = args(0);
+  octave_value argy = args(1);
 
   if (argx.is_numeric_type () && argy.is_numeric_type ())
     {
-      dim_vector dimx = argx.dims (), dimy = argy.dims ();
+      dim_vector dimx = argx.dims ();
+      dim_vector dimy = argy.dims ();
       bool match = dimx == dimy;
       if (! match && nargin == 2
           && dimx.is_vector () && dimy.is_vector ())
         {
           // Change to column vectors.
           dimx = dimx.redim (1);
           argx = argx.reshape (dimx);
           dimy = dimy.redim (1);
@@ -286,23 +288,28 @@ endfor\n\
   int nargin = args.length ();
 
   if (nargin != 2)
     {
       print_usage ();
       return retval;
     }
 
-  octave_value argx = args(0), argy = args(1);
+  octave_value argx = args(0);
+  octave_value argy = args(1);
 
   if (argx.is_numeric_type () && argy.is_numeric_type ())
     {
-      const dim_vector dimx = argx.dims (), dimy = argy.dims ();
+      const dim_vector dimx = argx.dims ();
+      const dim_vector dimy = argy.dims ();
       int nd = dimx.length ();
-      octave_idx_type m = dimx(0), k = dimx(1), n = dimy(1), np = 1;
+      octave_idx_type m = dimx(0);
+      octave_idx_type k = dimx(1);
+      octave_idx_type n = dimy(1);
+      octave_idx_type np = 1;
       bool match = dimy(0) == k && nd == dimy.length ();
       dim_vector dimz = dim_vector::alloc (nd);
       dimz(0) = m;
       dimz(1) = n;
       for (int i = 2; match && i < nd; i++)
         {
           match = match && dimx(i) == dimy(i);
           dimz(i) = dimx(i);
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -57,18 +57,18 @@ The eigenvalues returned by @code{eig} a
   if (nargin > 2 || nargin == 0 || nargout > 2)
     {
       print_usage ();
       return retval;
     }
 
   octave_value arg_a, arg_b;
 
-  octave_idx_type nr_a = 0, nr_b = 0;
-  octave_idx_type nc_a = 0, nc_b = 0;
+  octave_idx_type nr_a, nr_b, nc_a, nc_b;
+  nr_a = nr_b = nc_a = nc_b = 0;
 
   arg_a = args(0);
   nr_a = arg_a.rows ();
   nc_a = arg_a.columns ();
 
   int arg_is_empty = empty_arg ("eig", nr_a, nc_a);
   if (arg_is_empty < 0)
     return retval;
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -56,17 +56,18 @@ find_nonzero_elem_idx (const Array<T>& n
     default:
     case 3:
       retval(2) = Array<T> (nda.index (idx_vector (idx)));
       // Fall through!
 
     case 2:
       {
         Array<octave_idx_type> jdx (idx.dims ());
-        octave_idx_type n = idx.length (), nr = nda.rows ();
+        octave_idx_type n = idx.length ();
+        octave_idx_type nr = nda.rows ();
         for (octave_idx_type i = 0; i < n; i++)
           {
             jdx.xelem (i) = idx.xelem (i) / nr;
             idx.xelem (i) %= nr;
           }
         iext = -1;
         retval(1) = idx_vector (jdx, -1);
       }
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -120,18 +120,19 @@ extended_gcd (double a, double b, double
 {
   if (! xisinteger (a) || ! xisinteger (b))
     (*current_liboctave_error_handler)
       ("gcd: all values must be integers");
 
   double aa = fabs (a);
   double bb = fabs (b);
 
-  double xx = 0, yy = 1;
-  double lx = 1, ly = 0;
+  double xx, lx, yy, ly;
+  xx = 0, lx = 1;
+  yy = 1, ly = 0;
 
   while (bb != 0)
     {
       double qq = gnulib::floor (aa / bb);
       double tt = fmod (aa, bb);
 
       aa = bb;
       bb = tt;
@@ -156,26 +157,28 @@ static std::complex<FP>
 extended_gcd (const std::complex<FP>& a, const std::complex<FP>& b,
               std::complex<FP>& x, std::complex<FP>& y)
 {
   if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
       || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
     (*current_liboctave_error_handler)
       ("gcd: all complex parts must be integers");
 
-  std::complex<FP> aa = a, bb = b;
+  std::complex<FP> aa = a;
+  std::complex<FP> bb = b;
   bool swapped = false;
   if (abs (aa) < abs (bb))
     {
       std::swap (aa, bb);
       swapped = true;
     }
 
-  std::complex<FP> xx = 0, lx = 1;
-  std::complex<FP> yy = 1, ly = 0;
+  std::complex<FP> xx, lx, yy, ly;
+  xx = 0, lx = 1;
+  yy = 1, ly = 0;
 
   while (abs(bb) != 0)
     {
       std::complex<FP> qq, rr;
       divide (aa, bb, qq, rr);
       aa = bb;
       bb = rr;
 
@@ -199,18 +202,19 @@ extended_gcd (const std::complex<FP>& a,
 
 template <class T>
 static octave_int<T>
 extended_gcd (const octave_int<T>& a, const octave_int<T>& b,
               octave_int<T>& x, octave_int<T>& y)
 {
   T aa = a.abs ().value ();
   T bb = b.abs ().value ();
-  T xx = 0, lx = 1;
-  T yy = 1, ly = 0;
+  T xx, lx, yy, ly;
+  xx = 0, lx = 1;
+  yy = 1, ly = 0;
 
   while (bb != 0)
     {
       T qq = aa / bb;
       T tt = aa % bb;
       aa = bb;
       bb = tt;
 
@@ -342,17 +346,18 @@ do_extended_gcd (const octave_value& a, 
 
       const T *aptr = aa.fortran_vec ();
       const T *bptr = bb.fortran_vec ();
 
       bool inca = aa.numel () != 1;
       bool incb = bb.numel () != 1;
 
       T *gptr = gg.fortran_vec ();
-      T *xptr = xx.fortran_vec (), *yptr = yy.fortran_vec ();
+      T *xptr = xx.fortran_vec ();
+      T *yptr = yy.fortran_vec ();
 
       octave_idx_type n = gg.numel ();
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_quit ();
 
           *gptr++ = extended_gcd (*aptr, *bptr, *xptr++, *yptr++);
 
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -142,17 +142,18 @@ opengl_texture::create (const octave_val
 
   dim_vector dv (data.dims ());
 
   // Expect RGB data
   if (dv.length () == 3 && dv(2) == 3)
     {
       // FIXME: dim_vectors hold octave_idx_type values.
       //        Should we check for dimensions larger than intmax?
-      int h = dv(0), w = dv(1), tw, th;
+      int h, w, tw, th;
+      h = dv(0), w = dv(1);
       GLuint id;
       bool ok = true;
 
       tw = next_power_of_2 (w);
       th = next_power_of_2 (w);
 
       glGenTextures (1, &id);
       glBindTexture (GL_TEXTURE_2D, id);
@@ -997,17 +998,18 @@ opengl_renderer::draw_axes_x_grid (const
       std::string minorgridstyle = props.get_minorgridlinestyle ();
       bool do_xgrid = (props.is_xgrid () && (gridstyle != "none"));
       bool do_xminorgrid = (props.is_xminorgrid ()
                             && (minorgridstyle != "none"));
       bool do_xminortick = props.is_xminortick ();
       Matrix xticks = xform.xscale (props.get_xtick ().matrix_value ());
       Matrix xmticks = xform.xscale (props.get_xmtick ().matrix_value ());
       string_vector xticklabels = props.get_xticklabel ().all_strings ();
-      int wmax = 0, hmax = 0;
+      int wmax = 0;
+      int hmax = 0;
       bool tick_along_z = nearhoriz || xisinf (fy);
       bool mirror = props.is_box () && xstate != AXE_ANY_DIR;
 
       set_color (props.get_xcolor_rgb ());
 
       // grid lines
       if (do_xgrid)
         render_grid (gridstyle, xticks, x_min, x_max,
@@ -1105,17 +1107,18 @@ opengl_renderer::draw_axes_y_grid (const
       std::string minorgridstyle = props.get_minorgridlinestyle ();
       bool do_ygrid = (props.is_ygrid () && (gridstyle != "none"));
       bool do_yminorgrid = (props.is_yminorgrid ()
                             && (minorgridstyle != "none"));
       bool do_yminortick = props.is_yminortick ();
       Matrix yticks = xform.yscale (props.get_ytick ().matrix_value ());
       Matrix ymticks = xform.yscale (props.get_ymtick ().matrix_value ());
       string_vector yticklabels = props.get_yticklabel ().all_strings ();
-      int wmax = 0, hmax = 0;
+      int wmax = 0;
+      int hmax = 0;
       bool tick_along_z = nearhoriz || xisinf (fx);
       bool mirror = props.is_box () && ystate != AXE_ANY_DIR
                     && (! props.has_property ("__plotyy_axes__"));
 
       set_color (props.get_ycolor_rgb ());
 
       // grid lines
       if (do_ygrid)
@@ -1204,17 +1207,18 @@ opengl_renderer::draw_axes_z_grid (const
       std::string minorgridstyle = props.get_minorgridlinestyle ();
       bool do_zgrid = (props.is_zgrid () && (gridstyle != "none"));
       bool do_zminorgrid = (props.is_zminorgrid ()
                             && (minorgridstyle != "none"));
       bool do_zminortick = props.is_zminortick ();
       Matrix zticks = xform.zscale (props.get_ztick ().matrix_value ());
       Matrix zmticks = xform.zscale (props.get_zmtick ().matrix_value ());
       string_vector zticklabels = props.get_zticklabel ().all_strings ();
-      int wmax = 0, hmax = 0;
+      int wmax = 0;
+      int hmax = 0;
       bool mirror = props.is_box () && zstate != AXE_ANY_DIR;
 
       set_color (props.get_zcolor_rgb ());
 
       // grid lines
       if (do_zgrid)
         render_grid (gridstyle, zticks, z_min, z_max,
                      xPlane, xPlaneN, yPlane, yPlaneN, 2, true);
@@ -1557,17 +1561,18 @@ opengl_renderer::draw_line (const line::
 
 void
 opengl_renderer::draw_surface (const surface::properties& props)
 {
   const Matrix x = xform.xscale (props.get_xdata ().matrix_value ());
   const Matrix y = xform.yscale (props.get_ydata ().matrix_value ());
   const Matrix z = xform.zscale (props.get_zdata ().matrix_value ());
 
-  int zr = z.rows (), zc = z.columns ();
+  int zr = z.rows ();
+  int zc = z.columns ();
 
   NDArray c;
   const NDArray n = props.get_vertexnormals ().array_value ();
 
   // FIXME: handle transparency
   Matrix a;
 
   if (props.facelighting_is ("phong") || props.edgelighting_is ("phong"))
@@ -2547,17 +2552,18 @@ opengl_renderer::draw_text (const text::
 
 }
 
 void
 opengl_renderer::draw_image (const image::properties& props)
 {
   octave_value cdata = props.get_color_data ();
   dim_vector dv (cdata.dims ());
-  int h = dv(0), w = dv(1);
+  int h = dv(0);
+  int w = dv(1);
 
   Matrix x = props.get_xdata ().matrix_value ();
   Matrix y = props.get_ydata ().matrix_value ();
 
   // Someone wants us to draw an empty image? No way.
   if (x.is_empty () || y.is_empty ())
     return;
 
@@ -2605,18 +2611,19 @@ opengl_renderer::draw_image (const image
       nor_dy = 1;
     }
 
 
   // OpenGL won't draw the image if it's origin is outside the
   // viewport/clipping plane so we must do the clipping
   // ourselfes - only draw part of the image
 
-  int j0 = 0, j1 = w;
-  int i0 = 0, i1 = h;
+  int j0, j1, i0, i1;
+  j0 = 0, j1 = w;
+  i0 = 0, i1 = h;
 
   float im_xmin = x(0) - nor_dx/2;
   float im_xmax = x(1) + nor_dx/2;
   float im_ymin = y(0) - nor_dy/2;
   float im_ymax = y(1) + nor_dy/2;
   if (props.is_clipping ()) // clip to axes
     {
       if (im_xmin < xmin)
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -39,17 +39,18 @@ glps_renderer::draw (const graphics_obje
 {
   static bool in_draw = false;
   static std::string old_print_cmd;
 
   if (!in_draw)
     {
       in_draw = true;
 
-      GLint buffsize = 0, state = GL2PS_OVERFLOW;
+      GLint buffsize = 0;
+      GLint state = GL2PS_OVERFLOW;
       GLint viewport[4];
 
       glGetIntegerv (GL_VIEWPORT, viewport);
 
       GLint gl2ps_term;
       if (term.find ("eps") != std::string::npos) gl2ps_term = GL2PS_EPS;
       else if (term.find ("pdf") != std::string::npos) gl2ps_term = GL2PS_PDF;
       else if (term.find ("svg") != std::string::npos) gl2ps_term = GL2PS_SVG;
@@ -217,17 +218,18 @@ glps_renderer::draw_text (const text::pr
 {
   if (props.get_string ().is_empty ())
     return;
 
   set_font (props);
   set_color (props.get_color_rgb ());
 
   const Matrix pos = get_transform ().scale (props.get_data_position ());
-  int halign = 0, valign = 0;
+  int halign = 0;
+  int valign = 0;
 
   if (props.horizontalalignment_is ("center"))
     halign = 1;
   else if (props.horizontalalignment_is ("right"))
     halign = 2;
 
   if (props.verticalalignment_is ("top"))
     valign = 2;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -4699,17 +4699,18 @@ axes::properties::update_camera (void)
       cameratarget = xform2cam (c_center);
     }
   else
     c_center = cam2xform (get_cameratarget ().matrix_value ());
 
   if (camerapositionmode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
-      double az = tview(0), el = tview(1);
+      double az = tview(0);
+      double el = tview(1);
       double d = 5 * sqrt (pb(0)*pb(0)+pb(1)*pb(1)+pb(2)*pb(2));
 
       if (el == 90 || el == -90)
         c_eye(2) = d*signum (el);
       else
         {
           az *= M_PI/180.0;
           el *= M_PI/180.0;
@@ -4724,17 +4725,18 @@ axes::properties::update_camera (void)
       cameraposition = xform2cam (c_eye);
     }
   else
     c_eye = cam2xform (get_cameraposition ().matrix_value ());
 
   if (cameraupvectormode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
-      double az = tview(0), el = tview(1);
+      double az = tview(0);
+      double el = tview(1);
 
       if (el == 90 || el == -90)
         {
           c_upv(0) =
             -signum (el) *sin (az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
           c_upv(1) =
             signum (el) * cos (az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
         }
@@ -4786,17 +4788,18 @@ axes::properties::update_camera (void)
   l(1,0) = u(0); l(1,1) = u(1); l(1,2) = u(2);
   l(2,0) = -f(0); l(2,1) = -f(1); l(2,2) = -f(2);
   x_view = x_view * l;
   translate (x_view, -c_eye(0), -c_eye(1), -c_eye(2));
   scale (x_view, pb(0), pb(1), pb(2));
   translate (x_view, -0.5, -0.5, -0.5);
 
   Matrix x_cube = x_view * unit_cube ();
-  ColumnVector cmin = x_cube.row_min (), cmax = x_cube.row_max ();
+  ColumnVector cmin = x_cube.row_min ();
+  ColumnVector cmax = x_cube.row_max ();
   double xM = cmax(0)-cmin(0);
   double yM = cmax(1)-cmin(1);
 
   Matrix bb = get_boundingbox (true);
 
   double v_angle;
 
   if (cameraviewanglemode_is ("auto"))
@@ -4892,19 +4895,21 @@ axes::properties::update_axes_layout (vo
 
   double xd = (xdir_is ("normal") ? 1 : -1);
   double yd = (ydir_is ("normal") ? 1 : -1);
   double zd = (zdir_is ("normal") ? 1 : -1);
 
   const Matrix xlims = xform.xscale (get_xlim ().matrix_value ());
   const Matrix ylims = xform.yscale (get_ylim ().matrix_value ());
   const Matrix zlims = xform.zscale (get_zlim ().matrix_value ());
-  double x_min = xlims(0), x_max = xlims(1);
-  double y_min = ylims(0), y_max = ylims(1);
-  double z_min = zlims(0), z_max = zlims(1);
+
+  double x_min, x_max, y_min, y_max, z_min, z_max;
+  x_min = xlims(0), x_max = xlims(1);
+  y_min = ylims(0), y_max = ylims(1);
+  z_min = zlims(0), z_max = zlims(1);
 
   ColumnVector p1, p2, dir (3);
 
   xstate = ystate = zstate = AXE_ANY_DIR;
 
   p1 = xform.transform (x_min, (y_min+y_max)/2, (z_min+z_max)/2, false);
   p2 = xform.transform (x_max, (y_min+y_max)/2, (z_min+z_max)/2, false);
   dir(0) = xround (p2(0)-p1(0));
@@ -5134,17 +5139,19 @@ axes::properties::update_xlabel_position
     {
       graphics_xform xform = get_transform ();
 
       Matrix ext (1, 2, 0.0);
       ext = get_ticklabel_extents (get_xtick ().matrix_value (),
                                    get_xticklabel ().all_strings (),
                                    get_xlim ().matrix_value ());
 
-      double wmax = ext(0), hmax = ext(1), angle = 0;
+      double wmax = ext(0);
+      double hmax = ext(1);
+      double angle = 0;
       ColumnVector p =
         graphics_xform::xform_vector ((xpTickN+xpTick)/2, ypTick, zpTick);
 
       bool tick_along_z = nearhoriz || xisinf (fy);
       if (tick_along_z)
         p(2) += (signum (zpTick-zpTickN)*fz*xtickoffset);
       else
         p(1) += (signum (ypTick-ypTickN)*fy*xtickoffset);
@@ -5235,17 +5242,19 @@ axes::properties::update_ylabel_position
       // This keeps ylabels about the same distance from y-axis as
       // xlabels are from x-axis.
       // ALWAYS use an even number for padding or horizontal alignment
       // will be off.
       ext = get_ticklabel_extents (get_ytick ().matrix_value (),
                                    get_yticklabel ().all_strings (),
                                    get_ylim ().matrix_value ());
 
-      double wmax = ext(0)+4, hmax = ext(1), angle = 0;
+      double wmax = ext(0)+4;
+      double hmax = ext(1);
+      double angle = 0;
       ColumnVector p =
         graphics_xform::xform_vector (xpTick, (ypTickN+ypTick)/2, zpTick);
 
       bool tick_along_z = nearhoriz || xisinf (fx);
       if (tick_along_z)
         p(2) += (signum (zpTick-zpTickN)*fz*ytickoffset);
       else
         p(0) += (signum (xpTick-xpTickN)*fx*ytickoffset);
@@ -5328,17 +5337,19 @@ axes::properties::update_zlabel_position
     {
       graphics_xform xform = get_transform ();
 
       Matrix ext (1, 2, 0.0);
       ext = get_ticklabel_extents (get_ztick ().matrix_value (),
                                    get_zticklabel ().all_strings (),
                                    get_zlim ().matrix_value ());
 
-      double wmax = ext(0), hmax = ext(1), angle = 0;
+      double wmax = ext(0);
+      double hmax = ext(1);
+      double angle = 0;
       ColumnVector p;
 
       if (xySym)
         {
           p = graphics_xform::xform_vector (xPlaneN, yPlane,
                                             (zpTickN+zpTick)/2);
           if (xisinf (fy))
             p(0) += (signum (xPlaneN-xPlane)*fx*ztickoffset);
@@ -6397,17 +6408,18 @@ axes::properties::get_ticklabel_extents 
                                          const string_vector& ticklabels,
                                          const Matrix& limits)
 {
 #ifndef HAVE_FREETYPE
   double fontsize = get ("fontsize").double_value ();
 #endif
 
   Matrix ext (1, 2, 0.0);
-  double wmax = 0., hmax = 0.;
+  double wmax, hmax;
+  wmax = hmax = 0.;
   int n = std::min (ticklabels.numel (), ticks.numel ());
   for (int i = 0; i < n; i++)
     {
       double val = ticks(i);
       if (limits(0) <= val && val <= limits(1))
         {
           std::string label (ticklabels(i));
           label.erase (0, label.find_first_not_of (" "));
@@ -7220,17 +7232,18 @@ text::properties::update_font (void)
 #endif
 }
 
 void
 text::properties::update_text_extent (void)
 {
 #ifdef HAVE_FREETYPE
 
-  int halign = 0, valign = 0;
+  int halign = 0;
+  int valign = 0;
 
   if (horizontalalignment_is ("center"))
     halign = 1;
   else if (horizontalalignment_is ("right"))
     halign = 2;
 
   if (verticalalignment_is ("middle"))
     valign = 1;
@@ -7363,19 +7376,21 @@ surface::properties::update_normals (voi
 {
   if (normalmode_is ("auto"))
     {
       Matrix x = get_xdata ().matrix_value ();
       Matrix y = get_ydata ().matrix_value ();
       Matrix z = get_zdata ().matrix_value ();
 
 
-      int p = z.columns (), q = z.rows ();
-      int i1 = 0, i2 = 0, i3 = 0;
-      int j1 = 0, j2 = 0, j3 = 0;
+      int p = z.columns ();
+      int q = z.rows ();
+      int i1, i2, i3, j1, j2, j3;
+      i1 = i2 = i3 = 0;
+      j1 = j2 = j3 = 0;
 
       bool x_mat = (x.rows () == q);
       bool y_mat = (y.columns () == p);
 
       NDArray n (dim_vector (q, p, 3), 0.0);
 
       for (int i = 0; i < p; i++)
         {
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -50,18 +50,20 @@ along with Octave; see the file COPYING.
 
 template <class R, class T>
 static MArray<T>
 kron (const MArray<R>& a, const MArray<T>& b)
 {
   assert (a.ndims () == 2);
   assert (b.ndims () == 2);
 
-  octave_idx_type nra = a.rows (), nrb = b.rows ();
-  octave_idx_type nca = a.cols (), ncb = b.cols ();
+  octave_idx_type nra = a.rows ();
+  octave_idx_type nrb = b.rows ();
+  octave_idx_type nca = a.cols ();
+  octave_idx_type ncb = b.cols ();
 
   MArray<T> c (dim_vector (nra*nrb, nca*ncb));
   T *cv = c.fortran_vec ();
 
   for (octave_idx_type ja = 0; ja < nca; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       for (octave_idx_type ia = 0; ia < nra; ia++)
         {
@@ -74,18 +76,21 @@ kron (const MArray<R>& a, const MArray<T
 }
 
 template <class R, class T>
 static MArray<T>
 kron (const MDiagArray2<R>& a, const MArray<T>& b)
 {
   assert (b.ndims () == 2);
 
-  octave_idx_type nra = a.rows (), nrb = b.rows (), dla = a.diag_length ();
-  octave_idx_type nca = a.cols (), ncb = b.cols ();
+  octave_idx_type nra = a.rows ();
+  octave_idx_type nrb = b.rows ();
+  octave_idx_type dla = a.diag_length ();
+  octave_idx_type nca = a.cols ();
+  octave_idx_type ncb = b.cols ();
 
   MArray<T> c (dim_vector (nra*nrb, nca*ncb), T ());
 
   for (octave_idx_type ja = 0; ja < dla; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       {
         octave_quit ();
         mx_inline_mul (nrb, &c.xelem (ja*nrb, ja*ncb + jb), a.dgelem (ja),
@@ -124,22 +129,25 @@ kron (const MSparse<T>& A, const MSparse
       }
 
   return C;
 }
 
 static PermMatrix
 kron (const PermMatrix& a, const PermMatrix& b)
 {
-  octave_idx_type na = a.rows (), nb = b.rows ();
-  const octave_idx_type *pa = a.data (), *pb = b.data ();
+  octave_idx_type na = a.rows ();
+  octave_idx_type nb = b.rows ();
+  const octave_idx_type *pa = a.data ();
+  const octave_idx_type *pb = b.data ();
   PermMatrix c(na*nb); // Row permutation.
   octave_idx_type *pc = c.fortran_vec ();
 
-  bool cola = a.is_col_perm (), colb = b.is_col_perm ();
+  bool cola = a.is_col_perm ();
+  bool colb = b.is_col_perm ();
   if (cola && colb)
     {
       for (octave_idx_type i = 0; i < na; i++)
         for (octave_idx_type j = 0; j < nb; j++)
           pc[pa[i]*nb+pb[j]] = i*nb+j;
     }
   else if (cola)
     {
@@ -277,17 +285,18 @@ Since the Kronecker product is associati
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin >= 2)
     {
-      octave_value a = args(0), b = args(1);
+      octave_value a = args(0);
+      octave_value b = args(1);
       retval = dispatch_kron (a, b);
       for (octave_idx_type i = 2; i < nargin; i++)
         retval = dispatch_kron (retval, args(i));
     }
   else
     print_usage ();
 
   return retval;
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1060,17 +1060,18 @@ save_vars (std::ostream& os, const std::
 static string_vector
 parse_save_options (const string_vector &argv,
                     load_save_format &format, bool &append,
                     bool &save_as_floats, bool &use_zlib)
 {
   string_vector retval;
   int argc = argv.length ();
 
-  bool do_double = false, do_tabs = false;
+  bool do_double = false;
+  bool do_tabs = false;
 
   for (int i = 0; i < argc; i++)
     {
       if (argv[i] == "-append")
         {
           append = true;
         }
       else if (argv[i] == "-ascii" || argv[i] == "-a")
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -110,17 +110,18 @@ template <class ArrayT>
 static octave_value
 do_numeric_lookup (const ArrayT& array, const ArrayT& values,
                    bool left_inf, bool right_inf,
                    bool match_idx, bool match_bool)
 {
   octave_value retval;
 
   Array<octave_idx_type> idx = array.lookup (values);
-  octave_idx_type n = array.numel (), nval = values.numel ();
+  octave_idx_type n = array.numel ();
+  octave_idx_type nval = values.numel ();
 
   // Post-process.
   if (match_bool)
     {
       boolNDArray match (idx.dims ());
       for (octave_idx_type i = 0; i < nval; i++)
         {
           octave_idx_type j = idx.xelem (i);
@@ -241,17 +242,18 @@ at most n-1).\n\
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3 || (nargin == 3 && ! args(2).is_string ()))
     {
       print_usage ();
       return retval;
     }
 
-  octave_value table = args(0), y = args(1);
+  octave_value table = args(0);
+  octave_value y = args(1);
   if (table.ndims () > 2 || (table.columns () > 1 && table.rows () > 1))
     warning ("lookup: table is not a vector");
 
   bool num_case = ((table.is_numeric_type () && y.is_numeric_type ())
                    || (table.is_char_matrix () && y.is_char_matrix ()));
   bool str_case = table.is_cellstr () && (y.is_string () || y.is_cellstr ());
   bool left_inf = false;
   bool right_inf = false;
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -733,17 +733,18 @@ hdf5_add_scalar_attr (hid_t loc_id, hid_
 //    = 0  Not an empty matrix; did nothing
 //    < 0  Error condition
 int
 save_hdf5_empty (hid_t loc_id, const char *name, const dim_vector d)
 {
   hsize_t sz = d.length ();
   OCTAVE_LOCAL_BUFFER (octave_idx_type, dims, sz);
   bool empty = false;
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid = -1;
+  hid_t data_hid = -1;
   int retval;
   for (hsize_t i = 0; i < sz; i++)
     {
       dims[i] = d(i);
       if (dims[i] < 1)
         empty = true;
     }
 
@@ -860,17 +861,19 @@ save_type_to_hdf5 (save_type st)
 // (stored as HDF5 groups).
 
 bool
 add_hdf5_data (hid_t loc_id, const octave_value& tc,
                const std::string& name, const std::string& doc,
                bool mark_as_global, bool save_as_floats)
 {
   hsize_t dims[3];
-  hid_t type_id = -1, space_id = -1, data_id = -1, data_type_id = -1;
+  hid_t type_id, space_id, data_id, data_type_id;
+  type_id = space_id = data_id = data_type_id = -1;
+
   bool retval = false;
   octave_value val = tc;
   // FIXME: diagonal & permutation matrices currently don't know how to save
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
   if (val.is_diag_matrix () || val.is_perm_matrix ()
       || val.type_id () == octave_lazy_index::static_type_id ())
     val = val.full_value ();
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1555,17 +1555,18 @@ skip_ahead:
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
 
 int
 read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet,
                               const std::string& filename)
 {
-  int16_t version=0, magic=0;
+  int16_t version = 0;
+  int16_t magic = 0;
   uint64_t subsys_offset;
 
   is.seekg (116, std::ios::beg);
   is.read (reinterpret_cast<char *> (&subsys_offset), 8);
 
   is.seekg (124, std::ios::beg);
   is.read (reinterpret_cast<char *> (&version), 2);
   is.read (reinterpret_cast<char *> (&magic), 2);
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -583,17 +583,19 @@ information.\n\
 %!error lu ()
 %!error <can not define pivoting threshold> lu ([1, 2; 3, 4], 2)
 */
 
 static
 bool check_lu_dims (const octave_value& l, const octave_value& u,
                     const octave_value& p)
 {
-  octave_idx_type m = l.rows (), k = u.rows (), n = u.columns ();
+  octave_idx_type m = l.rows ();
+  octave_idx_type k = u.rows ();
+  octave_idx_type n = u.columns ();
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
           && k == std::min (m, n) &&
           (p.is_undefined () || p.rows () == m));
 }
 
 DEFUN (luupdate, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -349,18 +349,20 @@ do_minmax_body (const octave_value_list&
           retval = do_minmax_red_op<boolNDArray> (arg, nargout, dim, ismin);
           break;
         default:
           gripe_wrong_type_arg (func, arg);
         }
     }
   else if (nargin == 2)
     {
-      octave_value argx = args(0), argy = args(1);
-      builtin_type_t xtyp = argx.builtin_type (), ytyp = argy.builtin_type ();
+      octave_value argx = args(0);
+      octave_value argy = args(1);
+      builtin_type_t xtyp = argx.builtin_type ();
+      builtin_type_t ytyp = argy.builtin_type ();
       builtin_type_t rtyp;
       if (xtyp == btyp_char && ytyp == btyp_char)
         rtyp = btyp_char;
       else
         rtyp = btyp_mixed_numeric (xtyp, ytyp);
 
       switch (rtyp)
         {
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -112,17 +112,18 @@ octave_fields::orderfields (Array<octave
 }
 
 bool
 octave_fields::equal_up_to_order (const octave_fields& other,
                                   octave_idx_type* perm) const
 {
   bool retval = true;
 
-  iterator p = begin (), q = other.begin ();
+  iterator p = begin ();
+  iterator q = other.begin ();
   for (; p != end () && q != other.end (); p++, q++)
     {
       if (p->first == q->first)
         perm[p->second] = q->second;
       else
         {
           retval = false;
           break;
diff --git a/libinterp/corefcn/oct-obj.cc b/libinterp/corefcn/oct-obj.cc
--- a/libinterp/corefcn/oct-obj.cc
+++ b/libinterp/corefcn/oct-obj.cc
@@ -30,17 +30,18 @@ along with Octave; see the file COPYING.
 #include "Cell.h"
 
 // We are likely to have a lot of octave_value_list objects to allocate,
 // so make the grow_size large.
 DEFINE_OCTAVE_ALLOCATOR2(octave_value_list, 1024);
 
 octave_value_list::octave_value_list (const std::list<octave_value_list>& lst)
 {
-  octave_idx_type n = 0, nel = 0;
+  octave_idx_type n = 0;
+  octave_idx_type nel = 0;
 
   // Determine number.
   for (std::list<octave_value_list>::const_iterator p = lst.begin ();
        p != lst.end (); p++)
     {
       n++;
       nel += p->length ();
     }
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -1048,17 +1048,18 @@ octave_base_stream::skipl (off_t num, bo
   err = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       std::istream& is = *isp;
 
-      int c = 0, lastc = -1;
+      int c = 0;
+      int lastc = -1;
       cnt = 0;
 
       while (is && (c = is.get ()) != EOF)
         {
           // Handle CRLF, CR, or LF as line ending.
 
           if (c == '\r' || (c == '\n' && lastc != '\r'))
             {
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -120,17 +120,18 @@ to have a common size.\n\
         retval = arg.sparse_complex_matrix_value ();
       else if (arg.is_numeric_type ())
         retval = arg.sparse_matrix_value ();
       else
         gripe_wrong_type_arg ("sparse", arg);
     }
   else if (nargin == 2)
     {
-      octave_idx_type m = 0, n = 0;
+      octave_idx_type m = 0;
+      octave_idx_type n = 0;
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         {
           m = args(0).idx_type_value ();
           n = args(1).idx_type_value ();
         }
       else
         error ("sparse: dimensions M,N must be scalar");
 
@@ -155,17 +156,18 @@ to have a common size.\n\
           else
             error ("sparse: invalid option: %s", opt.c_str ());
 
           nargin -= 1;
         }
 
       if (! error_state)
         {
-          octave_idx_type m = -1, n = -1, nzmax = -1;
+          octave_idx_type m, n, nzmax;
+          m = n = nzmax = -1;
           if (nargin == 6)
             {
               nzmax = args(5).idx_type_value ();
               nargin --;
             }
 
           if (nargin == 5)
             {
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -96,17 +96,18 @@ do_sqrtm (const octave_value& arg)
   octave_value retval;
 
   MatrixType mt = arg.matrix_type ();
 
   bool iscomplex = arg.is_complex_type ();
 
   typedef typename Matrix::element_type real_type;
 
-  real_type cutoff = 0, one = 1;
+  real_type cutoff = 0;
+  real_type one = 1;
   real_type eps = std::numeric_limits<real_type>::epsilon ();
 
   if (! iscomplex)
     {
       Matrix x = octave_value_extract<Matrix> (arg);
 
       if (mt.is_unknown ()) // if type is not known, compute it now.
         arg.matrix_type (mt = MatrixType (x));
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -55,17 +55,18 @@ single_num (std::istringstream& is)
       is.get ();
       c = is.peek ();
     }
 
   if (std::toupper (c) == 'I')
     {
       // It's infinity.
       is.get ();
-      char c1 = is.get (), c2 = is.get ();
+      char c1 = is.get ();
+      char c2 = is.get ();
       if (std::tolower (c1) == 'n' && std::tolower (c2) == 'f')
         {
           num = octave_Inf;
           is.peek (); // May set EOF bit.
         }
       else
         is.setstate (std::ios::failbit); // indicate that read has failed.
     }
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -204,17 +204,18 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
         {
           error ("strfind: unknown option: %s", opt.c_str ());
           return retval;
         }
     }
 
   if (nargin == 2)
     {
-      octave_value argstr = args(0), argpat = args(1);
+      octave_value argstr = args(0);
+      octave_value argpat = args(1);
       if (argpat.is_string ())
         {
           Array<char> needle = argpat.char_array_value ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
           qs_preprocess (needle, table);
 
           if (argstr.is_string ())
             retval = octave_value (qs_search (needle,
@@ -274,17 +275,19 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
 static Array<char>
 qs_replace (const Array<char>& str, const Array<char>& pat,
             const Array<char>& rep,
             const octave_idx_type *table,
             bool overlaps = true)
 {
   Array<char> ret = str;
 
-  octave_idx_type siz = str.numel (), psiz = pat.numel (), rsiz = rep.numel ();
+  octave_idx_type siz = str.numel ();
+  octave_idx_type psiz = pat.numel ();
+  octave_idx_type rsiz = rep.numel ();
 
   if (psiz != 0)
     {
       // Look up matches, without overlaps.
       const Array<octave_idx_type> idx = qs_search (pat, str, table, overlaps);
       octave_idx_type nidx = idx.numel ();
 
       if (nidx)
@@ -307,17 +310,18 @@ qs_replace (const Array<char>& str, cons
                 }
 
               retsiz += siz - k;
             }
           else
             retsiz = siz + nidx * (rsiz - psiz);
 
           ret.clear (dim_vector (1, retsiz));
-          const char *src = str.data (), *reps = rep.data ();
+          const char *src = str.data ();
+          const char *reps = rep.data ();
           char *dest = ret.fortran_vec ();
 
           octave_idx_type k = 0;
           for (octave_idx_type i = 0; i < nidx; i++)
             {
               octave_idx_type j = idx(i);
               if (j >= k)
                 dest = std::copy (src + k, src + j, dest);
@@ -375,17 +379,19 @@ strrep (\"This is a test string\", \"is\
         {
           error ("strrep: unknown option: %s", opt.c_str ());
           return retval;
         }
     }
 
   if (nargin == 3)
     {
-      octave_value argstr = args(0), argpat = args(1), argrep = args(2);
+      octave_value argstr = args(0);
+      octave_value argpat = args(1);
+      octave_value argrep = args(2);
       if (argpat.is_string () && argrep.is_string ())
         {
           const Array<char> pat = argpat.char_array_value ();
           const Array<char> rep = argrep.char_array_value ();
 
           OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
           qs_preprocess (pat, table);
 
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -642,28 +642,30 @@ This is just the opposite of the corresp
 %!error strcmp ("foo", "bar", 3)
 */
 
 // Apparently, Matlab ignores the dims with strncmp. It also
 static bool
 strncmp_array_op (const charNDArray& s1, const charNDArray& s2,
                   octave_idx_type n)
 {
-  octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
+  octave_idx_type l1 = s1.numel ();
+  octave_idx_type l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
 // Otherwise, just use strings. Note that we neither extract substrings (which
 // would mean a copy, at least in GCC), nor use string::compare (which is a
 // 3-way compare).
 static bool
 strncmp_str_op (const std::string& s1, const std::string& s2, octave_idx_type n)
 {
-  octave_idx_type l1 = s1.length (), l2 = s2.length ();
+  octave_idx_type l1 = s1.length ();
+  octave_idx_type l2 = s2.length ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
 DEFUN (strncmp, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmp (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} characters of strings @var{s1} and @var{s2} are\n\
@@ -794,28 +796,30 @@ This is just the opposite of the corresp
 %!assert (strcmpi ("abc123", "ABC123"), true)
 */
 
 // Like strncmp.
 static bool
 strncmpi_array_op (const charNDArray& s1, const charNDArray& s2,
                    octave_idx_type n)
 {
-  octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
+  octave_idx_type l1 = s1.numel ();
+  octave_idx_type l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data (),
                          icmp_char_eq ()));
 }
 
 // Ditto.
 static bool
 strncmpi_str_op (const std::string& s1, const std::string& s2,
                  octave_idx_type n)
 {
-  octave_idx_type l1 = s1.length (), l2 = s2.length ();
+  octave_idx_type l1 = s1.length ();
+  octave_idx_type l2 = s2.length ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data (),
                          icmp_char_eq ()));
 }
 
 DEFUNX ("strncmpi", Fstrncmpi, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmpi (@var{s1}, @var{s2}, @var{n})\n\
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -37,17 +37,18 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-obj.h"
 
 // The bulk of the work.
 template <class T>
 static Array<T>
 do_tril (const Array<T>& a, octave_idx_type k, bool pack)
 {
-  octave_idx_type nr = a.rows (), nc = a.columns ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.columns ();
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
       octave_idx_type j1 = std::min (std::max (zero, k), nc);
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
       octave_idx_type n = j1 * nr + ((j2 - j1) * (nr-(j1-k) + nr-(j2-1-k))) / 2;
@@ -78,17 +79,18 @@ do_tril (const Array<T>& a, octave_idx_t
       return r;
     }
 }
 
 template <class T>
 static Array<T>
 do_triu (const Array<T>& a, octave_idx_type k, bool pack)
 {
-  octave_idx_type nr = a.rows (), nc = a.columns ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.columns ();
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
       octave_idx_type j1 = std::min (std::max (zero, k), nc);
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
       octave_idx_type n
@@ -269,17 +271,18 @@ do_trilu (const std::string& name,
                            name.c_str (), arg.class_name ().c_str ());
                     return octave_value ();
                   }
 
                 octave_value tmp = arg;
                 if (arg.numel () == 0)
                   return arg;
 
-                octave_idx_type nr = dims(0), nc = dims (1);
+                octave_idx_type nr = dims(0);
+                octave_idx_type nc = dims(1);
 
                 // The sole purpose of the below is to force the correct
                 // matrix size. This would not be necessary if the
                 // octave_value resize function allowed a fill_value.
                 // It also allows odd attributes in some user types
                 // to be handled. With a fill_value ot should be replaced
                 // with
                 //
diff --git a/libinterp/corefcn/txt-eng-ft.cc b/libinterp/corefcn/txt-eng-ft.cc
--- a/libinterp/corefcn/txt-eng-ft.cc
+++ b/libinterp/corefcn/txt-eng-ft.cc
@@ -630,17 +630,18 @@ ft_render::process_character (FT_ULong c
 void
 ft_render::visit (text_element_string& e)
 {
   if (font.is_valid ())
     {
       FT_UInt glyph_index, previous = 0;
 
       std::string str = e.string_value ();
-      size_t n = str.length (), curr = 0;
+      size_t n = str.length ();
+      size_t curr = 0;
       mbstate_t ps;
       memset (&ps, 0, sizeof (ps));  // Initialize state to 0.
       wchar_t wc;
 
       while (n > 0)
         {
           size_t r = gnulib::mbrtowc (&wc, str.data () + curr, n, &ps);
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1400,17 +1400,19 @@ public:
         param.command = '\0';
 
         if (Vwhos_line_format[idx] == '%')
           {
             bool error_encountered = false;
             param.modifier = 'r';
             param.parameter_length = 0;
 
-            int a = 0, b = -1, balance = 1;
+            int a = 0;
+            int b = -1;
+            int balance = 1;
             unsigned int items;
             size_t pos;
             std::string cmd;
 
             // Parse one command from whos_line_format
             cmd = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
             pos = cmd.find (';');
             if (pos != std::string::npos)
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -708,17 +708,19 @@ xleftdiv (const FloatComplexMatrix& a, c
 
 template <class MT, class DMT>
 MT
 mdm_div_impl (const MT& a, const DMT& d)
 {
   if (! mx_div_conform (a, d))
     return MT ();
 
-  octave_idx_type m = a.rows (), n = d.rows (), l = d.length ();
+  octave_idx_type m = a.rows ();
+  octave_idx_type n = d.rows ();
+  octave_idx_type l = d.length ();
   MT x (m, n);
   typedef typename DMT::element_type S;
   typedef typename MT::element_type T;
   const T *aa = a.data ();
   const S *dd = d.data ();
   T *xx = x.fortran_vec ();
 
   for (octave_idx_type j = 0; j < l; j++)
@@ -789,17 +791,20 @@ xdiv (const FloatComplexMatrix& a, const
 
 template <class MT, class DMT>
 MT
 dmm_leftdiv_impl (const DMT& d, const MT& a)
 {
   if (! mx_leftdiv_conform (d, a, blas_no_trans))
     return MT ();
 
-  octave_idx_type m = d.cols (), n = a.cols (), k = a.rows (), l = d.length ();
+  octave_idx_type m = d.cols ();
+  octave_idx_type n = a.cols ();
+  octave_idx_type k = a.rows ();
+  octave_idx_type l = d.length ();
   MT x (m, n);
   typedef typename DMT::element_type S;
   typedef typename MT::element_type T;
   const T *aa = a.data ();
   const S *dd = d.data ();
   T *xx = x.fortran_vec ();
 
   for (octave_idx_type j = 0; j < n; j++)
@@ -866,18 +871,21 @@ xleftdiv (const FloatComplexDiagMatrix& 
 
 template <class MT, class DMT>
 MT
 dmdm_div_impl (const MT& a, const DMT& d)
 {
   if (! mx_div_conform (a, d))
     return MT ();
 
-  octave_idx_type m = a.rows (), n = d.rows (), k = d.cols ();
-  octave_idx_type l = std::min (m, n), lk = std::min (l, k);
+  octave_idx_type m = a.rows ();
+  octave_idx_type n = d.rows ();
+  octave_idx_type k = d.cols ();
+  octave_idx_type l = std::min (m, n);
+  octave_idx_type lk = std::min (l, k);
   MT x (m, n);
   typedef typename DMT::element_type S;
   typedef typename MT::element_type T;
   const T *aa = a.data ();
   const S *dd = d.data ();
   T *xx = x.fortran_vec ();
 
   for (octave_idx_type i = 0; i < lk; i++)
@@ -938,18 +946,21 @@ xdiv (const FloatComplexDiagMatrix& a, c
 
 template <class MT, class DMT>
 MT
 dmdm_leftdiv_impl (const DMT& d, const MT& a)
 {
   if (! mx_leftdiv_conform (d, a, blas_no_trans))
     return MT ();
 
-  octave_idx_type m = d.cols (), n = a.cols (), k = d.rows ();
-  octave_idx_type l = std::min (m, n), lk = std::min (l, k);
+  octave_idx_type m = d.cols ();
+  octave_idx_type n = a.cols ();
+  octave_idx_type k = d.rows ();
+  octave_idx_type l = std::min (m, n);
+  octave_idx_type lk = std::min (l, k);
   MT x (m, n);
   typedef typename DMT::element_type S;
   typedef typename MT::element_type T;
   const T *aa = a.data ();
   const S *dd = d.data ();
   T *xx = x.fortran_vec ();
 
   for (octave_idx_type i = 0; i < lk; i++)
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -170,17 +170,18 @@ Undocumented internal function.\n\
                                    ismalloc, flags, outfile, errfile);
       if (! exitcode)
         {
           // triangulate non-simplicial facets
           qh_triangulate ();
 
           facetT *facet;
           vertexT *vertex, **vertexp;
-          octave_idx_type nf = 0, i = 0;
+          octave_idx_type nf = 0;
+          octave_idx_type i = 0;
 
           FORALLfacets
             {
               if (! facet->upperdelaunay)
                 nf++;
 
               // Double check.  Non-simplicial facets will cause segfault below
               if (! facet->simplicial)
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -739,17 +739,19 @@ x = @var{R} \\ @var{C}\n\
 
 %!error qr (sprandn (10,10,0.2), ones (10,1))
 */
 
 static
 bool check_qr_dims (const octave_value& q, const octave_value& r,
                     bool allow_ecf = false)
 {
-  octave_idx_type m = q.rows (), k = r.rows (), n = r.columns ();
+  octave_idx_type m = q.rows ();
+  octave_idx_type k = r.rows ();
+  octave_idx_type n = r.columns ();
   return ((q.ndims () == 2 && r.ndims () == 2 && k == q.columns ())
           && (m == k || (allow_ecf && k == n && k < m)));
 }
 
 static
 bool check_index (const octave_value& i, bool vector_allowed = false)
 {
   return ((i.is_real_type () || i.is_integer_type ())
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -482,17 +482,18 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
 
   if (nr == 0 && nc == 0)
     return octave_value (NDArray (dim_vector (1, 0)));
 
   // sizes of the heaps
   octave_idx_type s = 0;
 
   // head- and tail-indices for the queue
-  octave_idx_type qt = 0, qh = 0;
+  octave_idx_type qt = 0;
+  octave_idx_type qh = 0;
   CMK_Node v, w;
   // dimension of the matrix
   octave_idx_type N = nr;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, cidx2, N + 1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, ridx2, cidx[N]);
   transpose (N, ridx, cidx, ridx2, cidx2);
 
diff --git a/libinterp/dldfcn/tsearch.cc b/libinterp/dldfcn/tsearch.cc
--- a/libinterp/dldfcn/tsearch.cc
+++ b/libinterp/dldfcn/tsearch.cc
@@ -105,18 +105,20 @@ points @code{(@var{xi}, @var{yi})}.  For
       maxx(k) = max (REF (x, k, 0), REF (x, k, 1), REF (x, k, 2)) + eps;
       miny(k) = min (REF (y, k, 0), REF (y, k, 1), REF (y, k, 2)) - eps;
       maxy(k) = max (REF (y, k, 0), REF (y, k, 1), REF (y, k, 2)) + eps;
     }
 
   const octave_idx_type np = xi.length ();
   ColumnVector values (np);
 
-  double x0 = 0.0, y0 = 0.0;
-  double a11 = 0.0, a12 = 0.0, a21 = 0.0, a22 = 0.0, det = 0.0;
+  double x0, y0, a11, a12, a21, a22, det;
+  x0 = y0 = 0.0;
+  a11 = a12 = a21 = a22 = 0.0;
+  det = 0.0;
 
   octave_idx_type k = nelem; // k is a counter of elements
   for (octave_idx_type kp = 0; kp < np; kp++)
     {
       const double xt = xi(kp);
       const double yt = yi(kp);
 
       // check if last triangle contains the next point
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -436,17 +436,18 @@ octave_base_diag<DMT, MT>::save_ascii (s
 
   return true;
 }
 
 template <class DMT, class MT>
 bool
 octave_base_diag<DMT, MT>::load_ascii (std::istream& is)
 {
-  octave_idx_type r = 0, c = 0;
+  octave_idx_type r = 0;
+  octave_idx_type c = 0;
   bool success = true;
 
   if (extract_keyword (is, "rows", r, true)
       && extract_keyword (is, "columns", c, true))
     {
       octave_idx_type l = r < c ? r : c;
       MT tmp (l, 1);
       is >> tmp;
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -342,17 +342,18 @@ octave_base_int_matrix<T>::save_hdf5 (hi
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   bool retval = true;
   dim_vector dv = this->dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
 
@@ -545,17 +546,18 @@ octave_base_int_scalar<T>::load_binary (
 
 template <class T>
 bool
 octave_base_int_scalar<T>::save_hdf5 (hid_t loc_id, const char *name, bool)
 {
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   bool retval = true;
   hsize_t dimens[3];
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -346,17 +346,18 @@ octave_base_matrix<MT>::assign (const oc
           }
 
         if (! error_state)
           {
             if (scalar_opt)
               {
                 // optimize all scalar indices. Don't construct an index array,
                 // but rather calc a scalar index directly.
-                octave_idx_type k = 1, j = 0;
+                octave_idx_type k = 1;
+                octave_idx_type j = 0;
                 for (octave_idx_type i = 0; i < n_idx; i++)
                   {
                     j += idx_vec(i)(0) * k;
                     k *= dv (i);
                   }
                 matrix(j) = rhs;
               }
             else
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -416,17 +416,18 @@ octave_bool_matrix::save_hdf5 (hid_t loc
                                bool /* save_as_floats */)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
   boolNDArray m = bool_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -353,17 +353,18 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT,
                                H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
   SparseBoolMatrix m = sparse_bool_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -160,17 +160,18 @@ octave_bool::load_binary (std::istream& 
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_bool::save_hdf5 (hid_t loc_id, const char *name,
                         bool /* save_as_floats */)
 {
   hsize_t dimens[3];
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1072,17 +1072,18 @@ bool
 octave_cell::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   hsize_t rank = dv.length ();
-  hid_t space_hid = -1, data_hid = -1, size_hid = -1;
+  hid_t space_hid, data_hid, size_hid;
+  space_hid = data_hid = size_hid = -1;
 
 #if HAVE_HDF5_18
   data_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
 
   if (data_hid < 0)
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1274,17 +1274,18 @@ octave_class::clear_exemplar_map (void)
 //  do so.  If successful, a "true" value is returned.
 //
 //  Note that we don't check the loaded object structure against the
 //  class structure here so the user's loadobj method has a chance
 //  to do its magic.
 bool
 octave_class::reconstruct_parents (void)
 {
-  bool retval = true, might_have_inheritance = false;
+  bool retval = true;
+  bool might_have_inheritance = false;
   std::string dbgstr = "dork";
 
   // First, check to see if there might be an issue with inheritance.
   for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
       std::string  key = map.key (p);
       Cell         val = map.contents (p);
       if ( val(0).is_object () )
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -310,17 +310,18 @@ octave_complex::load_binary (std::istrea
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_complex::save_hdf5 (hid_t loc_id, const char *name,
                            bool /* save_as_floats */)
 {
   hsize_t dimens[3];
-  hid_t space_hid = -1, type_hid = -1, data_hid = -1;
+  hid_t space_hid, type_hid, data_hid;
+  space_hid = type_hid = data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0)
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -162,17 +162,18 @@ octave_complex_diag_matrix::map (unary_m
       return to_dense ().map (umap);
     }
 }
 
 bool
 octave_complex_diag_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
-  int32_t r = matrix.rows (), c = matrix.cols ();
+  int32_t r = matrix.rows ();
+  int32_t c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   ComplexMatrix m = ComplexMatrix (matrix.extract_diag ());
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -556,17 +556,18 @@ octave_complex_matrix::save_hdf5 (hid_t 
                                   bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
-  hid_t space_hid = -1, data_hid = -1, type_hid = -1;
+  hid_t space_hid, data_hid, type_hid;
+  space_hid = data_hid = type_hid = -1;
   bool retval = true;
   ComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -385,17 +385,18 @@ octave_sparse_complex_matrix::save_hdf5 
   hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT,
                                H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
   SparseComplexMatrix m = sparse_complex_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -716,17 +716,18 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
 #if HAVE_HDF5_18
   group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
-  hid_t space_hid = -1, data_hid = -1, type_hid = -1;;
+  hid_t space_hid, data_hid, type_hid;
+  space_hid = data_hid = type_hid = -1;
 
   // attach the type of the variable
   type_hid = H5Tcopy (H5T_C_S1);
   H5Tset_size (type_hid, nm.length () + 1);
   if (type_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -286,17 +286,18 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
 #endif
   if (group_hid < 0 ) return false;
 
   size_t len = 0;
   for (int i = 0; i < ifargs.length (); i++)
     if (len < ifargs(i).length ())
       len = ifargs(i).length ();
 
-  hid_t space_hid = -1, data_hid = -1, type_hid = -1;;
+  hid_t space_hid, data_hid, type_hid;
+  space_hid = data_hid = type_hid = -1;
   bool retval = true;
 
   // FIXME: Is there a better way of saving string vectors,
   //        than a null padded matrix?
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, 2);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -186,17 +186,18 @@ octave_float_scalar::load_binary (std::i
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_float_scalar::save_hdf5 (hid_t loc_id, const char *name,
                                 bool /* save_as_floats */)
 {
   hsize_t dimens[3];
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -295,17 +295,18 @@ octave_float_complex::load_binary (std::
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_float_complex::save_hdf5 (hid_t loc_id, const char *name,
                                  bool /* save_as_floats */)
 {
   hsize_t dimens[3];
-  hid_t space_hid = -1, type_hid = -1, data_hid = -1;
+  hid_t space_hid, type_hid, data_hid;
+  space_hid = type_hid = data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
   if (type_hid < 0)
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -145,17 +145,18 @@ octave_float_complex_diag_matrix::map (u
 }
 
 
 bool
 octave_float_complex_diag_matrix::save_binary (std::ostream& os,
                                                bool& /* save_as_floats */)
 {
 
-  int32_t r = matrix.rows (), c = matrix.cols ();
+  int32_t r = matrix.rows ();
+  int32_t c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   FloatComplexMatrix m = FloatComplexMatrix (matrix.extract_diag ());
   save_type st = LS_FLOAT;
   if (matrix.length () > 4096) // FIXME: make this configurable.
     {
       float max_val, min_val;
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -531,17 +531,18 @@ bool
 octave_float_complex_matrix::save_hdf5 (hid_t loc_id, const char *name, bool)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
-  hid_t space_hid = -1, data_hid = -1, type_hid = -1;
+  hid_t space_hid, data_hid, type_hid;
+  space_hid = data_hid = type_hid = -1;
   bool retval = true;
   FloatComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -114,17 +114,18 @@ octave_float_diag_matrix::map (unary_map
     }
 }
 
 bool
 octave_float_diag_matrix::save_binary (std::ostream& os,
                                        bool& /* save_as_floats*/)
 {
 
-  int32_t r = matrix.rows (), c = matrix.cols ();
+  int32_t r = matrix.rows ();
+  int32_t c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   FloatMatrix m = FloatMatrix (matrix.extract_diag ());
   save_type st = LS_FLOAT;
   if (matrix.length () > 8192) // FIXME: make this configurable.
     {
       float max_val, min_val;
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -558,17 +558,18 @@ bool
 octave_float_matrix::save_hdf5 (hid_t loc_id, const char *name, bool)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
   FloatNDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1145,17 +1145,18 @@ box_more (JNIEnv* jni_env, jobject jobj,
 
       if (retval.is_undefined ())
         {
           cls = jni_env->FindClass ("[[D");
 
           if (jni_env->IsInstanceOf (jobj, cls))
             {
               jobjectArray jarr = reinterpret_cast<jobjectArray> (jobj);
-              int rows = jni_env->GetArrayLength (jarr), cols = 0;
+              int rows = jni_env->GetArrayLength (jarr);
+              int cols = 0;
 
               if (rows > 0)
                 {
                   Matrix m;
 
                   for (int r = 0; r < rows; r++)
                     {
                       jdoubleArray_ref row (jni_env,
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -543,17 +543,18 @@ hdf5_make_range_type (hid_t num_type)
   return type_id;
 }
 
 bool
 octave_range::save_hdf5 (hid_t loc_id, const char *name,
                          bool /* save_as_floats */)
 {
   hsize_t dimens[3];
-  hid_t space_hid = -1, type_hid = -1, data_hid = -1;
+  hid_t space_hid, type_hid, data_hid;
+  space_hid = type_hid = data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
   type_hid = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0)
     {
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -174,17 +174,18 @@ octave_diag_matrix::map (unary_mapper_t 
       return to_dense ().map (umap);
     }
 }
 
 bool
 octave_diag_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
-  int32_t r = matrix.rows (), c = matrix.cols ();
+  int32_t r = matrix.rows ();
+  int32_t c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   Matrix m = Matrix (matrix.extract_diag ());
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -670,17 +670,18 @@ bool
 octave_matrix::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
   NDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -416,17 +416,18 @@ octave_sparse_matrix::save_hdf5 (hid_t l
   hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT,
                                H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
   SparseMatrix m = sparse_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -201,17 +201,18 @@ octave_scalar::load_binary (std::istream
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_scalar::save_hdf5 (hid_t loc_id, const char *name,
                           bool /* save_as_floats */)
 {
   hsize_t dimens[3];
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -578,17 +578,18 @@ octave_char_matrix_str::save_hdf5 (hid_t
                                    bool /* save_as_floats */)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
-  hid_t space_hid = -1, data_hid = -1;
+  hid_t space_hid, data_hid;
+  space_hid = data_hid = -1;
   bool retval = true;
   charNDArray m = char_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -774,17 +774,18 @@ octave_user_function::bind_automatic_var
       for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
            p != lvalue_list->end (); p++)
         nbh += p->is_black_hole ();
 
       if (nbh > 0)
         {
           // Only assign the hidden variable if black holes actually present.
           Matrix bh (1, nbh);
-          octave_idx_type k = 0, l = 0;
+          octave_idx_type k = 0;
+          octave_idx_type l = 0;
           for (std::list<octave_lvalue>::const_iterator
                p = lvalue_list->begin (); p != lvalue_list->end (); p++)
             {
               if (p->is_black_hole ())
                 bh(l++) = k+1;
               k += p->numel ();
             }
 
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -157,17 +157,18 @@ simplify_and_or_op (tree_expression *&a,
 
   return retop;
 }
 
 tree_binary_expression *
 maybe_compound_binary_expression (tree_expression *a, tree_expression *b,
                                   int l, int c, octave_value::binary_op t)
 {
-  tree_expression *ca = a, *cb = b;
+  tree_expression *ca = a;
+  tree_expression *cb = b;
   octave_value::compound_binary_op ct;
 
   switch (t)
     {
     case octave_value::op_mul:
       ct = simplify_mul_op (ca, cb);
       break;
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -374,17 +374,18 @@ tree_evaluator::visit_simple_for_command
     else if (rhs.is_matrix_type () || rhs.is_cell () || rhs.is_string ()
              || rhs.is_map ())
       {
         // A matrix or cell is reshaped to 2 dimensions and iterated by
         // columns.
 
         dim_vector dv = rhs.dims ().redim (2);
 
-        octave_idx_type nrows = dv(0), steps = dv(1);
+        octave_idx_type nrows = dv(0);
+        octave_idx_type steps = dv(1);
 
         if (steps > 0)
           {
             octave_value arg = rhs;
             if (rhs.ndims () > 2)
               arg = arg.reshape (dv);
 
             // for row vectors, use single index to speed things up.
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -678,17 +678,18 @@ maybe_warn_string_concat (bool all_dq_st
                      "concatenation of different character string types may have unintended consequences");
 }
 
 template<class TYPE, class T>
 static void
 single_type_concat (Array<T>& result,
                     tm_const& tmp)
 {
-  octave_idx_type r = 0, c = 0;
+  octave_idx_type r = 0;
+  octave_idx_type c = 0;
 
   for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
     {
       tm_row_const row = *p;
       // Skip empty arrays to allow looser rules.
       if (row.dims ().any_zero ())
         continue;
 
@@ -748,17 +749,18 @@ single_type_concat (Array<T>& result,
           octave_idx_type i = 0;
           for (tm_row_const::iterator q = row.begin ();
                q != row.end () && ! error_state; q++)
             result(i++) = octave_value_extract<T> (*q);
 
           return;
         }
 
-      octave_idx_type ncols = row.length (), i = 0;
+      octave_idx_type ncols = row.length ();
+      octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (Array<T>, array_list, ncols);
 
       for (tm_row_const::iterator q = row.begin ();
            q != row.end () && ! error_state;
            q++)
         {
           octave_quit ();
 
@@ -786,22 +788,24 @@ single_type_concat (Sparse<T>& result,
     {
       result = Sparse<T> (dv);
       return;
     }
 
   // Sparse matrices require preallocation for efficient indexing; besides,
   // only horizontal concatenation can be efficiently handled by indexing.
   // So we just cat all rows through liboctave, then cat the final column.
-  octave_idx_type nrows = tmp.length (), j = 0;
+  octave_idx_type nrows = tmp.length ();
+  octave_idx_type j = 0;
   OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_row_list, nrows);
   for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
     {
       tm_row_const row = *p;
-      octave_idx_type ncols = row.length (), i = 0;
+      octave_idx_type ncols = row.length ();
+      octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, ncols);
 
       for (tm_row_const::iterator q = row.begin ();
            q != row.end () && ! error_state;
            q++)
         {
           octave_quit ();
 
@@ -824,22 +828,24 @@ single_type_concat (octave_map& result,
                     tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = octave_map (dv);
       return;
     }
 
-  octave_idx_type nrows = tmp.length (), j = 0;
+  octave_idx_type nrows = tmp.length ();
+  octave_idx_type j = 0;
   OCTAVE_LOCAL_BUFFER (octave_map, map_row_list, nrows);
   for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
     {
       tm_row_const row = *p;
-      octave_idx_type ncols = row.length (), i = 0;
+      octave_idx_type ncols = row.length ();
+      octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (MAP, map_list, ncols);
 
       for (tm_row_const::iterator q = row.begin ();
            q != row.end () && ! error_state;
            q++)
         {
           octave_quit ();
 
