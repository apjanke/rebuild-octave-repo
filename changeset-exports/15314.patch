# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1346951088 14400
#      Thu Sep 06 13:04:48 2012 -0400
# Node ID 67ef63ead0235597aa0e1f38f304f983f395e9a6
# Parent  34ae358bd5663c380b86040554e42f6f410c3b15
# Parent  de9bfcf637dfa40be608a7eb0952e80e7d261bb5
Merge in Thorsten Liebig's changes

diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -667,105 +667,122 @@ fi
 
 ### Check for ZLIB library.
 
 OCTAVE_CHECK_LIB(z, ZLIB,
   [ZLIB library not found.  Octave will not be able to save or load compressed data files or HDF5 files.],
   [zlib.h], [gzclearerr])
 
 ### Check for the LLVM library
-dnl
-dnl LLVM is odd and has its own pkg-config like script.  We should probably
-dnl check for existence and ???.
-dnl
-save_CPPFLAGS="$CPPFLAGS"
-save_CXXFLAGS="$CXXFLAGS"
-save_LIBS="$LIBS"
-save_LDFLAGS="$LDFLAGS"
 
-AC_ARG_VAR(LLVM_CONFIG, [path to llvm-config utility])
-
-AC_ARG_ENABLE([jit-debug],
-  AS_HELP_STRING([--enable-jit-debug], [enable debug printing of JIT IRs]))
-
-AS_IF([test "x$enable_jit_debug" = "xyes"], [
-  AC_DEFINE(OCTAVE_JIT_DEBUG, 1, [Define to 1 for JIT debug printing.])
-])
+build_jit=false
+AC_ARG_ENABLE([jit],
+  [AS_HELP_STRING([--enable-jit],
+    [(EXPERIMENTAL) enable JIT compiler])],
+  [if test "$enableval" = yes; then
+     build_jit=true
+   fi],
+  [])
 
 LLVM_CXXFLAGS=
 LLVM_CPPFLAGS=
 LLVM_LDFLAGS=
 LLVM_LIBS=
 
-if test "x$ac_cv_env_LLVM_CONFIG_set" = "xset"; then
-  warn_llvm="LLVM was not found or is to old. JIT is disabled."
+if test $build_jit = true; then
+
+  ## Find llvm-config program from environment variable or by searching
+  AC_ARG_VAR(LLVM_CONFIG, [path to llvm-config utility])
+  AC_CHECK_PROG(LLVM_CONFIG, llvm-config, llvm-config, [])
+  
+  AC_ARG_ENABLE([jit-debug],
+    [AS_HELP_STRING([--enable-jit-debug], [enable debug printing of JIT IRs])])
 
-  ## We use -isystem if available because we do not want to see warnings in LLVM
-  LLVM_INCLUDE_FLAG=-I
-  OCTAVE_CC_FLAG(-isystem ., [
-    LLVM_INCLUDE_FLAG=-isystem
-    AC_MSG_NOTICE([using -isystem for llvm headers])])
+  if test x$enable_jit_debug = "xyes"; then
+    AC_DEFINE(OCTAVE_JIT_DEBUG, 1, [Define to 1 for JIT debug printing.])
+  fi
+
+  if test -z "$LLVM_CONFIG"; then
+    warn_llvm="llvm-config utility not found.  JIT compiler is disabled."
+  else
+    ## Preset warning message in case compile fails
+    warn_llvm="LLVM was not found or is to old.  JIT compiler is disabled."
+
+    save_CPPFLAGS="$CPPFLAGS"
+    save_CXXFLAGS="$CXXFLAGS"
+    save_LIBS="$LIBS"
+    save_LDFLAGS="$LDFLAGS"
 
-  LLVM_LDFLAGS="-L`$LLVM_CONFIG --libdir`"
-  LLVM_LIBS=`$LLVM_CONFIG --libs`
-  dnl Use -isystem so we don't get warnings from llvm headers
-  LLVM_CPPFLAGS="$LLVM_INCLUDE_FLAG `$LLVM_CONFIG --includedir`"
-  LLVM_CXXFLAGS=
+    ## Use -isystem if available because we don't want to see warnings in LLVM
+    LLVM_INCLUDE_FLAG=-I
+    OCTAVE_CC_FLAG(-isystem ., [
+      LLVM_INCLUDE_FLAG=-isystem
+      AC_MSG_NOTICE([using -isystem for LLVM headers])])
+
+    LLVM_LDFLAGS="-L`$LLVM_CONFIG --libdir`"
+    LLVM_LIBS=`$LLVM_CONFIG --libs`
+    dnl Use -isystem so we don't get warnings from llvm headers
+    LLVM_CPPFLAGS="$LLVM_INCLUDE_FLAG `$LLVM_CONFIG --includedir`"
+    LLVM_CXXFLAGS=
 
-  dnl
-  dnl We define some extra flags that LLVM requires in order to include headers.
-  dnl Ideally we should get these from llvm-config, but llvm-config isn't very
-  dnl helpful.
-  dnl
-  CPPFLAGS="-D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS $LLVM_CPPFLAGS $CPPFLAGS"
-  CXXFLAGS="$LLVM_CXXFLAGS $CXXFLAGS"
-  LIBS="$LLVM_LIBS $LIBS"
-  LDFLAGS="$LLVM_LDFLAGS $LDFLAGS"
+    dnl
+    dnl Define some extra flags that LLVM requires in order to include headers.
+    dnl Ideally we should get these from llvm-config, but llvm-config isn't
+    dnl very helpful.
+    dnl
+    CPPFLAGS="-D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS $LLVM_CPPFLAGS $CPPFLAGS"
+    CXXFLAGS="$LLVM_CXXFLAGS $CXXFLAGS"
+    LIBS="$LLVM_LIBS $LIBS"
+    LDFLAGS="$LLVM_LDFLAGS $LDFLAGS"
 
-  AC_LANG_PUSH(C++)
-    AC_CHECK_HEADERS([llvm/LLVMContext.h, llvm/Support/TargetSelect.h], [
+    AC_LANG_PUSH(C++)
+    AC_CHECK_HEADERS([llvm/LLVMContext.h llvm/Support/TargetSelect.h], [
       AC_MSG_CHECKING([for llvm::getGlobalContext in llvm/LLVMContext.h])
         AC_COMPILE_IFELSE(
           [AC_LANG_PROGRAM([[
             #include <llvm/LLVMContext.h>
             ]], [[
             llvm::LLVMContext& ctx = llvm::getGlobalContext ();
             ]])],
           [AC_MSG_RESULT([yes])
            warn_llvm=
            XTRA_CXXFLAGS="$XTRA_CXXFLAGS $LLVM_CXXFLAGS $LLVM_CPPFLAGS"],
           [AC_MSG_RESULT([no])
       ])
     ])
-  AC_LANG_POP(C++)
-  
-else
-  warn_llvm="LLVM_CONFIG not set. The experiential JIT feature is disabled."
+    AC_LANG_POP(C++)
+    CPPFLAGS="$save_CPPFLAGS"
+    CXXFLAGS="$save_CXXFLAGS"
+    LIBS="$save_LIBS"
+    LDFLAGS="$save_LDFLAGS"
+  fi
+
+  if test -z "$warn_llvm"; then
+    AC_DEFINE(HAVE_LLVM, 1, [Define to 1 if LLVM is available.])
+  else
+    build_jit=false
+    LLVM_CPPFLAGS=
+    LLVM_CXXFLAGS=
+    LLVM_LDFLAGS=
+    LLVM_LIBS=
+    OCTAVE_CONFIGURE_WARNING([warn_llvm])
+  fi
+
+## FIXME: Re-instate when JIT is enabled by default
+#else
+#  ## JIT build disabled
+#  warn_llvm="JIT compiler disabled, some performance loss for loops"
+#  OCTAVE_CONFIGURE_WARNING([warn_llvm])
 fi
 
-if test -z "$warn_llvm"; then
-  AC_DEFINE(HAVE_LLVM, 1, [Define to 1 if LLVM is available.])
-else
-  LLVM_CXXFLAGS=
-  LLVM_CPPFLAGS=
-  LLVM_LDFLAGS=
-  LLVM_LIBS=
-  OCTAVE_CONFIGURE_WARNING([warn_llvm])
-fi
-
+AC_SUBST(LLVM_CPPFLAGS)
 AC_SUBST(LLVM_CXXFLAGS)
-AC_SUBST(LLVM_CPPFLAGS)
 AC_SUBST(LLVM_LDFLAGS)
 AC_SUBST(LLVM_LIBS)
 
-CPPFLAGS="$save_CPPFLAGS"
-CXXFLAGS="$save_CXXFLAGS"
-LIBS="$save_LIBS"
-LDFLAGS="$save_LDFLAGS"
-
 ### Check for HDF5 library.
 
 save_CPPFLAGS="$CPPFLAGS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
 save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
 OCTAVE_CHECK_LIB(hdf5, HDF5,
   [HDF5 library not found.  Octave will not be able to save or load HDF5 data files.],
@@ -1738,30 +1755,17 @@ case "$canonical_host_type" in
   ;;
   *-*-msdosmsvc*)
     AC_CHECK_LIB(dirent, opendir)
     LIBS="$LIBS -ladvapi32 -lgdi32 -lws2_32 -luser32 -lkernel32"
   ;;
 esac
 
 ## Find a termlib to use.
-octave_found_termlib=no
-for termlib in ncurses curses termcap terminfo termlib; do
-  AC_CHECK_LIB(${termlib}, tputs, [
-    TERM_LIBS="-l${termlib}"
-    octave_found_termlib=yes
-    break])
-done
-
-if test "$octave_found_termlib" = no; then
-  warn_termlibs="I couldn't find -ltermcap, -lterminfo, -lncurses, -lcurses, o\
-r -ltermlib!"
-  AC_MSG_WARN([$warn_termlibs])
-fi
-AC_SUBST(TERM_LIBS)
+OCTAVE_CHECK_LIB_TERMLIB
 
 ### Checks for header files.
 
 AC_HEADER_DIRENT
 AC_HEADER_SYS_WAIT
 
 dnl FIXME: We should probably only generate this file if it is missing.
 ### Produce unistd.h for MSVC target, this simplifies changes in
@@ -2178,23 +2182,23 @@ AC_SUBST(WARN_CFLAGS)
 AC_SUBST(WARN_CXXFLAGS)
 
 ### GUI/Qt related tests.
 
 HAVE_QT=false
 QT_INCDIR=
 QT_LIBDIR=
 win32_terminal=no
-build_gui=yes
+build_gui=true
 GUIDIR=libgui
 AC_ARG_ENABLE(gui,
   [AS_HELP_STRING([--disable-gui], [don't build the GUI])],
-  [if test "$enableval" = no; then build_gui=no; fi], [build_gui=yes])
+  [if test "$enableval" = no; then build_gui=false; fi], [build_gui=true])
 
-if test $build_gui = yes; then
+if test $build_gui = true; then
   ## Check for Qt libraries
   PKG_CHECK_MODULES(QT, [QtCore, QtGui, QtNetwork],
     [],
     [AC_MSG_ERROR([Qt libraries are required to build the GUI])])
 
   ## Check for Qt utility programs
   AC_CHECK_PROGS(QMAKE, [qmake-qt5 qmake-qt4 qmake])
   if test -z "$QMAKE"; then
@@ -2258,17 +2262,17 @@ if test $build_gui = yes; then
       AC_SEARCH_LIBS([openpty], [util],
         [AC_DEFINE(HAVE_OPENPTY, [], [Define whether openpty exists])])
       ;;
   esac
 else
   ## GUI disabled.  Eliminate building GUIDIR directory
   GUIDIR=
 fi
-AM_CONDITIONAL([AMCOND_BUILD_GUI], [test $build_gui = yes])
+AM_CONDITIONAL([AMCOND_BUILD_GUI], [test $build_gui = true])
 AM_CONDITIONAL([WIN32_TERMINAL], [test $win32_terminal = yes])
 AC_SUBST(QT_INCDIR)
 AC_SUBST(QT_LIBDIR)
 AC_SUBST(GUIDIR)
 
 ### Run configure in subdirectories.
 
 export CC
@@ -2553,16 +2557,18 @@ Octave is now configured for $canonical_
   X11 libraries:               $X11_LIBS
   Z CPPFLAGS:                  $Z_CPPFLAGS
   Z LDFLAGS:                   $Z_LDFLAGS
   Z libraries:                 $Z_LIBS
 
   Default pager:               $DEFAULT_PAGER
   gnuplot:                     $GNUPLOT
 
+  Build Octave GUI:                   $build_gui
+  JIT compiler for loops:             $build_jit
   Do internal array bounds checking:  $BOUNDS_CHECKING
   Use octave_allocator:               $USE_OCTAVE_ALLOCATOR
   Build static libraries:             $STATIC_LIBS
   Build shared libraries:             $SHARED_LIBS
   Dynamic Linking:                    $ENABLE_DYNAMIC_LINKING $DL_API_MSG
   Include support for GNU readline:   $USE_READLINE
   64-bit array dims and indexing:     $USE_64_BIT_IDX_T
 ])
diff --git a/libgui/src/files-dockwidget.cc b/libgui/src/files-dockwidget.cc
--- a/libgui/src/files-dockwidget.cc
+++ b/libgui/src/files-dockwidget.cc
@@ -114,17 +114,17 @@ void
 files_dock_widget::item_double_clicked (const QModelIndex & index)
 {
   // Retrieve the file info associated with the model index.
   QFileInfo fileInfo = _file_system_model->fileInfo (index);
   display_directory (fileInfo.absoluteFilePath ());
 }
 
 void
-files_dock_widget::set_current_directory (QString currentDirectory)
+files_dock_widget::set_current_directory (const QString& currentDirectory)
 {
   display_directory (currentDirectory);
 }
 
 void
 files_dock_widget::handle_directory_entered ()
 {
   display_directory (_current_directory->text ());
@@ -134,17 +134,17 @@ void
 files_dock_widget::do_up_directory ()
 {
   QDir dir = QDir (_file_system_model->filePath (_file_tree_view->rootIndex ()));
   dir.cdUp ();
   display_directory (dir.absolutePath ());
 }
 
 void
-files_dock_widget::display_directory (QString directory)
+files_dock_widget::display_directory (const QString& directory)
 {
   QFileInfo fileInfo (directory);
   if (fileInfo.exists ())
     {
       if (fileInfo.isDir ())
         {
           _file_tree_view->setRootIndex (_file_system_model->
                                         index (fileInfo.absoluteFilePath ()));
diff --git a/libgui/src/files-dockwidget.h b/libgui/src/files-dockwidget.h
--- a/libgui/src/files-dockwidget.h
+++ b/libgui/src/files-dockwidget.h
@@ -52,35 +52,35 @@ public:
 public slots:
   /** Slot for handling a change in directory via double click. */
   void item_double_clicked (const QModelIndex & index);
 
   /** Slot for handling the up-directory button in the toolbar. */
   void do_up_directory ();
 
   /** Sets the current directory being displayed. */
-  void set_current_directory (QString currentDirectory);
+  void set_current_directory (const QString& currentDirectory);
 
   /** Accepts user input a the line edit for the current directory. */
   void handle_directory_entered ();
 
-  void display_directory (QString directory);
+  void display_directory (const QString& directory);
 
   /** Tells the widget to react on changed settings. */
   void notice_settings ();
 
   /** Slot to steer changing visibility from outside. */
   void handle_visibility_changed (bool visible);
 
 signals:
   /** Emitted, whenever the user requested to open a file. */
-  void open_file (QString fileName);
+  void open_file (const QString& fileName);
 
   /** Emitted, whenever the currently displayed directory changed. */
-  void displayed_directory_changed (QString directory);
+  void displayed_directory_changed (const QString& directory);
 
   /** Custom signal that tells if a user has clicke away that dock widget. */
   void active_changed (bool active);
 
 protected:
   void closeEvent (QCloseEvent *event);
 
 private:
diff --git a/libgui/src/history-dockwidget.h b/libgui/src/history-dockwidget.h
--- a/libgui/src/history-dockwidget.h
+++ b/libgui/src/history-dockwidget.h
@@ -43,20 +43,20 @@ public:
   void event_reject (octave_event *e);
 
 public slots:
   void handle_visibility_changed (bool visible);
   void request_history_model_update ();
   void reset_model ();
 
 signals:
-  void information (QString message);
+  void information (const QString& message);
 
   /** Emitted, whenever the user double-clicked a command in the history. */
-  void command_double_clicked (QString command);
+  void command_double_clicked (const QString& command);
 
   /** Custom signal that tells if a user has clicked away that dock widget. */
   void active_changed (bool active);
 protected:
   void closeEvent (QCloseEvent *event);
 private slots:
   void handle_double_click (QModelIndex modelIndex);
 
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -52,17 +52,17 @@ class file_editor_interface : public QDo
     virtual QToolBar *toolbar () = 0;
 
     virtual void handle_entered_debug_mode () = 0;
     virtual void handle_quit_debug_mode () = 0;
 
   public slots:
     virtual void request_new_file () = 0;
     virtual void request_open_file () = 0;
-    virtual void request_open_file (QString fileName) = 0;
+    virtual void request_open_file (const QString& fileName) = 0;
 
   signals:
       void active_changed (bool active);
 
   protected:
     QTerminal* _terminal;
     main_window* _main_window;
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -193,17 +193,17 @@ file_editor_tab::closeEvent (QCloseEvent
       else
         {
           event->accept();
         }
     }
 }
 
 void
-file_editor_tab::set_file_name (QString fileName)
+file_editor_tab::set_file_name (const QString& fileName)
 {
   _file_name = fileName;
   update_lexer ();
   update_tracked_file ();
 }
 
 void
 file_editor_tab::handle_margin_clicked(int margin, int line,
@@ -431,17 +431,17 @@ file_editor_tab::update_tracked_file ()
   if (!trackedFiles.isEmpty ())
     _file_system_watcher.removePaths (trackedFiles);
 
   if (_file_name != UNNAMED_FILE)
     _file_system_watcher.addPath (_file_name);
 }
 
 int
-file_editor_tab::check_file_modified (QString msg, int cancelButton)
+file_editor_tab::check_file_modified (const QString& msg, int cancelButton)
 {
   int decision = QMessageBox::Yes;
   if (_edit_area->isModified ())
     {
       // file is modified but not saved, aks user what to do
       decision = QMessageBox::warning (this,
                                        msg,
                                        tr ("The file %1\n"
@@ -622,17 +622,17 @@ file_editor_tab::open_file (QString dir)
     }
   else
     {
       return false;
     }
 }
 
 void
-file_editor_tab::load_file (QString fileName)
+file_editor_tab::load_file (const QString& fileName)
 {
   if (!_file_editor->isVisible ())
     {
       _file_editor->show ();
     }
 
   QFile file (fileName);
   if (!file.open (QFile::ReadOnly))
@@ -671,17 +671,17 @@ file_editor_tab::new_file ()
 }
 
 bool file_editor_tab::save_file()
 {
   return save_file (_file_name);
 }
 
 bool
-file_editor_tab::save_file (QString saveFileName)
+file_editor_tab::save_file (const QString& saveFileName)
 {
   // it is a new file with the name "<unnamed>" -> call saveFielAs
   if (saveFileName == UNNAMED_FILE || saveFileName.isEmpty ())
     {
       return save_file_as();
     }
 
   QStringList watched_files = _file_system_watcher.files();
@@ -773,17 +773,17 @@ file_editor_tab::run_file ()
   _file_editor->terminal ()->sendText (QString ("cd \'%1\'\n%2\n")
     .arg(path).arg (function_name));
   // TODO: Sending a run event crashes for long scripts. Find out why.
   //  octave_link::instance ()
   //      ->post_event (new octave_run_file_event (*this, _file_name.toStdString ()));
 }
 
 void
-file_editor_tab::file_has_changed (QString fileName)
+file_editor_tab::file_has_changed (const QString& fileName)
 {
   Q_UNUSED (fileName);
   if (QFile::exists (_file_name))
     {
       // Prevent popping up multiple message boxes when the file has
       // been changed multiple times.
       static bool alreadyAsking = false;
       if (!alreadyAsking)
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -59,44 +59,43 @@ public slots:
   void copy ();
   void paste ();
   void undo ();
   void redo ();
   void set_debugger_position (int line);
 
   void set_modified (bool modified = true);
 
-  bool open_file (QString dir = QString ());
-  void load_file (QString fileName);
+  bool open_file (const QString& dir = QString ());
+  void load_file (const QString& fileName);
   void new_file ();
   bool save_file ();
-  bool save_file(QString saveFileName);
+  bool save_file (const QString& saveFileName);
   bool save_file_as();
   void run_file ();
 
-  void file_has_changed (QString fileName);
-  
+  void file_has_changed (const QString& fileName);
   QString get_file_name () const {return _file_name;} 
 
 signals:
-  void file_name_changed (QString fileName);
+  void file_name_changed (const QString& fileName);
   void editor_state_changed ();
   void close_request ();
 
 protected:
   void closeEvent (QCloseEvent *event);
-  void set_file_name (QString fileName);
+  void set_file_name (const QString& fileName);
 
 private:
   void update_lexer ();
   void request_add_breakpoint (int line);
   void request_remove_breakpoint (int line);
 
   void update_tracked_file ();
-  int check_file_modified (QString msg, int cancelButton);
+  int check_file_modified (const QString& msg, int cancelButton);
   void do_comment_selected_text (bool comment);
 
   file_editor *         _file_editor;
   QsciScintilla *       _edit_area;
 
   QString               _file_name;
   QString               _file_name_short;
 
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -111,17 +111,17 @@ file_editor::request_open_file ()
         {
           // If no file was loaded, remove the tab again.
           _tab_widget->removeTab (_tab_widget->indexOf (fileEditorTab));
         }
     }
 }
 
 void
-file_editor::request_open_file (QString fileName)
+file_editor::request_open_file (const QString& fileName)
 {
   if (!isVisible ())
     {
       show ();
     }
 
   file_editor_tab *fileEditorTab = new file_editor_tab (this);
   if (fileEditorTab)
@@ -279,17 +279,17 @@ void
 file_editor::request_find ()
 {
   file_editor_tab *_active_file_editor_tab = active_editor_tab ();
   if (_active_file_editor_tab)
     _active_file_editor_tab->find ();
 }
 
 void
-file_editor::handle_file_name_changed (QString fileName)
+file_editor::handle_file_name_changed (const QString& fileName)
 {
   QObject *senderObject = sender ();
   file_editor_tab *fileEditorTab
     = dynamic_cast<file_editor_tab*> (senderObject);
   if (fileEditorTab)
     {
       for(int i = 0; i < _tab_widget->count (); i++)
         {
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -45,31 +45,31 @@ enum editor_markers
 
 class file_editor : public file_editor_interface
 {
 Q_OBJECT
 
 public:
   file_editor (QTerminal *terminal, main_window *m);
   ~file_editor ();
-  void loadFile (QString fileName);
+  void loadFile (const QString& fileName);
 
   QTerminal *       terminal ();
   main_window *     get_main_window ();
 
   QMenu *           debug_menu ();
   QToolBar *        toolbar ();
 
   void handle_entered_debug_mode ();
   void handle_quit_debug_mode ();
 
 public slots:
   void request_new_file ();
   void request_open_file ();
-  void request_open_file (QString fileName);
+  void request_open_file (const QString& fileName);
 
   void request_undo ();
   void request_redo ();
   void request_copy ();
   void request_cut ();
   void request_paste ();
   void request_save_file ();
   void request_save_file_as ();
@@ -83,17 +83,17 @@ public slots:
   void request_next_breakpoint ();
   void request_previous_breakpoint ();
   void request_remove_breakpoint ();
 
   void request_comment_selected_text ();
   void request_uncomment_selected_text ();
   void request_find ();
 
-  void handle_file_name_changed (QString fileName);
+  void handle_file_name_changed (const QString& fileName);
   void handle_tab_close_request (int index);
   void handle_tab_close_request ();
   void active_tab_changed (int index);
   void handle_editor_state_changed ();
 
 private:
   void construct ();
   void add_file_editor_tab(file_editor_tab *f);
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -80,24 +80,24 @@ main_window::new_file ()
 void
 main_window::open_file ()
 {
   _file_editor->request_open_file ();
   focus_editor ();
 }
 
 void
-main_window::open_file (QString file_name)
+main_window::open_file (const QString& file_name)
 {
   _file_editor->request_open_file (file_name);
   focus_editor ();
 }
 
 void
-main_window::report_status_message (QString statusMessage)
+main_window::report_status_message (const QString& statusMessage)
 {
   _status_bar->showMessage (statusMessage, 1000);
 }
 
 void
 main_window::handle_save_workspace_request ()
 {
   QString selectedFile =
@@ -135,17 +135,17 @@ main_window::handle_clear_workspace_requ
 void
 main_window::handle_clear_history_request()
 {
   octave_link::instance ()
       ->post_event (new octave_clear_history_event (*this));
 }
 
 void
-main_window::handle_command_double_clicked (QString command)
+main_window::handle_command_double_clicked (const QString& command)
 {
   _terminal->sendText (command);
   _terminal->setFocus ();
 }
 
 void
 main_window::open_bug_tracker_page ()
 {
@@ -211,17 +211,17 @@ main_window::prepare_for_quit ()
 
 void
 main_window::reset_windows ()
 {
   // TODO: Implement.
 }
 
 void
-main_window::current_working_directory_has_changed (QString directory)
+main_window::current_working_directory_has_changed (const QString& directory)
 {
   if (_current_directory_combo_box->count () > 31)
     {
       _current_directory_combo_box->removeItem (0);
     }
   _current_directory_combo_box->addItem (directory);
   int index = _current_directory_combo_box->findText (directory);
   _current_directory_combo_box->setCurrentIndex (index);
@@ -239,17 +239,17 @@ main_window::change_current_working_dire
     {
       octave_link::instance ()
           ->post_event (new octave_change_directory_event (*this,
                         selectedDirectory.toStdString ()));
     }
 }
 
 void
-main_window::set_current_working_directory (QString directory)
+main_window::set_current_working_directory (const QString& directory)
 {
   octave_link::instance ()
       ->post_event (new octave_change_directory_event (*this,
                     directory.toStdString ()));
 }
 
 void
 main_window::current_working_directory_up ()
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -78,36 +78,36 @@ Q_OBJECT public:
     return _files_dock_widget;
   }
   bool is_closing () { return _closing; }
 
 signals:
   void settings_changed ();
 
 public slots:
-  void report_status_message (QString statusMessage);
+  void report_status_message (const QString& statusMessage);
   void handle_save_workspace_request ();
   void handle_load_workspace_request ();
   void handle_clear_workspace_request ();
   void handle_clear_history_request ();
-  void handle_command_double_clicked (QString command);
+  void handle_command_double_clicked (const QString& command);
   void new_file ();
   void open_file ();
-  void open_file (QString file_name);
+  void open_file (const QString& file_name);
   void open_bug_tracker_page ();
   void open_agora_page ();
   void open_octave_forge_page ();
   void process_settings_dialog_request ();
   void show_about_octave ();
   void notice_settings ();
   void prepare_for_quit ();
   void reset_windows ();
-  void current_working_directory_has_changed (QString directory);
+  void current_working_directory_has_changed (const QString& directory);
   void change_current_working_directory ();
-  void set_current_working_directory (QString directory);
+  void set_current_working_directory (const QString& directory);
   void current_working_directory_up ();
 
   void focus_command_window ();
   void focus_command_history ();
   void focus_current_directory ();
   void focus_workspace ();
   void focus_editor ();
   void focus_documentation ();
diff --git a/libgui/src/octave-qt-event-listener.h b/libgui/src/octave-qt-event-listener.h
--- a/libgui/src/octave-qt-event-listener.h
+++ b/libgui/src/octave-qt-event-listener.h
@@ -36,14 +36,14 @@ class octave_qt_event_listener
 
     void current_directory_has_changed (std::string directory);
     void about_to_exit ();
 
     void entered_debug_mode ();
     void quit_debug_mode ();
 
   signals:
-    void current_directory_has_changed_signal (QString directory);
+    void current_directory_has_changed_signal (const QString& directory);
     void entered_debug_mode_signal ();
     void quit_debug_mode_signal ();
 };
 
 #endif // OCTAVEQTEVENTLISTENER_H
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -36,17 +36,17 @@ parser::parser(QObject *parent)
   _compressors_map.insert ("bz2",  "bzip2 -dc \"%1\"");
   _compressors_map.insert ("gz",   "gzip -dc \"%1\"");
   _compressors_map.insert ("lzma", "lzma -dc \"%1\"");
   _compressors_map.insert ("xz",   "xz -dc \"%1\"");
   _compressors_map.insert ("Z",    "gunzip -c \"%1\"");
 }
 
 void
-parser::set_info_path (QString infoPath)
+parser::set_info_path (const QString& infoPath)
 {
   this->_info_path = infoPath;
 
   _info_files.clear ();
 
   QFileInfo info (infoPath);
 
   QString path = info.absolutePath ();
@@ -95,30 +95,32 @@ parser::open_file (QFileInfo & file_info
         return NULL;
       iodevice = io;
     }
 
   return iodevice;
 }
 
 int
-parser::is_ref (QString node)
+parser::is_ref (const QString& node)
 {
   if (_ref_map.contains (node))
     {
       node_position ref = _ref_map [node];
 
       return ref.pos-_node_map [ref._node_name].pos;
     }
   return -1;
 }
 
 QString
-parser::search_node (QString node)
+parser::search_node (const QString& node_arg)
 {
+  QString node = node_arg;
+
   QFileInfo file_info;
   QString ref;
 
   if (_ref_map.contains (node))
     {
       ref = node;
       node = _ref_map [ref]._node_name;
     }
@@ -147,17 +149,17 @@ parser::search_node (QString node)
       io->close ();
       delete io;
     }
 
   return QString ();
 }
 
 QString
-parser::search_node (QString node, QIODevice *io)
+parser::search_node (const QString& node, QIODevice *io)
 {
   while (!io->atEnd ())
     {
       QString text = get_next_node (io);
       if(node == get_node_name (text))
         {
           return text;
         }
@@ -181,72 +183,72 @@ parser::get_next_node (QIODevice *io)
         {
           text.append (line);
         }
     }
   return text;
 }
 
 static QString
-get_first_line (QString text)
+get_first_line (const QString& text)
 {
   int n = text.indexOf ("\n");
 
   if (n < 0)
     {
       return QString ();
     }
 
   QString first_line = text.left (n);
   return first_line;
 }
 
 static QString
-parser_node (QString text, QString node_name)
+parser_node (const QString& text, const QString& node_name)
 {
   QString firstLine = get_first_line (text);
   QStringList nodes = firstLine.split (",");
   for (int i = 0;i < nodes.size (); i++)
     {
       QString node = nodes.at (i).trimmed ();
 
       if (node.startsWith (node_name))
         {
           return node.remove (0, node_name.size ()).trimmed ();
         }
     }
   return QString ();
 }
 
 QString
-parser::get_node_name (QString text)
+parser::get_node_name (const QString& text)
 {
   return parser_node (text, "Node:");
 }
 
 QString
-parser::get_node_up (QString text)
+parser::get_node_up (const QString& text)
 {
   return parser_node (text, "Up:");
 }
 
 QString
-parser::get_node_next (QString text)
+parser::get_node_next (const QString& text)
 {
   return parser_node (text, "Next:");
 }
 
 QString
-parser::get_node_prev (QString text)
+parser::get_node_prev (const QString& text)
 {
   return parser_node (text, "Prev:");
 }
 
 static void
-replace_links (QString &text)
+replace_links (QString& text)
 {
   QRegExp re ("(\\*[N|n]ote|\n\\*)([ |\n]+)([^:]+):([^:\\.,]*)([:,\\.])");
   int i = 0, f;
 
   while ( (i = re.indexIn (text,i)) != -1)
     {
       QString type     = re.cap (1);
       QString note     = re.cap (3);
@@ -277,47 +279,50 @@ replace_links (QString &text)
       href += re.cap (2) + "<a href='" + url_link + "'>" + note + ":" + link + re.cap (5) + "</a>";
       f = re.matchedLength ();
       text.replace (i,f,href);
       i += href.size ();
     }
 }
 
 static void
-replace_colons (QString &text)
+replace_colons (QString& text)
 {
   QRegExp re ("`([^']+)'");
   int i = 0, f;
   while ( (i = re.indexIn (text, i)) != -1)
     {
       QString t = re.cap (1);
       QString bold = "<b>`" + t + "</b>'";
 
       f = re.matchedLength ();
       text.replace (i,f,bold);
       i += bold.size ();
     }
 }
 
 static void
-info_to_html (QString &text)
+info_to_html (QString& text)
 {
   text.replace ("&", "&amp;");
   text.replace ("<", "&lt;");
   text.replace (">", "&gt;");
 
   text.replace ("\n* Menu:", "\n<b>Menu:</b>");
   text.replace ("*See also:*", "<b>See also:</b>");
   replace_colons (text);
   replace_links (text);
 }
 
 QString
-parser::node_text_to_html (QString text, int anchorPos, QString anchor)
+parser::node_text_to_html (const QString& text_arg, int anchorPos,
+                           const QString& anchor)
 {
+  QString text = text_arg;
+
   QString nodeName = get_node_name (text);
   QString nodeUp   = get_node_up (text);
   QString nodeNext = get_node_next (text);
   QString nodePrev = get_node_prev (text);
 
   if (anchorPos > -1)
     {
       QString text1 = text.left (anchorPos);
@@ -474,33 +479,33 @@ parser::seek (QIODevice *io, int pos)
   while (!io->atEnd () && pos > 0)
     {
       io->getChar (&ch);
       pos--;
     }
 }
 
 static void
-replace (QString &text, QRegExp re, QString after)
+replace (QString& text, const QRegExp& re, const QString& after)
 {
   int pos = 0;
 
   while ( (pos = re.indexIn (text, pos)) != -1)
     {
       QString cap = text.mid (pos,re.matchedLength ());
       QString a (after);
       a = a.arg (cap);
       text.remove (pos, re.matchedLength ());
       text.insert (pos, a);
       pos += a.size ();
     }
 }
 
 QString
-parser::global_search (QString text, int max_founds)
+parser::global_search (const QString& text, int max_founds)
 {
   QString results;
   QStringList words = text.split (" ",QString::SkipEmptyParts);
 
   QString re_program ("(" + words.at (0));
   for (int i = 1; i < words.size (); i++)
     {
       re_program += "|" + words.at (i);
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -40,30 +40,31 @@
  */
 class parser
     : public QObject
 {
   Q_OBJECT
 
 public:
   parser (QObject *parent = 0);
-  void set_info_path (QString _info_path);
+  void set_info_path (const QString& _info_path);
   QString get_info_path ();
-  QString search_node (QString node);
-  QString global_search (QString text, int maxFounds);
+  QString search_node (const QString& node);
+  QString global_search (const QString& text, int maxFounds);
 
   /** Checks if this node is reference. If node is reference, it will be returned its position
     * in text, else  it will be returned -1.
     */
-  int is_ref (QString node);
+  int is_ref (const QString& node);
 
   /**Translates text of node to Html. If anchorPos is not -1, then anchor is inserted in that
     * position.
     */
-  QString node_text_to_html (QString text, int anchorPos=-1, QString anchor=QString());
+  QString node_text_to_html (const QString& text, int anchorPos = -1,
+                             const QString& anchor = QString ());
 
 private:
   struct node_position
   {
     QString _node_name;
     int pos;
   };
 
@@ -73,22 +74,22 @@ private:
   };
 
   struct info_file_item
   {
     QFileInfo file_info;
     int real_size;
   };
 
-  QString search_node (QString node, QIODevice * io);
+  QString search_node (const QString& node, QIODevice * io);
   QString get_next_node (QIODevice * io);
-  QString get_node_name (QString text);
-  QString get_node_up (QString text);
-  QString get_node_next (QString text);
-  QString get_node_prev (QString text);
+  QString get_node_name (const QString& text);
+  QString get_node_up (const QString& text);
+  QString get_node_next (const QString& text);
+  QString get_node_prev (const QString& text);
 
   /** Parses info files and gets map of node positions.*/
   void parse_info_map();
 
   /** Open info files and uncompress them. */
   QIODevice *open_file(QFileInfo & fileInfo);
 
   /** Calculates real position of nodes.
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -26,17 +26,17 @@
 #include <QHBoxLayout>
 
 #include "file-ops.h"
 #include "help.h"
 #include "defaults.h"
 
 
 webinfo::webinfo (QWidget *parent)
-  :QWidget (parent)
+  : QWidget (parent)
 {
   _font_web = font ();
 
   QVBoxLayout *layout = new QVBoxLayout ();
   layout->setMargin (0);
   setLayout (layout);
 
   QHBoxLayout *hboxLayout = new QHBoxLayout ();
@@ -85,24 +85,24 @@ webinfo::webinfo (QWidget *parent)
   connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
 
   resize (500, 300);
 
   set_info_path (QString::fromStdString (Vinfo_file));
 }
 
 void
-webinfo::set_info_path (QString info_path)
+webinfo::set_info_path (const QString& info_path)
 {
   _parser.set_info_path (info_path);
   load_node ("Top");
 }
 
 void
-webinfo::load_node (QString node_name)
+webinfo::load_node (const QString& node_name)
 {
   //Check if node has been already opened.
   for (int i = 0;i < _tab_bar->count (); i++)
     {
       if (node_name == _tab_bar->tabText (i))
         {
           _tab_bar->setCurrentIndex (i);
           return;
@@ -137,17 +137,17 @@ webinfo::current_tab_changed (int index)
 
   if (_text_browser->font () != _font_web)
     {
       _text_browser->setFont (_font_web);
     }
 }
 
 QTextBrowser *
-webinfo::addNewTab(QString name)
+webinfo::addNewTab (const QString& name)
 {
   _text_browser = new QTextBrowser (this);
   _text_browser->setOpenLinks (false);
   _text_browser->show ();
 
   connect (_text_browser, SIGNAL (anchorClicked (const QUrl &)), this, SLOT (link_clicked (const QUrl &)) );
   disconnect(_tab_bar, SIGNAL (currentChanged(int)), this, SLOT (current_tab_changed (int)));
 
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -26,21 +26,21 @@
 #include <QCheckBox>
 #include <QToolButton>
 
 class webinfo : public QWidget
 {
   Q_OBJECT
 public:
   webinfo (QWidget *parent = 0);
-  void set_info_path (QString info_path);
-  void load_node (QString node_name);
+  void set_info_path (const QString& info_path);
+  void load_node (const QString& node_name);
 
 public slots:
-  void link_clicked (const QUrl &link);
+  void link_clicked (const QUrl& link);
   void current_tab_changed (int index);
   void close_tab ();
   void search ();
   void zoom_in ();
   void zoom_out ();
 
 private:
   QTextBrowser        *_text_browser;
@@ -50,11 +50,11 @@ private:
   QLineEdit           *_search_line_edit;
   QCheckBox           *_search_check_box;
   QToolButton         *_zoom_in_button;
   QToolButton         *_zoom_out_button;
 
   parser              _parser;
   QFont               _font_web;
 
-  QTextBrowser *addNewTab (QString name);
+  QTextBrowser *addNewTab (const QString& name);
   void closeTab(int index);
 };
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -48,17 +48,17 @@ resource_manager::resource_manager (void
 }
 
 resource_manager::~resource_manager (void)
 {
   delete settings;
 }
 
 QString
-resource_manager::find_translator_file (QString language)
+resource_manager::find_translator_file (const QString& language)
 {
   // TODO: Quick hack to be able to test language files.
   return QString ("../languages/%1.qm").arg (language);
 }
 
 bool
 resource_manager::instance_ok (void)
 {
@@ -122,17 +122,17 @@ resource_manager::do_reload_settings (vo
    }
   else
      first_run = false;
 
   do_set_settings (settings_file);
 }
 
 void
-resource_manager::do_set_settings (QString file)
+resource_manager::do_set_settings (const QString& file)
 {
   delete settings;
   settings = new QSettings (file, QSettings::IniFormat);
 }
 
 bool
 resource_manager::do_is_first_run (void)
 {
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -49,23 +49,23 @@ public:
   }
 
   static void reload_settings (void)
   {
     if (instance_ok ())
       instance->do_reload_settings ();
   }
 
-  static void set_settings (QString file)
+  static void set_settings (const QString& file)
   {
     if (instance_ok ())
       instance->do_set_settings (file);
   }
 
-  static QString find_translator_file (QString language);
+  static QString find_translator_file (const QString& language);
 
   static void update_network_settings (void)
   {
     if (instance_ok ())
       instance->do_update_network_settings ();
   }
 
   static bool is_first_run (void)
@@ -96,16 +96,16 @@ private:
   bool first_run;
 
   QSettings *do_get_settings (void);
 
   QString do_get_home_path (void);
 
   void do_reload_settings (void);
 
-  void do_set_settings (QString file);
+  void do_set_settings (const QString& file);
 
   void do_update_network_settings (void);
 
   bool do_is_first_run (void);
 };
 
 #endif // RESOURCEMANAGER_H
diff --git a/libinterp/interp-core/jit-typeinfo.cc b/libinterp/interp-core/jit-typeinfo.cc
--- a/libinterp/interp-core/jit-typeinfo.cc
+++ b/libinterp/interp-core/jit-typeinfo.cc
@@ -2193,17 +2193,17 @@ jit_typeinfo::do_type_of (const octave_v
         = dynamic_cast<octave_builtin *> (ov.internal_rep ());
       return builtin && builtin->to_jit () ? builtin->to_jit ()
         : unknown_function;
     }
 
   if (ov.is_range ())
     return get_range ();
 
-  if (ov.is_double_type ())
+  if (ov.is_double_type () && ! ov.is_complex_type ())
     {
       if (ov.is_real_scalar ())
         return get_scalar ();
 
       if (ov.is_matrix_type ())
         return get_matrix ();
     }
 
diff --git a/libinterp/interp-core/pt-jit.cc b/libinterp/interp-core/pt-jit.cc
--- a/libinterp/interp-core/pt-jit.cc
+++ b/libinterp/interp-core/pt-jit.cc
@@ -22,19 +22,28 @@ along with Octave; see the file COPYING.
 
 #define __STDC_LIMIT_MACROS
 #define __STDC_CONSTANT_MACROS
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#ifdef HAVE_LLVM
+#include "defun.h"
+#include "ov.h"
+#include "pt-all.h"
+#include "pt-jit.h"
+#include "symtab.h"
+#include "variables.h"
 
-#include "pt-jit.h"
+bool Venable_jit_debug = false;
+
+bool Venable_jit_compiler = true;
+
+#ifdef HAVE_LLVM
 
 #include <llvm/Analysis/CallGraph.h>
 #include <llvm/Analysis/Passes.h>
 #include <llvm/Analysis/Verifier.h>
 #include <llvm/LLVMContext.h>
 #include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/ExecutionEngine/JIT.h>
 #include <llvm/Module.h>
@@ -45,19 +54,16 @@ along with Octave; see the file COPYING.
 #include <llvm/Target/TargetData.h>
 #include <llvm/Transforms/IPO.h>
 #include <llvm/Transforms/Scalar.h>
 
 #ifdef OCTAVE_JIT_DEBUG
 #include <llvm/Bitcode/ReaderWriter.h>
 #endif
 
-#include "symtab.h"
-#include "pt-all.h"
-
 static llvm::IRBuilder<> builder (llvm::getGlobalContext ());
 
 static llvm::LLVMContext& context = llvm::getGlobalContext ();
 
 // -------------------- jit_convert --------------------
 jit_convert::jit_convert (tree &tee, jit_type *for_bounds)
   : iterator_count (0), for_bounds_count (0), short_count (0), breaking (false)
 {
@@ -478,17 +484,17 @@ jit_convert::visit_no_op_command (tree_n
 {
   throw jit_fail_exception ();
 }
 
 void
 jit_convert::visit_constant (tree_constant& tc)
 {
   octave_value v = tc.rvalue1 ();
-  if (v.is_real_scalar () && v.is_double_type ())
+  if (v.is_real_scalar () && v.is_double_type () && ! v.is_complex_type ())
     {
       double dv = v.double_value ();
       result = factory.create<jit_const_scalar> (dv);
     }
   else if (v.is_range ())
     {
       Range rv = v.range_value ();
       result = factory.create<jit_const_range> (rv);
@@ -1705,57 +1711,70 @@ jit_info::compile (tree_jit& tjit, tree&
   try
     {
       jit_convert conv (tee, for_bounds);
       jit_infer infer (conv.get_factory (), conv.get_blocks (),
                        conv.get_variable_map ());
 
       infer.infer ();
 #ifdef OCTAVE_JIT_DEBUG
-      jit_block_list& blocks = infer.get_blocks ();
-      jit_block *entry_block = blocks.front ();
-      entry_block->label ();
-      std::cout << "-------------------- Compiling tree --------------------\n";
-      std::cout << tee.str_print_code () << std::endl;
-      blocks.print (std::cout, "octave jit ir");
+      if (Venable_jit_debug)
+        {
+          jit_block_list& blocks = infer.get_blocks ();
+          jit_block *entry_block = blocks.front ();
+          entry_block->label ();
+          std::cout << "-------------------- Compiling tree --------------------\n";
+          std::cout << tee.str_print_code () << std::endl;
+          blocks.print (std::cout, "octave jit ir");
+        }
 #endif
 
       jit_factory& factory = conv.get_factory ();
       jit_convert_llvm to_llvm;
       llvm_function = to_llvm.convert (tjit.get_module (), infer.get_blocks (),
                                        factory.constants ());
       arguments = to_llvm.get_arguments ();
       bounds = conv.get_bounds ();
     }
   catch (const jit_fail_exception& e)
     {
 #ifdef OCTAVE_JIT_DEBUG
-      if (e.known ())
-        std::cout << "jit fail: " << e.what () << std::endl;
+      if (Venable_jit_debug)
+        {
+          if (e.known ())
+            std::cout << "jit fail: " << e.what () << std::endl;
+        }
 #endif
     }
 
   if (llvm_function)
     {
 #ifdef OCTAVE_JIT_DEBUG
-      std::cout << "-------------------- llvm ir --------------------";
       llvm::raw_os_ostream llvm_cout (std::cout);
-      llvm_function->print (llvm_cout);
-      std::cout << std::endl;
-      llvm::verifyFunction (*llvm_function);
+
+      if (Venable_jit_debug)
+        {
+          std::cout << "-------------------- llvm ir --------------------";
+          llvm_function->print (llvm_cout);
+          std::cout << std::endl;
+          llvm::verifyFunction (*llvm_function);
+        }
 #endif
 
       tjit.optimize (llvm_function);
 
 #ifdef OCTAVE_JIT_DEBUG
-      std::cout << "-------------------- optimized llvm ir "
-                << "--------------------\n";
-      llvm_function->print (llvm_cout);
-      llvm_cout.flush ();
-      std::cout << std::endl;
+      if (Venable_jit_debug)
+        {
+          std::cout << "-------------------- optimized llvm ir "
+                    << "--------------------\n";
+          llvm_function->print (llvm_cout);
+          llvm_cout.flush ();
+          std::cout << std::endl;
+        }
 #endif
 
       void *void_fn = engine->getPointerToFunction (llvm_function);
       function = reinterpret_cast<jited_function> (void_fn);
     }
 }
 
 octave_value
@@ -1763,16 +1782,44 @@ jit_info::find (const vmap& extra_vars, 
 {
   vmap::const_iterator iter = extra_vars.find (vname);
   return iter == extra_vars.end () ? symbol_table::varval (vname)
     : *iter->second;
 }
 
 #endif
 
+DEFUN (enable_jit_debug, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} enable_jit_debug ()\n\
+Query or set the internal variable that determines whether\n\
+debugging/tracing is enabled for Octave's JIT compiler.\n\
+@end deftypefn")
+{
+#if defined (HAVE_LLVM) && defined (OCTAVE_JIT_DEBUG)
+  return SET_INTERNAL_VARIABLE (enable_jit_debug);
+#else
+  warning ("enable_jit_debug: JIT compiling not available in this version of Octave");
+  return octave_value ();
+#endif
+}
+
+DEFUN (enable_jit_compiler, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} enable_jit_compiler ()\n\
+Query or set the internal variable that enables Octave's JIT compiler.\n\
+@end deftypefn")
+{
+#if defined (HAVE_LLVM)
+  return SET_INTERNAL_VARIABLE (enable_jit_compiler);
+#else
+  warning ("enable_jit_compiler: JIT compiling not available in this version of Octave");
+  return octave_value ();
+#endif
+}
 
 /*
 Test some simple cases that compile.
 
 %!test
 %! inc = 1e-5;
 %! result = 0;
 %! for ii = 0:inc:1
@@ -2047,9 +2094,18 @@ Test some simple cases that compile.
 %! for i=1:1e3
 %!   for j=1:2
 %!     a = a + b;
 %!   endfor
 %! endfor
 %! assert (a, 2000);
 %! assert (b, 1);
 
+%!test
+%! a = [1+1i 1+2i];
+%! b = 0;
+%! while 1
+%!   b = a(1);
+%!   break;
+%! endwhile
+%! assert (b, a(1));
+
 */
diff --git a/libinterp/interp-core/pt-jit.h b/libinterp/interp-core/pt-jit.h
--- a/libinterp/interp-core/pt-jit.h
+++ b/libinterp/interp-core/pt-jit.h
@@ -373,9 +373,16 @@ private:
   jited_function function;
   llvm::Function *llvm_function;
 
   std::vector<std::pair<std::string, bool> > arguments;
   type_bound_vector bounds;
 };
 
 #endif
+
+// If TRUE, enable JIT compiler debugging/tracing.
+extern bool Venable_jit_debug;
+
+// If TRUE, enable JIT compiler.
+extern bool Venable_jit_compiler;
+
 #endif
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -1469,22 +1469,27 @@ specified option.\n\
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
       if (! error_state)
         {
-          Cell c = m.contents (arg.c_str ());
+          if (m.isfield (arg))
+            {
+              Cell c = m.contents (arg);
 
-          if (c.is_empty ())
-            error ("octave_config_info: no info for `%s'", arg.c_str ());
+              if (c.is_empty ())
+                error ("octave_config_info: no info for `%s'", arg.c_str ());
+              else
+                retval = c(0);
+            }
           else
-            retval = c(0);
+            error ("octave_config_info: invalid parameter `%s'", arg.c_str ());
         }
     }
   else if (nargin == 0)
     retval = m;
   else
     print_usage ();
 
   return retval;
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -123,16 +123,24 @@ static bool verbose_flag = false;
 // If TRUE, force the GUI to start.
 // (--force-gui)
 static bool force_gui_option = false;
 
 // If TRUE don't start the GUI.
 // (--no-gui)
 static bool no_gui_option = false;
 
+// If TRUE, disable the JIT compiler.
+// (--no-jit-compiler)
+static bool no_jit_compiler_option = false;
+
+// If TRUE, enable JIT compiler debugging/tracing.
+// (--jit-debug)
+static bool jit_debug_option = false;
+
 // If TRUE, force readline command line editing.
 // (--line-editing)
 static bool forced_line_editing = false;
 
 // If TRUE, initialize history list from saved history file.
 // (--no-history; -H)
 static bool read_history_file = true;
 
@@ -173,20 +181,21 @@ static bool no_window_system = false;
 // (--texi-macros-file)
 static std::string texi_macros_file;
 
 // Usage message
 static const char *usage_string =
   "octave [-HVdfhiqvx] [--debug] [--echo-commands] [--eval CODE]\n\
        [--exec-path path] [--force-gui] [--help] [--image-path path]\n\
        [--info-file file] [--info-program prog] [--interactive]\n\
-       [--line-editing] [--no-gui] [--no-history] [--no-init-file]\n\
-       [--no-init-path] [--no-line-editing] [--no-site-file]\n\
-       [--no-window-system] [-p path] [--path path] [--silent]\n\
-       [--traditional] [--verbose] [--version] [file]";
+       [--jit-debug] [--line-editing] [--no-gui] [--no-history]\n\
+       [--no-init-file] [--no-init-path] [--no-jit-compiler]\n\
+       [--no-line-editing] [--no-site-file] [--no-window-system]\n\
+       [-p path] [--path path] [--silent] [--traditional]\n\
+       [--verbose] [--version] [file]";
 
 // This is here so that it's more likely that the usage message and
 // the real set of options will agree.  Note: the `+' must come first
 // to prevent getopt from permuting arguments!
 static const char *short_opts = "+HVdfhip:qvx";
 
 // The code to evaluate at startup (--eval CODE)
 static std::string code_to_eval;
@@ -198,45 +207,49 @@ static bool persist = false;
 // fields in this structure.
 #define DOC_CACHE_FILE_OPTION 1
 #define EVAL_OPTION 2
 #define EXEC_PATH_OPTION 3
 #define FORCE_GUI_OPTION 4
 #define IMAGE_PATH_OPTION 5
 #define INFO_FILE_OPTION 6
 #define INFO_PROG_OPTION 7
-#define LINE_EDITING_OPTION 8
-#define NO_GUI_OPTION 9
-#define NO_INIT_FILE_OPTION 10
-#define NO_INIT_PATH_OPTION 11
-#define NO_LINE_EDITING_OPTION 12
-#define NO_SITE_FILE_OPTION 13
-#define NO_WINDOW_SYSTEM_OPTION 14
-#define PERSIST_OPTION 15
-#define TEXI_MACROS_FILE_OPTION 16
-#define TRADITIONAL_OPTION 17
+#define JIT_DEBUG_OPTION 8
+#define LINE_EDITING_OPTION 9
+#define NO_GUI_OPTION 10
+#define NO_INIT_FILE_OPTION 11
+#define NO_INIT_PATH_OPTION 12
+#define NO_JIT_COMPILER_OPTION 13
+#define NO_LINE_EDITING_OPTION 14
+#define NO_SITE_FILE_OPTION 15
+#define NO_WINDOW_SYSTEM_OPTION 16
+#define PERSIST_OPTION 17
+#define TEXI_MACROS_FILE_OPTION 18
+#define TRADITIONAL_OPTION 19
 struct option long_opts[] =
   {
     { "braindead",        no_argument,       0, TRADITIONAL_OPTION },
     { "debug",            no_argument,       0, 'd' },
     { "doc-cache-file",   required_argument, 0, DOC_CACHE_FILE_OPTION },
     { "echo-commands",    no_argument,       0, 'x' },
     { "eval",             required_argument, 0, EVAL_OPTION },
     { "exec-path",        required_argument, 0, EXEC_PATH_OPTION },
     { "force-gui",        no_argument,       0, FORCE_GUI_OPTION },
     { "help",             no_argument,       0, 'h' },
     { "image-path",       required_argument, 0, IMAGE_PATH_OPTION },
     { "info-file",        required_argument, 0, INFO_FILE_OPTION },
     { "info-program",     required_argument, 0, INFO_PROG_OPTION },
     { "interactive",      no_argument,       0, 'i' },
+    { "jit-debug",        no_argument,       0, JIT_DEBUG_OPTION },
     { "line-editing",     no_argument,       0, LINE_EDITING_OPTION },
     { "no-gui",           no_argument,       0, NO_GUI_OPTION },
     { "no-history",       no_argument,       0, 'H' },
     { "no-init-file",     no_argument,       0, NO_INIT_FILE_OPTION },
     { "no-init-path",     no_argument,       0, NO_INIT_PATH_OPTION },
+    { "no-jit",           no_argument,       0, NO_JIT_COMPILER_OPTION },
     { "no-line-editing",  no_argument,       0, NO_LINE_EDITING_OPTION },
     { "no-site-file",     no_argument,       0, NO_SITE_FILE_OPTION },
     { "no-window-system", no_argument,       0, NO_WINDOW_SYSTEM_OPTION },
     { "norc",             no_argument,       0, 'f' },
     { "path",             required_argument, 0, 'p' },
     { "persist",          no_argument,       0, PERSIST_OPTION },
     { "quiet",            no_argument,       0, 'q' },
     { "silent",           no_argument,       0, 'q' },
@@ -570,21 +583,23 @@ Options:\n\
   --eval CODE             Evaluate CODE.  Exit when done unless --persist.\n\
   --exec-path PATH        Set path for executing subprograms.\n\
   --force-gui             Force graphical user interface to start.\n\
   --help, -h,             Print short help message and exit.\n\
   --image-path PATH       Add PATH to head of image search path.\n\
   --info-file FILE        Use top-level info file FILE.\n\
   --info-program PROGRAM  Use PROGRAM for reading info files.\n\
   --interactive, -i       Force interactive behavior.\n\
+  --jit-debug             Enable JIT compiler debugging/tracing.\n\
   --line-editing          Force readline use for command-line editing.\n\
   --no-gui                Disable the graphical user interface.\n\
   --no-history, -H        Don't save commands to the history list\n\
   --no-init-file          Don't read the ~/.octaverc or .octaverc files.\n\
   --no-init-path          Don't initialize function search path.\n\
+  --no-jit-compiler       Disable the JIT compiler.\n\
   --no-line-editing       Don't use readline for command-line editing.\n\
   --no-site-file          Don't read the site-wide octaverc file.\n\
   --no-window-system      Disable window system, including graphics.\n\
   --norc, -f              Don't read any initialization files.\n\
   --path PATH, -p PATH    Add PATH to head of function search path.\n\
   --persist               Go interactive after --eval or reading from FILE.\n\
   --silent, -q            Don't print message at startup.\n\
   --texi-macros-file FILE Use Texinfo macros in FILE for makeinfo command.\n\
@@ -796,30 +811,38 @@ octave_process_command_line (int argc, c
             info_file = optarg;
           break;
 
         case INFO_PROG_OPTION:
           if (optarg)
             info_program = optarg;
           break;
 
+        case JIT_DEBUG_OPTION:
+          jit_debug_option = true;
+          break;
+
         case LINE_EDITING_OPTION:
           forced_line_editing = true;
           break;
 
+        case NO_GUI_OPTION:
+          no_gui_option = true;
+          break;
+
         case NO_INIT_FILE_OPTION:
           read_init_files = false;
           break;
 
-        case NO_GUI_OPTION:
-          no_gui_option = true;
+        case NO_INIT_PATH_OPTION:
+          set_initial_path = false;
           break;
 
-        case NO_INIT_PATH_OPTION:
-          set_initial_path = false;
+        case NO_JIT_COMPILER_OPTION:
+          no_jit_compiler_option = true;
           break;
 
         case NO_LINE_EDITING_OPTION:
           line_editing = false;
           break;
 
         case NO_SITE_FILE_OPTION:
           read_site_files = 0;
@@ -939,16 +962,22 @@ octave_initialize_interpreter (int argc,
     bind_internal_variable ("info_program", info_program);
 
   if (no_window_system)
     display_info::no_window_system ();
 
   if (! texi_macros_file.empty ())
     bind_internal_variable ("texi_macros_file", texi_macros_file);
 
+  if (jit_debug_option)
+    bind_internal_variable ("enable_jit_debugging", true);
+
+  if (no_jit_compiler_option)
+    bind_internal_variable ("enable_jit_compiler", false);
+
   // Make sure we clean up when we exit.  Also allow users to register
   // functions.  If we don't have atexit or on_exit, we're going to
   // leave some junk files around if we exit abnormally.
 
   atexit (do_octave_atexit);
 
   // Is input coming from a terminal?  If so, we are probably
   // interactive.
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -39,19 +39,20 @@ along with Octave; see the file COPYING.
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "variables.h"
 #include "pt-all.h"
 #include "pt-eval.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 
-#if HAVE_LLVM
 //FIXME: This should be part of tree_evaluator
 #include "pt-jit.h"
+
+#if HAVE_LLVM
 static tree_jit jiter;
 #endif
 
 static tree_evaluator std_evaluator;
 
 tree_evaluator *current_evaluator = &std_evaluator;
 
 int tree_evaluator::dbstep_flag = 0;
@@ -305,17 +306,17 @@ tree_evaluator::visit_simple_for_command
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
 #if HAVE_LLVM
-  if (jiter.execute (cmd, rhs))
+  if (Venable_jit_compiler && jiter.execute (cmd, rhs))
     return;
 #endif
 
   if (error_state || rhs.is_undefined ())
     return;
 
   {
     tree_expression *lhs = cmd.left_hand_side ();
@@ -1042,17 +1043,17 @@ tree_evaluator::visit_unwind_protect_com
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
   if (error_state)
     return;
 
 #if HAVE_LLVM
-  if (jiter.execute (cmd))
+  if (Venable_jit_compiler && jiter.execute (cmd))
     return;
 #endif
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -670,16 +670,35 @@ AC_DEFUN([OCTAVE_CHECK_LIB_QHULL_OK], [
   ])
   if test "$octave_cv_lib_qhull_ok" = "yes"; then
     $1
   else
     $2
   fi
 ])
 dnl
+dnl Find a suitable termlib to use.
+dnl
+AC_DEFUN([OCTAVE_CHECK_LIB_TERMLIB], [
+  TERM_LIBS=
+  octave_found_termlib=no
+  for termlib in ncurses curses termcap terminfo termlib; do
+    AC_CHECK_LIB([${termlib}], [tputs], [
+      TERM_LIBS="-l${termlib}"
+      octave_found_termlib=yes
+      break])
+  done
+
+  if test "$octave_found_termlib" = no; then
+    warn_termlibs="I couldn't find -ltermcap, -lterminfo, -lncurses, -lcurses, or -ltermlib!"
+    AC_MSG_WARN([$warn_termlibs])
+  fi
+  AC_SUBST(TERM_LIBS)
+])
+dnl
 dnl Check for support of OpenMP with a given compiler flag.
 dnl If found define HAVE_OPENMP and add the compile flag
 dnl to CFLAGS and CXXFLAGS.
 dnl
 AC_DEFUN([OCTAVE_CHECK_OPENMP], [
   AC_MSG_CHECKING([for support of OpenMP])
   XCFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS $1"
@@ -1077,16 +1096,18 @@ AC_DEFUN([OCTAVE_ENABLE_READLINE], [
   AC_ARG_ENABLE(readline,
     [AS_HELP_STRING([--disable-readline],
       [use readline library])],
     [if test "$enableval" = no; then
        USE_READLINE=false
        warn_readline="command editing and history features require GNU Readline"
      fi])
   if $USE_READLINE; then
+    dnl RHEL 5 and older systems require termlib set before enabling readline
+    AC_REQUIRE([OCTAVE_CHECK_LIB_TERMLIB])
     save_LIBS="$LIBS"
     LIBS="$TERM_LIBS"
     AC_CHECK_LIB(readline, rl_set_keyboard_input_timeout,
       [READLINE_LIBS="-lreadline"
       AC_DEFINE(USE_READLINE, 1, [Define to 1 to use the readline library.])
       ],
       [AC_MSG_WARN([I need GNU Readline 4.2 or later])
       AC_MSG_ERROR([this is fatal unless you specify --disable-readline])
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -16,113 +16,113 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} print ()
 ## @deftypefnx {Function File} {} print (@var{options})
 ## @deftypefnx {Function File} {} print (@var{filename}, @var{options})
 ## @deftypefnx {Function File} {} print (@var{h}, @var{filename}, @var{options})
-## Print a graph, or save it to a file.  Both output formatted for 
+## Print a plot, or save it to a file.  Both output formatted for 
 ## printing (PDF and PostScript), and many bitmapped and vector
 ## image formats are supported.
 ##
-## @var{h} specifies the figure handle.  If no handle is specified
-## the handle for the current figure is used.
-##
 ## @var{filename} defines the name of the output file.  If the
 ## file name has no suffix, one is inferred from the specified
 ## device and appended to the file name.  If no filename is
 ## specified, the output is sent to the printer.
 ##
-## For output to a printer, to a PostScript file, or a PDF file,
+## @var{h} specifies the figure handle.  If no handle is specified
+## the handle for the current figure is used.
+##
+## For output to a printer, PostScript file, or PDF file,
 ## the paper size is specified by the figure's @code{papersize}
 ## property.  The location and size of the image on the page are
 ## specified by the figure's @code{paperposition} property.  The
 ## orientation of the page is specified by the figure's
 ## @code{paperorientation} property.
 ##
 ## The width and height of images are specified by the figure's
 ## @code{paperpositon(3:4)} property values.
 ##
-## The @code{print} command supports several @var{options}:
+## The @code{print} command supports many @var{options}:
 ##
 ## @table @code
 ## @item -f@var{h}
 ##   Specify the handle, @var{h}, of the figure to be printed.  The
-##   default is the current figure.
+## default is the current figure.
 ##
 ## @item -P@var{printer}
-##   Set the @var{printer} name to which the graph is sent if no
-##   @var{filename} is specified.
+##   Set the @var{printer} name to which the plot is sent if no
+## @var{filename} is specified.
 ##
 ## @item -G@var{ghostscript_command}
-##   Specify the command for calling Ghostscript.  For Unix and Windows,
+##   Specify the command for calling Ghostscript.  For Unix and Windows
 ## the defaults are 'gs' and 'gswin32c', respectively.
 ##
 ## @item -color
 ## @itemx -mono
 ##   Monochrome or color output.
 ##
 ## @item -solid
 ## @itemx -dashed
-##   Forces all lines to be solid or dashed, respectively.
+##   Force all lines to be solid or dashed, respectively.
 ##
 ## @item -portrait
 ## @itemx -landscape
 ##   Specify the orientation of the plot for printed output.  For
 ## non-printed output the aspect ratio of the output corresponds to
 ## the plot area defined by the "paperposition" property in the
 ## orientation specified.  This options is equivalent to changing
 ## the figure's "paperorientation" property.
 ##
 ## @item -TextAlphaBits=@var{n}
 ## @itemx -GraphicsAlphaBits=@var{n}
 ##   Octave is able to produce output for various printers, bitmaps, and
 ## vector formats by using Ghostscript.
 ## For bitmap and printer output anti-aliasing is applied using
 ## Ghostscript's TextAlphaBits and GraphicsAlphaBits options.
 ## The default number of bits for each is 4.
-## Allowed values, for @var{N}, are 1, 2, or 4.
+## Allowed values for @var{N} are 1, 2, or 4.
 ##
 ## @item -d@var{device}
 ##   The available output format is specified by the option @var{device},
-##   and is one of:
+## and is one of:
 ##
 ##   @table @code
 ##   @item ps
 ##   @itemx ps2
 ##   @itemx psc
 ##   @itemx psc2
 ##     Postscript (level 1 and 2, mono and color).  The FLTK graphics
-##     toolkit generates Postscript level 3.0.
+## toolkit generates Postscript level 3.0.
 ##
 ##   @item eps
 ##   @itemx eps2
 ##   @itemx epsc
 ##   @itemx epsc2
 ##     Encapsulated postscript (level 1 and 2, mono and color).  The FLTK
 ## graphic toolkit generates Postscript level 3.0.
 ##
 ##   @item tex
 ##   @itemx epslatex
 ##   @itemx epslatexstandalone
 ##   @itemx pstex
 ##   @itemx pslatex
 ##   @itemx pdflatex
-##     Generate a @LaTeX{} (or @TeX{}) file for labels, and eps/ps/pdf
+##     Generate a @LaTeX{} (or @TeX{}) file for labels and eps/ps/pdf
 ## for graphics.  The file produced by @code{epslatexstandalone} can be
 ## processed directly by @LaTeX{}.  The other formats are intended to
 ## be included in a @LaTeX{} (or @TeX{}) document.  The @code{tex} device
 ## is the same as the @code{epslatex} device.  The @code{pdflatex} device
 ## is only available for the FLTK graphics toolkit.
 ##
 ##   @item tikz
-##     Generate a @LaTeX{} file using PGF/TikZ@.  For the FLTK the result is
-##   PGF.
+##     Generate a @LaTeX{} file using PGF/TikZ@.  For the FLTK toolkit
+## the result is PGF.
 ##
 ##   @item ill
 ##   @itemx aifm
 ##     Adobe Illustrator (Obsolete for Gnuplot versions > 4.2)
 ##
 ##   @item cdr
 ##   @itemx @nospell{corel}
 ##     CorelDraw
@@ -131,19 +131,19 @@
 ##     AutoCAD
 ##
 ##   @item emf
 ##   @itemx meta
 ##     Microsoft Enhanced Metafile
 ##
 ##   @item fig
 ##     XFig.  For the Gnuplot graphics toolkit, the additional options
-##     @option{-textspecial} or @option{-textnormal} can be used to control
-##     whether the special flag should be set for the text in
-##     the figure (default is @option{-textnormal}).
+## @option{-textspecial} or @option{-textnormal} can be used to control
+## whether the special flag should be set for the text in
+## the figure.  (default is @option{-textnormal})
 ##
 ##   @item hpgl
 ##     HP plotter language
 ##
 ##   @item mf
 ##     Metafont
 ##
 ##   @item png
@@ -203,62 +203,62 @@
 ## and devices are available.
 ##
 ##   When Ghostscript output is sent to a printer the size is determined
 ## by the figure's "papersize" property.  When the output
 ## is sent to a file the size is determined by the plot box defined by
 ## the figure's "paperposition" property.
 ##
 ## @itemx -append
-##   Appends the PS, or PDF output to a pre-existing file of the
+##   Append Postscript or PDF output to a pre-existing file of the
 ## same type.
 ##
 ## @itemx -r@var{NUM}
 ##   Resolution of bitmaps in pixels per inch.  For both metafiles and
-## SVG the default is the screen resolution, for other it is 150 dpi.
+## SVG the default is the screen resolution; for other formats it is 150 dpi.
 ## To specify screen resolution, use "-r0".
 ##
 ## @item -tight
-##   Forces a tight bounding box for eps-files.
+##   Force a tight bounding box for eps files.
 ##
 ## @item -@var{preview}
-##   Adds a preview to eps-files.  Supported formats are;
+##   Add a preview to eps files.  Supported formats are:
 ##
 ##   @table @code
 ##   @item -interchange
-##     Provides an interchange preview.
+##     Provide an interchange preview.
 ##
 ##   @item -metalfile
-##     Provides a metafile preview.
+##     Provide a metafile preview.
 ##
 ##   @item -pict
-##     Provides pict preview.
+##     Provide pict preview.
 ##
 ##   @item -tiff
-##     Provides a tiff preview.
+##     Provide a tiff preview.
 ##   @end table
 ##
 ## @item -S@var{xsize},@var{ysize}
-##   Plot size in pixels for EMF, GIF, JPEG, PBM, PNG and SVG@.  For
+##   Plot size in pixels for EMF, GIF, JPEG, PBM, PNG, and SVG@.  For
 ## PS, EPS, PDF, and other vector formats the plot size is in points.
 ## This option is equivalent to changing the size of the plot box
-## associated with "paperposition" property.  Using the command form of
-## the print function, you must quote the @var{xsize},@var{ysize}
-## option.  For example, by writing @w{@code{"-S640,480"}}.
+## associated with the "paperposition" property.  When using the command form
+## of the print function you must quote the @var{xsize},@var{ysize}
+## option.  For example, by writing @w{"-S640,480"}.
 ##
 ## @item -F@var{fontname}
 ## @itemx -F@var{fontname}:@var{size}
 ## @itemx -F:@var{size}
-##   Associates all text with the @var{fontname} and/or @var{fontsize}.
-## @var{fontname} is ignored for some devices; dxf, fig, hpgl, etc.
+##   Use @var{fontname} and/or @var{fontsize} for all text.
+## @var{fontname} is ignored for some devices: dxf, fig, hpgl, etc.
 ## @end table
 ##
 ## The filename and options can be given in any order.
 ##
-## Example: Print to a file, using the svg device.
+## Example: Print to a file using the svg device.
 ##
 ## @example
 ## @group
 ## figure (1);
 ## clf ();
 ## surf (peaks);
 ## print -dsvg figure1.svg
 ## @end group
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #include <config.h>
 #endif
 
 #include <string>
+#include <cstring>
 #include <map>
 #include <list>
 #include <algorithm>
 #include <iostream>
 #include <fstream>
 #include <vector>
 #include <cstdlib>
 
@@ -43,31 +44,31 @@ along with Octave; see the file COPYING.
 
 using namespace std;
 
 static bool initialized = false;
 static map<string,string> vars;
 
 static string OCTAVE_VERSION = %OCTAVE_CONF_VERSION%;
 
-static std::string
-substitute_prefix (const std::string& s, const std::string& prefix,
-                   const std::string& new_prefix)
+static string
+substitute_prefix (const string& s, const string& prefix,
+                   const string& new_prefix)
 {
-  std::string retval = s;
+  string retval = s;
 
   if (!prefix.empty () && new_prefix != prefix)
     {
       int len = prefix.length ();
       if (retval.find (prefix) == 0)
         retval.replace (0, len, new_prefix);
     }
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
-  std::replace (retval.begin (), retval.end (), '/', '\\');
+  replace (retval.begin (), retval.end (), '/', '\\');
 #endif
 
   return retval;
 }
 
 static string
 get_line (FILE *fp)
 {
@@ -118,17 +119,17 @@ initialize (void)
 
   initialized = true;
 
   vars["OCTAVE_HOME"] = get_variable ("OCTAVE_HOME", "");
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
   int n = 1024;
 
-  std::string bin_dir (n, '\0');
+  string bin_dir (n, '\0');
 
   while (true)
     {
       int status = GetModuleFileName (0, &bin_dir[0], n);
 
       if (status < n)
         {
           bin_dir.resize (status);
@@ -149,20 +150,20 @@ initialize (void)
         vars["OCTAVE_HOME"] = bin_dir.substr (0, pos);
     }
 #endif
 
   vars["SED"] = get_variable ("SED", %OCTAVE_CONF_SED%);
 
   vars["OCTAVE_PREFIX"] = %OCTAVE_CONF_PREFIX%;
 
-  std::string DEFAULT_OCTINCLUDEDIR = %OCTAVE_CONF_OCTINCLUDEDIR%;
-  std::string DEFAULT_INCLUDEDIR = %OCTAVE_CONF_INCLUDEDIR%;
-  std::string DEFAULT_LIBDIR = %OCTAVE_CONF_LIBDIR%;
-  std::string DEFAULT_OCTLIBDIR = %OCTAVE_CONF_OCTLIBDIR%;
+  string DEFAULT_OCTINCLUDEDIR = %OCTAVE_CONF_OCTINCLUDEDIR%;
+  string DEFAULT_INCLUDEDIR = %OCTAVE_CONF_INCLUDEDIR%;
+  string DEFAULT_LIBDIR = %OCTAVE_CONF_LIBDIR%;
+  string DEFAULT_OCTLIBDIR = %OCTAVE_CONF_OCTLIBDIR%;
 
   if (! vars["OCTAVE_HOME"].empty ())
     {
       DEFAULT_OCTINCLUDEDIR
         = substitute_prefix (DEFAULT_OCTINCLUDEDIR, vars["OCTAVE_PREFIX"],
                              vars["OCTAVE_HOME"]);
 
       DEFAULT_INCLUDEDIR
@@ -179,28 +180,28 @@ initialize (void)
     }
 
   vars["OCTINCLUDEDIR"] = get_variable ("OCTINCLUDEDIR", DEFAULT_OCTINCLUDEDIR);
   vars["INCLUDEDIR"] = get_variable ("INCLUDEDIR", DEFAULT_INCLUDEDIR);
   vars["LIBDIR"] = get_variable ("LIBDIR", DEFAULT_LIBDIR);
   vars["OCTLIBDIR"] = get_variable ("OCTLIBDIR", DEFAULT_OCTLIBDIR);
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
-  std::string DEFAULT_INCFLAGS
+  string DEFAULT_INCFLAGS
     = "-I" + quote_path (vars["OCTINCLUDEDIR"] + "\\..")
     + " -I" + quote_path (vars["OCTINCLUDEDIR"]);
 #else
-  std::string DEFAULT_INCFLAGS
+  string DEFAULT_INCFLAGS
     = "-I" + quote_path (vars["OCTINCLUDEDIR"] + "/..")
     + " -I" + quote_path (vars["OCTINCLUDEDIR"]);
 #endif
   if (vars["INCLUDEDIR"] != "/usr/include")
     DEFAULT_INCFLAGS += " -I" + quote_path (vars["INCLUDEDIR"]);
 
-  std::string DEFAULT_LFLAGS = "-L" + quote_path (vars["OCTLIBDIR"]);
+  string DEFAULT_LFLAGS = "-L" + quote_path (vars["OCTLIBDIR"]);
   if (vars["LIBDIR"] != "/usr/lib")
     DEFAULT_LFLAGS += " -L" + quote_path (vars["LIBDIR"]);
 
   vars["CPPFLAGS"] = get_variable ("CPPFLAGS", %OCTAVE_CONF_CPPFLAGS%);
   vars["INCFLAGS"] = get_variable ("INCFLAGS", DEFAULT_INCFLAGS);
   vars["F77"] = get_variable ("F77", %OCTAVE_CONF_F77%);
   vars["FFLAGS"] = get_variable ("FFLAGS", %OCTAVE_CONF_FFLAGS%);
   vars["FPICFLAG"] = get_variable ("FPICFLAG", %OCTAVE_CONF_FPICFLAG%);
@@ -314,17 +315,17 @@ static string help_msg =
 "                            DEPEND_FLAGS              OCTAVE_LINK_OPTS\n"
 "                            DL_LD                     OCT_LINK_DEPS\n"   
 "                            DL_LDFLAGS                OCT_LINK_OPTS\n"   
 "                            EXEEXT                    RDYNAMIC_FLAG\n"   
 "                            F77                       READLINE_LIBS\n"   
 "                            F77_INTEGER_8_FLAG        SED\n"             
 "                            FFLAGS                    XTRA_CFLAGS\n"     
 "                            FFTW3_LDFLAGS             XTRA_CXXFLAGS\n"   
-"                            FFTW3_LIBS                                   
+"                            FFTW3_LIBS\n"      
 "                            FFTW3F_LDFLAGS\n"
 "                            FFTW3F_LIBS\n"
 "\n"
 "  --link-stand-alone      Link a stand-alone executable file.\n"
 "\n"
 "  --mex                   Assume we are creating a MEX file.  Set the\n"
 "                          default output extension to \".mex\".\n"
 "\n"
@@ -347,31 +348,33 @@ static string help_msg =
 #ifdef _MSC_VER
 "                            .lib  library file\n"
 #endif
 "\n";
 
 static string
 basename (const string& s, bool strip_path = false)
 {
+  string retval;
   size_t pos = s.rfind ('.');
-  string retval;
 
   if (pos == string::npos)
     retval = s;
   else
     retval = s.substr (0, pos);
+
   if (strip_path)
     {
       size_t p1 = retval.rfind ('/'), p2 = retval.rfind ('\\');
       pos = (p1 != string::npos && p2 != string::npos
              ? max (p1, p2) : (p2 != string::npos ? p2 : p1));
       if (pos != string::npos)
-        retval = retval.substr (0, pos);
+        retval = retval.substr (++pos, string::npos);
     }
+
   return retval;
 }
 
 inline bool
 starts_with (const string& s, const string& prefix)
 {
   return (s.length () >= prefix.length () && s.find (prefix) == 0);
 }
