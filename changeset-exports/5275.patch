# HG changeset patch
# User jwe
# Date 1112976457 0
#      Fri Apr 08 16:07:37 2005 +0000
# Node ID 23b37da9fd5b67e7a8dfda2422b14244a0085ca2
# Parent  eae7b40388e9ad87d423ea35a57d0df99c659cd5
[project @ 2005-04-08 16:07:35 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,31 @@
+2005-04-08  John W. Eaton  <jwe@octave.org>
+
+	* Initial merge of 64-bit changes from Clinton Chee:
+
+	2005-04-07  John W. Eaton  <jwe@octave.org>
+
+	* configure.in (--enable-64): Make default disabled.
+
+	2005-04-06  John W. Eaton  <jwe@octave.org>
+
+	* mk-opts.pl (emit_show_function, emit_set_functions,
+	emit_print_function): Also accept "octave_idx_type" and
+	"Array<octave_idx_type>".
+
+	2005-04-01  John W. Eaton  <jwe@octave.org>
+
+	* Makeconf.in (USE_64_BIT_IDX_T): Substitute value.
+	(do-subst-config-vals): Add to list of substitutions.
+
+	* configure.in (AC_CONFIG_FILES): Perform substitutions on
+	liboctave/oct-types.h too.
+	Handle --enable-64.
+
 2005-04-06  David Bateman  <dbateman@free.fr>
 
 	* configure.in: Split the HDF5 and zlib detection code, so that zlib 
 	can be used for compressed load/save in the absence of HDF5.
 
 	* Makeconf.in: Define UMFPACK_LIBS.
 
 	* Configure.in: Slightly alter the UMFPACK detection code so that it 
diff --git a/Makeconf.in b/Makeconf.in
--- a/Makeconf.in
+++ b/Makeconf.in
@@ -185,16 +185,18 @@ LIBREADLINE = @LIBREADLINE@
 TERMLIBS = @TERMLIBS@
 
 BLAS_LIBS = @BLAS_LIBS@
 FFTW_LIBS = @FFTW_LIBS@
 GLPK_LIBS = @GLPK_LIBS@
 UMFPACK_LIBS = @UMFPACK_LIBS@
 LIBS = @LIBS@
 
+USE_64_BIT_IDX_T = @USE_64_BIT_IDX_T@
+
 # The arguments passed to configure.
 config_opts = @config_opts@
 
 # ==================== Where To Install Things ====================
 
 # The default location for installation.  Everything is placed in
 # subdirectories of this directory.  The default values for many of
 # the variables below are expressed in terms of this one, so you may
@@ -460,16 +462,17 @@ echo "making $@ from $<"
   -e "s;%OCTAVE_CONF_SHLEXT%;\"${SHLEXT}\";" \
   -e "s;%OCTAVE_CONF_SHLLINKEXT%;\"${SHLLINKEXT}\";" \
   -e "s;%OCTAVE_CONF_SHLEXT_VER%;\"${SHLEXT_VER}\";" \
   -e "s;%OCTAVE_CONF_SH_LD%;\"${SH_LD}\";" \
   -e "s;%OCTAVE_CONF_SH_LDFLAGS%;\"${SH_LDFLAGS}\";" \
   -e "s;%OCTAVE_CONF_SONAME_FLAGS%;\"${SONAME_FLAGS}\";" \
   -e "s;%OCTAVE_CONF_STATIC_LIBS%;\"${STATIC_LIBS}\";" \
   -e "s;%OCTAVE_CONF_UGLY_DEFS%;\"${UGLY_DEFS}\";" \
+  -e "s;%OCTAVE_CONF_USE_64_BIT_IDX_T%;\"${USE_64_BIT_IDX_T}\";" \
   -e "s;%OCTAVE_CONF_VERSION%;\"${version}\";" \
   -e "s;%OCTAVE_CONF_ENABLE_DYNAMIC_LINKING%;\"${ENABLE_DYNAMIC_LINKING}\";" \
   -e "s;%OCTAVE_CONF_XTRA_CFLAGS%;\"${XTRA_CFLAGS}\";" \
   -e "s;%OCTAVE_CONF_XTRA_CXXFLAGS%;\"${XTRA_CXXFLAGS}\";" \
   -e "s;%OCTAVE_CONF_YACC%;\"${YACC}\";" \
   -e "s;%OCTAVE_CONF_YFLAGS%;\"${YFLAGS}\";" \
   -e "s;%OCTAVE_CONF_config_opts%;\"${config_opts}\";" | \
   $(SED)  -e "s;%OCTAVE_CONF_DEFS%;\"${UGLY_DEFS}\";" > $@-t
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.470 $)
+AC_REVISION($Revision: 1.471 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -139,16 +139,48 @@ AC_SUBST(PLPLOT_DIR)
 BOUNDS_CHECKING=false
 AC_ARG_ENABLE(bounds-check,
   [  --enable-bounds-check   for internal array classes (default is no)],
   [if test "$enableval" = yes; then BOUNDS_CHECKING=true; fi], [])
 if $BOUNDS_CHECKING; then
   AC_DEFINE(BOUNDS_CHECKING, 1, [Define to use internal bounds checking.])
 fi
 
+### If possible, use a 64-bit integer type for array dimensions and indexing.
+
+USE_64_BIT_IDX_T=false
+OCTAVE_IDX_TYPE=int
+AC_ARG_ENABLE(64,
+  [  --enable-64             use 64-bit integer for array dimensions and indexing],
+  [if test "$enableval" = yes; then USE_64_BIT_IDX_T=true; fi], [])
+if $USE_64_BIT_IDX_T; then
+  AC_CHECK_SIZEOF(void *)
+  AC_CHECK_SIZEOF(int)
+  AC_CHECK_SIZEOF(long)
+  if test $ac_cv_sizeof_void_p -eq 8; then
+    if test $ac_cv_sizeof_int -eq 8; then
+      OCTAVE_IDX_TYPE=int
+    elif test $ac_cv_sizeof_long -eq 8; then
+      OCTAVE_IDX_TYPE=long
+    else
+      AC_MSG_WARN([no suitable type found for octave_idx_type so disabling 64-bit features])    
+      USE_64_BIT_IDX_T=false
+    fi
+  else
+    warn_64_bit="pointers are not 64-bits wide so disabling 64-bit features"
+    AC_MSG_WARN($warn_64_bit)
+    USE_64_BIT_IDX_T=false
+  fi
+fi
+AC_SUBST(OCTAVE_IDX_TYPE)
+if $USE_64_BIT_IDX_T; then
+  AC_DEFINE(USE_64_BIT_IDX_T, 1, [Define if using 64-bit integers for array dimensions and indexing])
+fi
+AC_SUBST(USE_64_BIT_IDX_T)
+
 ### It seems that there are some broken inline assembly functions in
 ### the GNU libc.  Since I'm not sure how to test whether we are using
 ### GNU libc, just disable them for all platforms.
 
 AC_MSG_RESULT([defining __NO_MATH_INLINES avoids buggy GNU libc exp function])
 AC_DEFINE(__NO_MATH_INLINES, 1, [Define if your version of GNU libc has buggy inline assembly code for math functions like exp.])
 
 ### See which C++ compiler to use (we expect to find g++).
@@ -665,17 +697,17 @@ AC_SUBST(BLAS_DIR)
 AC_SUBST(LAPACK_DIR)
 
 # Check for UMFPACK library.
 
 UMFPACK_LIBS=
 AC_SUBST(UMFPACK_LIBS)
 
 AC_ARG_WITH(umfpack,
-  [  --without-umfpack          don't use UMFPACK, disable some sparse functionality],
+  [  --without-umfpack       don't use UMFPACK, disable some sparse functionality],
   with_umfpack=$withval, with_umfpack=yes)
 
 if test "$with_umfpack" = "yes"; then
   have_umfpack_header=no
   with_umfpack=no
   AC_CHECK_HEADER(umfpack/umfpack.h, [have_umfpack_header=yes; break])
   if test "$have_umfpack_header" = yes; then
     AC_CHECK_LIB(amd, amd_postorder, [
@@ -1533,31 +1565,33 @@ typedef int sig_atomic_t;
 
 #if defined (_UNICOS)
 #define F77_USES_CRAY_CALLING_CONVENTION
 #endif
 
 #if 0
 #define F77_USES_VISUAL_FORTRAN_CALLING_CONVENTION
 #endif
+
+#include "oct-types.h"
 ])
 
 ### Do the substitutions in all the Makefiles.
 
 AC_CONFIG_FILES([Makefile octMakefile Makeconf install-octave \
   test/Makefile dlfcn/Makefile \
   doc/Makefile doc/faq/Makefile doc/interpreter/Makefile \
   doc/liboctave/Makefile doc/refcard/Makefile emacs/Makefile \
-  examples/Makefile liboctave/Makefile src/Makefile \
-  libcruft/Makefile libcruft/Makerules libcruft/amos/Makefile \
-  libcruft/blas/Makefile libcruft/daspk/Makefile \
-  libcruft/dasrt/Makefile libcruft/dassl/Makefile \
-  libcruft/fftpack/Makefile libcruft/lapack/Makefile \
-  libcruft/minpack/Makefile libcruft/misc/Makefile \
-  libcruft/odepack/Makefile \
+  examples/Makefile liboctave/Makefile liboctave/oct-types.h \
+  src/Makefile libcruft/Makefile libcruft/Makerules \
+  libcruft/amos/Makefile libcruft/blas/Makefile \
+  libcruft/daspk/Makefile libcruft/dasrt/Makefile 
+  libcruft/dassl/Makefile libcruft/fftpack/Makefile \
+  libcruft/lapack/Makefile libcruft/minpack/Makefile \
+  libcruft/misc/Makefile libcruft/odepack/Makefile \
   libcruft/ordered-qz/Makefile libcruft/quadpack/Makefile \
   libcruft/ranlib/Makefile libcruft/slatec-fn/Makefile \
   libcruft/slatec-err/Makefile libcruft/villad/Makefile \
   libcruft/blas-xtra/Makefile libcruft/lapack-xtra/Makefile])
 AC_OUTPUT
 
 AC_CONFIG_COMMANDS([default-1],[[chmod +x install-octave]],[[]])
 
@@ -1589,16 +1623,17 @@ Octave is now configured for $canonical_
   Default pager:        $DEFAULT_PAGER
   gnuplot:              $GNUPLOT_BINARY
 
   Do internal array bounds checking:  $BOUNDS_CHECKING
   Build static libraries:             $STATIC_LIBS
   Build shared libraries:             $SHARED_LIBS
   Dynamic Linking:                    $ENABLE_DYNAMIC_LINKING $DL_API_MSG
   Include support for GNU readline:   $USE_READLINE
+  64-bit array dims and indexing:     $USE_64_BIT_IDX_T
 ])
 
 warn_msg_printed=false
 
 if $ENABLE_DYNAMIC_LINKING; then
   if $SHARED_LIBS; then
     true
   else
@@ -1678,16 +1713,21 @@ if test -n "$warn_hdf5"; then
   warn_msg_printed=true
 fi
 
 if test -n "$warn_zlib"; then
   AC_MSG_WARN($warn_zlib)
   warn_msg_printed=true
 fi
 
+if test -n "$warn_64_bit"; then
+  AC_MSG_WARN($warn_64_bit)
+  warn_msg_printed=true
+fi
+
 if test -n "$warn_gnuplot"; then
 
   ## If you change this text, be sure to also change the corresponding
   ## set of warnings above.
 
   AC_MSG_WARN([I didn't find gnuplot.  It isn't necessary to have gnuplot])
   AC_MSG_WARN([installed, but you won't be able to use any of Octave's])
   AC_MSG_WARN([plotting commands without it.])
diff --git a/liboctave/Array-i.cc b/liboctave/Array-i.cc
--- a/liboctave/Array-i.cc
+++ b/liboctave/Array-i.cc
@@ -27,16 +27,17 @@ Software Foundation, 59 Temple Place - S
 #include "oct-inttypes.h"
 
 // Instantiate Arrays of integer values.
 
 #include "Array.h"
 #include "Array.cc"
 
 INSTANTIATE_ARRAY_AND_ASSIGN (int);
+INSTANTIATE_ARRAY_AND_ASSIGN (long);
 
 INSTANTIATE_ARRAY_ASSIGN (int, short);
 INSTANTIATE_ARRAY_ASSIGN (int, char);
 
 INSTANTIATE_ARRAY_AND_ASSIGN (octave_int8);
 INSTANTIATE_ARRAY_AND_ASSIGN (octave_int16);
 INSTANTIATE_ARRAY_AND_ASSIGN (octave_int32);
 INSTANTIATE_ARRAY_AND_ASSIGN (octave_int64);
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -24,17 +24,17 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "Array-util.h"
 #include "dim-vector.h"
 #include "lo-error.h"
 
 bool
-index_in_bounds (const Array<int>& ra_idx, const dim_vector& dimensions)
+index_in_bounds (const Array<octave_idx_type>& ra_idx, const dim_vector& dimensions)
 {
   bool retval = true;
 
   int n = ra_idx.length ();
 
   if (n == dimensions.length ())
     {
       for (int i = 0; i < n; i++)
@@ -48,17 +48,17 @@ index_in_bounds (const Array<int>& ra_id
     }
   else
     retval = false;
 
   return retval;
 }
 
 void
-increment_index (Array<int>& ra_idx, const dim_vector& dimensions,
+increment_index (Array<octave_idx_type>& ra_idx, const dim_vector& dimensions,
 		 int start_dimension)
 {
   ra_idx(start_dimension)++;
 
   int n = ra_idx.length () - 1;
 
   for (int i = start_dimension; i < n; i++)
     {
@@ -67,20 +67,20 @@ increment_index (Array<int>& ra_idx, con
       else
  	{
  	  ra_idx(i) = 0;
  	  ra_idx(i+1)++;
  	}
     }
 }
 
-int
-get_scalar_idx (Array<int>& idx, dim_vector& dims)
+octave_idx_type
+get_scalar_idx (Array<octave_idx_type>& idx, dim_vector& dims)
 {
-  int retval (-1);
+  octave_idx_type retval (-1);
 
   int n = idx.length ();
 
   if (n > 0)
     {
       retval = idx(--n);
 
       while (--n >= 0)
@@ -88,22 +88,22 @@ get_scalar_idx (Array<int>& idx, dim_vec
 	  retval *= dims (n);
 	
 	  retval += idx(n);
 	}
     }
   return retval;
 }
 
-int
-num_ones (const Array<int>& ra_idx)
+octave_idx_type
+num_ones (const Array<octave_idx_type>& ra_idx)
 {
-  int retval = 0;
+  octave_idx_type retval = 0;
 
-  for (int i = 0; i < ra_idx.length (); i++)
+  for (octave_idx_type i = 0; i < ra_idx.length (); i++)
     {
       if (ra_idx (i) == 1)
 	retval++;
     }
 
   return retval;
 }
 
@@ -129,36 +129,36 @@ is_scalar (const dim_vector& dim)
 	      break;
 	    }
 	}
     }
   return retval;
 }
 
 bool
-any_ones (const Array<int>& arr)
+any_ones (const Array<octave_idx_type>& arr)
 {
   bool retval = false;
 
-  for (int i = 0; i < arr.length (); i++)
+  for (octave_idx_type i = 0; i < arr.length (); i++)
     {
       if (arr (i) == 1)
 	{
 	  retval = true;
 	
 	  break;
 	}
     }
   return retval;
 }
 
-int
-compute_index (const Array<int>& ra_idx, const dim_vector& dims)
+octave_idx_type
+compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims)
 {
-  int retval = -1;
+  octave_idx_type retval = -1;
 
   int n = dims.length ();
 
   if (n > 0 && n == ra_idx.length ())
     {
       retval = ra_idx(--n);
 
       while (--n >= 0)
@@ -170,33 +170,33 @@ compute_index (const Array<int>& ra_idx,
     }
   else
     (*current_liboctave_error_handler)
       ("ArrayN<T>::compute_index: invalid ra_idxing operation");
 
   return retval;
 }
 
-Array<int>
+Array<octave_idx_type>
 conv_to_int_array (const Array<idx_vector>& a)
 {
-  Array<int> retval (a.length ());
+  Array<octave_idx_type> retval (a.length ());
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     retval (i) = a(i).elem (0);
 
   return retval;
 }
 
 Array<idx_vector>
-conv_to_array (const idx_vector *tmp, const int len)
+conv_to_array (const idx_vector *tmp, const octave_idx_type len)
 {
   Array<idx_vector> retval (len);
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
       retval (i) = tmp[i];
 
   return retval;
 }
 
 dim_vector
 freeze (Array<idx_vector>& ra_idx, const dim_vector& dimensions, int resize_ok)
 {
@@ -213,23 +213,23 @@ freeze (Array<idx_vector>& ra_idx, const
   for (int i = 0; i < n; i++)
     retval(i) = ra_idx(i).freeze (dimensions(i), tag[i < 2 ? i : 3],
 				  resize_ok);
 
   return retval;
 }
 
 bool
-vector_equivalent (const Array<int>& ra_idx)
+vector_equivalent (const Array<octave_idx_type>& ra_idx)
 {
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
   bool found_first = false;
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     {
       if (ra_idx(i) != 1)
         {
 	  if (! found_first)
 	    found_first = true;
 	  else
 	    return false;
 	}
@@ -238,38 +238,38 @@ vector_equivalent (const Array<int>& ra_
   return true;
 }
 
 bool
 all_ok (const Array<idx_vector>& ra_idx)
 {
   bool retval = true;
 
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     {
       if (! ra_idx(i))
 	{
 	  retval = false;
 	  break;
 	}
     }
 
   return retval;
 }
 
 bool
 any_orig_empty (const Array<idx_vector>& ra_idx)
 {
   bool retval = false;
 
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     {
       if (ra_idx(i).orig_empty ())
 	{
 	  retval = true;
 	  break;
 	}
     }
 
@@ -277,114 +277,114 @@ any_orig_empty (const Array<idx_vector>&
 }
 
 bool
 all_colon_equiv (const Array<idx_vector>& ra_idx,
 		 const dim_vector& frozen_lengths)
 {
   bool retval = true;
 
-  int idx_n = ra_idx.length ();
+  octave_idx_type idx_n = ra_idx.length ();
 
   int n = frozen_lengths.length ();
 
   assert (idx_n == n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     {
       if (! ra_idx(i).is_colon_equiv (frozen_lengths(i)))
 	{
 	  retval = false;
 	  break;
 	}
     }
 
   return retval;
 }
 
 bool
-is_in (int num, const idx_vector& idx)
+is_in (octave_idx_type num, const idx_vector& idx)
 {
-  int n = idx.capacity ();
+  octave_idx_type n = idx.capacity ();
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     if (idx.elem (i) == num)
       return true;
 
   return false;
 }
 
-int
-how_many_lgt (const int num, idx_vector& idxv)
+octave_idx_type
+how_many_lgt (const octave_idx_type num, idx_vector& idxv)
 {
-  int retval = 0;
+  octave_idx_type retval = 0;
 
-  int n = idxv.capacity ();
+  octave_idx_type n = idxv.capacity ();
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     {
       if (num > idxv.elem (i))
 	retval++;
     }
 
   return retval;
 }
 
 bool
-all_ones (const Array<int>& arr)
+all_ones (const Array<octave_idx_type>& arr)
 {
   bool retval = true;
 
-  for (int i = 0; i < arr.length (); i++)
+  for (octave_idx_type i = 0; i < arr.length (); i++)
     {
       if (arr(i) != 1)
 	{
 	  retval = false;
 	  break;
 	}
     }
 
   return retval;
 }
 
-Array<int>
-get_elt_idx (const Array<idx_vector>& ra_idx, const Array<int>& result_idx)
+Array<octave_idx_type>
+get_elt_idx (const Array<idx_vector>& ra_idx, const Array<octave_idx_type>& result_idx)
 {
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
-  Array<int> retval (n);
+  Array<octave_idx_type> retval (n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     retval(i) = ra_idx(i).elem (result_idx(i));
 
   return retval;
 }
 
-Array<int>
-get_ra_idx (int idx, const dim_vector& dims)
+Array<octave_idx_type>
+get_ra_idx (octave_idx_type idx, const dim_vector& dims)
 {
-  Array<int> retval;
+  Array<octave_idx_type> retval;
 
   int n_dims = dims.length ();
 
   retval.resize (n_dims);
 
   for (int i = 0; i < n_dims; i++)
     retval(i) = 0;
 
   assert (idx > 0 || idx < dims.numel ());
 
-  for (int i = 0; i < idx; i++)
+  for (octave_idx_type i = 0; i < idx; i++)
     increment_index (retval, dims);
 
   // XXX FIXME XXX -- the solution using increment_index is not
   // efficient.
 
 #if 0
-  int var = 1;
+  octave_idx_type var = 1;
   for (int i = 0; i < n_dims; i++)
     {
       std::cout << "idx: " << idx << ", var: " << var << ", dims(" << i << "): " << dims(i) <<"\n";
       retval(i) = ((int)floor(((idx) / (double)var))) % dims(i);
       idx -= var * retval(i);
       var = dims(i);
     }
 #endif
@@ -419,18 +419,18 @@ short_freeze (Array<idx_vector>& ra_idx,
         size_left *= dimensions(i); 
  
       if (ra_idx(n-1).is_colon())
         {
 	  retval(n-1) = size_left;
 	}
       else
 	{
-	  int last_ra_idx = ra_idx(n-1)(0);
-	  for (int i = 1; i < ra_idx (n - 1).capacity (); i++)
+	  octave_idx_type last_ra_idx = ra_idx(n-1)(0);
+	  for (octave_idx_type i = 1; i < ra_idx (n - 1).capacity (); i++)
 	    last_ra_idx = (last_ra_idx > ra_idx(n-1)(i) ? last_ra_idx : 
 			   ra_idx(n-1)(i));
 
 	  if (last_ra_idx < size_left)
             {
               retval(n-1) = ra_idx(n-1).freeze (size_left,
 						"dimension", resize_ok);
             }
@@ -445,25 +445,25 @@ short_freeze (Array<idx_vector>& ra_idx,
 		("index exceeds N-d array dimensions");
 	    }
 	}
     }
 
   return retval;
 }
 
-Array<int>
-calc_permutated_idx (const Array<int>& old_idx, 
-		     const Array<int>& perm_vec, bool inv)
+Array<octave_idx_type>
+calc_permutated_idx (const Array<octave_idx_type>& old_idx, 
+		     const Array<octave_idx_type>& perm_vec, bool inv)
 {
-  int n_el = old_idx.length ();
+  octave_idx_type n_el = old_idx.length ();
 
-  Array<int> retval (n_el);
+  Array<octave_idx_type> retval (n_el);
 
-  for (int i = 0; i < n_el; i++)
+  for (octave_idx_type i = 0; i < n_el; i++)
     {
       if (inv)
 	retval(perm_vec(i)) = old_idx(i);
       else
 	retval(i) = old_idx(perm_vec(i));
     }
 
   return retval;
diff --git a/liboctave/Array-util.h b/liboctave/Array-util.h
--- a/liboctave/Array-util.h
+++ b/liboctave/Array-util.h
@@ -25,66 +25,66 @@ Software Foundation, 59 Temple Place - S
 
 #include <cassert>
 
 #include "Array.h"
 #include "dim-vector.h"
 #include "idx-vector.h"
 #include "lo-error.h"
 
-extern bool index_in_bounds (const Array<int>& ra_idx,
+extern bool index_in_bounds (const Array<octave_idx_type>& ra_idx,
 			     const dim_vector& dimensions);
 
-extern void increment_index (Array<int>& ra_idx,
+extern void increment_index (Array<octave_idx_type>& ra_idx,
 			     const dim_vector& dimensions,
 			     int start_dimension = 0);
 
-extern int get_scalar_idx (Array<int>& idx, dim_vector& dims);
+extern octave_idx_type get_scalar_idx (Array<octave_idx_type>& idx, dim_vector& dims);
 
-extern int num_ones (const Array<int>& ra_idx);
+extern octave_idx_type num_ones (const Array<octave_idx_type>& ra_idx);
 
 extern bool is_scalar (const dim_vector& dim);
 
-extern bool any_ones (const Array<int>& arr);
+extern bool any_ones (const Array<octave_idx_type>& arr);
 
-extern int compute_index (const Array<int>& ra_idx, const dim_vector& dims);
+extern octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims);
 
-extern Array<int> conv_to_int_array (const Array<idx_vector>& a);
+extern Array<octave_idx_type> conv_to_int_array (const Array<idx_vector>& a);
 
-extern Array<idx_vector> conv_to_array (const idx_vector *tmp, const int len);
+extern Array<idx_vector> conv_to_array (const idx_vector *tmp, const octave_idx_type len);
 
 extern dim_vector freeze (Array<idx_vector>& ra_idx,
 			  const dim_vector& dimensions, int resize_ok);
 
-extern bool vector_equivalent (const Array<int>& ra_idx);
+extern bool vector_equivalent (const Array<octave_idx_type>& ra_idx);
 
 extern bool all_ok (const Array<idx_vector>& ra_idx);
 
 extern bool any_orig_empty (const Array<idx_vector>& ra_idx);
 
 extern bool all_colon_equiv (const Array<idx_vector>& ra_idx,
 			     const dim_vector& frozen_lengths);
 
-extern bool is_in (int num, const idx_vector& idx);
+extern bool is_in (octave_idx_type num, const idx_vector& idx);
 
-extern int how_many_lgt (const int num, idx_vector& idxv);
+extern octave_idx_type how_many_lgt (const octave_idx_type num, idx_vector& idxv);
 
-extern bool all_ones (const Array<int>& arr);
+extern bool all_ones (const Array<octave_idx_type>& arr);
 
-extern Array<int> get_elt_idx (const Array<idx_vector>& ra_idx,
-			       const Array<int>& result_idx);
+extern Array<octave_idx_type> get_elt_idx (const Array<idx_vector>& ra_idx,
+			       const Array<octave_idx_type>& result_idx);
 
-extern Array<int> get_ra_idx (int idx, const dim_vector& dims);
+extern Array<octave_idx_type> get_ra_idx (octave_idx_type idx, const dim_vector& dims);
 
 extern dim_vector short_freeze (Array<idx_vector>& ra_idx,
 				const dim_vector& dimensions,
 				int resize_ok);
 
-extern Array<int> calc_permutated_idx (const Array<int>& old_idx, 
-				       const Array<int>& perm_vec, bool inv);
+extern Array<octave_idx_type> calc_permutated_idx (const Array<octave_idx_type>& old_idx, 
+				       const Array<octave_idx_type>& perm_vec, bool inv);
 
 extern void gripe_nonconformant (const char *op, int op1_len, int op2_len);
 
 extern void gripe_nonconformant (const char *op, int op1_nr, int op1_nc,
 				 int op2_nr, int op2_nc);
 
 
 extern void gripe_nonconformant (const char *op, dim_vector& op1_dims,
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -88,17 +88,17 @@ Array<T>::squeeze (void) const
 	  switch (k)
 	    {
 	    case 0:
 	      new_dimensions = dim_vector (1, 1);
 	      break;
 
 	    case 1:
 	      {
-		int tmp = new_dimensions(0);
+		octave_idx_type tmp = new_dimensions(0);
 
 		new_dimensions.resize (2);
 
 		new_dimensions(0) = tmp;
 		new_dimensions(1) = 1;
 	      }
 	      break;
 
@@ -119,76 +119,77 @@ Array<T>::squeeze (void) const
 
   return retval;
 }
 
 // A guess (should be quite conservative).
 #define MALLOC_OVERHEAD 1024
 
 template <class T>
-int
-Array<T>::get_size (int r, int c)
+octave_idx_type
+Array<T>::get_size (octave_idx_type r, octave_idx_type c)
 {
   // XXX KLUGE XXX
 
   // If an allocation of an array with r * c elements of type T
   // would cause an overflow in the allocator when computing the
   // size of the allocation, then return a value which, although
   // not equivalent to the actual request, should be too large for
   // most current hardware, but not so large to cause the
   // allocator to barf on computing retval * sizeof (T).
 
   static int nl;
   static double dl
-    = frexp (static_cast<double>
-	     (INT_MAX - MALLOC_OVERHEAD) / sizeof (T), &nl);
+    = frexp (static_cast<double> 
+	(std::numeric_limits<octave_idx_type>::max() - MALLOC_OVERHEAD) / sizeof (T), &nl);
 
   // This value should be an integer.  If we return this value and
   // things work the way we expect, we should be paying a visit to
   // new_handler in no time flat.
-  static int max_items = static_cast<int> (ldexp (dl, nl));
+  static octave_idx_type max_items = static_cast<octave_idx_type> (ldexp (dl, nl));  // = dl.2^nl
 
   int nr, nc;
-  double dr = frexp (static_cast<double> (r), &nr);
-  double dc = frexp (static_cast<double> (c), &nc);
+  double dr = frexp (static_cast<double> (r), &nr);   // r = dr * 2^nr
+  double dc = frexp (static_cast<double> (c), &nc);   // c = dc * 2^nc
 
   int nt = nr + nc;
   double dt = dr * dc;
 
   if (dt < 0.5)
     {
       nt--;
       dt *= 2;
     }
 
+	// if (r*c) below limit, then return r*c, otherwise return TOO BIG num!
   return (nt < nl || (nt == nl && dt < dl)) ? r * c : max_items;
 }
 
 template <class T>
-int
-Array<T>::get_size (int r, int c, int p)
+octave_idx_type
+Array<T>::get_size (octave_idx_type r, octave_idx_type c, octave_idx_type p)
 {
   // XXX KLUGE XXX
 
   // If an allocation of an array with r * c * p elements of type T
   // would cause an overflow in the allocator when computing the
   // size of the allocation, then return a value which, although
   // not equivalent to the actual request, should be too large for
   // most current hardware, but not so large to cause the
   // allocator to barf on computing retval * sizeof (T).
 
   static int nl;
   static double dl
     = frexp (static_cast<double>
-	     (INT_MAX - MALLOC_OVERHEAD) / sizeof (T), &nl);
+	(std::numeric_limits<octave_idx_type>::max() - MALLOC_OVERHEAD) / sizeof (T), &nl);
 
   // This value should be an integer.  If we return this value and
   // things work the way we expect, we should be paying a visit to
   // new_handler in no time flat.
-  static int max_items = static_cast<int> (ldexp (dl, nl));
+  static octave_idx_type max_items = static_cast<octave_idx_type> (ldexp (dl, nl));
 
   int nr, nc, np;
   double dr = frexp (static_cast<double> (r), &nr);
   double dc = frexp (static_cast<double> (c), &nc);
   double dp = frexp (static_cast<double> (p), &np);
 
   int nt = nr + nc + np;
   double dt = dr * dc * dp;
@@ -204,40 +205,40 @@ Array<T>::get_size (int r, int c, int p)
 	  dt *= 2;
 	}
     }
 
   return (nt < nl || (nt == nl && dt < dl)) ? r * c * p : max_items;
 }
 
 template <class T>
-int
+octave_idx_type
 Array<T>::get_size (const dim_vector& ra_idx)
 {
   // XXX KLUGE XXX
 
   // If an allocation of an array with r * c elements of type T
   // would cause an overflow in the allocator when computing the
   // size of the allocation, then return a value which, although
   // not equivalent to the actual request, should be too large for
   // most current hardware, but not so large to cause the
   // allocator to barf on computing retval * sizeof (T).
 
   static int nl;
   static double dl
     = frexp (static_cast<double>
-	     (INT_MAX - MALLOC_OVERHEAD) / sizeof (T), &nl);
+	(std::numeric_limits<octave_idx_type>::max() - MALLOC_OVERHEAD) / sizeof (T), &nl);
 
   // This value should be an integer.  If we return this value and
   // things work the way we expect, we should be paying a visit to
   // new_handler in no time flat.
 
-  static int max_items = static_cast<int> (ldexp (dl, nl));
-
-  int retval = max_items;
+  static octave_idx_type max_items = static_cast<octave_idx_type> (ldexp (dl, nl));
+
+  octave_idx_type retval = max_items;
 
   int n = ra_idx.length ();
 
   int nt = 0;
   double dt = 1;
 
   for (int i = 0; i < n; i++)
     {
@@ -263,20 +264,20 @@ Array<T>::get_size (const dim_vector& ra
     }
 
   return retval;
 }
 
 #undef MALLOC_OVERHEAD
 
 template <class T>
-int
-Array<T>::compute_index (const Array<int>& ra_idx) const
+octave_idx_type
+Array<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
-  int retval = -1;
+  octave_idx_type retval = -1;
 
   int n = dimensions.length ();
 
   if (n > 0 && n == ra_idx.length ())
     {
       retval = ra_idx(--n);
 
       while (--n >= 0)
@@ -289,83 +290,83 @@ Array<T>::compute_index (const Array<int
     (*current_liboctave_error_handler)
       ("Array<T>::compute_index: invalid ra_idxing operation");
 
   return retval;
 }
 
 template <class T>
 T
-Array<T>::range_error (const char *fcn, int n) const
+Array<T>::range_error (const char *fcn, octave_idx_type n) const
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
   return T ();
 }
 
 template <class T>
 T&
-Array<T>::range_error (const char *fcn, int n)
+Array<T>::range_error (const char *fcn, octave_idx_type n)
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
   static T foo;
   return foo;
 }
 
 template <class T>
 T
-Array<T>::range_error (const char *fcn, int i, int j) const
+Array<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j) const
 {
   (*current_liboctave_error_handler)
     ("%s (%d, %d): range error", fcn, i, j);
   return T ();
 }
 
 template <class T>
 T&
-Array<T>::range_error (const char *fcn, int i, int j)
+Array<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j)
 {
   (*current_liboctave_error_handler)
     ("%s (%d, %d): range error", fcn, i, j);
   static T foo;
   return foo;
 }
 
 template <class T>
 T
-Array<T>::range_error (const char *fcn, int i, int j, int k) const
+Array<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j, octave_idx_type k) const
 {
   (*current_liboctave_error_handler)
     ("%s (%d, %d, %d): range error", fcn, i, j, k);
   return T ();
 }
 
 template <class T>
 T&
-Array<T>::range_error (const char *fcn, int i, int j, int k)
+Array<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j, octave_idx_type k)
 {
   (*current_liboctave_error_handler)
     ("%s (%d, %d, %d): range error", fcn, i, j, k);
   static T foo;
   return foo;
 }
 
 template <class T>
 T
 Array<T>::range_error (const char *fcn, const Array<int>& ra_idx) const
 {
   OSSTREAM buf;
 
   buf << fcn << " (";
 
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
   if (n > 0)
     buf << ra_idx(0);
 
-  for (int i = 1; i < n; i++)
+  for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
 
   buf << OSSTREAM_ENDS;
 
   (*current_liboctave_error_handler) (OSSTREAM_C_STR (buf));
 
@@ -377,22 +378,22 @@ Array<T>::range_error (const char *fcn, 
 template <class T>
 T&
 Array<T>::range_error (const char *fcn, const Array<int>& ra_idx)
 {
   OSSTREAM buf;
 
   buf << fcn << " (";
 
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
   if (n > 0)
     buf << ra_idx(0);
 
-  for (int i = 1; i < n; i++)
+  for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
 
   buf << OSSTREAM_ENDS;
 
   (*current_liboctave_error_handler) (OSSTREAM_C_STR (buf));
 
@@ -418,17 +419,17 @@ Array<T>::reshape (const dim_vector& new
   else
     retval = *this;
 
   return retval;
 }
 
 template <class T>
 Array<T>
-Array<T>::permute (const Array<int>& perm_vec, bool inv) const
+Array<T>::permute (const Array<octave_idx_type>& perm_vec, bool inv) const
 {
   Array<T> retval;
 
   dim_vector dv = dims ();
   dim_vector dv_new;
 
   int perm_vec_len = perm_vec.length ();
 
@@ -444,17 +445,17 @@ Array<T>::permute (const Array<int>& per
   const Array<T> tmp = reshape (dv);
 
   // Need this array to check for identical elements in permutation array.
   Array<bool> checked (perm_vec_len, false);
 
   // Find dimension vector of permuted array.
   for (int i = 0; i < perm_vec_len; i++)
     {
-      int perm_elt = perm_vec.elem (i);
+      octave_idx_type perm_elt = perm_vec.elem (i);
 
       if (perm_elt >= perm_vec_len || perm_elt < 0)
 	{
 	  (*current_liboctave_error_handler)
 	    ("%s: permutation vector contains an invalid element",
 	     inv ? "ipermute" : "permute");
 
 	  return retval;
@@ -472,77 +473,77 @@ Array<T>::permute (const Array<int>& per
 	checked.elem(perm_elt) = true;
 
       dv_new(i) = dv(perm_elt);
     }
 
   retval.resize (dv_new);
 
   // Index array to the original array.
-  Array<int> old_idx (perm_vec_len, 0);
+  Array<octave_idx_type> old_idx (perm_vec_len, 0);
 
   // Number of elements in Array (should be the same for
   // both the permuted array and original array).
-  int n = retval.length ();
+  octave_idx_type n = retval.length ();
 
   // Permute array.
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     {
       // Get the idx of permuted array.
-      Array<int> new_idx = calc_permutated_idx (old_idx, perm_vec, inv);
+      Array<octave_idx_type> new_idx = calc_permutated_idx (old_idx, perm_vec, inv);
 
       retval.elem (new_idx) = tmp.elem (old_idx);
 
       increment_index (old_idx, dv);
     }
 
   return retval;
 }
 
 template <class T>
 void
-Array<T>::resize_no_fill (int n)
+Array<T>::resize_no_fill (octave_idx_type n)
 {
   if (n < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
   if (n == length ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
-  int old_len = length ();
+  octave_idx_type old_len = length ();
 
   rep = new typename Array<T>::ArrayRep (n);
 
   dimensions = dim_vector (n);
 
   if (n > 0 && old_data && old_len > 0)
     {
-      int min_len = old_len < n ? old_len : n;
-
-      for (int i = 0; i < min_len; i++)
+      octave_idx_type min_len = old_len < n ? old_len : n;
+
+      for (octave_idx_type i = 0; i < min_len; i++)
 	xelem (i) = old_data[i];
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
 Array<T>::resize_no_fill (const dim_vector& dv)
 {
-  int n = dv.length ();
-
-  for (int i = 0; i < n; i++)
+  octave_idx_type n = dv.length ();
+
+  for (octave_idx_type i = 0; i < n; i++)
     {
       if (dv(i) < 0)
 	{
 	  (*current_liboctave_error_handler)
 	    ("can't resize to negative dimension");
 	  return;
 	}
     }
@@ -550,69 +551,69 @@ Array<T>::resize_no_fill (const dim_vect
   bool same_size = true;
 
   if (dimensions.length () != n)
     {
       same_size = false;
     }
   else
     {
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  if (dv(i) != dimensions(i))
 	    {
 	      same_size = false;
 	      break;
 	    }
 	}
     }
 
   if (same_size)
     return;
 
   typename Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
 
-  int ts = get_size (dv);
+  octave_idx_type ts = get_size (dv);
 
   rep = new typename Array<T>::ArrayRep (ts);
 
   dim_vector dv_old = dimensions;
-  int dv_old_orig_len = dv_old.length ();
+  octave_idx_type  dv_old_orig_len = dv_old.length ();
   dimensions = dv;
-  int ts_old = get_size (dv_old);
+  octave_idx_type ts_old = get_size (dv_old);
 
   if (ts > 0 && ts_old > 0 && dv_old_orig_len > 0)
     {
-      Array<int> ra_idx (dimensions.length (), 0);
+      Array<octave_idx_type> ra_idx (dimensions.length (), 0);
 
       if (n > dv_old_orig_len)
 	{
 	  dv_old.resize (n);
 
-	  for (int i = dv_old_orig_len; i < n; i++)
+	  for (octave_idx_type i = dv_old_orig_len; i < n; i++)
 	    dv_old.elem (i) = 1;
 	}
 
-      for (int i = 0; i < ts; i++)
+      for (octave_idx_type i = 0; i < ts; i++)
 	{
 	  if (index_in_bounds (ra_idx, dv_old))
 	    rep->elem (i) = old_data[get_scalar_idx (ra_idx, dv_old)];
 
 	  increment_index (ra_idx, dimensions);
 	}
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
-Array<T>::resize_no_fill (int r, int c)
+Array<T>::resize_no_fill (octave_idx_type r, octave_idx_type c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
@@ -624,43 +625,43 @@ Array<T>::resize_no_fill (int r, int c)
   assert (ndims () == 2);
 
   if (r == dim1 () && c == dim2 ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = Array<T>::rep;
   const T *old_data = data ();
 
-  int old_d1 = dim1 ();
-  int old_d2 = dim2 ();
-  int old_len = length ();
-
-  int ts = get_size (r, c);
+  octave_idx_type old_d1 = dim1 ();
+  octave_idx_type old_d2 = dim2 ();
+  octave_idx_type old_len = length ();
+
+  octave_idx_type ts = get_size (r, c);
 
   rep = new typename Array<T>::ArrayRep (ts);
 
   dimensions = dim_vector (r, c);
 
   if (ts > 0 && old_data && old_len > 0)
     {
-      int min_r = old_d1 < r ? old_d1 : r;
-      int min_c = old_d2 < c ? old_d2 : c;
-
-      for (int j = 0; j < min_c; j++)
-	for (int i = 0; i < min_r; i++)
+      octave_idx_type min_r = old_d1 < r ? old_d1 : r;
+      octave_idx_type min_c = old_d2 < c ? old_d2 : c;
+
+      for (octave_idx_type j = 0; j < min_c; j++)
+	for (octave_idx_type i = 0; i < min_r; i++)
 	  xelem (i, j) = old_data[old_d1*j+i];
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
-Array<T>::resize_no_fill (int r, int c, int p)
+Array<T>::resize_no_fill (octave_idx_type r, octave_idx_type c, octave_idx_type p)
 {
   if (r < 0 || c < 0 || p < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
@@ -672,86 +673,86 @@ Array<T>::resize_no_fill (int r, int c, 
   assert (ndims () == 3);
 
   if (r == dim1 () && c == dim2 () && p == dim3 ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
 
-  int old_d1 = dim1 ();
-  int old_d2 = dim2 ();
-  int old_d3 = dim3 ();
-  int old_len = length ();
-
-  int ts = get_size (get_size (r, c), p);
+  octave_idx_type old_d1 = dim1 ();
+  octave_idx_type old_d2 = dim2 ();
+  octave_idx_type old_d3 = dim3 ();
+  octave_idx_type old_len = length ();
+
+  octave_idx_type ts = get_size (get_size (r, c), p);
 
   rep = new typename Array<T>::ArrayRep (ts);
 
   dimensions = dim_vector (r, c, p);
 
   if (ts > 0 && old_data && old_len > 0)
     {
-      int min_r = old_d1 < r ? old_d1 : r;
-      int min_c = old_d2 < c ? old_d2 : c;
-      int min_p = old_d3 < p ? old_d3 : p;
-
-      for (int k = 0; k < min_p; k++)
-	for (int j = 0; j < min_c; j++)
-	  for (int i = 0; i < min_r; i++)
+      octave_idx_type min_r = old_d1 < r ? old_d1 : r;
+      octave_idx_type min_c = old_d2 < c ? old_d2 : c;
+      octave_idx_type min_p = old_d3 < p ? old_d3 : p;
+
+      for (octave_idx_type k = 0; k < min_p; k++)
+	for (octave_idx_type j = 0; j < min_c; j++)
+	  for (octave_idx_type i = 0; i < min_r; i++)
 	    xelem (i, j, k) = old_data[old_d1*(old_d2*k+j)+i];
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
-Array<T>::resize_and_fill (int n, const T& val)
+Array<T>::resize_and_fill (octave_idx_type n, const T& val)
 {
   if (n < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
   if (n == length ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
-  int old_len = length ();
+  octave_idx_type old_len = length ();
 
   rep = new typename Array<T>::ArrayRep (n);
 
   dimensions = dim_vector (n);
 
   if (n > 0)
     {
-      int min_len = old_len < n ? old_len : n;
+      octave_idx_type min_len = old_len < n ? old_len : n;
 
       if (old_data && old_len > 0)
 	{
-	  for (int i = 0; i < min_len; i++)
+	  for (octave_idx_type i = 0; i < min_len; i++)
 	    xelem (i) = old_data[i];
 	}
 
-      for (int i = old_len; i < n; i++)
+      for (octave_idx_type i = old_len; i < n; i++)
 	xelem (i) = val;
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
-Array<T>::resize_and_fill (int r, int c, const T& val)
+Array<T>::resize_and_fill (octave_idx_type r, octave_idx_type c, const T& val)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
@@ -761,54 +762,54 @@ Array<T>::resize_and_fill (int r, int c,
   assert (ndims () == 2);
 
   if (r == dim1 () && c == dim2 ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = Array<T>::rep;
   const T *old_data = data ();
 
-  int old_d1 = dim1 ();
-  int old_d2 = dim2 ();
-  int old_len = length ();
-
-  int ts = get_size (r, c);
+  octave_idx_type old_d1 = dim1 ();
+  octave_idx_type old_d2 = dim2 ();
+  octave_idx_type old_len = length ();
+
+  octave_idx_type ts = get_size (r, c);
 
   rep = new typename Array<T>::ArrayRep (ts);
 
   dimensions = dim_vector (r, c);
 
   if (ts > 0)
     {
-      int min_r = old_d1 < r ? old_d1 : r;
-      int min_c = old_d2 < c ? old_d2 : c;
+      octave_idx_type min_r = old_d1 < r ? old_d1 : r;
+      octave_idx_type min_c = old_d2 < c ? old_d2 : c;
 
       if (old_data && old_len > 0)
 	{
-	  for (int j = 0; j < min_c; j++)
-	    for (int i = 0; i < min_r; i++)
+	  for (octave_idx_type j = 0; j < min_c; j++)
+	    for (octave_idx_type i = 0; i < min_r; i++)
 	      xelem (i, j) = old_data[old_d1*j+i];
 	}
 
-      for (int j = 0; j < min_c; j++)
-	for (int i = min_r; i < r; i++)
+      for (octave_idx_type j = 0; j < min_c; j++)
+	for (octave_idx_type i = min_r; i < r; i++)
 	  xelem (i, j) = val;
 
-      for (int j = min_c; j < c; j++)
-	for (int i = 0; i < r; i++)
+      for (octave_idx_type j = min_c; j < c; j++)
+	for (octave_idx_type i = 0; i < r; i++)
 	  xelem (i, j) = val;
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
-Array<T>::resize_and_fill (int r, int c, int p, const T& val)
+Array<T>::resize_and_fill (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val)
 {
   if (r < 0 || c < 0 || p < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
@@ -818,71 +819,71 @@ Array<T>::resize_and_fill (int r, int c,
   assert (ndims () == 3);
 
   if (r == dim1 () && c == dim2 () && p == dim3 ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
 
-  int old_d1 = dim1 ();
-  int old_d2 = dim2 ();
-  int old_d3 = dim3 ();
-
-  int old_len = length ();
-
-  int ts = get_size (get_size (r, c), p);
+  octave_idx_type old_d1 = dim1 ();
+  octave_idx_type old_d2 = dim2 ();
+  octave_idx_type old_d3 = dim3 ();
+
+  octave_idx_type old_len = length ();
+
+  octave_idx_type ts = get_size (get_size (r, c), p);
 
   rep = new typename Array<T>::ArrayRep (ts);
 
   dimensions = dim_vector (r, c, p);
 
   if (ts > 0)
     {
-      int min_r = old_d1 < r ? old_d1 : r;
-      int min_c = old_d2 < c ? old_d2 : c;
-      int min_p = old_d3 < p ? old_d3 : p;
+      octave_idx_type min_r = old_d1 < r ? old_d1 : r;
+      octave_idx_type min_c = old_d2 < c ? old_d2 : c;
+      octave_idx_type min_p = old_d3 < p ? old_d3 : p;
 
       if (old_data && old_len > 0)
-	for (int k = 0; k < min_p; k++)
-	  for (int j = 0; j < min_c; j++)
-	    for (int i = 0; i < min_r; i++)
+	for (octave_idx_type k = 0; k < min_p; k++)
+	  for (octave_idx_type j = 0; j < min_c; j++)
+	    for (octave_idx_type i = 0; i < min_r; i++)
 	      xelem (i, j, k) = old_data[old_d1*(old_d2*k+j)+i];
 
       // XXX FIXME XXX -- if the copy constructor is expensive, this
       // may win.  Otherwise, it may make more sense to just copy the
       // value everywhere when making the new ArrayRep.
 
-      for (int k = 0; k < min_p; k++)
-	for (int j = min_c; j < c; j++)
-	  for (int i = 0; i < min_r; i++)
+      for (octave_idx_type k = 0; k < min_p; k++)
+	for (octave_idx_type j = min_c; j < c; j++)
+	  for (octave_idx_type i = 0; i < min_r; i++)
 	    xelem (i, j, k) = val;
 
-      for (int k = 0; k < min_p; k++)
-	for (int j = 0; j < c; j++)
-	  for (int i = min_r; i < r; i++)
+      for (octave_idx_type k = 0; k < min_p; k++)
+	for (octave_idx_type j = 0; j < c; j++)
+	  for (octave_idx_type i = min_r; i < r; i++)
 	    xelem (i, j, k) = val;
 
-      for (int k = min_p; k < p; k++)
-	for (int j = 0; j < c; j++)
-	  for (int i = 0; i < r; i++)
+      for (octave_idx_type k = min_p; k < p; k++)
+	for (octave_idx_type j = 0; j < c; j++)
+	  for (octave_idx_type i = 0; i < r; i++)
 	    xelem (i, j, k) = val;
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
 Array<T>::resize_and_fill (const dim_vector& dv, const T& val)
 {
-  int n = dv.length ();
-
-  for (int i = 0; i < n; i++)
+  octave_idx_type n = dv.length ();
+
+  for (octave_idx_type i = 0; i < n; i++)
     {
       if (dv(i) < 0)
 	{
 	  (*current_liboctave_error_handler)
 	    ("can't resize to negative dimension");
 	  return;
 	}
     }
@@ -890,145 +891,145 @@ Array<T>::resize_and_fill (const dim_vec
   bool same_size = true;
 
   if (dimensions.length () != n)
     {
       same_size = false;
     }
   else
     {
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  if (dv(i) != dimensions(i))
 	    {
 	      same_size = false;
 	      break;
 	    }
 	}
     }
 
   if (same_size)
     return;
 
   typename Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
 
-  int len = get_size (dv);
+  octave_idx_type len = get_size (dv);
 
   rep = new typename Array<T>::ArrayRep (len);
 
   dim_vector dv_old = dimensions;
-  int dv_old_orig_len = dv_old.length ();
+  octave_idx_type dv_old_orig_len = dv_old.length ();
   dimensions = dv;
 
   if (len > 0 && dv_old_orig_len > 0)
     {
-      Array<int> ra_idx (dimensions.length (), 0);
+      Array<octave_idx_type> ra_idx (dimensions.length (), 0);
       
       if (n > dv_old_orig_len)
 	{
 	  dv_old.resize (n);
 
-	  for (int i = dv_old_orig_len; i < n; i++)
+	  for (octave_idx_type i = dv_old_orig_len; i < n; i++)
 	    dv_old.elem (i) = 1;
 	}
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	{
 	  if (index_in_bounds (ra_idx, dv_old))
 	    rep->elem (i) = old_data[get_scalar_idx (ra_idx, dv_old)];
 	  else
 	    rep->elem (i) = val;
 	  
 	  increment_index (ra_idx, dimensions);
 	}
     }
   else
-    for (int i = 0; i < len; i++)
+    for (octave_idx_type i = 0; i < len; i++)
       rep->elem (i) = val;
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 Array<T>&
-Array<T>::insert (const Array<T>& a, int r, int c)
+Array<T>::insert (const Array<T>& a, octave_idx_type r, octave_idx_type c)
 {
   if (ndims () == 2 && a.ndims () == 2)
     insert2 (a, r, c);
   else
     insertN (a, r, c);
 
   return *this;
 }
 
 
 template <class T>
 Array<T>&
-Array<T>::insert2 (const Array<T>& a, int r, int c)
+Array<T>::insert2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_rows = a.rows ();
-  int a_cols = a.cols ();
+  octave_idx_type a_rows = a.rows ();
+  octave_idx_type a_cols = a.cols ();
 
   if (r < 0 || r + a_rows > rows () || c < 0 || c + a_cols > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int j = 0; j < a_cols; j++)
-    for (int i = 0; i < a_rows; i++)
+  for (octave_idx_type j = 0; j < a_cols; j++)
+    for (octave_idx_type i = 0; i < a_rows; i++)
       elem (r+i, c+j) = a.elem (i, j);
 
   return *this;
 }
 
 template <class T>
 Array<T>&
-Array<T>::insertN (const Array<T>& a, int r, int c)
+Array<T>::insertN (const Array<T>& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector dv = dims ();
 
   dim_vector a_dv = a.dims ();
 
   int n = a_dv.length ();
 
   if (n == dimensions.length ())
     {
-      Array<int> a_ra_idx (a_dv.length (), 0);
+      Array<octave_idx_type> a_ra_idx (a_dv.length (), 0);
 
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
 
       for (int i = 0; i < n; i++)
 	{
 	  if (a_ra_idx(i) < 0 || (a_ra_idx(i) + a_dv(i)) > dv(i))
 	    {
 	      (*current_liboctave_error_handler)
 		("Array<T>::insert: range error for insert");
 	      return *this;
 	    }
 	}
 
-      int n_elt = a.numel ();
+      octave_idx_type n_elt = a.numel ();
       
       const T *a_data = a.data ();   
    
-      int iidx = 0;
+      octave_idx_type iidx = 0;
 	  
-      int a_rows = a_dv(0);
-
-      int this_rows = dv(0);
+      octave_idx_type a_rows = a_dv(0);
+
+      octave_idx_type this_rows = dv(0);
 	  
-      int numel_page = a_dv(0) * a_dv(1);	  
-
-      int count_pages = 0;
+      octave_idx_type numel_page = a_dv(0) * a_dv(1);	  
+
+      octave_idx_type count_pages = 0;
 	  
-      for (int i = 0; i < n_elt; i++)
+      for (octave_idx_type i = 0; i < n_elt; i++)
 	{
 	  if (i != 0 && i % a_rows == 0)
 	    iidx += (this_rows - a_rows);	      
 	  
 	  if (i % numel_page == 0)
 	    iidx = c * dv(0) + r + dv(0) * dv(1) * count_pages++;
 
 	  elem (iidx++) = a_data[i];
@@ -1038,28 +1039,28 @@ Array<T>::insertN (const Array<T>& a, in
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
 
   return *this;
 }
 
 template <class T>
 Array<T>&
-Array<T>::insert (const Array<T>& a, const Array<int>& ra_idx)
+Array<T>::insert (const Array<T>& a, const Array<octave_idx_type>& ra_idx)
 {
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
   if (n == dimensions.length ())
     {
       dim_vector dva = a.dims ();
       dim_vector dv = dims ();
       int len_a = dva.length ();
       int non_full_dim = 0;
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  if (ra_idx(i) < 0 || (ra_idx(i) + 
 				(i < len_a ? dva(i) : 1)) > dimensions(i))
 	    {
 	      (*current_liboctave_error_handler)
 		("Array<T>::insert: range error for insert");
 	      return *this;
 	    }
@@ -1069,50 +1070,50 @@ Array<T>::insert (const Array<T>& a, con
 	}
 
       if (dva.numel ())
         {
 	  if (non_full_dim < 2)
 	    {
 	      // Special case for fast concatenation
 	      const T *a_data = a.data ();
-	      int numel_to_move = 1;
-	      int skip = 0;
+	      octave_idx_type numel_to_move = 1;
+	      octave_idx_type skip = 0;
 	      for (int i = 0; i < len_a; i++)
 		if (ra_idx(i) == 0 && dva(i) == dv(i))
 		  numel_to_move *= dva(i);
 		else
 		  {
 		    skip = numel_to_move * (dv(i) - dva(i));
 		    numel_to_move *= dva(i);
 		    break;
 		  }
 
-	      int jidx = ra_idx(n-1);
+	      octave_idx_type jidx = ra_idx(n-1);
 	      for (int i = n-2; i >= 0; i--)
 		{
 		  jidx *= dv(i);
 		  jidx += ra_idx(i);
 		}
 
-	      int iidx = 0;
-	      int moves = dva.numel () / numel_to_move;
-	      for (int i = 0; i < moves; i++)
+	      octave_idx_type iidx = 0;
+	      octave_idx_type moves = dva.numel () / numel_to_move;
+	      for (octave_idx_type i = 0; i < moves; i++)
 		{
-		  for (int j = 0; j < numel_to_move; j++)
+		  for (octave_idx_type j = 0; j < numel_to_move; j++)
 		    elem (jidx++) = a_data[iidx++];
 		  jidx += skip;
 		}
 	    }
 	  else
 	    {
 	      // Generic code
 	      const T *a_data = a.data ();
 	      int nel = a.numel ();
-	      Array<int> a_idx (n, 0);
+	      Array<octave_idx_type> a_idx (n, 0);
 
 	      for (int i = 0; i < nel; i++)
 		{
 		  int iidx = a_idx(n-1) + ra_idx(n-1);
 		  for (int j = n-2; j >= 0; j--)
 		    {
 		      iidx *= dv(j);
 		      iidx += a_idx(j) + ra_idx(j);
@@ -1133,25 +1134,25 @@ Array<T>::insert (const Array<T>& a, con
 }
 
 template <class T>
 Array<T>
 Array<T>::transpose (void) const
 {
   assert (ndims () == 2);
 
-  int nr = dim1 ();
-  int nc = dim2 ();
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
 
   if (nr > 1 && nc > 1)
     {
       Array<T> result (dim_vector (nc, nr));
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  result.xelem (j, i) = xelem (i, j);
 
       return result;
     }
   else
     {
       // Fast transpose for vectors and empty matrices
       return Array<T> (*this, dim_vector (nc, nr));
@@ -1256,50 +1257,50 @@ Array<T>::maybe_delete_elements (idx_vec
       break;
     }
 }
 
 template <class T>
 void
 Array<T>::maybe_delete_elements_1 (idx_vector& idx_arg)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (len == 0)
     return;
 
   if (idx_arg.is_colon_equiv (len, 1))
     resize_no_fill (0);
   else
     {
       int num_to_delete = idx_arg.length (len);
 
       if (num_to_delete != 0)
 	{
-	  int new_len = len;
-
-	  int iidx = 0;
-
-	  for (int i = 0; i < len; i++)
+	  octave_idx_type new_len = len;
+
+	  octave_idx_type iidx = 0;
+
+	  for (octave_idx_type i = 0; i < len; i++)
 	    if (i == idx_arg.elem (iidx))
 	      {
 		iidx++;
 		new_len--;
 
 		if (iidx == num_to_delete)
 		  break;
 	      }
 
 	  if (new_len > 0)
 	    {
 	      T *new_data = new T [new_len];
 
-	      int ii = 0;
+	      octave_idx_type ii = 0;
 	      iidx = 0;
-	      for (int i = 0; i < len; i++)
+	      for (octave_idx_type i = 0; i < len; i++)
 		{
 		  if (iidx < num_to_delete && i == idx_arg.elem (iidx))
 		    iidx++;
 		  else
 		    {
 		      new_data[ii] = elem (i);
 		      ii++;
 		    }
@@ -1321,23 +1322,23 @@ Array<T>::maybe_delete_elements_1 (idx_v
 }
 
 template <class T>
 void
 Array<T>::maybe_delete_elements_2 (idx_vector& idx_arg)
 {
   assert (ndims () == 2);
 
-  int nr = dim1 ();
-  int nc = dim2 ();
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
 
   if (nr == 0 && nc == 0)
     return;
 
-  int n;
+  octave_idx_type n;
   if (nr == 1)
     n = nc;
   else if (nc == 1)
     n = nr;
   else
     {
       // Reshape to row vector for Matlab compatibility.
 
@@ -1354,41 +1355,41 @@ Array<T>::maybe_delete_elements_2 (idx_v
       // A(idx,:) = [] (delete rows) or A(:,idx) (delete columns).
 
       resize_no_fill (0, 0);
       return;
     }
 
   idx_arg.sort (true);
 
-  int num_to_delete = idx_arg.length (n);
+  octave_idx_type num_to_delete = idx_arg.length (n);
 
   if (num_to_delete != 0)
     {
-      int new_n = n;
-
-      int iidx = 0;
-
-      for (int i = 0; i < n; i++)
+      octave_idx_type new_n = n;
+
+      octave_idx_type iidx = 0;
+
+      for (octave_idx_type i = 0; i < n; i++)
 	if (i == idx_arg.elem (iidx))
 	  {
 	    iidx++;
 	    new_n--;
 
 	    if (iidx == num_to_delete)
 	      break;
 	  }
 
       if (new_n > 0)
 	{
 	  T *new_data = new T [new_n];
 
-	  int ii = 0;
+	  octave_idx_type ii = 0;
 	  iidx = 0;
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      if (iidx < num_to_delete && i == idx_arg.elem (iidx))
 		iidx++;
 	      else
 		{
 		  new_data[ii] = elem (i);
 
 		  ii++;
@@ -1420,18 +1421,18 @@ Array<T>::maybe_delete_elements_2 (idx_v
 }
 
 template <class T>
 void
 Array<T>::maybe_delete_elements (idx_vector& idx_i, idx_vector& idx_j)
 {
   assert (ndims () == 2);
 
-  int nr = dim1 ();
-  int nc = dim2 ();
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
 
   if (nr == 0 && nc == 0)
     return;
 
   if (idx_i.is_colon ())
     {
       if (idx_j.is_colon ())
 	{
@@ -1466,51 +1467,51 @@ Array<T>::maybe_delete_elements (idx_vec
   if (idx_i.is_colon_equiv (nr, 1))
     {
       if (idx_j.is_colon_equiv (nc, 1))
 	resize_no_fill (0, 0);
       else
 	{
 	  idx_j.sort (true);
 
-	  int num_to_delete = idx_j.length (nc);
+	  octave_idx_type num_to_delete = idx_j.length (nc);
 
 	  if (num_to_delete != 0)
 	    {
 	      if (nr == 1 && num_to_delete == nc)
 		resize_no_fill (0, 0);
 	      else
 		{
-		  int new_nc = nc;
-
-		  int iidx = 0;
-
-		  for (int j = 0; j < nc; j++)
+		  octave_idx_type new_nc = nc;
+
+		  octave_idx_type iidx = 0;
+
+		  for (octave_idx_type j = 0; j < nc; j++)
 		    if (j == idx_j.elem (iidx))
 		      {
 			iidx++;
 			new_nc--;
 
 			if (iidx == num_to_delete)
 			  break;
 		      }
 
 		  if (new_nc > 0)
 		    {
 		      T *new_data = new T [nr * new_nc];
 
-		      int jj = 0;
+		      octave_idx_type jj = 0;
 		      iidx = 0;
-		      for (int j = 0; j < nc; j++)
+		      for (octave_idx_type j = 0; j < nc; j++)
 			{
 			  if (iidx < num_to_delete && j == idx_j.elem (iidx))
 			    iidx++;
 			  else
 			    {
-			      for (int i = 0; i < nr; i++)
+			      for (octave_idx_type i = 0; i < nr; i++)
 				new_data[nr*jj+i] = elem (i, j);
 			      jj++;
 			    }
 			}
 
 		      if (--(Array<T>::rep)->count <= 0)
 			delete Array<T>::rep;
 
@@ -1529,51 +1530,51 @@ Array<T>::maybe_delete_elements (idx_vec
   else if (idx_j.is_colon_equiv (nc, 1))
     {
       if (idx_i.is_colon_equiv (nr, 1))
 	resize_no_fill (0, 0);
       else
 	{
 	  idx_i.sort (true);
 
-	  int num_to_delete = idx_i.length (nr);
+	  octave_idx_type num_to_delete = idx_i.length (nr);
 
 	  if (num_to_delete != 0)
 	    {
 	      if (nc == 1 && num_to_delete == nr)
 		resize_no_fill (0, 0);
 	      else
 		{
-		  int new_nr = nr;
-
-		  int iidx = 0;
-
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nr = nr;
+
+		  octave_idx_type iidx = 0;
+
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (i == idx_i.elem (iidx))
 		      {
 			iidx++;
 			new_nr--;
 
 			if (iidx == num_to_delete)
 			  break;
 		      }
 
 		  if (new_nr > 0)
 		    {
 		      T *new_data = new T [new_nr * nc];
 
-		      int ii = 0;
+		      octave_idx_type ii = 0;
 		      iidx = 0;
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			{
 			  if (iidx < num_to_delete && i == idx_i.elem (iidx))
 			    iidx++;
 			  else
 			    {
-			      for (int j = 0; j < nc; j++)
+			      for (octave_idx_type j = 0; j < nc; j++)
 				new_data[new_nr*j+ii] = elem (i, j);
 			      ii++;
 			    }
 			}
 
 		      if (--(Array<T>::rep)->count <= 0)
 			delete Array<T>::rep;
 
@@ -1597,43 +1598,43 @@ Array<T>::maybe_delete_elements (idx_vec
 {
   assert (0);
 }
 
 template <class T>
 void
 Array<T>::maybe_delete_elements (Array<idx_vector>& ra_idx, const T& rfv)
 {
-  int n_idx = ra_idx.length ();
+  octave_idx_type n_idx = ra_idx.length ();
 
   dim_vector lhs_dims = dims ();
 
   if (lhs_dims.all_zero ())
     return;
 
   int n_lhs_dims = lhs_dims.length ();
 
   Array<int> idx_is_colon (n_idx, 0);
 
   Array<int> idx_is_colon_equiv (n_idx, 0);
 
   // Initialization of colon arrays.
 
-  for (int i = 0; i < n_idx; i++)
+  for (octave_idx_type i = 0; i < n_idx; i++)
     {
       idx_is_colon_equiv(i) = ra_idx(i).is_colon_equiv (lhs_dims(i), 1);
 
       idx_is_colon(i) = ra_idx(i).is_colon ();
     }
 
   bool idx_ok = true;
 
   // Check for index out of bounds.
 
-  for (int i = 0 ; i < n_idx - 1; i++)
+  for (octave_idx_type i = 0 ; i < n_idx - 1; i++)
     {
       if (! (idx_is_colon(i) || idx_is_colon_equiv(i)))
 	{
 	  ra_idx(i).sort (true);
 
 	  if (ra_idx(i).max () > lhs_dims(i))
 	    {
 	      (*current_liboctave_error_handler)
@@ -1650,21 +1651,21 @@ Array<T>::maybe_delete_elements (Array<i
 	      idx_ok = false;
 	      break;
 	    }
 	}
     }
 
   if (n_idx <= n_lhs_dims)
     {
-      int last_idx = ra_idx(n_idx-1).max ();
-
-      int sum_el = lhs_dims(n_idx-1);
-
-      for (int i = n_idx; i < n_lhs_dims; i++)
+      octave_idx_type last_idx = ra_idx(n_idx-1).max ();
+
+      octave_idx_type sum_el = lhs_dims(n_idx-1);
+
+      for (octave_idx_type i = n_idx; i < n_lhs_dims; i++)
 	  sum_el *= lhs_dims(i);
 
       if (last_idx > sum_el - 1)
 	{
 	  (*current_liboctave_error_handler)
 	    ("index exceeds array dimensions");
 
 	  idx_ok = false;
@@ -1697,17 +1698,17 @@ Array<T>::maybe_delete_elements (Array<i
 	  //
 	  // If we enumerate all of the elements, we should have zero
 	  // elements in that dimension with the same number of elements
 	  // in the other dimensions that we started with.
 
 	  dim_vector temp_dims;
 	  temp_dims.resize (n_idx);
 
-	  for (int i = 0; i < n_idx; i++)
+	  for (octave_idx_type i = 0; i < n_idx; i++)
 	    {
 	      if (idx_is_colon (i))
 		temp_dims(i) =  lhs_dims(i);
 	      else
 		temp_dims(i) = 0;
 	    }
 
 	  resize (temp_dims);
@@ -1720,40 +1721,40 @@ Array<T>::maybe_delete_elements (Array<i
 	  if (n_idx < n_lhs_dims)
 	    {
 	      // Collapse dimensions beyond last index.
 
 	      if (liboctave_wfi_flag && ! (ra_idx(n_idx-1).is_colon ()))
 		(*current_liboctave_warning_handler)
 		  ("fewer indices than dimensions for N-d array");
 
-	      for (int i = n_idx; i < n_lhs_dims; i++)
+	      for (octave_idx_type i = n_idx; i < n_lhs_dims; i++)
 		lhs_dims(n_idx-1) *= lhs_dims(i);
 
 	      lhs_dims.resize (n_idx);
 
 	      // Reshape *this.
 	      dimensions = lhs_dims;
 	    }
 
 	  int non_col = 0;
 
 	  // Find the non-colon column.
 
-	  for (int i = 0; i < n_idx; i++)
+	  for (octave_idx_type i = 0; i < n_idx; i++)
 	    {
 	      if (! idx_is_colon(i))
 		non_col = i;
 	    }
 
 	  // The length of the non-colon dimension.
 
-	  int non_col_dim = lhs_dims (non_col);
-
-	  int num_to_delete = ra_idx(non_col).length (lhs_dims (non_col));
+	  octave_idx_type non_col_dim = lhs_dims (non_col);
+
+	  octave_idx_type num_to_delete = ra_idx(non_col).length (lhs_dims (non_col));
 
 	  if (num_to_delete > 0)
 	    {
 	      int temp = lhs_dims.num_ones ();
 
 	      if (non_col_dim == 1)
 		temp--;
 
@@ -1766,84 +1767,84 @@ Array<T>::maybe_delete_elements (Array<i
 
 		  resize (zero_dims, rfv);
 		}
 	      else
 		{
 		  // New length of non-colon dimension
 		  // (calculated in the next for loop)
 
-		  int new_dim = non_col_dim;
-
-		  int iidx = 0;
-
-		  for (int j = 0; j < non_col_dim; j++)
+		  octave_idx_type new_dim = non_col_dim;
+
+		  octave_idx_type iidx = 0;
+
+		  for (octave_idx_type j = 0; j < non_col_dim; j++)
 		    if (j == ra_idx(non_col).elem (iidx))
 		      {
 			iidx++;
 
 			new_dim--;
 
 			if (iidx == num_to_delete)
 			  break;
 		      }
 
 		  // Creating the new nd array after deletions.
 
 		  if (new_dim > 0)
 		    {
 		      // Calculate number of elements in new array.
 
-		      int num_new_elem=1;
+		      octave_idx_type num_new_elem=1;
 
 		      for (int i = 0; i < n_idx; i++)
 			{
 			  if (i == non_col)
 			    num_new_elem *= new_dim;
 
 			  else
 			    num_new_elem *= lhs_dims(i);
 			}
 
 		      T *new_data = new T [num_new_elem];
 
-		      Array<int> result_idx (n_lhs_dims, 0);
+		      Array<octave_idx_type> result_idx (n_lhs_dims, 0);
 
 		      dim_vector new_lhs_dim = lhs_dims;
 
 		      new_lhs_dim(non_col) = new_dim;
 
-		      int num_elem = 1;
-
-		      int numidx = 0;
-
-		      int n = length ();
+		      octave_idx_type num_elem = 1;
+
+		      octave_idx_type numidx = 0;
+
+		      octave_idx_type n = length ();
 
 		      for (int i = 0; i < n_lhs_dims; i++)
 			if (i != non_col)
 			  num_elem *= lhs_dims(i);
 
 		      num_elem *= ra_idx(non_col).capacity ();
 
-		      for (int i = 0; i < n; i++)
+		      for (octave_idx_type i = 0; i < n; i++)
 			{
 			  if (numidx < num_elem
 			      && is_in (result_idx(non_col), ra_idx(non_col)))
 			    numidx++;
 
 			  else
 			    {
-			      Array<int> temp_result_idx = result_idx;
-
-			      int num_lgt = how_many_lgt (result_idx(non_col),
+			      Array<octave_idx_type> temp_result_idx = result_idx;
+
+			      octave_idx_type num_lgt = how_many_lgt (result_idx(non_col),
 							  ra_idx(non_col));
 
 			      temp_result_idx(non_col) -= num_lgt;
 
-			      int kidx
+			      octave_idx_type kidx
 				= ::compute_index (temp_result_idx, new_lhs_dim);
 
 			      new_data[kidx] = elem (result_idx);
 			    }
 
 			  increment_index (result_idx, lhs_dims);
 			}
 
@@ -1865,38 +1866,38 @@ Array<T>::maybe_delete_elements (Array<i
 	  // delete in the array which can be of any dimension. We
 	  // return a column vector, except for the case where we are
 	  // operating on a row vector. The elements are numerated
 	  // column by column.
 	  //
 	  // A(3,3,3)=2;
 	  // A(3:5) = []; A(6)=[]
 
-	  int lhs_numel = numel ();
+	  octave_idx_type lhs_numel = numel ();
 
 	  idx_vector idx_vec = ra_idx(0);
 
 	  idx_vec.freeze (lhs_numel, 0, true, liboctave_wrore_flag);
       
 	  idx_vec.sort (true);
 
-	  int num_to_delete = idx_vec.length (lhs_numel);
+	  octave_idx_type num_to_delete = idx_vec.length (lhs_numel);
 
 	  if (num_to_delete > 0)
 	    {
-	      int new_numel = lhs_numel - num_to_delete;
+	      octave_idx_type new_numel = lhs_numel - num_to_delete;
 
 	      T *new_data = new T[new_numel];
 
-	      Array<int> lhs_ra_idx (ndims (), 0);
-
-	      int ii = 0;
-	      int iidx = 0;
-
-	      for (int i = 0; i < lhs_numel; i++)
+	      Array<octave_idx_type> lhs_ra_idx (ndims (), 0);
+
+	      octave_idx_type ii = 0;
+	      octave_idx_type iidx = 0;
+
+	      for (octave_idx_type i = 0; i < lhs_numel; i++)
 		{
 		  if (iidx < num_to_delete && i == idx_vec.elem (iidx))
 		    {
 		      iidx++;
 		    }
 		  else
 		    {
 		      new_data[ii++] = elem (lhs_ra_idx);
@@ -1995,19 +1996,19 @@ Array<T>::index (idx_vector& idx_arg, in
 }
 
 template <class T>
 Array<T>
 Array<T>::index1 (idx_vector& idx_arg, int resize_ok, const T& rfv) const
 {
   Array<T> retval;
 
-  int len = length ();
-
-  int n = idx_arg.freeze (len, "vector", resize_ok);
+  octave_idx_type len = length ();
+
+  octave_idx_type n = idx_arg.freeze (len, "vector", resize_ok);
 
   if (idx_arg)
     {
       if (idx_arg.is_colon_equiv (len))
 	{
 	  retval = *this;
 	}
       else if (n == 0)
@@ -2019,19 +2020,19 @@ Array<T>::index1 (idx_vector& idx_arg, i
 	       && idx_arg.ones_count () == n)
 	{
 	  retval.resize_and_fill (n, elem (0));
 	}
       else
 	{
 	  retval.resize_no_fill (n);
 
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
-	      int ii = idx_arg.elem (i);
+	      octave_idx_type ii = idx_arg.elem (i);
 	      if (ii >= len)
 		retval.elem (i) = rfv;
 	      else
 		retval.elem (i) = elem (ii);
 	    }
 	}
     }
 
@@ -2043,55 +2044,55 @@ Array<T>::index1 (idx_vector& idx_arg, i
 template <class T>
 Array<T>
 Array<T>::index2 (idx_vector& idx_arg, int resize_ok, const T& rfv) const
 {
   Array<T> retval;
 
   assert (ndims () == 2);
 
-  int nr = dim1 ();
-  int nc = dim2 ();
-
-  int orig_len = nr * nc;
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
+
+  octave_idx_type orig_len = nr * nc;
 
   dim_vector idx_orig_dims = idx_arg.orig_dimensions ();
 
-  int idx_orig_rows = idx_arg.orig_rows ();
-  int idx_orig_columns = idx_arg.orig_columns ();
+  octave_idx_type idx_orig_rows = idx_arg.orig_rows ();
+  octave_idx_type idx_orig_columns = idx_arg.orig_columns ();
 
   if (idx_arg.is_colon ())
     {
       // Fast magic colon processing.
 
-      int result_nr = nr * nc;
-      int result_nc = 1;
+      octave_idx_type result_nr = nr * nc;
+      octave_idx_type result_nc = 1;
 
       retval = Array<T> (*this, dim_vector (result_nr, result_nc));
     }
   else if (nr == 1 && nc == 1)
     {
       Array<T> tmp = Array<T>::index1 (idx_arg, resize_ok);
 
-      int len = tmp.length ();
+      octave_idx_type len = tmp.length ();
 
       if (len == 0 && idx_arg.one_zero_only ())
 	retval = Array<T> (tmp, dim_vector (0, 0));
       else if (len >= idx_orig_dims.numel ())
 	retval = Array<T> (tmp, idx_orig_dims);
     }
   else if (nr == 1 || nc == 1)
     {
       // If indexing a vector with a matrix, return value has same
       // shape as the index.  Otherwise, it has same orientation as
       // indexed object.
 
       Array<T> tmp = Array<T>::index1 (idx_arg, resize_ok);
 
-      int len = tmp.length ();
+      octave_idx_type len = tmp.length ();
 
       if ((len != 0 && idx_arg.one_zero_only ())
 	  || idx_orig_rows == 1 || idx_orig_columns == 1)
 	{
 	  if (nr == 1)
 	    retval = Array<T> (tmp, dim_vector (1, len));
 	  else
 	    retval = Array<T> (tmp, dim_vector (len, 1));
@@ -2109,39 +2110,39 @@ Array<T>::index2 (idx_vector& idx_arg, i
 
       // This code is only for indexing matrices.  The vector
       // cases are handled above.
 
       idx_arg.freeze (nr * nc, "matrix", resize_ok);
 
       if (idx_arg)
 	{
-	  int result_nr = idx_orig_rows;
-	  int result_nc = idx_orig_columns;
+	  octave_idx_type result_nr = idx_orig_rows;
+	  octave_idx_type result_nc = idx_orig_columns;
 
 	  if (idx_arg.one_zero_only ())
 	    {
 	      result_nr = idx_arg.ones_count ();
 	      result_nc = (result_nr > 0 ? 1 : 0);
 	    }
 
 	  retval.resize_no_fill (result_nr, result_nc);
 
-	  int k = 0;
-	  for (int j = 0; j < result_nc; j++)
+	  octave_idx_type k = 0;
+	  for (octave_idx_type j = 0; j < result_nc; j++)
 	    {
-	      for (int i = 0; i < result_nr; i++)
+	      for (octave_idx_type i = 0; i < result_nr; i++)
 		{
-		  int ii = idx_arg.elem (k++);
+		  octave_idx_type ii = idx_arg.elem (k++);
 		  if (ii >= orig_len)
 		    retval.elem (i, j) = rfv;
 		  else
 		    {
-		      int fr = ii % nr;
-		      int fc = (ii - fr) / nr;
+		      octave_idx_type fr = ii % nr;
+		      octave_idx_type fc = (ii - fr) / nr;
 		      retval.elem (i, j) = elem (fr, fc);
 		    }
 		}
 	    }
 	}
       // idx_vector::freeze() printed an error message for us.
     }
 
@@ -2151,49 +2152,49 @@ Array<T>::index2 (idx_vector& idx_arg, i
 template <class T>
 Array<T>
 Array<T>::indexN (idx_vector& ra_idx, int resize_ok, const T& rfv) const
 {
   Array<T> retval;
 
   int n_dims = dims().length ();
 
-  int orig_len = dims().numel ();
+  octave_idx_type orig_len = dims().numel ();
 
   dim_vector idx_orig_dims = ra_idx.orig_dimensions ();
 
   if (ra_idx.is_colon ())
     {
       // Fast magic colon processing.
 
       retval = Array<T> (*this, dim_vector (orig_len, 1));
     }
   else if (length () == 1)
     {
       // Only one element in array.
 
       Array<T> tmp = Array<T>::index (ra_idx, resize_ok);
 
-      int len = tmp.length ();
+      octave_idx_type len = tmp.length ();
 
       if (len != 0)
 	{
 	  if (len >= idx_orig_dims.numel ())
 	    retval = Array<T> (tmp, idx_orig_dims);
 	}
       else
 	retval = Array<T> (tmp, dim_vector (0, 0));
     }
   else if (vector_equivalent (dims ()))
     {
       // We're getting elements from a vector equivalent i.e. (1x4x1).
 
       Array<T> tmp = Array<T>::index (ra_idx, resize_ok);
 
-      int len = tmp.length ();
+      octave_idx_type len = tmp.length ();
 
       if (len == 0)
 	{
 	  if (idx_orig_dims.any_zero ())
 	    retval = Array<T> (idx_orig_dims);
 	  else
 	    {
 	      dim_vector new_dims;
@@ -2249,36 +2250,36 @@ Array<T>::indexN (idx_vector& ra_idx, in
 
       if (ra_idx)
 	{
 	  dim_vector result_dims (idx_orig_dims);
 
 	  if (ra_idx.one_zero_only ())
 	    {
 	      result_dims.resize (2);
-	      int ntot = ra_idx.ones_count ();
+	      octave_idx_type ntot = ra_idx.ones_count ();
 	      result_dims(0) = ntot;
 	      result_dims(1) = (ntot > 0 ? 1 : 0);
 	    }
 
 	  result_dims.chop_trailing_singletons ();
 
 	  retval.resize (result_dims);
 
-	  int n = result_dims.numel ();
+	  octave_idx_type n = result_dims.numel ();
 
 	  int r_dims = result_dims.length ();
 
-	  Array<int> iidx (r_dims, 0);
-
-	  int k = 0;
-
-	  for (int i = 0; i < n; i++)
+	  Array<octave_idx_type> iidx (r_dims, 0);
+
+	  octave_idx_type k = 0;
+
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
-	      int ii = ra_idx.elem (k++);
+	      octave_idx_type ii = ra_idx.elem (k++);
 
 	      if (ii >= orig_len)
 	        retval.elem (iidx) = rfv;
 	      else
 	        {
 		  Array<int> temp = get_ra_idx (ii, dims ());
 
 		  retval.elem (iidx) = elem (temp);
@@ -2296,42 +2297,42 @@ template <class T>
 Array<T>
 Array<T>::index (idx_vector& idx_i, idx_vector& idx_j, int resize_ok,
 		 const T& rfv) const
 {
   Array<T> retval;
 
   assert (ndims () == 2);
 
-  int nr = dim1 ();
-  int nc = dim2 ();
-
-  int n = idx_i.freeze (nr, "row", resize_ok);
-  int m = idx_j.freeze (nc, "column", resize_ok);
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
+
+  octave_idx_type n = idx_i.freeze (nr, "row", resize_ok);
+  octave_idx_type m = idx_j.freeze (nc, "column", resize_ok);
 
   if (idx_i && idx_j)
     {
       if (idx_i.orig_empty () || idx_j.orig_empty () || n == 0 || m == 0)
 	{
 	  retval.resize_no_fill (n, m);
 	}
       else if (idx_i.is_colon_equiv (nr) && idx_j.is_colon_equiv (nc))
 	{
 	  retval = *this;
 	}
       else
 	{
 	  retval.resize_no_fill (n, m);
 
-	  for (int j = 0; j < m; j++)
+	  for (octave_idx_type j = 0; j < m; j++)
 	    {
-	      int jj = idx_j.elem (j);
-	      for (int i = 0; i < n; i++)
+	      octave_idx_type jj = idx_j.elem (j);
+	      for (octave_idx_type i = 0; i < n; i++)
 		{
-		  int ii = idx_i.elem (i);
+		  octave_idx_type ii = idx_i.elem (i);
 		  if (ii >= nr || jj >= nc)
 		    retval.elem (i, j) = rfv;
 		  else
 		    retval.elem (i, j) = elem (ii, jj);
 		}
 	    }
 	}
     }
@@ -2350,28 +2351,28 @@ Array<T>::index (Array<idx_vector>& ra_i
 
   Array<T> retval;
 
   int n_dims = dimensions.length ();
 
   // Remove trailing singletons in ra_idx, but leave at least ndims
   // elements.
 
-  int ra_idx_len = ra_idx.length ();
+  octave_idx_type ra_idx_len = ra_idx.length ();
 
   bool trim_trailing_singletons = true;
-  for (int j = ra_idx_len; j > n_dims; j--)
+  for (octave_idx_type j = ra_idx_len; j > n_dims; j--)
     {
       idx_vector iidx = ra_idx (ra_idx_len-1);
       if (iidx.capacity () == 1 && trim_trailing_singletons)
 	ra_idx_len--;
       else
 	trim_trailing_singletons = false;
 
-      for (int i = 0; i < iidx.capacity (); i++)
+      for (octave_idx_type i = 0; i < iidx.capacity (); i++)
 	if (iidx (i) != 0)
 	  {
 	    (*current_liboctave_error_handler)
 	      ("index exceeds N-d array dimensions");
 	    
 	    return retval;
 	  }
     }
@@ -2405,27 +2406,27 @@ Array<T>::index (Array<idx_vector>& ra_i
       else
 	{
 	  dim_vector frozen_lengths_for_resize = frozen_lengths;
 
 	  frozen_lengths_for_resize.chop_trailing_singletons ();
 
 	  retval.resize (frozen_lengths_for_resize);
 
-	  int n = retval.length ();
-
-	  Array<int> result_idx (ra_idx.length (), 0);
-
-	  Array<int> elt_idx;
-
-	  for (int i = 0; i < n; i++)
+	  octave_idx_type n = retval.length ();
+
+	  Array<octave_idx_type> result_idx (ra_idx.length (), 0);
+
+	  Array<octave_idx_type> elt_idx;
+
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      elt_idx = get_elt_idx (ra_idx, result_idx);
 
-	      int numelem_elt = get_scalar_idx (elt_idx, new_dims);
+	      octave_idx_type numelem_elt = get_scalar_idx (elt_idx, new_dims);
 
 	      if (numelem_elt > length () || numelem_elt < 0)
 		(*current_liboctave_error_handler)
 		  ("invalid N-d array index");
 	      else
 		retval.elem (i) = elem (numelem_elt);
 
 	      increment_index (result_idx, frozen_lengths);
@@ -2491,45 +2492,45 @@ int
 assign1 (Array<LT>& lhs, const Array<RT>& rhs, const LT& rfv)
 {
   int retval = 1;
 
   idx_vector *tmp = lhs.get_idx ();
 
   idx_vector lhs_idx = tmp[0];
 
-  int lhs_len = lhs.length ();
-  int rhs_len = rhs.length ();
-
-  int n = lhs_idx.freeze (lhs_len, "vector", true, liboctave_wrore_flag);
+  octave_idx_type lhs_len = lhs.length ();
+  octave_idx_type rhs_len = rhs.length ();
+
+  octave_idx_type n = lhs_idx.freeze (lhs_len, "vector", true, liboctave_wrore_flag);
 
   if (n != 0)
     {
       if (rhs_len == n || rhs_len == 1)
 	{
-	  int max_idx = lhs_idx.max () + 1;
+	  octave_idx_type max_idx = lhs_idx.max () + 1;
 	  if (max_idx > lhs_len)
 	    lhs.resize_and_fill (max_idx, rfv);
 	}
 
       if (rhs_len == n)
 	{
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
-	      int ii = lhs_idx.elem (i);
+	      octave_idx_type ii = lhs_idx.elem (i);
 	      lhs.elem (ii) = rhs.elem (i);
 	    }
 	}
       else if (rhs_len == 1)
 	{
 	  RT scalar = rhs.elem (0);
 
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
-	      int ii = lhs_idx.elem (i);
+	      octave_idx_type ii = lhs_idx.elem (i);
 	      lhs.elem (ii) = scalar;
 	    }
 	}
       else
 	{
 	  (*current_liboctave_error_handler)
 	    ("A(I) = X: X must be a scalar or a vector with same length as I");
 
@@ -2537,17 +2538,17 @@ assign1 (Array<LT>& lhs, const Array<RT>
 	}
     }
   else if (lhs_idx.is_colon ())
     {
       if (lhs_len == 0)
 	{
 	  lhs.resize_no_fill (rhs_len);
 
-	  for (int i = 0; i < rhs_len; i++)
+	  for (octave_idx_type i = 0; i < rhs_len; i++)
 	    lhs.elem (i) = rhs.elem (i);
 	}
       else
 	(*current_liboctave_error_handler)
 	  ("A(:) = X: A must be the same size as X");
     }
   else if (! (rhs_len == 1 || rhs_len == 0))
     {
@@ -2560,41 +2561,41 @@ assign1 (Array<LT>& lhs, const Array<RT>
   lhs.clear_index ();
 
   return retval;
 }
 
 #define MAYBE_RESIZE_LHS \
   do \
     { \
-      int max_row_idx = idx_i_is_colon ? rhs_nr : idx_i.max () + 1; \
-      int max_col_idx = idx_j_is_colon ? rhs_nc : idx_j.max () + 1; \
+      octave_idx_type max_row_idx = idx_i_is_colon ? rhs_nr : idx_i.max () + 1; \
+      octave_idx_type max_col_idx = idx_j_is_colon ? rhs_nc : idx_j.max () + 1; \
  \
-      int new_nr = max_row_idx > lhs_nr ? max_row_idx : lhs_nr; \
-      int new_nc = max_col_idx > lhs_nc ? max_col_idx : lhs_nc; \
+      octave_idx_type new_nr = max_row_idx > lhs_nr ? max_row_idx : lhs_nr; \
+      octave_idx_type new_nc = max_col_idx > lhs_nc ? max_col_idx : lhs_nc; \
  \
       lhs.resize_and_fill (new_nr, new_nc, rfv); \
     } \
   while (0)
 
 template <class LT, class RT>
 int
 assign2 (Array<LT>& lhs, const Array<RT>& rhs, const LT& rfv)
 {
   int retval = 1;
 
   int n_idx = lhs.index_count ();
 
-  int lhs_nr = lhs.rows ();
-  int lhs_nc = lhs.cols ();
+  octave_idx_type lhs_nr = lhs.rows ();
+  octave_idx_type lhs_nc = lhs.cols ();
 
   Array<RT> xrhs = rhs;
 
-  int rhs_nr = xrhs.rows ();
-  int rhs_nc = xrhs.cols ();
+  octave_idx_type rhs_nr = xrhs.rows ();
+  octave_idx_type rhs_nc = xrhs.cols ();
 
   if (xrhs.ndims () > 2)
     {
       xrhs = xrhs.squeeze ();
 
       dim_vector dv_tmp = xrhs.dims ();
 
       switch (dv_tmp.length ())
@@ -2626,19 +2627,19 @@ assign2 (Array<LT>& lhs, const Array<RT>
   if (n_idx > 1)
     idx_j = tmp[1];
 
   if (n_idx > 0)
     idx_i = tmp[0];
 
   if (n_idx == 2)
     {
-      int n = idx_i.freeze (lhs_nr, "row", true, liboctave_wrore_flag);
-
-      int m = idx_j.freeze (lhs_nc, "column", true, liboctave_wrore_flag);
+      octave_idx_type n = idx_i.freeze (lhs_nr, "row", true, liboctave_wrore_flag);
+
+      octave_idx_type m = idx_j.freeze (lhs_nc, "column", true, liboctave_wrore_flag);
 
       int idx_i_is_colon = idx_i.is_colon ();
       int idx_j_is_colon = idx_j.is_colon ();
 
       if (idx_i_is_colon)
 	n = lhs_nr > 0 ? lhs_nr : rhs_nr;
 
       if (idx_j_is_colon)
@@ -2658,39 +2659,39 @@ assign2 (Array<LT>& lhs, const Array<RT>
 		  // are empty.
 
 		  if (n > 0 && m > 0)
 		    {
 		      MAYBE_RESIZE_LHS;
 
 		      RT scalar = xrhs.elem (0, 0);
 
-		      for (int j = 0; j < m; j++)
+		      for (octave_idx_type j = 0; j < m; j++)
 			{
-			  int jj = idx_j.elem (j);
-			  for (int i = 0; i < n; i++)
+			  octave_idx_type jj = idx_j.elem (j);
+			  for (octave_idx_type i = 0; i < n; i++)
 			    {
-			      int ii = idx_i.elem (i);
+			      octave_idx_type ii = idx_i.elem (i);
 			      lhs.elem (ii, jj) = scalar;
 			    }
 			}
 		    }
 		}
 	      else if (n == rhs_nr && m == rhs_nc)
 		{
 		  if (n > 0 && m > 0)
 		    {
 		      MAYBE_RESIZE_LHS;
 
-		      for (int j = 0; j < m; j++)
+		      for (octave_idx_type j = 0; j < m; j++)
 			{
-			  int jj = idx_j.elem (j);
-			  for (int i = 0; i < n; i++)
+			  octave_idx_type jj = idx_j.elem (j);
+			  for (octave_idx_type i = 0; i < n; i++)
 			    {
-			      int ii = idx_i.elem (i);
+			      octave_idx_type ii = idx_i.elem (i);
 			      lhs.elem (ii, jj) = xrhs.elem (i, j);
 			    }
 			}
 		    }
 		}
 	      else if (n == 0 && m == 0)
 		{
 		  if (! ((rhs_nr == 1 && rhs_nc == 1)
@@ -2718,19 +2719,19 @@ assign2 (Array<LT>& lhs, const Array<RT>
       // idx_vector::freeze() printed an error message for us.
     }
   else if (n_idx == 1)
     {
       int lhs_is_empty = lhs_nr == 0 || lhs_nc == 0;
 
       if (lhs_is_empty || (lhs_nr == 1 && lhs_nc == 1))
 	{
-	  int lhs_len = lhs.length ();
-
-	  int n = idx_i.freeze (lhs_len, 0, true, liboctave_wrore_flag);
+	  octave_idx_type lhs_len = lhs.length ();
+
+	  octave_idx_type n = idx_i.freeze (lhs_len, 0, true, liboctave_wrore_flag);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		{
 		  if (n != 0 && (lhs_nr != 0 || lhs_nc != 0))
 		    lhs.maybe_delete_elements (idx_i);
 		}
@@ -2742,28 +2743,28 @@ assign2 (Array<LT>& lhs, const Array<RT>
 			  && idx_i.is_colon ()
 			  && ! (rhs_nr == 1 || rhs_nc == 1))
 			{
 			  (*current_liboctave_warning_handler)
 			    ("A(:) = X: X is not a vector or scalar");
 			}
 		      else
 			{
-			  int idx_nr = idx_i.orig_rows ();
-			  int idx_nc = idx_i.orig_columns ();
+			  octave_idx_type idx_nr = idx_i.orig_rows ();
+			  octave_idx_type idx_nc = idx_i.orig_columns ();
 
 			  if (! (rhs_nr == idx_nr && rhs_nc == idx_nc))
 			    (*current_liboctave_warning_handler)
 			      ("A(I) = X: X does not have same shape as I");
 			}
 		    }
 
 		  if (assign1 (lhs, xrhs, rfv))
 		    {
-		      int len = lhs.length ();
+		      octave_idx_type len = lhs.length ();
 
 		      if (len > 0)
 			{
 			  // The following behavior is much simplified
 			  // over previous versions of Octave.  It
 			  // seems to be compatible with Matlab.
 
 			  lhs.dimensions = dim_vector (1, lhs.length ());
@@ -2818,50 +2819,50 @@ assign2 (Array<LT>& lhs, const Array<RT>
 	  if (liboctave_wfi_flag
 	      && ! (idx_i.is_colon ()
 		    || (idx_i.one_zero_only ()
 			&& idx_i.orig_rows () == lhs_nr
 			&& idx_i.orig_columns () == lhs_nc)))
 	    (*current_liboctave_warning_handler)
 	      ("single index used for matrix");
 
-	  int len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
+	  octave_idx_type len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		lhs.maybe_delete_elements (idx_i);
 	      else if (len == 0)
 		{
 		  if (! ((rhs_nr == 1 && rhs_nc == 1)
 			 || (rhs_nr == 0 || rhs_nc == 0)))
 		    (*current_liboctave_error_handler)
 		      ("A([]) = X: X must be an empty matrix or scalar");
 		}
 	      else if (len == rhs_nr * rhs_nc)
 		{
-		  int k = 0;
-		  for (int j = 0; j < rhs_nc; j++)
+		  octave_idx_type k = 0;
+		  for (octave_idx_type j = 0; j < rhs_nc; j++)
 		    {
-		      for (int i = 0; i < rhs_nr; i++)
+		      for (octave_idx_type i = 0; i < rhs_nr; i++)
 			{
-			  int ii = idx_i.elem (k++);
-			  int fr = ii % lhs_nr;
-			  int fc = (ii - fr) / lhs_nr;
+			  octave_idx_type ii = idx_i.elem (k++);
+			  octave_idx_type fr = ii % lhs_nr;
+			  octave_idx_type fc = (ii - fr) / lhs_nr;
 			  lhs.elem (fr, fc) = xrhs.elem (i, j);
 			}
 		    }
 		}
 	      else if (rhs_nr == 1 && rhs_nc == 1)
 		{
 		  RT scalar = rhs.elem (0, 0);
 
-		  for (int i = 0; i < len; i++)
+		  for (octave_idx_type i = 0; i < len; i++)
 		    {
-		      int ii = idx_i.elem (i);
+		      octave_idx_type ii = idx_i.elem (i);
 		      lhs.elem (ii) = scalar;
 		    }
 		}
 	      else
 		{
 		  (*current_liboctave_error_handler)
       ("A(I) = X: X must be a scalar or a matrix with the same size as I");
 
@@ -2887,17 +2888,17 @@ assign2 (Array<LT>& lhs, const Array<RT>
 template <class LT, class RT>
 int
 assignN (Array<LT>& lhs, const Array<RT>& rhs, const LT& rfv)
 {
   int retval = 1;
 
   dim_vector rhs_dims = rhs.dims ();
 
-  int rhs_dims_len = rhs_dims.length ();
+  octave_idx_type rhs_dims_len = rhs_dims.length ();
 
   bool rhs_is_scalar = is_scalar (rhs_dims);
 
   int n_idx = lhs.index_count ();
 
   idx_vector *idx_vex = lhs.get_idx ();
 
   Array<idx_vector> idx = conv_to_array (idx_vex, n_idx);
@@ -2912,48 +2913,48 @@ assignN (Array<LT>& lhs, const Array<RT>
 
       if (liboctave_wfi_flag
 	  && ! (iidx.is_colon ()
 		|| (iidx.one_zero_only ()
 		    && iidx.orig_dimensions () == lhs.dims ())))
 	(*current_liboctave_warning_handler)
 	  ("single index used for N-d array");
 
-      int lhs_len = lhs.length ();
-
-      int len = iidx.freeze (lhs_len, "N-d arrray");
+      octave_idx_type lhs_len = lhs.length ();
+
+      octave_idx_type len = iidx.freeze (lhs_len, "N-d arrray");
 
       if (iidx)
 	{
 	  if (len == 0)
 	    {
 	      if (! (rhs_dims.all_ones () || rhs_dims.any_zero ()))
 		{
 		  (*current_liboctave_error_handler)
 		    ("A([]) = X: X must be an empty matrix or scalar");
 
 		  retval = 0;
 		}
 	    }
 	  else if (len == rhs.length ())
 	    {
-	      for (int i = 0; i < len; i++)
+	      for (octave_idx_type i = 0; i < len; i++)
 		{
-		  int ii = iidx.elem (i);
+		  octave_idx_type ii = iidx.elem (i);
 
 		  lhs.elem (ii) = rhs.elem (i);
 		}
 	    }
 	  else if (rhs_is_scalar)
 	    {
 	      RT scalar = rhs.elem (0);
 
-	      for (int i = 0; i < len; i++)
+	      for (octave_idx_type i = 0; i < len; i++)
 		{
-		  int ii = iidx.elem (i);
+		  octave_idx_type ii = iidx.elem (i);
 
 		  lhs.elem (ii) = scalar;
 		}
 	    }
 	  else
 	    {
 	      (*current_liboctave_error_handler)
 		("A(I) = X: X must be a scalar or a matrix with the same size as I");
@@ -2965,23 +2966,23 @@ assignN (Array<LT>& lhs, const Array<RT>
 	}
     }
   else
     {
       // Maybe expand to more dimensions.
 
       dim_vector lhs_dims = lhs.dims ();
 
-      int lhs_dims_len = lhs_dims.length ();
+      octave_idx_type lhs_dims_len = lhs_dims.length ();
 
       dim_vector final_lhs_dims = lhs_dims;
 
       dim_vector frozen_len;
 
-      int orig_lhs_dims_len = lhs_dims_len;
+      octave_idx_type orig_lhs_dims_len = lhs_dims_len;
 
       bool orig_empty = lhs_dims.all_zero ();
 
       if (n_idx < lhs_dims_len)
 	{
 	  // Collapse dimensions beyond last index.  Note that we
 	  // delay resizing LHS until we know that the assignment will
 	  // succeed.
@@ -3084,58 +3085,58 @@ assignN (Array<LT>& lhs, const Array<RT>
 	      frozen_len = freeze (idx, lhs_dims, true);
 
 	      if (rhs_is_scalar)
 		{
 		  lhs.resize_and_fill (new_dims, rfv);
 
 		  if  (! final_lhs_dims.any_zero ())
 		    {
-		      int n = Array<LT>::get_size (frozen_len);
-
-		      Array<int> result_idx (lhs_dims_len, 0);
+		      octave_idx_type n = Array<LT>::get_size (frozen_len);
+
+		      Array<octave_idx_type> result_idx (lhs_dims_len, 0);
 
 		      RT scalar = rhs.elem (0);
 
-		      for (int i = 0; i < n; i++)
+		      for (octave_idx_type i = 0; i < n; i++)
 			{
-			  Array<int> elt_idx = get_elt_idx (idx, result_idx);
+			  Array<octave_idx_type> elt_idx = get_elt_idx (idx, result_idx);
 
 			  lhs.elem (elt_idx) = scalar;
 
 			  increment_index (result_idx, frozen_len);
 			}
 		    }
 		}
 	      else
 		{
 		  // RHS is matrix or higher dimension.
 
-		  int n = Array<LT>::get_size (frozen_len);
+		  octave_idx_type n = Array<LT>::get_size (frozen_len);
 
 		  if (n != rhs.numel ())
 		    {
 		      (*current_liboctave_error_handler)
 			("A(IDX-LIST) = X: X must be a scalar or size of X must equal number of elements indexed by IDX-LIST");
 
 			  retval = 0;
 		    }
 		  else
 		    {
 		      lhs.resize_and_fill (new_dims, rfv);
 
 		      if  (! final_lhs_dims.any_zero ())
 			{
 			  n = Array<LT>::get_size (frozen_len);
 
-			  Array<int> result_idx (lhs_dims_len, 0);
-
-			  for (int i = 0; i < n; i++)
+			  Array<octave_idx_type> result_idx (lhs_dims_len, 0);
+
+			  for (octave_idx_type i = 0; i < n; i++)
 			    {
-			      Array<int> elt_idx = get_elt_idx (idx, result_idx);
+			      Array<octave_idx_type> elt_idx = get_elt_idx (idx, result_idx);
 
 			      lhs.elem (elt_idx) = rhs.elem (i);
 
 			      increment_index (result_idx, frozen_len);
 			    }
 			}
 		    }
 		}
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -54,51 +54,51 @@ protected:
   // The real representation of all arrays.
   //--------------------------------------------------------------------
 
   class ArrayRep
   {
   public:
 
     T *data;
-    int len;
+    octave_idx_type len;
     int count;
 
-    ArrayRep (T *d, int l) : data (d), len (l), count (1) { }
+    ArrayRep (T *d, octave_idx_type l) : data (d), len (l), count (1) { }
 
     ArrayRep (void) : data (0), len (0), count (1) { }
 
-    explicit ArrayRep (int n) : data (new T [n]), len (n), count (1) { }
+    explicit ArrayRep (octave_idx_type n) : data (new T [n]), len (n), count (1) { }
 
-    explicit ArrayRep (int n, const T& val)
+    explicit ArrayRep (octave_idx_type n, const T& val)
       : data (new T [n]), len (n), count (1)
       {
 	fill (val);
       }
 
     ArrayRep (const ArrayRep& a)
       : data (new T [a.len]), len (a.len), count (1)
       {
-        for (int i = 0; i < len; i++)
+        for (octave_idx_type i = 0; i < len; i++)
 	  data[i] = a.data[i];
       }
  
     ~ArrayRep (void) { delete [] data; }
 
-    int length (void) const { return len; }
+    octave_idx_type length (void) const { return len; }
 
     void fill (const T& val)
       {
-	for (int i = 0; i < len; i++)
+	for (octave_idx_type i = 0; i < len; i++)
 	  data[i] = val;
       }
 
-    T& elem (int n) { return data[n]; }
+    T& elem (octave_idx_type n) { return data[n]; }
 
-    T elem (int n) const { return data[n]; }
+    T elem (octave_idx_type n) const { return data[n]; }
 
     void qsort (int (*compare) (const void *, const void *))
       {
 	octave_qsort (data, static_cast<size_t> (len), sizeof (T), compare);
       }
 
   private:
 
@@ -138,17 +138,17 @@ public:
 
   dim_vector dimensions;
 
 protected:
 
   idx_vector *idx;
   int idx_count;
 
-  Array (T *d, int n)
+  Array (T *d, octave_idx_type n)
     : rep (new typename Array<T>::ArrayRep (d, n)), dimensions (n),
       idx (0), idx_count (0) { }
 
   Array (T *d, const dim_vector& dv)
     : rep (new typename Array<T>::ArrayRep (d, get_size (dv))),
       dimensions (dv), idx (0), idx_count (0) { }
 
 private:
@@ -174,21 +174,21 @@ private:
   }
 
 public:
 
   Array (void)
     : rep (nil_rep ()), dimensions (),
       idx (0), idx_count (0) { rep->count++; }
 
-  explicit Array (int n)
+  explicit Array (octave_idx_type n)
     : rep (new typename Array<T>::ArrayRep (n)), dimensions (n),
       idx (0), idx_count (0) { }
 
-  explicit Array (int n, const T& val)
+  explicit Array (octave_idx_type n, const T& val)
     : rep (new typename Array<T>::ArrayRep (n)), dimensions (n),
       idx (0), idx_count (0)
     {
       fill (val);
     }
 
   // Type conversion case.
   template <class U>
@@ -238,237 +238,237 @@ public:
       idx_count = 0;
       idx = 0;
 
       return *this;
     }
 
   void fill (const T& val) { make_unique (val); }
 
-  int capacity (void) const { return rep->length (); }
-  int length (void) const { return capacity (); }
-  int nelem (void) const { return capacity (); }
-  int numel (void) const { return nelem (); }
+  octave_idx_type capacity (void) const { return rep->length (); }
+  octave_idx_type length (void) const { return capacity (); }
+  octave_idx_type nelem (void) const { return capacity (); }
+  octave_idx_type numel (void) const { return nelem (); }
 
-  int dim1 (void) const { return dimensions(0); }
-  int dim2 (void) const { return dimensions(1); }
-  int dim3 (void) const { return dimensions(2); }
+  octave_idx_type dim1 (void) const { return dimensions(0); }
+  octave_idx_type dim2 (void) const { return dimensions(1); }
+  octave_idx_type dim3 (void) const { return dimensions(2); }
 
-  int rows (void) const { return dim1 (); }
-  int cols (void) const { return dim2 (); }
-  int columns (void) const { return dim2 (); }
-  int pages (void) const { return dim3 (); }
+  octave_idx_type rows (void) const { return dim1 (); }
+  octave_idx_type cols (void) const { return dim2 (); }
+  octave_idx_type columns (void) const { return dim2 (); }
+  octave_idx_type pages (void) const { return dim3 (); }
 
   size_t byte_size (void) const { return numel () * sizeof (T); }
 
   dim_vector dims (void) const { return dimensions; }
 
   Array<T> squeeze (void) const;
   
   void chop_trailing_singletons (void) 
   { dimensions.chop_trailing_singletons (); }
   
-  static int get_size (int r, int c);
-  static int get_size (int r, int c, int p);
-  static int get_size (const dim_vector& dv);
+  static octave_idx_type get_size (octave_idx_type r, octave_idx_type c);
+  static octave_idx_type get_size (octave_idx_type r, octave_idx_type c, octave_idx_type p);
+  static octave_idx_type get_size (const dim_vector& dv);
 
-  int compute_index (const Array<int>& ra_idx) const;
+  octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
-  T range_error (const char *fcn, int n) const;
-  T& range_error (const char *fcn, int n);
+  T range_error (const char *fcn, octave_idx_type n) const;
+  T& range_error (const char *fcn, octave_idx_type n);
 
-  T range_error (const char *fcn, int i, int j) const;
-  T& range_error (const char *fcn, int i, int j);
+  T range_error (const char *fcn, octave_idx_type i, octave_idx_type j) const;
+  T& range_error (const char *fcn, octave_idx_type i, octave_idx_type j);
 
-  T range_error (const char *fcn, int i, int j, int k) const;
-  T& range_error (const char *fcn, int i, int j, int k);
+  T range_error (const char *fcn, octave_idx_type i, octave_idx_type j, octave_idx_type k) const;
+  T& range_error (const char *fcn, octave_idx_type i, octave_idx_type j, octave_idx_type k);
 
   T range_error (const char *fcn, const Array<int>& ra_idx) const;
   T& range_error (const char *fcn, const Array<int>& ra_idx);
 
   // No checking, even for multiple references, ever.
 
-  T& xelem (int n) { return rep->elem (n); }
-  T xelem (int n) const { return rep->elem (n); }
+  T& xelem (octave_idx_type n) { return rep->elem (n); }
+  T xelem (octave_idx_type n) const { return rep->elem (n); }
 
-  T& xelem (int i, int j) { return xelem (dim1()*j+i); }
-  T xelem (int i, int j) const { return xelem (dim1()*j+i); }
+  T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1()*j+i); }
+  T xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1()*j+i); }
 
-  T& xelem (int i, int j, int k) { return xelem (i, dim2()*k+j); }
-  T xelem (int i, int j, int k) const { return xelem (i, dim2()*k+j); }
+  T& xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return xelem (i, dim2()*k+j); }
+  T xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return xelem (i, dim2()*k+j); }
 
   T& xelem (const Array<int>& ra_idx)
     { return xelem (compute_index (ra_idx)); }
 
   T xelem (const Array<int>& ra_idx) const
     { return xelem (compute_index (ra_idx)); }
 
   // XXX FIXME XXX -- would be nice to fix this so that we don't
   // unnecessarily force a copy, but that is not so easy, and I see no
   // clean way to do it.
 
-  T& checkelem (int n)
+  T& checkelem (octave_idx_type n)
     {
       if (n < 0 || n >= rep->length ())
 	return range_error ("T& Array<T>::checkelem", n);
       else
 	{
 	  make_unique ();
 	  return xelem (n);
 	}
     }
 
-  T& checkelem (int i, int j)
+  T& checkelem (octave_idx_type i, octave_idx_type j)
     {
       if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
 	return range_error ("T& Array<T>::checkelem", i, j);
       else
 	return elem (dim1()*j+i);
     }
 
-  T& checkelem (int i, int j, int k)
+  T& checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
     {
       if (i < 0 || j < 0 || k < 0 || i >= dim1 () || j >= dim2 () || k >= dim3 ())
 	return range_error ("T& Array<T>::checkelem", i, j, k);
       else
 	return elem (i, dim2()*k+j);
     }
 
   T& checkelem (const Array<int>& ra_idx)
     {
-      int i = compute_index (ra_idx);
+      octave_idx_type i = compute_index (ra_idx);
 
       if (i < 0)
 	return range_error ("T& Array<T>::checkelem", ra_idx);
       else
 	return elem (i);
     }
 
-  T& elem (int n)
+  T& elem (octave_idx_type n)
     {
       make_unique ();
       return xelem (n);
     }
 
-  T& elem (int i, int j) { return elem (dim1()*j+i); }
+  T& elem (octave_idx_type i, octave_idx_type j) { return elem (dim1()*j+i); }
 
-  T& elem (int i, int j, int k) { return elem (i, dim2()*k+j); }
+  T& elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, dim2()*k+j); }
 
   T& elem (const Array<int>& ra_idx)
     { return Array<T>::elem (compute_index (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
-  T& operator () (int n) { return checkelem (n); }
-  T& operator () (int i, int j) { return checkelem (i, j); }
-  T& operator () (int i, int j, int k) { return checkelem (i, j, k); }
+  T& operator () (octave_idx_type n) { return checkelem (n); }
+  T& operator () (octave_idx_type i, octave_idx_type j) { return checkelem (i, j); }
+  T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return checkelem (i, j, k); }
   T& operator () (const Array<int>& ra_idx) { return checkelem (ra_idx); }
 #else
-  T& operator () (int n) { return elem (n); }
-  T& operator () (int i, int j) { return elem (i, j); }
-  T& operator () (int i, int j, int k) { return elem (i, j, k); }
+  T& operator () (octave_idx_type n) { return elem (n); }
+  T& operator () (octave_idx_type i, octave_idx_type j) { return elem (i, j); }
+  T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, j, k); }
   T& operator () (const Array<int>& ra_idx) { return elem (ra_idx); }
 #endif
 
-  T checkelem (int n) const
+  T checkelem (octave_idx_type n) const
     {
       if (n < 0 || n >= rep->length ())
 	return range_error ("T Array<T>::checkelem", n);
       else
 	return xelem (n);
     }
 
-  T checkelem (int i, int j) const
+  T checkelem (octave_idx_type i, octave_idx_type j) const
     {
       if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
 	return range_error ("T Array<T>::checkelem", i, j);
       else
 	return elem (dim1()*j+i);
     }
 
-  T checkelem (int i, int j, int k) const
+  T checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
     {
       if (i < 0 || j < 0 || k < 0 || i >= dim1 () || j >= dim2 () || k >= dim3 ())
 	return range_error ("T Array<T>::checkelem", i, j, k);
       else
 	return Array<T>::elem (i, Array<T>::dim1()*k+j);
     }
 
   T checkelem (const Array<int>& ra_idx) const
     {
-      int i = compute_index (ra_idx);
+      octave_idx_type i = compute_index (ra_idx);
 
       if (i < 0)
 	return range_error ("T Array<T>::checkelem", ra_idx);
       else
 	return Array<T>::elem (i);
     }
 
-  T elem (int n) const { return xelem (n); }
+  T elem (octave_idx_type n) const { return xelem (n); }
 
-  T elem (int i, int j) const { return elem (dim1()*j+i); }
+  T elem (octave_idx_type i, octave_idx_type j) const { return elem (dim1()*j+i); }
 
-  T elem (int i, int j, int k) const { return elem (i, dim2()*k+j); }
+  T elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return elem (i, dim2()*k+j); }
 
   T elem (const Array<int>& ra_idx) const
     { return Array<T>::elem (compute_index (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
-  T operator () (int n) const { return checkelem (n); }
-  T operator () (int i, int j) const { return checkelem (i, j); }
-  T operator () (int i, int j, int k) const { return checkelem (i, j, k); }
+  T operator () (octave_idx_type n) const { return checkelem (n); }
+  T operator () (octave_idx_type i, octave_idx_type j) const { return checkelem (i, j); }
+  T operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return checkelem (i, j, k); }
   T operator () (const Array<int>& ra_idx) const { return checkelem (ra_idx); }
 #else
-  T operator () (int n) const { return elem (n); }
-  T operator () (int i, int j) const { return elem (i, j); }
-  T operator () (int i, int j, int k) const { return elem (i, j, k); }
+  T operator () (octave_idx_type n) const { return elem (n); }
+  T operator () (octave_idx_type i, octave_idx_type j) const { return elem (i, j); }
+  T operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return elem (i, j, k); }
   T operator () (const Array<int>& ra_idx) const { return elem (ra_idx); }
 #endif
 
   Array<T> reshape (const dim_vector& new_dims) const;
 
-  Array<T> permute (const Array<int>& vec, bool inv = false) const;
-  Array<T> ipermute (const Array<int>& vec) const
+  Array<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
+  Array<T> ipermute (const Array<octave_idx_type>& vec) const
     { return permute (vec, true); }
 
-  void resize_no_fill (int n);
-  void resize_and_fill (int n, const T& val);
+  void resize_no_fill (octave_idx_type n);
+  void resize_and_fill (octave_idx_type n, const T& val);
 
   // !!! WARNING !!! -- the following resize_no_fill and
   // resize_and_fill functions are public because template friends
   // don't work properly with versions of gcc earlier than 3.3.  You
   // should use these functions only in classes that are derived
   // from Array<T>.
 
   // protected:
 
-  void resize_no_fill (int r, int c);
-  void resize_and_fill (int r, int c, const T& val);
+  void resize_no_fill (octave_idx_type r, octave_idx_type c);
+  void resize_and_fill (octave_idx_type r, octave_idx_type c, const T& val);
 
-  void resize_no_fill (int r, int c, int p);
-  void resize_and_fill (int r, int c, int p, const T& val);
+  void resize_no_fill (octave_idx_type r, octave_idx_type c, octave_idx_type p);
+  void resize_and_fill (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val);
 
   void resize_no_fill (const dim_vector& dv);
   void resize_and_fill (const dim_vector& dv, const T& val);
 
 public:
 
   void resize (int n) { resize_no_fill (n); }
 
   void resize (int n, const T& val) { resize_and_fill (n, val); }
 
   void resize (const dim_vector& dv) { resize_no_fill (dv); }
 
   void resize (const dim_vector& dv, const T& val)
     { resize_and_fill (dv, val); }
 
-  Array<T>& insert (const Array<T>& a, int r, int c);
-  Array<T>& insert2 (const Array<T>& a, int r, int c);
-  Array<T>& insertN (const Array<T>& a, int r, int c);
+  Array<T>& insert (const Array<T>& a, octave_idx_type r, octave_idx_type c);
+  Array<T>& insert2 (const Array<T>& a, octave_idx_type r, octave_idx_type c);
+  Array<T>& insertN (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
-  Array<T>& insert (const Array<T>& a, const Array<int>& idx);
+  Array<T>& insert (const Array<T>& a, const Array<octave_idx_type>& idx);
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
   bool is_empty (void) const { return numel () == 0; }
 
   Array<T> transpose (void) const;
 
   const T *data (void) const { return rep->data; }
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -37,50 +37,50 @@ class idx_vector;
 // Two dimensional array class.
 
 template <class T>
 class
 Array2 : public Array<T>
 {
 protected:
 
-  static int get_size (int r, int c) { return Array<T>::get_size (r, c); }
+  static octave_idx_type get_size (octave_idx_type r, octave_idx_type c) { return Array<T>::get_size (r, c); }
 
-  Array2 (T *d, int r, int c) : Array<T> (d, dim_vector (r, c)) { }
+  Array2 (T *d, octave_idx_type r, octave_idx_type c) : Array<T> (d, dim_vector (r, c)) { }
 
 public:
 
   Array2 (void) : Array<T> (dim_vector (0, 0)) { }
 
-  Array2 (int r, int c) : Array<T> (dim_vector (r, c)) { }
+  Array2 (octave_idx_type r, octave_idx_type c) : Array<T> (dim_vector (r, c)) { }
 
-  Array2 (int r, int c, const T& val)
+  Array2 (octave_idx_type r, octave_idx_type c, const T& val)
     : Array<T> (dim_vector (r, c), val) { }
 
   Array2 (const Array2<T>& a) : Array<T> (a, a.dims ()) { }
 
-  Array2 (const Array<T>& a, int r, int c)
+  Array2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
     : Array<T> (a, dim_vector (r, c)) { }
 
   ~Array2 (void) { }
 
   Array2<T>& operator = (const Array2<T>& a)
     {
       if (this != &a)
 	Array<T>::operator = (a);
 
       return *this;
     }
 
-  void resize (int r, int c) { this->resize_no_fill (r, c); }
+  void resize (octave_idx_type r, octave_idx_type c) { this->resize_no_fill (r, c); }
 
-  void resize (int r, int c, const T& val)
+  void resize (octave_idx_type r, octave_idx_type c, const T& val)
     { this->resize_and_fill (r, c, val); }
 
-  Array2<T>& insert (const Array2<T>& a, int r, int c)
+  Array2<T>& insert (const Array2<T>& a, octave_idx_type r, octave_idx_type c)
     {
       Array<T>::insert (a, r, c);
       return *this;
     }
 
   Array2<T> transpose (void) const
     {
       Array<T> tmp = Array<T>::transpose ();
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -35,49 +35,49 @@ class idx_vector;
 // Three dimensional array class.
 
 template <class T>
 class
 Array3 : public Array<T>
 {
 protected:
 
-  static int get_size (int r, int c, int p)
+  static octave_idx_type get_size (octave_idx_type r, octave_idx_type c, octave_idx_type p)
     { return Array<T>::get_size (r, c, p); }
 
-  Array3 (T *d, int r, int c, int p) : Array<T> (d, dim_vector (r, c, p)) { }
+  Array3 (T *d, octave_idx_type r, octave_idx_type c, octave_idx_type p) : Array<T> (d, dim_vector (r, c, p)) { }
 
 public:
 
   Array3 (void) : Array<T> (dim_vector (0, 0, 0)) { }
 
-  Array3 (int r, int c, int p) : Array<T> (dim_vector (r, c, p)) { }
+  Array3 (octave_idx_type r, octave_idx_type c, octave_idx_type p) : Array<T> (dim_vector (r, c, p)) { }
 
-  Array3 (int r, int c, int p, const T& val)
+  Array3 (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val)
     : Array<T> (dim_vector (r, c, p), val) { }
 
   Array3 (const Array3<T>& a)
     : Array<T> (a, a.dims ()) { }
 
-  Array3 (const Array<T>& a, int r, int c, int p)
+  Array3 (const Array<T>& a, octave_idx_type r, octave_idx_type c, octave_idx_type p)
     : Array<T> (a, dim_vector (r, c, p)) { }
 
   ~Array3 (void) { }
 
   Array3<T>& operator = (const Array3<T>& a)
     {
       if (this != &a)
 	Array<T>::operator = (a);
 
       return *this;
     }
 
-  void resize (int r, int c, int p) { this->resize_no_fill (r, c, p); }
+  void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p) { this->resize_no_fill (r, c, p); }
 
-  void resize (int r, int c, int p, const T& val)
+  void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val)
     { this->resize_and_fill (r, c, p, val); }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/ArrayN.cc b/liboctave/ArrayN.cc
--- a/liboctave/ArrayN.cc
+++ b/liboctave/ArrayN.cc
@@ -51,79 +51,79 @@ operator << (std::ostream& os, const Arr
     os << " (" << a_dims.str () << ")";
 
   os <<"\n\n";
 
   if (n_dims)
     {
       os << "data:";
 
-      Array<int> ra_idx (n_dims, 0);
+      Array<octave_idx_type> ra_idx (n_dims, 0);
 
       // Number of times the first 2d-array is to be displayed.
 
-      int m = 1;
+      octave_idx_type m = 1;
       for (int i = 2; i < n_dims; i++)
 	m *= a_dims(i);
 
       if (m == 1)
         {
-          int rows = 0;
-          int cols = 0;
+          octave_idx_type rows = 0;
+          octave_idx_type cols = 0;
 
           switch (n_dims)
             {
 	    case 2:
 	      rows = a_dims(0);
 	      cols = a_dims(1);
 
-	      for (int j = 0; j < rows; j++)
+	      for (octave_idx_type j = 0; j < rows; j++)
 		{
 		  ra_idx(0) = j;
-		  for (int k = 0; k < cols; k++)
+		  for (octave_idx_type k = 0; k < cols; k++)
 		    {
 		      ra_idx(1) = k;
 		      os << " " << a.elem(ra_idx);
 		    }
 		  os << "\n";
 		}
 	      break;
 
 	    default:
 	      rows = a_dims(0);
 
-	      for (int k = 0; k < rows; k++)
+	      for (octave_idx_type k = 0; k < rows; k++)
 		{
 		  ra_idx(0) = k;
 		  os << " " << a.elem(ra_idx);
 		}
 	      break;
 	    }
 
           os << "\n";
         }
       else
         {
-          int rows = a_dims(0);
-          int cols = a_dims(1);
+          octave_idx_type rows = a_dims(0);
+          octave_idx_type cols = a_dims(1);
 
           for (int i = 0; i < m; i++)
             {
               os << "\n(:,:,";
 
               for (int j = 2; j < n_dims - 1; j++)
 		os << ra_idx(j) + 1 << ",";
 
 	      os << ra_idx(n_dims - 1) + 1 << ") = \n";
 
-	      for (int j = 0; j < rows; j++)
+	      for (octave_idx_type j = 0; j < rows; j++)
 	        {
 	          ra_idx(0) = j;
 
-	          for (int k = 0; k < cols; k++)
+	          for (octave_idx_type k = 0; k < cols; k++)
 	            {
 		      ra_idx(1) = k;
 		      os << " " << a.elem(ra_idx);
 		    }
 
 	          os << "\n";
 	        }
 
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -103,17 +103,17 @@ public:
   ArrayN<T> transpose (void) const { return Array<T>::transpose (); }
 
   ArrayN<T>& insert (const ArrayN<T>& a, const dim_vector& dv)
     {
       Array<T>::insert (a, dv);
       return *this;
     }
 
-  ArrayN<T>& insert (const ArrayN<T>& a, int r, int c)
+  ArrayN<T>& insert (const ArrayN<T>& a, octave_idx_type r, octave_idx_type c)
   {
     Array<T>::insert (a, r, c);
     return *this;
   }
 
   ArrayN<T> index (idx_vector& i, int resize_ok = 0,
 		   const T& rfv = resize_fill_value (T ())) const
     {
diff --git a/liboctave/Bounds.cc b/liboctave/Bounds.cc
--- a/liboctave/Bounds.cc
+++ b/liboctave/Bounds.cc
@@ -78,17 +78,17 @@ Bounds::set_upper_bounds (const ColumnVe
   ub = u;
 
   return *this;
 }
 
 std::ostream&
 operator << (std::ostream& os, const Bounds& b)
 {
-  for (int i = 0; i < b.size (); i++)
+  for (octave_idx_type i = 0; i < b.size (); i++)
     os << b.lower_bound (i) << " " << b.upper_bound (i) << "\n";
 
   return os;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/Bounds.h b/liboctave/Bounds.h
--- a/liboctave/Bounds.h
+++ b/liboctave/Bounds.h
@@ -30,17 +30,17 @@ Software Foundation, 59 Temple Place - S
 class
 Bounds
 {
 public:
 
   Bounds (void)
     : lb (), ub () { }
 
-  Bounds (int n)
+  Bounds (octave_idx_type n)
     : lb (n, 0.0), ub (n, 0.0) { }
 
   Bounds (const ColumnVector l, const ColumnVector u)
     : lb (l), ub (u)
       {
         if (lb.capacity () != ub.capacity ())
 	  {
 	    error ("inconsistent sizes for lower and upper bounds");
@@ -58,55 +58,55 @@ public:
 	  lb = a.lower_bounds ();
 	  ub = a.upper_bounds ();
 	}
       return *this;
     }
 
   ~Bounds (void) { }
 
-  Bounds& resize (int n)
+  Bounds& resize (octave_idx_type n)
     {
       lb.resize (n);
       ub.resize (n);
 
       return *this;
     }
 
-  double lower_bound (int index) const { return lb.elem (index); }
-  double upper_bound (int index) const { return ub.elem (index); }
+  double lower_bound (octave_idx_type index) const { return lb.elem (index); }
+  double upper_bound (octave_idx_type index) const { return ub.elem (index); }
 
   ColumnVector lower_bounds (void) const { return lb; }
   ColumnVector upper_bounds (void) const { return ub; }
 
-  int size (void) const { return lb.capacity (); }
+  octave_idx_type size (void) const { return lb.capacity (); }
 
-  Bounds& set_bound (int index, double low, double high)
+  Bounds& set_bound (octave_idx_type index, double low, double high)
     {
       lb.elem (index) = low;
       ub.elem (index) = high;
       return *this;
     }
 
   Bounds& set_bounds (double low, double high)
     {
       lb.fill (low);
       ub.fill (high);
       return *this;
     }
 
   Bounds& set_bounds (const ColumnVector lb, const ColumnVector ub);
 
-  Bounds& set_lower_bound (int index, double low)
+  Bounds& set_lower_bound (octave_idx_type index, double low)
     {
       lb.elem (index) = low;
       return *this;
     }
 
-  Bounds& set_upper_bound (int index, double high)
+  Bounds& set_upper_bound (octave_idx_type index, double high)
     {
       ub.elem (index) = high;
       return *this;
     }
 
   Bounds& set_lower_bounds (double low)
     {
       lb.fill (low);
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -35,254 +35,254 @@ Software Foundation, 59 Temple Place - S
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const int&, const int&, const Complex&,
-			   const Complex*, const int&, const Complex*,
-			   const int&, const Complex&, Complex*, const int&
+			   const octave_idx_type&, const octave_idx_type&, const Complex&,
+			   const Complex*, const octave_idx_type&, const Complex*,
+			   const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL);
 }
 
 // Complex Column Vector class
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
    : MArray<Complex> (a.length ())
 {
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     elem (i) = a.elem (i);
 }
 
 bool
 ComplexColumnVector::operator == (const ComplexColumnVector& a) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len != a.length ())
     return 0;
   return mx_inline_equal (data (), a.data (), len);
 }
 
 bool
 ComplexColumnVector::operator != (const ComplexColumnVector& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexColumnVector&
-ComplexColumnVector::insert (const ColumnVector& a, int r)
+ComplexColumnVector::insert (const ColumnVector& a, octave_idx_type r)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexColumnVector&
-ComplexColumnVector::insert (const ComplexColumnVector& a, int r)
+ComplexColumnVector::insert (const ComplexColumnVector& a, octave_idx_type r)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	xelem (i) = val;
     }
 
 
   return *this;
 }
 
 ComplexColumnVector&
-ComplexColumnVector::fill (double val, int r1, int r2)
+ComplexColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
-      for (int i = r1; i <= r2; i++)
+      for (octave_idx_type i = r1; i <= r2; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexColumnVector&
-ComplexColumnVector::fill (const Complex& val, int r1, int r2)
+ComplexColumnVector::fill (const Complex& val, octave_idx_type r1, octave_idx_type r2)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
-      for (int i = r1; i <= r2; i++)
+      for (octave_idx_type i = r1; i <= r2; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexColumnVector
 ComplexColumnVector::stack (const ColumnVector& a) const
 {
-  int len = length ();
-  int nr_insert = len;
+  octave_idx_type len = length ();
+  octave_idx_type nr_insert = len;
   ComplexColumnVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 ComplexColumnVector
 ComplexColumnVector::stack (const ComplexColumnVector& a) const
 {
-  int len = length ();
-  int nr_insert = len;
+  octave_idx_type len = length ();
+  octave_idx_type nr_insert = len;
   ComplexColumnVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 ComplexRowVector
 ComplexColumnVector::hermitian (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   return ComplexRowVector (mx_inline_conj_dup (data (), len), len);
 }
 
 ComplexRowVector
 ComplexColumnVector::transpose (void) const
 {
   return ComplexRowVector (*this);
 }
 
 ComplexColumnVector
 conj (const ComplexColumnVector& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   ComplexColumnVector retval;
   if (a_len > 0)
     retval = ComplexColumnVector (mx_inline_conj_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexColumnVector
-ComplexColumnVector::extract (int r1, int r2) const
+ComplexColumnVector::extract (octave_idx_type r1, octave_idx_type r2) const
 {
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
-  int new_r = r2 - r1 + 1;
+  octave_idx_type new_r = r2 - r1 + 1;
 
   ComplexColumnVector result (new_r);
 
-  for (int i = 0; i < new_r; i++)
+  for (octave_idx_type i = 0; i < new_r; i++)
     result.elem (i) = elem (r1+i);
 
   return result;
 }
 
 ComplexColumnVector
-ComplexColumnVector::extract_n (int r1, int n) const
+ComplexColumnVector::extract_n (octave_idx_type r1, octave_idx_type n) const
 {
   ComplexColumnVector result (n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     result.elem (i) = elem (r1+i);
 
   return result;
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector&
 ComplexColumnVector::operator += (const ColumnVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -292,19 +292,19 @@ ComplexColumnVector::operator += (const 
 
   mx_inline_add2 (d, a.data (), len);
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator -= (const ColumnVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -325,30 +325,30 @@ operator * (const ComplexMatrix& m, cons
   return m * tmp;
 }
 
 ComplexColumnVector
 operator * (const ComplexMatrix& m, const ComplexColumnVector& a)
 {
   ComplexColumnVector retval;
 
-  int nr = m.rows ();
-  int nc = m.cols ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.cols ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nc == 0 || nr == 0)
 	retval.resize (nr, 0.0);
       else
 	{
-	  int ld = nr;
+	  octave_idx_type ld = nr;
 
 	  retval.resize (nr);
 	  Complex *y = retval.fortran_vec ();
 
 	  F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
 				   nr, nc, 1.0, m.data (), ld,
 				   a.data (), 1, 0.0, y, 1
 				   F77_CHAR_ARG_LEN (1)));
@@ -371,92 +371,92 @@ operator * (const Matrix& m, const Compl
   return tmp * a;
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 ComplexColumnVector
 operator * (const DiagMatrix& m, const ComplexColumnVector& a)
 {
-  int nr = m.rows ();
-  int nc = m.cols ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.cols ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
 
-  for (int i = a_len; i < nr; i++)
+  for (octave_idx_type i = a_len; i < nr; i++)
     result.elem (i) = 0.0;
 
   return result;
 }
 
 ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
 {
-  int nr = m.rows ();
-  int nc = m.cols ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.cols ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
 
-  for (int i = a_len; i < nr; i++)
+  for (octave_idx_type i = a_len; i < nr; i++)
     result.elem (i) = 0.0;
 
   return result;
 }
 
 ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
 {
-  int nr = m.rows ();
-  int nc = m.cols ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.cols ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     result.elem (i) = a.elem (i) * m.elem (i, i);
 
-  for (int i = a_len; i < nr; i++)
+  for (octave_idx_type i = a_len; i < nr; i++)
     result.elem (i) = 0.0;
 
   return result;
 }
 
 // other operations
 
 ComplexColumnVector
@@ -466,101 +466,101 @@ ComplexColumnVector::map (c_c_Mapper f) 
   return b.apply (f);
 }
 
 ColumnVector
 ComplexColumnVector::map (d_c_Mapper f) const
 {
   const Complex *d = data ();
 
-  int len = length ();
+  octave_idx_type len = length ();
 
   ColumnVector retval (len);
 
   double *r = retval.fortran_vec ();
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     r[i] = f (d[i]);
 
   return retval;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::apply (c_c_Mapper f)
 {
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     d[i] = f (d[i]);
 
   return *this;
 }
 
 Complex
 ComplexColumnVector::min (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
-  for (int i = 1; i < len; i++)
+  for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
       {
 	res = elem (i);
 	absres = std::abs (res);
       }
 
   return res;
 }
 
 Complex
 ComplexColumnVector::max (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
-  for (int i = 1; i < len; i++)
+  for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
       {
 	res = elem (i);
 	absres = std::abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexColumnVector& a)
 {
-  int len = a.length();
+  octave_idx_type len = a.length();
 
   if (len < 1)
     is.clear (std::ios::badbit);
   else
     {
       double tmp;
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
             a.elem (i) = tmp;
           else
             break;
         }
     }
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -32,19 +32,19 @@ ComplexColumnVector : public MArray<Comp
 {
 friend class ComplexMatrix;
 friend class ComplexRowVector;
 
 public:
 
   ComplexColumnVector (void) : MArray<Complex> () { }
 
-  explicit ComplexColumnVector (int n) : MArray<Complex> (n) { }
+  explicit ComplexColumnVector (octave_idx_type n) : MArray<Complex> (n) { }
 
-  ComplexColumnVector (int n, const Complex& val)
+  ComplexColumnVector (octave_idx_type n, const Complex& val)
     : MArray<Complex> (n, val) { }
 
   ComplexColumnVector (const ComplexColumnVector& a) : MArray<Complex> (a) { }
 
   ComplexColumnVector (const MArray<Complex>& a) : MArray<Complex> (a) { }
 
   explicit ComplexColumnVector (const ColumnVector& a);
 
@@ -54,37 +54,37 @@ public:
       return *this;
     }
 
   bool operator == (const ComplexColumnVector& a) const;
   bool operator != (const ComplexColumnVector& a) const;
 
   // destructive insert/delete/reorder operations
 
-  ComplexColumnVector& insert (const ColumnVector& a, int r);
-  ComplexColumnVector& insert (const ComplexColumnVector& a, int r);
+  ComplexColumnVector& insert (const ColumnVector& a, octave_idx_type r);
+  ComplexColumnVector& insert (const ComplexColumnVector& a, octave_idx_type r);
 
   ComplexColumnVector& fill (double val);
   ComplexColumnVector& fill (const Complex& val);
-  ComplexColumnVector& fill (double val, int r1, int r2);
-  ComplexColumnVector& fill (const Complex& val, int r1, int r2);
+  ComplexColumnVector& fill (double val, octave_idx_type r1, octave_idx_type r2);
+  ComplexColumnVector& fill (const Complex& val, octave_idx_type r1, octave_idx_type r2);
 
   ComplexColumnVector stack (const ColumnVector& a) const;
   ComplexColumnVector stack (const ComplexColumnVector& a) const;
 
   ComplexRowVector hermitian (void) const;  // complex conjugate transpose.
   ComplexRowVector transpose (void) const;
 
   friend ComplexColumnVector conj (const ComplexColumnVector& a);
 
   // resize is the destructive equivalent for this one
 
-  ComplexColumnVector extract (int r1, int r2) const;
+  ComplexColumnVector extract (octave_idx_type r1, octave_idx_type r2) const;
 
-  ComplexColumnVector extract_n (int r1, int n) const;
+  ComplexColumnVector extract_n (octave_idx_type r1, octave_idx_type n) const;
 
   // column vector by column vector -> column vector operations
 
   ComplexColumnVector& operator += (const ColumnVector& a);
   ComplexColumnVector& operator -= (const ColumnVector& a);
 
   // matrix by column vector -> column vector operations
 
@@ -122,17 +122,17 @@ public:
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
 
 private:
 
-  ComplexColumnVector (Complex *d, int l) : MArray<Complex> (d, l) { }
+  ComplexColumnVector (Complex *d, octave_idx_type l) : MArray<Complex> (d, l) { }
 };
 
 MARRAY_FORWARD_DEFS (MArray, ComplexColumnVector, Complex)
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Complex Diagonal Matrix class
 
 ComplexDiagMatrix::ComplexDiagMatrix (const DiagMatrix& a)
   : MDiagArray2<Complex> (a.rows (), a.cols ())
 {
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 bool
 ComplexDiagMatrix::operator == (const ComplexDiagMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
@@ -55,182 +55,182 @@ bool
 ComplexDiagMatrix::operator != (const ComplexDiagMatrix& a) const
 {
   return !(*this == a);
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (double val)
 {
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     elem (i, i) = val;
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const Complex& val)
 {
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     elem (i, i) = val;
   return *this;
 }
 
 ComplexDiagMatrix&
-ComplexDiagMatrix::fill (double val, int beg, int end)
+ComplexDiagMatrix::fill (double val, octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = beg; i <= end; i++)
+  for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 ComplexDiagMatrix&
-ComplexDiagMatrix::fill (const Complex& val, int beg, int end)
+ComplexDiagMatrix::fill (const Complex& val, octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = beg; i <= end; i++)
+  for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
-ComplexDiagMatrix::fill (const ColumnVector& a, int beg)
+ComplexDiagMatrix::fill (const ColumnVector& a, octave_idx_type beg)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
-ComplexDiagMatrix::fill (const ComplexColumnVector& a, int beg)
+ComplexDiagMatrix::fill (const ComplexColumnVector& a, octave_idx_type beg)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
-ComplexDiagMatrix::fill (const RowVector& a, int beg)
+ComplexDiagMatrix::fill (const RowVector& a, octave_idx_type beg)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
-ComplexDiagMatrix::fill (const ComplexRowVector& a, int beg)
+ComplexDiagMatrix::fill (const ComplexRowVector& a, octave_idx_type beg)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::hermitian (void) const
 {
@@ -244,50 +244,50 @@ ComplexDiagMatrix::transpose (void) cons
   return ComplexDiagMatrix (mx_inline_dup (data (), length ()),
 			    cols (), rows ());
 }
 
 ComplexDiagMatrix
 conj (const ComplexDiagMatrix& a)
 {
   ComplexDiagMatrix retval;
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = ComplexDiagMatrix (mx_inline_conj_dup (a.data (), a_len),
 				a.rows (), a.cols ());
   return retval;
 }
 
 // resize is the destructive analog for this one
 
 ComplexMatrix
-ComplexDiagMatrix::extract (int r1, int c1, int r2, int c2) const
+ComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
-  int new_r = r2 - r1 + 1;
-  int new_c = c2 - c1 + 1;
+  octave_idx_type new_r = r2 - r1 + 1;
+  octave_idx_type new_c = c2 - c1 + 1;
 
   ComplexMatrix result (new_r, new_c);
 
-  for (int j = 0; j < new_c; j++)
-    for (int i = 0; i < new_r; i++)
+  for (octave_idx_type j = 0; j < new_c; j++)
+    for (octave_idx_type i = 0; i < new_r; i++)
       result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // extract row or column i.
 
 ComplexRowVector
-ComplexDiagMatrix::row (int i) const
+ComplexDiagMatrix::row (octave_idx_type i) const
 {
-  int r = rows ();
-  int c = cols ();
+  octave_idx_type r = rows ();
+  octave_idx_type c = cols ();
   if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector (); 
     }
 
   ComplexRowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
@@ -302,31 +302,31 @@ ComplexDiagMatrix::row (char *s) const
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return row (0);
+    return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 }
 
 ComplexColumnVector
-ComplexDiagMatrix::column (int i) const
+ComplexDiagMatrix::column (octave_idx_type i) const
 {
-  int r = rows ();
-  int c = cols ();
+  octave_idx_type r = rows ();
+  octave_idx_type c = cols ();
   if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector (); 
     }
 
   ComplexColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
@@ -341,17 +341,17 @@ ComplexDiagMatrix::column (char *s) cons
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return column (0);
+    return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector (); 
     }
 }
@@ -361,28 +361,28 @@ ComplexDiagMatrix::inverse (void) const
 {
   int info;
   return inverse (info);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (int& info) const
 {
-  int r = rows ();
-  int c = cols ();
+  octave_idx_type r = rows ();
+  octave_idx_type c = cols ();
   if (r != c)
     {
       (*current_liboctave_error_handler) ("inverse requires square matrix");
       return ComplexDiagMatrix ();
     }
 
   ComplexDiagMatrix retval (r, c);
 
   info = 0;
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     {
       if (elem (i, i) == 0.0)
 	{
 	  info = -1;
 	  return *this;
 	}
       else
 	retval.elem (i, i) = 1.0 / elem (i, i);
@@ -391,21 +391,21 @@ ComplexDiagMatrix::inverse (int& info) c
   return retval;
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator += (const DiagMatrix& a)
 {
-  int r = rows ();
-  int c = cols ();
+  octave_idx_type r = rows ();
+  octave_idx_type c = cols ();
 
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (r != a_nr || c != a_nc)
     {
       gripe_nonconformant ("operator +=", r, c, a_nr, a_nc);
       return *this;
     }
 
   if (r == 0 || c == 0)
@@ -415,36 +415,36 @@ ComplexDiagMatrix::operator += (const Di
 
   mx_inline_add2 (d, a.data (), length ());
   return *this;
 }
 
 ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, const DiagMatrix& b)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     {
       gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return ComplexDiagMatrix ();
     }
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
-  int len = a_nr < b_nc ? a_nr : b_nc;
+  octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     {
       Complex a_element = a.elem (i, i);
       double b_element = b.elem (i, i);
 
       if (a_element == 0.0 || b_element == 0.0)
         c.elem (i, i) = 0.0;
       else if (a_element == 1.0)
         c.elem (i, i) = b_element;
@@ -455,36 +455,36 @@ operator * (const ComplexDiagMatrix& a, 
     }
 
   return c;
 }
 
 ComplexDiagMatrix
 operator * (const DiagMatrix& a, const ComplexDiagMatrix& b)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     {
       gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return ComplexDiagMatrix ();
     }
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
-  int len = a_nr < b_nc ? a_nr : b_nc;
+  octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     {
       double a_element = a.elem (i, i);
       Complex b_element = b.elem (i, i);
 
       if (a_element == 0.0 || b_element == 0.0)
         c.elem (i, i) = 0.0;
       else if (a_element == 1.0)
         c.elem (i, i) = b_element;
@@ -503,46 +503,46 @@ ComplexColumnVector
 ComplexDiagMatrix::diag (void) const
 {
   return diag (0);
 }
 
 // Could be optimized...
 
 ComplexColumnVector
-ComplexDiagMatrix::diag (int k) const
+ComplexDiagMatrix::diag (octave_idx_type k) const
 {
-  int nnr = rows ();
-  int nnc = cols ();
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ComplexColumnVector d;
 
   if (nnr > 0 && nnc > 0)
     {
-      int ndiag = (nnr < nnc) ? nnr : nnc;
+      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
       d.resize (ndiag);
 
       if (k > 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i+k);
 	}
       else if ( k < 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i-k, i);
 	}
       else
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i);
 	}
     }
   else
     (*current_liboctave_error_handler)
       ("diag: requested diagonal out of range");
 
   return d;
@@ -550,19 +550,19 @@ ComplexDiagMatrix::diag (int k) const
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexDiagMatrix& a)
 {
   Complex ZERO (0.0);
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.rows (); i++)
+  for (octave_idx_type i = 0; i < a.rows (); i++)
     {
-      for (int j = 0; j < a.cols (); j++)
+      for (octave_idx_type j = 0; j < a.cols (); j++)
 	{
 	  if (i == j)
 	    os << " " /* setw (field_width) */ << a.elem (i, i);
 	  else
 	    os << " " /* setw (field_width) */ << ZERO;
 	}
       os << "\n";
     }
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -34,19 +34,19 @@ Software Foundation, 59 Temple Place - S
 
 class
 ComplexDiagMatrix : public MDiagArray2<Complex>
 {
 public:
 
   ComplexDiagMatrix (void) : MDiagArray2<Complex> () { }
 
-  ComplexDiagMatrix (int r, int c) : MDiagArray2<Complex> (r, c) { }
+  ComplexDiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<Complex> (r, c) { }
 
-  ComplexDiagMatrix (int r, int c, const Complex& val)
+  ComplexDiagMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
     : MDiagArray2<Complex> (r, c, val) { }
 
   explicit ComplexDiagMatrix (const RowVector& a)
     : MDiagArray2<Complex> (ComplexRowVector (a)) { }
 
   explicit ComplexDiagMatrix (const ComplexRowVector& a)
     : MDiagArray2<Complex> (a) { }
 
@@ -70,64 +70,64 @@ public:
       return *this;
     }
 
   bool operator == (const ComplexDiagMatrix& a) const;
   bool operator != (const ComplexDiagMatrix& a) const;
 
   ComplexDiagMatrix& fill (double val);
   ComplexDiagMatrix& fill (const Complex& val);
-  ComplexDiagMatrix& fill (double val, int beg, int end);
-  ComplexDiagMatrix& fill (const Complex& val, int beg, int end);
+  ComplexDiagMatrix& fill (double val, octave_idx_type beg, octave_idx_type end);
+  ComplexDiagMatrix& fill (const Complex& val, octave_idx_type beg, octave_idx_type end);
   ComplexDiagMatrix& fill (const ColumnVector& a);
   ComplexDiagMatrix& fill (const ComplexColumnVector& a);
   ComplexDiagMatrix& fill (const RowVector& a);
   ComplexDiagMatrix& fill (const ComplexRowVector& a);
-  ComplexDiagMatrix& fill (const ColumnVector& a, int beg);
-  ComplexDiagMatrix& fill (const ComplexColumnVector& a, int beg);
-  ComplexDiagMatrix& fill (const RowVector& a, int beg);
-  ComplexDiagMatrix& fill (const ComplexRowVector& a, int beg);
+  ComplexDiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
+  ComplexDiagMatrix& fill (const ComplexColumnVector& a, octave_idx_type beg);
+  ComplexDiagMatrix& fill (const RowVector& a, octave_idx_type beg);
+  ComplexDiagMatrix& fill (const ComplexRowVector& a, octave_idx_type beg);
 
   ComplexDiagMatrix hermitian (void) const;  // complex conjugate transpose
   ComplexDiagMatrix transpose (void) const;
 
   friend ComplexDiagMatrix conj (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
-  ComplexMatrix extract (int r1, int c1, int r2, int c2) const;
+  ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   // extract row or column i
 
-  ComplexRowVector row (int i) const;
+  ComplexRowVector row (octave_idx_type i) const;
   ComplexRowVector row (char *s) const;
 
-  ComplexColumnVector column (int i) const;
+  ComplexColumnVector column (octave_idx_type i) const;
   ComplexColumnVector column (char *s) const;
 
   ComplexDiagMatrix inverse (int& info) const;
   ComplexDiagMatrix inverse (void) const;
 
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   ComplexDiagMatrix& operator += (const DiagMatrix& a);
   ComplexDiagMatrix& operator -= (const DiagMatrix& a);
 
   // other operations
 
   ComplexColumnVector diag (void) const;
-  ComplexColumnVector diag (int k) const;
+  ComplexColumnVector diag (octave_idx_type k) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexDiagMatrix& a);
 
 private:
 
-  ComplexDiagMatrix (Complex *d, int nr, int nc)
+  ComplexDiagMatrix (Complex *d, octave_idx_type nr, octave_idx_type nc)
     : MDiagArray2<Complex> (d, nr, nc) { }
 };
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b);
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -59,170 +59,170 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, Complex*, const int&, int&,
-			     int&, double*, int&
+			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&,
+			     octave_idx_type&, double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, const int&, double*,
-			     const int&, double*, const int&, int&
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgemm, ZGEMM) (F77_CONST_CHAR_ARG_DECL,
 			   F77_CONST_CHAR_ARG_DECL,
-			   const int&, const int&, const int&,
-			   const Complex&, const Complex*, const int&,
-			   const Complex*, const int&, const Complex&,
-			   Complex*, const int&
+			   const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			   const Complex&, const Complex*, const octave_idx_type&,
+			   const Complex*, const octave_idx_type&, const Complex&,
+			   Complex*, const octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL
 			   F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zgetrf, ZGETRF) (const int&, const int&, Complex*, const int&,
-			     int*, int&);
+  F77_FUNC (zgetrf, ZGETRF) (const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&,
+			     octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgetrs, ZGETRS) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, Complex*, const int&,
-			     const int*, Complex*, const int&, int&
+			     const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&,
+			     const octave_idx_type*, Complex*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zgetri, ZGETRI) (const int&, Complex*, const int&, const int*,
-			     Complex*, const int&, int&);
+  F77_FUNC (zgetri, ZGETRI) (const octave_idx_type&, Complex*, const octave_idx_type&, const octave_idx_type*,
+			     Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgecon, ZGECON) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, Complex*, 
-			     const int&, const double&, double&, 
-			     Complex*, double*, int&
+			     const octave_idx_type&, Complex*, 
+			     const octave_idx_type&, const double&, double&, 
+			     Complex*, double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zgelss, ZGELSS) (const int&, const int&, const int&,
-			     Complex*, const int&, Complex*,
-			     const int&, double*, double&, int&,
-			     Complex*, const int&, double*, int&);
+  F77_FUNC (zgelss, ZGELSS) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     Complex*, const octave_idx_type&, Complex*,
+			     const octave_idx_type&, double*, double&, octave_idx_type&,
+			     Complex*, const octave_idx_type&, double*, octave_idx_type&);
 
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
   // implicit double precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
   F77_RET_T
-  F77_FUNC (cffti, CFFTI) (const int&, Complex*);
+  F77_FUNC (cffti, CFFTI) (const octave_idx_type&, Complex*);
 
   F77_RET_T
-  F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
+  F77_FUNC (cfftf, CFFTF) (const octave_idx_type&, Complex*, Complex*);
 
   F77_RET_T
-  F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
+  F77_FUNC (cfftb, CFFTB) (const octave_idx_type&, Complex*, Complex*);
 
   F77_RET_T
   F77_FUNC (zlartg, ZLARTG) (const Complex&, const Complex&,
 			     double&, Complex&, Complex&);
 
   F77_RET_T
   F77_FUNC (ztrsyl, ZTRSYL) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, const int&,
-			     const Complex*, const int&,
-			     const Complex*, const int&,
-			     const Complex*, const int&, double&, int&
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     const Complex*, const octave_idx_type&,
+			     const Complex*, const octave_idx_type&,
+			     const Complex*, const octave_idx_type&, double&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xzlange, XZLANGE) (F77_CONST_CHAR_ARG_DECL,
-			       const int&, const int&, const Complex*,
-			       const int&, double*, double&
+			       const octave_idx_type&, const octave_idx_type&, const Complex*,
+			       const octave_idx_type&, double*, double&
 			       F77_CHAR_ARG_LEN_DECL);
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 // Complex Matrix class
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
   : MArray2<Complex> (a.rows (), a.cols ())
 {
-  for (int j = 0; j < cols (); j++)
-    for (int i = 0; i < rows (); i++)
+  for (octave_idx_type j = 0; j < cols (); j++)
+    for (octave_idx_type i = 0; i < rows (); i++)
       elem (i, j) = a.elem (i, j);
 }
 
 ComplexMatrix::ComplexMatrix (const RowVector& rv)
   : MArray2<Complex> (1, rv.length (), 0.0)
 {
-  for (int i = 0; i < rv.length (); i++)
+  for (octave_idx_type i = 0; i < rv.length (); i++)
     elem (0, i) = rv.elem (i);
 }
 
 ComplexMatrix::ComplexMatrix (const ColumnVector& cv)
   : MArray2<Complex> (cv.length (), 1, 0.0)
 {
-  for (int i = 0; i < cv.length (); i++)
+  for (octave_idx_type i = 0; i < cv.length (); i++)
     elem (i, 0) = cv.elem (i);
 }
 
 ComplexMatrix::ComplexMatrix (const DiagMatrix& a)
   : MArray2<Complex> (a.rows (), a.cols (), 0.0)
 {
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexRowVector& rv)
   : MArray2<Complex> (1, rv.length (), 0.0)
 {
-  for (int i = 0; i < rv.length (); i++)
+  for (octave_idx_type i = 0; i < rv.length (); i++)
     elem (0, i) = rv.elem (i);
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexColumnVector& cv)
   : MArray2<Complex> (cv.length (), 1, 0.0)
 {
-  for (int i = 0; i < cv.length (); i++)
+  for (octave_idx_type i = 0; i < cv.length (); i++)
     elem (i, 0) = cv.elem (i);
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexDiagMatrix& a)
   : MArray2<Complex> (a.rows (), a.cols (), 0.0)
 {
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // XXX FIXME XXX -- could we use a templated mixed-type copy function
 // here?
 
 ComplexMatrix::ComplexMatrix (const boolMatrix& a)
   : MArray2<Complex> (a.rows (), a.cols (), 0.0)
 {
-  for (int i = 0; i < a.rows (); i++)
-    for (int j = 0; j < a.cols (); j++)
+  for (octave_idx_type i = 0; i < a.rows (); i++)
+    for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = a.elem (i, j);
 }
 
 ComplexMatrix::ComplexMatrix (const charMatrix& a)
   : MArray2<Complex> (a.rows (), a.cols (), 0.0)
 {
-  for (int i = 0; i < a.rows (); i++)
-    for (int j = 0; j < a.cols (); j++)
+  for (octave_idx_type i = 0; i < a.rows (); i++)
+    for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = a.elem (i, j);
 }
 
 bool
 ComplexMatrix::operator == (const ComplexMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return false;
@@ -234,801 +234,801 @@ bool
 ComplexMatrix::operator != (const ComplexMatrix& a) const
 {
   return !(*this == a);
 }
 
 bool
 ComplexMatrix::is_hermitian (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (is_square () && nr > 0)
     {
-      for (int i = 0; i < nr; i++)
-	for (int j = i; j < nc; j++)
+      for (octave_idx_type i = 0; i < nr; i++)
+	for (octave_idx_type j = i; j < nc; j++)
 	  if (elem (i, j) != conj (elem (j, i)))
 	    return false;
 
       return true;
     }
 
   return false;
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexMatrix&
-ComplexMatrix::insert (const Matrix& a, int r, int c)
+ComplexMatrix::insert (const Matrix& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_nr >0 && a_nc > 0)
     {
       make_unique ();
 
-      for (int j = 0; j < a_nc; j++)
-	for (int i = 0; i < a_nr; i++)
+      for (octave_idx_type j = 0; j < a_nc; j++)
+	for (octave_idx_type i = 0; i < a_nr; i++)
 	  xelem (r+i, c+j) = a.elem (i, j);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const RowVector& a, int r, int c)
+ComplexMatrix::insert (const RowVector& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ColumnVector& a, int r, int c)
+ComplexMatrix::insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const DiagMatrix& a, int r, int c)
+ComplexMatrix::insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ComplexMatrix& a, int r, int c)
+ComplexMatrix::insert (const ComplexMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   Array2<Complex>::insert (a, r, c);
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ComplexRowVector& a, int r, int c)
+ComplexMatrix::insert (const ComplexRowVector& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ComplexColumnVector& a, int r, int c)
+ComplexMatrix::insert (const ComplexColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ComplexDiagMatrix& a, int r, int c)
+ComplexMatrix::insert (const ComplexDiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (double val)
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (const Complex& val)
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::fill (double val, int r1, int c1, int r2, int c2)
+ComplexMatrix::fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
-      for (int j = c1; j <= c2; j++)
-	for (int i = r1; i <= r2; i++)
+      for (octave_idx_type j = c1; j <= c2; j++)
+	for (octave_idx_type i = r1; i <= r2; i++)
 	  xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::fill (const Complex& val, int r1, int c1, int r2, int c2)
+ComplexMatrix::fill (const Complex& val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >=c1)
     {
       make_unique ();
 
-      for (int j = c1; j <= c2; j++)
-	for (int i = r1; i <= r2; i++)
+      for (octave_idx_type j = c1; j <= c2; j++)
+	for (octave_idx_type i = r1; i <= r2; i++)
 	  xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const Matrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const RowVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.length ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ColumnVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.length ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const DiagMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexRowVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.length ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexColumnVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.length ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexDiagMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const Matrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const RowVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ColumnVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const DiagMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexRowVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexColumnVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexDiagMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return *this;
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::hermitian (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   ComplexMatrix result;
   if (length () > 0)
     {
       result.resize (nc, nr);
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  result.elem (j, i) = conj (elem (i, j));
     }
   return result;
 }
 
 ComplexMatrix
 conj (const ComplexMatrix& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   ComplexMatrix retval;
   if (a_len > 0)
     retval = ComplexMatrix (mx_inline_conj_dup (a.data (), a_len),
 			    a.rows (), a.cols ());
   return retval;
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexMatrix
-ComplexMatrix::extract (int r1, int c1, int r2, int c2) const
+ComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
-
-  int new_r = r2 - r1 + 1;
-  int new_c = c2 - c1 + 1;
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
+
+  octave_idx_type new_r = r2 - r1 + 1;
+  octave_idx_type new_c = c2 - c1 + 1;
 
   ComplexMatrix result (new_r, new_c);
 
-  for (int j = 0; j < new_c; j++)
-    for (int i = 0; i < new_r; i++)
+  for (octave_idx_type j = 0; j < new_c; j++)
+    for (octave_idx_type i = 0; i < new_r; i++)
       result.xelem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 ComplexMatrix
-ComplexMatrix::extract_n (int r1, int c1, int nr, int nc) const
+ComplexMatrix::extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const
 {
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       result.xelem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // extract row or column i.
 
 ComplexRowVector
-ComplexMatrix::row (int i) const
+ComplexMatrix::row (octave_idx_type i) const
 {
-  int nc = cols ();
+  octave_idx_type nc = cols ();
   if (i < 0 || i >= rows ())
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 
   ComplexRowVector retval (nc);
-  for (int j = 0; j < cols (); j++)
+  for (octave_idx_type j = 0; j < cols (); j++)
     retval.xelem (j) = elem (i, j);
 
   return retval;
 }
 
 ComplexRowVector
 ComplexMatrix::row (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return row (0);
+    return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 }
 
 ComplexColumnVector
-ComplexMatrix::column (int i) const
+ComplexMatrix::column (octave_idx_type i) const
 {
-  int nr = rows ();
+  octave_idx_type nr = rows ();
   if (i < 0 || i >= cols ())
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector ();
     }
 
   ComplexColumnVector retval (nr);
-  for (int j = 0; j < nr; j++)
+  for (octave_idx_type j = 0; j < nr; j++)
     retval.xelem (j) = elem (j, i);
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::column (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return column (0);
+    return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ComplexColumnVector ();
     }
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (void) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return inverse (info, rcond, 0, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::inverse (int& info) const
+ComplexMatrix::inverse (octave_idx_type& info) const
 {
   double rcond;
   return inverse (info, rcond, 0, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::inverse (int& info, double& rcond, int force, 
+ComplexMatrix::inverse (octave_idx_type& info, double& rcond, int force, 
 			int calc_cond) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<int> ipvt (nr);
-      int *pipvt = ipvt.fortran_vec ();
+      Array<octave_idx_type> ipvt (nr);
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       Complex *tmp_data = retval.fortran_vec ();
 
       Array<Complex> z(1);
-      int lwork = -1;
+      octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt, 
 				 z.fortran_vec (), lwork, info));
 
       if (f77_exception_encountered) 
 	{
 	  (*current_liboctave_error_handler)
 	    ("unrecoverable error in zgetri");
 	  return retval;
 	}
 
-      lwork = static_cast<int> (STD_OCTAVE::real(z(0)));
+      lwork = static_cast<octave_idx_type> (STD_OCTAVE::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
-	anorm  = retval.abs().sum().row(0).max();
+	anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
       else
 	{
 	  // Throw-away extra info LAPACK gives so as to not change output.
 	  rcond = 0.0;
 	  if (info != 0) 
 	    info = -1;
 	  else if (calc_cond) 
 	    {
 	      // Now calculate the condition number for non-singular matrix.
-	      int zgecon_info = 0;
+	      octave_idx_type zgecon_info = 0;
 	      char job = '1';
 	      Array<double> rz (2 * nc);
 	      double *prz = rz.fortran_vec ();
 	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					 nc, tmp_data, nr, anorm, 
 					 rcond, pz, prz, zgecon_info
 					 F77_CHAR_ARG_LEN (1)));
 
@@ -1039,17 +1039,17 @@ ComplexMatrix::inverse (int& info, doubl
 	      if (zgecon_info != 0) 
 		info = -1;
 	    }
 
 	  if (info == -1 && ! force)
 	    retval = *this;  // Restore contents.
 	  else
 	    {
-	      int zgetri_info = 0;
+	      octave_idx_type zgetri_info = 0;
 
 	      F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
 					 pz, lwork, zgetri_info));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler)
 		  ("unrecoverable error in zgetri");
 
@@ -1070,19 +1070,19 @@ ComplexMatrix::pseudo_inverse (double to
   ComplexSVD result (*this, SVD::economy);
 
   DiagMatrix S = result.singular_values ();
   ComplexMatrix U = result.left_singular_matrix ();
   ComplexMatrix V = result.right_singular_matrix ();
 
   ColumnVector sigma = S.diag ();
 
-  int r = sigma.length () - 1;
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type r = sigma.length () - 1;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
 	tol = nr * sigma.elem (0) * DBL_EPSILON;
       else
 	tol = nc * sigma.elem (0) * DBL_EPSILON;
     }
@@ -1193,128 +1193,128 @@ ComplexMatrix::ifourier2d (void) const
 
 #else
 
 ComplexMatrix
 ComplexMatrix::fourier (void) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
-
-  int npts, nsamples;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  int nn = 4*npts+15;
+  octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
-
-  int npts, nsamples;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  int nn = 4*npts+15;
+  octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
       F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
-  for (int j = 0; j < npts*nsamples; j++)
+  for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fourier2d (void) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
-
-  int npts, nsamples;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  int nn = 4*npts+15;
+  octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
@@ -1323,147 +1323,147 @@ ComplexMatrix::fourier2d (void) const
   wsave.resize (nn);
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (npts);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
-      for (int i = 0; i < npts; i++)
+      for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-      for (int i = 0; i < npts; i++)
+      for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier2d (void) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
-
-  int npts, nsamples;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  int nn = 4*npts+15;
+  octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
       F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
-  for (int j = 0; j < npts*nsamples; j++)
+  for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn);
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (npts);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
-      for (int i = 0; i < npts; i++)
+      for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-      for (int i = 0; i < npts; i++)
+      for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
 
   return retval;
 }
 
 #endif
 
 ComplexDET
 ComplexMatrix::determinant (void) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 ComplexDET
-ComplexMatrix::determinant (int& info) const
+ComplexMatrix::determinant (octave_idx_type& info) const
 {
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 ComplexDET
-ComplexMatrix::determinant (int& info, double& rcond, int calc_cond) const
+ComplexMatrix::determinant (octave_idx_type& info, double& rcond, int calc_cond) const
 {
   ComplexDET retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0)
     {
       Complex d[2];
       d[0] = 1.0;
       d[1] = 0.0;
       retval = ComplexDET (d);
     }
   else
     {
-      Array<int> ipvt (nr);
-      int *pipvt = ipvt.fortran_vec ();
+      Array<octave_idx_type> ipvt (nr);
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
-	anorm = atmp.abs().sum().row(0).max();
+	anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nr, nc, tmp_data, nr, pipvt, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
       else
 	{
 	  // Throw-away extra info LAPACK gives so as to not change output.
@@ -1497,17 +1497,17 @@ ComplexMatrix::determinant (int& info, d
 	      if (info != 0) 
 		{
 		  info = -1;
 		  retval = ComplexDET ();
 		} 
 	      else 
 		{
 		  Complex d[2] = { 1., 0.};
-		  for (int i=0; i<nc; i++) 
+		  for (octave_idx_type i=0; i<nc; i++) 
 		    {
 		      if (ipvt(i) != (i+1)) d[0] = -d[0];
 		      d[0] = d[0] * atmp(i,i);
 		      if (d[0] == 0.) break;
 		      while (STD_OCTAVE::abs(d[0]) < 1.) 
 			{
 			  d[0] = 10. * d[0];
 			  d[1] = d[1] - 1.0;
@@ -1525,92 +1525,92 @@ ComplexMatrix::determinant (int& info, d
     }
   
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const Matrix& b, int& info) const
+ComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const Matrix& b, int& info, double& rcond) const
+ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const Matrix& b, int& info, double& rcond,
+ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcond,
 		      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcond, sing_handler);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const ComplexMatrix& b, int& info) const
+ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const ComplexMatrix& b, int& info, double& rcond) const
+ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const ComplexMatrix& b, int& info, double& rcond,
+ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
 		      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of linear equations");
   else
     {
       info = 0;
 
-      Array<int> ipvt (nr);
-      int *pipvt = ipvt.fortran_vec ();
+      Array<octave_idx_type> ipvt (nr);
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Array<Complex> z (2 * nc);
       Complex *pz = z.fortran_vec ();
       Array<double> rz (2 * nc);
       double *prz = rz.fortran_vec ();
 
       // Calculate the norm of the matrix, for later use.
-      double anorm = atmp.abs().sum().row(0).max();
+      double anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
       else
 	{
 	  // Throw-away extra info LAPACK gives so as to not change output.
@@ -1655,17 +1655,17 @@ ComplexMatrix::solve (const ComplexMatri
 		      ("matrix singular to machine precision, rcond = %g",
 		       rcond);
 		}
 	      else
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nc = b.cols ();
 
 		  job = 'N';
 		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, b_nc, tmp_data, nr,
 					     pipvt, result, b.rows(), info
 					     F77_CHAR_ARG_LEN (1))); 
 
 		  if (f77_exception_encountered)
@@ -1677,93 +1677,93 @@ ComplexMatrix::solve (const ComplexMatri
     }
   
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (ComplexColumnVector (b), info, rcond, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, int& info) const
+ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (ComplexColumnVector (b), info, rcond, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, int& info, double& rcond) const
+ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const
 {
   return solve (ComplexColumnVector (b), info, rcond, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, int& info, double& rcond,
+ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 		      solve_singularity_handler sing_handler) const
 {
   return solve (ComplexColumnVector (b), info, rcond, sing_handler);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ComplexColumnVector& b, int& info) const
+ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ComplexColumnVector& b, int& info,
+ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
 		      double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ComplexColumnVector& b, int& info,
+ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
 		      double& rcond,
 		      solve_singularity_handler sing_handler) const
 {
   ComplexColumnVector retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.length ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of linear equations");
   else
     {
       info = 0;
 
-      Array<int> ipvt (nr);
-      int *pipvt = ipvt.fortran_vec ();
+      Array<octave_idx_type> ipvt (nr);
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Array<Complex> z (2 * nc);
       Complex *pz = z.fortran_vec ();
       Array<double> rz (2 * nc);
       double *prz = rz.fortran_vec ();
 
       // Calculate the norm of the matrix, for later use.
-      double anorm = atmp.abs().sum().row(0).max();
+      double anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
       else
 	{
 	  // Throw-away extra info LAPACK gives so as to not change output.
@@ -1828,203 +1828,203 @@ ComplexMatrix::solve (const ComplexColum
 	}
     }
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (ComplexMatrix (b), info, rank);
 }
 
 ComplexMatrix
-ComplexMatrix::lssolve (const Matrix& b, int& info) const
+ComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (ComplexMatrix (b), info, rank);
 }
 
 ComplexMatrix
-ComplexMatrix::lssolve (const Matrix& b, int& info, int& rank) const
+ComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   return lssolve (ComplexMatrix (b), info, rank);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
-ComplexMatrix::lssolve (const ComplexMatrix& b, int& info) const
+ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
-ComplexMatrix::lssolve (const ComplexMatrix& b, int& info, int& rank) const
+ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   ComplexMatrix retval;
 
-  int nrhs = b.cols ();
-
-  int m = rows ();
-  int n = cols ();
+  octave_idx_type nrhs = b.cols ();
+
+  octave_idx_type m = rows ();
+  octave_idx_type n = cols ();
 
   if (m == 0 || n == 0 || m != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
-      int nrr = m > n ? m : n;
+      octave_idx_type nrr = m > n ? m : n;
       ComplexMatrix result (nrr, nrhs);
 
-      for (int j = 0; j < nrhs; j++)
-	for (int i = 0; i < m; i++)
+      for (octave_idx_type j = 0; j < nrhs; j++)
+	for (octave_idx_type i = 0; i < m; i++)
 	  result.elem (i, j) = b.elem (i, j);
 
       Complex *presult = result.fortran_vec ();
 
-      int len_s = m < n ? m : n;
+      octave_idx_type len_s = m < n ? m : n;
       Array<double> s (len_s);
       double *ps = s.fortran_vec ();
 
       double rcond = -1.0;
 
-      int lrwork = (5 * (m < n ? m : n)) - 4;
+      octave_idx_type lrwork = (5 * (m < n ? m : n)) - 4;
       lrwork = lrwork > 1 ? lrwork : 1;
       Array<double> rwork (lrwork);
       double *prwork = rwork.fortran_vec ();
 
       // Ask ZGELSS what the dimension of WORK should be.
 
-      int lwork = -1;
+      octave_idx_type lwork = -1;
 
       Array<Complex> work (1);
 
       F77_XFCN (zgelss, ZGELSS, (m, n, nrhs, tmp_data, m, presult,
 				 nrr, ps, rcond, rank,
 				 work.fortran_vec (), lwork, prwork,
 				 info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgelss");
       else
 	{
-	  lwork = static_cast<int> (STD_OCTAVE::real (work(0)));
+	  lwork = static_cast<octave_idx_type> (STD_OCTAVE::real (work(0)));
 	  work.resize (lwork);
 
 	  F77_XFCN (zgelss, ZGELSS, (m, n, nrhs, tmp_data, m, presult,
 				     nrr, ps, rcond, rank,
 				     work.fortran_vec (), lwork,
 				     prwork, info));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zgelss");
 	  else
 	    {
 	      retval.resize (n, nrhs);
-	      for (int j = 0; j < nrhs; j++)
-		for (int i = 0; i < n; i++)
+	      for (octave_idx_type j = 0; j < nrhs; j++)
+		for (octave_idx_type i = 0; i < n; i++)
 		  retval.elem (i, j) = result.elem (i, j);
 	    }
 	}
     }
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (ComplexColumnVector (b), info, rank);
 }
 
 ComplexColumnVector
-ComplexMatrix::lssolve (const ColumnVector& b, int& info) const
+ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (ComplexColumnVector (b), info, rank);
 }
 
 ComplexColumnVector
-ComplexMatrix::lssolve (const ColumnVector& b, int& info, int& rank) const
+ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   return lssolve (ComplexColumnVector (b), info, rank);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
-ComplexMatrix::lssolve (const ComplexColumnVector& b, int& info) const
+ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
-ComplexMatrix::lssolve (const ComplexColumnVector& b, int& info,
-			int& rank) const
+ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
+			octave_idx_type& rank) const
 {
   ComplexColumnVector retval;
 
-  int nrhs = 1;
-
-  int m = rows ();
-  int n = cols ();
+  octave_idx_type nrhs = 1;
+
+  octave_idx_type m = rows ();
+  octave_idx_type n = cols ();
 
   if (m == 0 || n == 0 || m != b.length ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of least squares problem");
   else
     {
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
-      int nrr = m > n ? m : n;
+      octave_idx_type nrr = m > n ? m : n;
       ComplexColumnVector result (nrr);
 
-      for (int i = 0; i < m; i++)
+      for (octave_idx_type i = 0; i < m; i++)
 	result.elem (i) = b.elem (i);
 
       Complex *presult = result.fortran_vec ();
 
-      int len_s = m < n ? m : n;
+      octave_idx_type len_s = m < n ? m : n;
       Array<double> s (len_s);
       double *ps = s.fortran_vec ();
 
       double rcond = -1.0;
 
-      int lrwork = (5 * (m < n ? m : n)) - 4;
+      octave_idx_type lrwork = (5 * (m < n ? m : n)) - 4;
       lrwork = lrwork > 1 ? lrwork : 1;
       Array<double> rwork (lrwork);
       double *prwork = rwork.fortran_vec ();
 
       // Ask ZGELSS what the dimension of WORK should be.
 
-      int lwork = -1;
+      octave_idx_type lwork = -1;
 
       Array<Complex> work (1);
 
       F77_XFCN (zgelss, ZGELSS, (m, n, nrhs, tmp_data, m, presult,
 				 nrr, ps, rcond, rank,
 				 work.fortran_vec (), lwork, prwork,
 				 info));
 
@@ -2041,17 +2041,17 @@ ComplexMatrix::lssolve (const ComplexCol
 				     prwork, info));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in zgelss");
 	  else
 	    {
 	      retval.resize (n);
-	      for (int i = 0; i < n; i++)
+	      for (octave_idx_type i = 0; i < n; i++)
 		retval.elem (i) = result.elem (i);
 	    }
 	}
     }
 
   return retval;
 }
 
@@ -2071,41 +2071,41 @@ static double padec [] =
 
 ComplexMatrix
 ComplexMatrix::expm (void) const
 {
   ComplexMatrix retval;
 
   ComplexMatrix m = *this;
 
-  int nc = columns ();
+  octave_idx_type nc = columns ();
 
   // Preconditioning step 1: trace normalization to reduce dynamic
   // range of poles, but avoid making stable eigenvalues unstable.
 
   // trace shift value
   Complex trshift = 0.0;
 
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     trshift += m.elem (i, i);
 
   trshift /= nc;
 
   if (trshift.real () < 0.0)
     trshift = trshift.imag ();
 
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     m.elem (i, i) -= trshift;
 
   // Preconditioning step 2: eigenvalue balancing.
   // code follows development in AEPBAL
 
   Complex *mp = m.fortran_vec ();
 
-  int info, ilo, ihi,ilos,ihis;
+  octave_idx_type info, ilo, ihi,ilos,ihis;
   Array<double> dpermute (nc);
   Array<double> dscale (nc);
 
   // XXX FIXME XXX -- should pass job as a parameter in expm
 
   // Permute first
   char job = 'P';
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
@@ -2154,41 +2154,41 @@ ComplexMatrix::expm (void) const
   // Check whether we need to square at all.
 
   if (sqpow < 0)
     sqpow = 0;
 
   if (sqpow > 0)
     {
       double scale_factor = 1.0;
-      for (int i = 0; i < sqpow; i++)
+      for (octave_idx_type i = 0; i < sqpow; i++)
 	scale_factor *= 2.0;
 
       m = m / scale_factor;
     }
 
   // npp, dpp: pade' approx polynomial matrices.
 
   ComplexMatrix npp (nc, nc, 0.0);
   ComplexMatrix dpp = npp;
 
   // Now powers a^8 ... a^1.
 
   int minus_one_j = -1;
-  for (int j = 7; j >= 0; j--)
+  for (octave_idx_type j = 7; j >= 0; j--)
     {
       npp = m * npp + m * padec[j];
       dpp = m * dpp + m * (minus_one_j * padec[j]);
       minus_one_j *= -1;
     }
 
   // Zero power.
 
   dpp = -dpp;
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
       npp.elem (j, j) += 1.0;
       dpp.elem (j, j) += 1.0;
     }
 
   // Compute pade approximation = inverse (dpp) * npp.
 
   retval = dpp.solve (npp);
@@ -2200,55 +2200,55 @@ ComplexMatrix::expm (void) const
       retval = retval * retval;
       sqpow--;
     }
 
   // Reverse preconditioning step 2: inverse balancing.
   // Done in two steps: inverse scaling, then inverse permutation
 
   // inverse scaling (diagonal transformation)
-  for (int i = 0; i < nc; i++)
-    for (int j = 0; j < nc; j++)
+  for (octave_idx_type i = 0; i < nc; i++)
+    for (octave_idx_type j = 0; j < nc; j++)
        retval(i,j) *= dscale(i) / dscale(j);
 
   OCTAVE_QUIT;
 
   // construct balancing permutation vector
   Array<int> iperm (nc);
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     iperm(i) = i;  // initialize to identity permutation
 
   // leading permutations in forward order
-  for (int i = 0; i < (ilo-1); i++)
+  for (octave_idx_type i = 0; i < (ilo-1); i++)
     {
-      int swapidx = static_cast<int> (dpermute(i)) - 1;
-      int tmp = iperm(i);
+      octave_idx_type swapidx = static_cast<int> (dpermute(i)) - 1;
+      octave_idx_type tmp = iperm(i);
       iperm(i) = iperm(swapidx);
       iperm(swapidx) = tmp;
     }
 
   // trailing permutations must be done in reverse order
-  for (int i = nc - 1; i >= ihi; i--)
+  for (octave_idx_type i = nc - 1; i >= ihi; i--)
     {
-      int swapidx = static_cast<int> (dpermute(i)) - 1;
-      int tmp = iperm(i);
+      octave_idx_type swapidx = static_cast<int> (dpermute(i)) - 1;
+      octave_idx_type tmp = iperm(i);
       iperm(i) = iperm(swapidx);
       iperm(swapidx) = tmp;
     }
 
   // construct inverse balancing permutation vector
   Array<int> invpvec (nc);
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     invpvec(iperm(i)) = i;     // Thanks to R. A. Lippert for this method
 
   OCTAVE_QUIT;
 
   ComplexMatrix tmpMat = retval;
-  for (int i = 0; i < nc; i++)
-    for (int j = 0; j < nc; j++)
+  for (octave_idx_type i = 0; i < nc; i++)
+    for (octave_idx_type j = 0; j < nc; j++)
       retval(i,j) = tmpMat(invpvec(i),invpvec(j));
 
   // Reverse preconditioning step 1: fix trace normalization.
 
   return exp (trshift) * retval;
 }
 
 // column vector by row vector -> matrix operations
@@ -2267,21 +2267,21 @@ operator * (const ComplexColumnVector& a
   return a * tmp;
 }
 
 ComplexMatrix
 operator * (const ComplexColumnVector& v, const ComplexRowVector& a)
 {
   ComplexMatrix retval;
 
-  int len = v.length ();
+  octave_idx_type len = v.length ();
 
   if (len != 0)
     {
-      int a_len = a.length ();
+      octave_idx_type a_len = a.length ();
 
       retval.resize (len, a_len);
       Complex *c = retval.fortran_vec ();
 
       F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
 			       F77_CONST_CHAR_ARG2 ("N", 1),
 			       len, a_len, 1, 1.0, v.data (), len,
 			       a.data (), 1, 0.0, c, len
@@ -2296,107 +2296,107 @@ operator * (const ComplexColumnVector& v
   return retval;
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 ComplexMatrix&
 ComplexMatrix::operator += (const DiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  int a_nr = rows ();
-  int a_nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type a_nr = rows ();
+  octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
       gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator -= (const DiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  int a_nr = rows ();
-  int a_nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type a_nr = rows ();
+  octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
       gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator += (const ComplexDiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  int a_nr = rows ();
-  int a_nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type a_nr = rows ();
+  octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
       gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator -= (const ComplexDiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  int a_nr = rows ();
-  int a_nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type a_nr = rows ();
+  octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
       gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // matrix by matrix -> matrix operations
 
 ComplexMatrix&
 ComplexMatrix::operator += (const Matrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
       gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
@@ -2406,21 +2406,21 @@ ComplexMatrix::operator += (const Matrix
 
   mx_inline_add2 (d, a.data (), length ());
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator -= (const Matrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
       gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
@@ -2432,23 +2432,23 @@ ComplexMatrix::operator -= (const Matrix
   return *this;
 }
 
 // unary operations
 
 boolMatrix
 ComplexMatrix::operator ! (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   boolMatrix b (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       b.elem (i, j) = elem (i, j) == 0.0;
 
   return b;
 }
 
 // other operations
 
 ComplexMatrix
@@ -2456,82 +2456,82 @@ ComplexMatrix::map (c_c_Mapper f) const
 {
   ComplexMatrix b (*this);
   return b.apply (f);
 }
 
 Matrix
 ComplexMatrix::map (d_c_Mapper f) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (elem(i,j));
 
   return retval;
 }
 
 boolMatrix
 ComplexMatrix::map (b_c_Mapper f) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   boolMatrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (elem(i,j));
 
   return retval;
 }
 
 ComplexMatrix&
 ComplexMatrix::apply (c_c_Mapper f)
 {
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     d[i] = f (d[i]);
 
   return *this;
 }
 
 bool
 ComplexMatrix::any_element_is_inf_or_nan (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	Complex val = elem (i, j);
 	if (xisinf (val) || xisnan (val))
 	  return true;
       }
 
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
 ComplexMatrix::all_elements_are_real (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  for (int j = 0; j < nc; j++)
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  double ip = STD_OCTAVE::imag (elem (i, j));
 
 	  if (ip != 0.0 || lo_ieee_signbit (ip))
 	    return false;
 	}
     }
 
@@ -2540,18 +2540,18 @@ ComplexMatrix::all_elements_are_real (vo
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
 // imaginary) values and return them in MAX_VAL and MIN_VAL. 
 
 bool
 ComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       Complex val = elem (0, 0);
 
       double r_val = STD_OCTAVE::real (val);
       double i_val = STD_OCTAVE::imag (val);
 
@@ -2562,18 +2562,18 @@ ComplexMatrix::all_integers (double& max
 	max_val = i_val;
 
       if (i_val < max_val)
 	min_val = i_val;
     }
   else
     return false;
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	Complex val = elem (i, j);
 
 	double r_val = STD_OCTAVE::real (val);
 	double i_val = STD_OCTAVE::imag (val);
 
 	if (r_val > max_val)
 	  max_val = r_val;
@@ -2592,21 +2592,21 @@ ComplexMatrix::all_integers (double& max
       }
 
   return true;
 }
 
 bool
 ComplexMatrix::too_large_for_float (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	Complex val = elem (i, j);
 
 	double r_val = STD_OCTAVE::real (val);
 	double i_val = STD_OCTAVE::imag (val);
 
 	if (r_val > FLT_MAX
 	    || i_val > FLT_MAX
@@ -2671,155 +2671,155 @@ ComplexMatrix::sumsq (int dim) const
   MX_BASE_REDUCTION_OP (ComplexMatrix, ROW_EXPR, COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 Matrix ComplexMatrix::abs (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval (i, j) = STD_OCTAVE::abs (elem (i, j));
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::diag (void) const
 {
   return diag (0);
 }
 
 ComplexColumnVector
-ComplexMatrix::diag (int k) const
+ComplexMatrix::diag (octave_idx_type k) const
 {
-  int nnr = rows ();
-  int nnc = cols ();
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ComplexColumnVector d;
 
   if (nnr > 0 && nnc > 0)
     {
-      int ndiag = (nnr < nnc) ? nnr : nnc;
+      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
       d.resize (ndiag);
 
       if (k > 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i+k);
 	}
       else if (k < 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i-k, i);
 	}
       else
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i);
 	}
     }
   else
     (*current_liboctave_error_handler)
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
 bool
-ComplexMatrix::row_is_real_only (int i) const
+ComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
-  int nc = columns ();
-
-  for (int j = 0; j < nc; j++)
+  octave_idx_type nc = columns ();
+
+  for (octave_idx_type j = 0; j < nc; j++)
     {
       if (STD_OCTAVE::imag (elem (i, j)) != 0.0)
 	{
 	  retval = false;
 	  break;
 	}
     }
 
   return retval;	      
 }
 
 bool
-ComplexMatrix::column_is_real_only (int j) const
+ComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
-  int nr = rows ();
-
-  for (int i = 0; i < nr; i++)
+  octave_idx_type nr = rows ();
+
+  for (octave_idx_type i = 0; i < nr; i++)
     {
       if (STD_OCTAVE::imag (elem (i, j)) != 0.0)
 	{
 	  retval = false;
 	  break;
 	}
     }
 
   return retval;	      
 }
 
 ComplexColumnVector
 ComplexMatrix::row_min (void) const
 {
-  Array<int> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
 
 ComplexColumnVector
-ComplexMatrix::row_min (Array<int>& idx_arg) const
+ComplexMatrix::row_min (Array<octave_idx_type>& idx_arg) const
 {
   ComplexColumnVector result;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
         {
 	  bool real_only = row_is_real_only (i);
 
-	  int idx_j;
+	  octave_idx_type idx_j;
 
 	  Complex tmp_min;
 
 	  double abs_min = octave_NaN;
 
 	  for (idx_j = 0; idx_j < nc; idx_j++)
 	    {
 	      tmp_min = elem (i, idx_j);
 
 	      if (! octave_is_NaN_or_NA (tmp_min))
 		{
 		  abs_min = real_only ? STD_OCTAVE::real (tmp_min) : STD_OCTAVE::abs (tmp_min);
 		  break;
 		}
 	    }
 
-	  for (int j = idx_j+1; j < nc; j++)
+	  for (octave_idx_type j = idx_j+1; j < nc; j++)
 	    {
 	      Complex tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
 	      double abs_tmp = real_only ? STD_OCTAVE::real (tmp) : STD_OCTAVE::abs (tmp);
 
@@ -2845,55 +2845,55 @@ ComplexMatrix::row_min (Array<int>& idx_
     }
 
   return result;
 }
 
 ComplexColumnVector
 ComplexMatrix::row_max (void) const
 {
-  Array<int> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return row_max (dummy_idx);
 }
 
 ComplexColumnVector
-ComplexMatrix::row_max (Array<int>& idx_arg) const
+ComplexMatrix::row_max (Array<octave_idx_type>& idx_arg) const
 {
   ComplexColumnVector result;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
         {
 	  bool real_only = row_is_real_only (i);
 
-	  int idx_j;
+	  octave_idx_type idx_j;
 
 	  Complex tmp_max;
 
 	  double abs_max = octave_NaN;
 
 	  for (idx_j = 0; idx_j < nc; idx_j++)
 	    {
 	      tmp_max = elem (i, idx_j);
 
 	      if (! octave_is_NaN_or_NA (tmp_max))
 		{
 		  abs_max = real_only ? STD_OCTAVE::real (tmp_max) : STD_OCTAVE::abs (tmp_max);
 		  break;
 		}
 	    }
 
-	  for (int j = idx_j+1; j < nc; j++)
+	  for (octave_idx_type j = idx_j+1; j < nc; j++)
 	    {
 	      Complex tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
 	      double abs_tmp = real_only ? STD_OCTAVE::real (tmp) : STD_OCTAVE::abs (tmp);
 
@@ -2919,55 +2919,55 @@ ComplexMatrix::row_max (Array<int>& idx_
     }
 
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_min (void) const
 {
-  Array<int> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return column_min (dummy_idx);
 }
 
 ComplexRowVector
-ComplexMatrix::column_min (Array<int>& idx_arg) const
+ComplexMatrix::column_min (Array<octave_idx_type>& idx_arg) const
 {
   ComplexRowVector result;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
         {
 	  bool real_only = column_is_real_only (j);
 
-	  int idx_i;
+	  octave_idx_type idx_i;
 
 	  Complex tmp_min;
 
 	  double abs_min = octave_NaN;
 
 	  for (idx_i = 0; idx_i < nr; idx_i++)
 	    {
 	      tmp_min = elem (idx_i, j);
 
 	      if (! octave_is_NaN_or_NA (tmp_min))
 		{
 		  abs_min = real_only ? STD_OCTAVE::real (tmp_min) : STD_OCTAVE::abs (tmp_min);
 		  break;
 		}
 	    }
 
-	  for (int i = idx_i+1; i < nr; i++)
+	  for (octave_idx_type i = idx_i+1; i < nr; i++)
 	    {
 	      Complex tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
 	      double abs_tmp = real_only ? STD_OCTAVE::real (tmp) : STD_OCTAVE::abs (tmp);
 
@@ -2993,55 +2993,55 @@ ComplexMatrix::column_min (Array<int>& i
     }
 
   return result;
 }
 
 ComplexRowVector
 ComplexMatrix::column_max (void) const
 {
-  Array<int> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return column_max (dummy_idx);
 }
 
 ComplexRowVector
-ComplexMatrix::column_max (Array<int>& idx_arg) const
+ComplexMatrix::column_max (Array<octave_idx_type>& idx_arg) const
 {
   ComplexRowVector result;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
         {
 	  bool real_only = column_is_real_only (j);
 
-	  int idx_i;
+	  octave_idx_type idx_i;
 
 	  Complex tmp_max;
 
 	  double abs_max = octave_NaN;
 
 	  for (idx_i = 0; idx_i < nr; idx_i++)
 	    {
 	      tmp_max = elem (idx_i, j);
 
 	      if (! octave_is_NaN_or_NA (tmp_max))
 		{
 		  abs_max = real_only ? STD_OCTAVE::real (tmp_max) : STD_OCTAVE::abs (tmp_max);
 		  break;
 		}
 	    }
 
-	  for (int i = idx_i+1; i < nr; i++)
+	  for (octave_idx_type i = idx_i+1; i < nr; i++)
 	    {
 	      Complex tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
 	      double abs_tmp = real_only ? STD_OCTAVE::real (tmp) : STD_OCTAVE::abs (tmp);
 
@@ -3069,41 +3069,41 @@ ComplexMatrix::column_max (Array<int>& i
   return result;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexMatrix& a)
 {
-  for (int i = 0; i < a.rows (); i++)
+  for (octave_idx_type i = 0; i < a.rows (); i++)
     {
-      for (int j = 0; j < a.cols (); j++)
+      for (octave_idx_type j = 0; j < a.cols (); j++)
 	{
 	  os << " ";
 	  octave_write_complex (os, a.elem (i, j));
 	}
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexMatrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (nr < 1 || nc < 1)
     is.clear (std::ios::badbit);
   else
     {
       Complex tmp;
-      for (int i = 0; i < nr; i++)
-	for (int j = 0; j < nc; j++)
+      for (octave_idx_type i = 0; i < nr; i++)
+	for (octave_idx_type j = 0; j < nc; j++)
 	  {
 	    tmp = octave_read_complex (is);
 	    if (is)
 	      a.elem (i, j) = tmp;
 	    else
 	      goto done;
 	  }
     }
@@ -3153,21 +3153,21 @@ Sylvester (const ComplexMatrix& a, const
   ComplexMatrix ub = bs.unitary_matrix ();
   ComplexMatrix sch_b = bs.schur_matrix ();
   
   ComplexMatrix cx = ua.hermitian () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
-  int a_nr = a.rows ();
-  int b_nr = b.rows ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type b_nr = b.rows ();
 
   double scale;
-  int info;
+  octave_idx_type info;
 
   Complex *pa = sch_a.fortran_vec ();
   Complex *pb = sch_b.fortran_vec ();
   Complex *px = cx.fortran_vec ();
   
   F77_XFCN (ztrsyl, ZTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
 			     F77_CONST_CHAR_ARG2 ("N", 1),
 			     1, a_nr, b_nr, pa, a_nr, pb,
@@ -3201,32 +3201,32 @@ operator * (const Matrix& m, const Compl
   return tmp * a;
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& m, const ComplexMatrix& a)
 {
   ComplexMatrix retval;
 
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.cols ();
+
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (nc != a_nr)
     gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
   else
     {
       if (nr == 0 || nc == 0 || a_nc == 0)
 	retval.resize (nr, a_nc, 0.0);
       else
 	{
-	  int ld  = nr;
-	  int lda = a.rows ();
+	  octave_idx_type ld  = nr;
+	  octave_idx_type lda = a.rows ();
 
 	  retval.resize (nr, a_nc);
 	  Complex *c = retval.fortran_vec ();
 
 	  F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
 				   F77_CONST_CHAR_ARG2 ("N", 1),
 				   nr, a_nc, nc, 1.0, m.data (),
 				   ld, a.data (), lda, 0.0, c, nr
@@ -3247,182 +3247,182 @@ operator * (const ComplexMatrix& m, cons
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 ComplexMatrix
 min (const Complex& c, const ComplexMatrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmin (c, m (i, j));
       }
 
   return result;
 }
 
 ComplexMatrix
 min (const ComplexMatrix& m, const Complex& c)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmin (m (i, j), c);
       }
 
   return result;
 }
 
 ComplexMatrix
 min (const ComplexMatrix& a, const ComplexMatrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.columns ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
 	("two-arg min expecting args of same size");
       return ComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  if (STD_OCTAVE::imag (a (i, j)) != 0.0 || STD_OCTAVE::imag (b (i, j)) != 0.0)
 	    {
 	      columns_are_real_only = 0;
 	      break;
 	    }
 	}
 
       if (columns_are_real_only)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    result (i, j) = xmin (STD_OCTAVE::real (a (i, j)), STD_OCTAVE::real (b (i, j)));
 	}
       else
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result (i, j) = xmin (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
 }
 
 ComplexMatrix
 max (const Complex& c, const ComplexMatrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmax (c, m (i, j));
       }
 
   return result;
 }
 
 ComplexMatrix
 max (const ComplexMatrix& m, const Complex& c)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmax (m (i, j), c);
       }
 
   return result;
 }
 
 ComplexMatrix
 max (const ComplexMatrix& a, const ComplexMatrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.columns ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
 	("two-arg max expecting args of same size");
       return ComplexMatrix ();
     }
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  if (STD_OCTAVE::imag (a (i, j)) != 0.0 || STD_OCTAVE::imag (b (i, j)) != 0.0)
 	    {
 	      columns_are_real_only = 0;
 	      break;
 	    }
 	}
 
       if (columns_are_real_only)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result (i, j) = xmax (STD_OCTAVE::real (a (i, j)), STD_OCTAVE::real (b (i, j)));
 	    }
 	}
       else
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result (i, j) = xmax (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -34,19 +34,19 @@ class
 ComplexMatrix : public MArray2<Complex>
 {
 public:
  
   typedef void (*solve_singularity_handler) (double rcond);
 
   ComplexMatrix (void) : MArray2<Complex> () { }
 
-  ComplexMatrix (int r, int c) : MArray2<Complex> (r, c) { }
+  ComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray2<Complex> (r, c) { }
 
-  ComplexMatrix (int r, int c, const Complex& val)
+  ComplexMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
     : MArray2<Complex> (r, c, val) { }
 
   ComplexMatrix (const ComplexMatrix& a) : MArray2<Complex> (a) { }
 
   ComplexMatrix (const MArray2<Complex>& a) : MArray2<Complex> (a) { }
 
   explicit ComplexMatrix (const Matrix& a);
 
@@ -74,30 +74,30 @@ public:
 
   bool operator == (const ComplexMatrix& a) const;
   bool operator != (const ComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
   // destructive insert/delete/reorder operations
 
-  ComplexMatrix& insert (const Matrix& a, int r, int c);
-  ComplexMatrix& insert (const RowVector& a, int r, int c);
-  ComplexMatrix& insert (const ColumnVector& a, int r, int c);
-  ComplexMatrix& insert (const DiagMatrix& a, int r, int c);
+  ComplexMatrix& insert (const Matrix& a, octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const RowVector& a, octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c);
 
-  ComplexMatrix& insert (const ComplexMatrix& a, int r, int c);
-  ComplexMatrix& insert (const ComplexRowVector& a, int r, int c);
-  ComplexMatrix& insert (const ComplexColumnVector& a, int r, int c);
-  ComplexMatrix& insert (const ComplexDiagMatrix& a, int r, int c);
+  ComplexMatrix& insert (const ComplexMatrix& a, octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ComplexRowVector& a, octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ComplexColumnVector& a, octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ComplexDiagMatrix& a, octave_idx_type r, octave_idx_type c);
 
   ComplexMatrix& fill (double val);
   ComplexMatrix& fill (const Complex& val);
-  ComplexMatrix& fill (double val, int r1, int c1, int r2, int c2);
-  ComplexMatrix& fill (const Complex& val, int r1, int c1, int r2, int c2);
+  ComplexMatrix& fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
+  ComplexMatrix& fill (const Complex& val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
 
   ComplexMatrix append (const Matrix& a) const;
   ComplexMatrix append (const RowVector& a) const;
   ComplexMatrix append (const ColumnVector& a) const;
   ComplexMatrix append (const DiagMatrix& a) const;
 
   ComplexMatrix append (const ComplexMatrix& a) const;
   ComplexMatrix append (const ComplexRowVector& a) const;
@@ -117,90 +117,90 @@ public:
   ComplexMatrix hermitian (void) const;  // complex conjugate transpose
   ComplexMatrix transpose (void) const
     { return MArray2<Complex>::transpose (); }
 
   friend ComplexMatrix conj (const ComplexMatrix& a);
 
   // resize is the destructive equivalent for this one
 
-  ComplexMatrix extract (int r1, int c1, int r2, int c2) const;
+  ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
-  ComplexMatrix extract_n (int r1, int c1, int nr, int nc) const;
+  ComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
-  ComplexRowVector row (int i) const;
+  ComplexRowVector row (octave_idx_type i) const;
   ComplexRowVector row (char *s) const;
 
-  ComplexColumnVector column (int i) const;
+  ComplexColumnVector column (octave_idx_type i) const;
   ComplexColumnVector column (char *s) const;
 
   ComplexMatrix inverse (void) const;
-  ComplexMatrix inverse (int& info) const;
-  ComplexMatrix inverse (int& info, double& rcond, int force = 0,
+  ComplexMatrix inverse (octave_idx_type& info) const;
+  ComplexMatrix inverse (octave_idx_type& info, double& rcond, int force = 0,
 			 int calc_cond = 1) const;
 
   ComplexMatrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   ComplexDET determinant (void) const;
-  ComplexDET determinant (int& info) const;
-  ComplexDET determinant (int& info, double& rcond, int calc_cond = 1) const;
+  ComplexDET determinant (octave_idx_type& info) const;
+  ComplexDET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
   ComplexMatrix solve (const Matrix& b) const;
-  ComplexMatrix solve (const Matrix& b, int& info) const;
-  ComplexMatrix solve (const Matrix& b, int& info, double& rcond) const;
-  ComplexMatrix solve (const Matrix& b, int& info, double& rcond,
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
 		       solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
 		       solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
-  ComplexColumnVector solve (const ColumnVector& b, int& info) const;
-  ComplexColumnVector solve (const ColumnVector& b, int& info,
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
-  ComplexColumnVector solve (const ColumnVector& b, int& info, double& rcond,
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   ComplexMatrix lssolve (const Matrix& b) const;
-  ComplexMatrix lssolve (const Matrix& b, int& info) const;
-  ComplexMatrix lssolve (const Matrix& b, int& info, int& rank) const;
+  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info) const;
+  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info,
-			 int& rank) const;
+  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
+  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
+			 octave_idx_type& rank) const;
 
   ComplexColumnVector lssolve (const ColumnVector& b) const;
-  ComplexColumnVector lssolve (const ColumnVector& b, int& info) const;
-  ComplexColumnVector lssolve (const ColumnVector& b, int& info,
-			       int& rank) const;
+  ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
+			       octave_idx_type& rank) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
-			       int& rank) const;
+  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info,
+			       octave_idx_type& rank) const;
 
   ComplexMatrix expm (void) const;
 
   // column vector by row vector -> matrix operations
 
   friend ComplexMatrix operator * (const ColumnVector& a,
 				   const ComplexRowVector& b);
 
@@ -246,43 +246,43 @@ public:
   ComplexMatrix cumprod (int dim = -1) const;
   ComplexMatrix cumsum (int dim = -1) const;
   ComplexMatrix prod (int dim = -1) const;
   ComplexMatrix sum (int dim = -1) const;
   ComplexMatrix sumsq (int dim = -1) const;
   Matrix abs (void) const;
 
   ComplexColumnVector diag (void) const;
-  ComplexColumnVector diag (int k) const;
+  ComplexColumnVector diag (octave_idx_type k) const;
 
-  bool row_is_real_only (int) const;
-  bool column_is_real_only (int) const;
+  bool row_is_real_only (octave_idx_type) const;
+  bool column_is_real_only (octave_idx_type) const;
 
   ComplexColumnVector row_min (void) const;
   ComplexColumnVector row_max (void) const;
 
-  ComplexColumnVector row_min (Array<int>& index) const;
-  ComplexColumnVector row_max (Array<int>& index) const;
+  ComplexColumnVector row_min (Array<octave_idx_type>& index) const; 
+  ComplexColumnVector row_max (Array<octave_idx_type>& index) const;
 
   ComplexRowVector column_min (void) const;
   ComplexRowVector column_max (void) const;
 
-  ComplexRowVector column_min (Array<int>& index) const;
-  ComplexRowVector column_max (Array<int>& index) const;
+  ComplexRowVector column_min (Array<octave_idx_type>& index) const;
+  ComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexMatrix& a);
   friend std::istream& operator >> (std::istream& is, ComplexMatrix& a);
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
 private:
 
-  ComplexMatrix (Complex *d, int r, int c) : MArray2<Complex> (d, r, c) { }
+  ComplexMatrix (Complex *d, octave_idx_type r, octave_idx_type c) : MArray2<Complex> (d, r, c) { }
 };
 
 ComplexMatrix Givens (const Complex&, const Complex&);
 
 ComplexMatrix Sylvester (const ComplexMatrix&, const ComplexMatrix&,
 			 const ComplexMatrix&);
 
 extern ComplexMatrix operator * (const Matrix&,        const ComplexMatrix&);
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -42,83 +42,83 @@ Software Foundation, 59 Temple Place - S
 extern "C"
 {
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
   // implicit double precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
   F77_RET_T
-  F77_FUNC (cffti, CFFTI) (const int&, Complex*);
+  F77_FUNC (cffti, CFFTI) (const octave_idx_type&, Complex*);
 
   F77_RET_T
-  F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
+  F77_FUNC (cfftf, CFFTF) (const octave_idx_type&, Complex*, Complex*);
 
   F77_RET_T
-  F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
+  F77_FUNC (cfftb, CFFTB) (const octave_idx_type&, Complex*, Complex*);
 }
 #endif
 
 #if defined (HAVE_FFTW3)
 ComplexNDArray
 ComplexNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
-  int stride = 1;
-  int n = dv(dim);
+  octave_idx_type stride = 1;
+  octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  int howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv (dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  int nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
-  int dist = (stride == 1 ? n : 1);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type dist = (stride == 1 ? n : 1);
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
-  for (int k = 0; k < nloop; k++)
+  for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
 		      n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
-  int stride = 1;
-  int n = dv(dim);
+  octave_idx_type stride = 1;
+  octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  int howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv (dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  int nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
-  int dist = (stride == 1 ? n : 1);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type dist = (stride == 1 ? n : 1);
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
-  for (int k = 0; k < nloop; k++)
+  for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (in + k * stride * n, out + k * stride * n, 
 		      n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
@@ -126,40 +126,40 @@ ComplexNDArray::fourier2d (void) const
   dim_vector dv = dims();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  int howmany = numel() / dv(0) / dv(1);
-  int dist = dv(0) * dv(1);
+  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type dist = dv(0) * dv(1);
 
-  for (int i=0; i < howmany; i++)
+  for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
   dim_vector dv = dims();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  int howmany = numel() / dv(0) / dv(1);
-  int dist = dv(0) * dv(1);
+  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type dist = dv(0) * dv(1);
 
-  for (int i=0; i < howmany; i++)
+  for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourierNd (void) const
 {
@@ -195,140 +195,140 @@ ComplexNDArray
 ComplexNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
-  int npts = dv(dim);
-  int nn = 4*npts+15;
+  octave_idx_type npts = dv(dim);
+  octave_idx_type nn = 4*npts+15;
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
 
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  int howmany = numel () / npts;
+  octave_idx_type howmany = numel () / npts;
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  int dist = (stride == 1 ? npts : 1);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+  octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int k = 0; k < nloop; k++)
+  for (octave_idx_type k = 0; k < nloop; k++)
     {
-      for (int j = 0; j < howmany; j++)
+      for (octave_idx_type j = 0; j < howmany; j++)
 	{
 	  OCTAVE_QUIT;
 
-	  for (int i = 0; i < npts; i++)
+	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
-	  for (int i = 0; i < npts; i++)
+	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
 	}
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
-  int npts = dv(dim);
-  int nn = 4*npts+15;
+  octave_idx_type npts = dv(dim);
+  octave_idx_type nn = 4*npts+15;
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
 
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  int howmany = numel () / npts;
+  octave_idx_type howmany = numel () / npts;
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  int dist = (stride == 1 ? npts : 1);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+  octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int k = 0; k < nloop; k++)
+  for (octave_idx_type k = 0; k < nloop; k++)
     {
-      for (int j = 0; j < howmany; j++)
+      for (octave_idx_type j = 0; j < howmany; j++)
 	{
 	  OCTAVE_QUIT;
 
-	  for (int i = 0; i < npts; i++)
+	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
-	  for (int i = 0; i < npts; i++)
+	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i] /
 	      static_cast<double> (npts);
 	}
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
-      int npts = dv2(i);
-      int nn = 4*npts+15;
+      octave_idx_type npts = dv2(i);
+      octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
-      int howmany = numel () / npts;
+      octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
 		 (howmany > stride ? stride : howmany));
-      int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      int dist = (stride == 1 ? npts : 1);
+      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+      octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-      for (int k = 0; k < nloop; k++)
+      for (octave_idx_type k = 0; k < nloop; k++)
 	{
-	  for (int j = 0; j < howmany; j++)
+	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
 	      OCTAVE_QUIT;
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
 	    }
 	}
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -336,47 +336,47 @@ ComplexNDArray::fourier2d (void) const
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
   dim_vector dv = dims();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
-      int npts = dv2(i);
-      int nn = 4*npts+15;
+      octave_idx_type npts = dv2(i);
+      octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
-      int howmany = numel () / npts;
+      octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
 		 (howmany > stride ? stride : howmany));
-      int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      int dist = (stride == 1 ? npts : 1);
+      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+      octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-      for (int k = 0; k < nloop; k++)
+      for (octave_idx_type k = 0; k < nloop; k++)
 	{
-	  for (int j = 0; j < howmany; j++)
+	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
 	      OCTAVE_QUIT;
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
 		  static_cast<double> (npts);
 	    }
 	}
 
       stride *= dv2(i);
     }
 
@@ -384,94 +384,94 @@ ComplexNDArray::ifourier2d (void) const
 }
 
 ComplexNDArray
 ComplexNDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
   int rank = dv.length ();
   ComplexNDArray retval (*this);
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
-      int npts = dv(i);
-      int nn = 4*npts+15;
+      octave_idx_type npts = dv(i);
+      octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
-      int howmany = numel () / npts;
+      octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
 		 (howmany > stride ? stride : howmany));
-      int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      int dist = (stride == 1 ? npts : 1);
+      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+      octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-      for (int k = 0; k < nloop; k++)
+      for (octave_idx_type k = 0; k < nloop; k++)
 	{
-	  for (int j = 0; j < howmany; j++)
+	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
 	      OCTAVE_QUIT;
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
 	    }
 	}
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
   int rank = dv.length ();
   ComplexNDArray retval (*this);
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
-      int npts = dv(i);
-      int nn = 4*npts+15;
+      octave_idx_type npts = dv(i);
+      octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
-      int howmany = numel () / npts;
+      octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
 		 (howmany > stride ? stride : howmany));
-      int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      int dist = (stride == 1 ? npts : 1);
+      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+      octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-      for (int k = 0; k < nloop; k++)
+      for (octave_idx_type k = 0; k < nloop; k++)
 	{
-	  for (int j = 0; j < howmany; j++)
+	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
 	      OCTAVE_QUIT;
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
 		  static_cast<double> (npts);
 	    }
 	}
 
       stride *= dv(i);
     }
 
@@ -482,46 +482,46 @@ ComplexNDArray::ifourierNd (void) const
 
 // unary operations
 
 boolNDArray
 ComplexNDArray::operator ! (void) const
 {
   boolNDArray b (dims ());
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     b.elem (i) = elem (i) == 0.0;
 
   return b;
 }
 
 // XXX FIXME XXX -- this is not quite the right thing.
 
 bool
 ComplexNDArray::any_element_is_inf_or_nan (void) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = elem (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
 ComplexNDArray::all_elements_are_real (void) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double ip = std::imag (elem (i));
 
       if (ip != 0.0 || lo_ieee_signbit (ip))
 	return false;
     }
 
   return true;
@@ -529,17 +529,17 @@ ComplexNDArray::all_elements_are_real (v
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
 // imaginary) values and return them in MAX_VAL and MIN_VAL. 
 
 bool
 ComplexNDArray::all_integers (double& max_val, double& min_val) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
   if (nel > 0)
     {
       Complex val = elem (0);
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
       
@@ -550,17 +550,17 @@ ComplexNDArray::all_integers (double& ma
 	max_val = i_val;
 
       if (i_val < max_val)
 	min_val = i_val;
     }
   else
     return false;
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = elem (i);
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
 
       if (r_val > max_val)
 	max_val = r_val;
@@ -579,19 +579,19 @@ ComplexNDArray::all_integers (double& ma
     }
 
   return true;
 }
 
 bool
 ComplexNDArray::too_large_for_float (void) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = elem (i);
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
 
       if (r_val > FLT_MAX
 	  || i_val > FLT_MAX
@@ -649,104 +649,104 @@ ComplexNDArray::sumsq (int dim) const
 
 ComplexNDArray 
 ComplexNDArray::sum (int dim) const
 {
   MX_ND_COMPLEX_OP_REDUCTION (+= elem (iter_idx), Complex (0, 0));
 }
 
 ComplexNDArray
-ComplexNDArray::concat (const ComplexNDArray& rb, const Array<int>& ra_idx)
+ComplexNDArray::concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 ComplexNDArray
-ComplexNDArray::concat (const NDArray& rb, const Array<int>& ra_idx)
+ComplexNDArray::concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   ComplexNDArray tmp (rb);
   if (rb.numel () > 0)
     insert (tmp, ra_idx);
   return *this;
 }
 
 ComplexNDArray
-concat (NDArray& ra, ComplexNDArray& rb, const Array<int>& ra_idx)
+concat (NDArray& ra, ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   ComplexNDArray retval (ra);
   if (rb.numel () > 0)
     retval.insert (rb, ra_idx);
   return retval;
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 ComplexNDArray
 ComplexNDArray::max (int dim) const
 {
-  ArrayN<int> dummy_idx;
+  ArrayN<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
 ComplexNDArray
-ComplexNDArray::max (ArrayN<int>& idx_arg, int dim) const
+ComplexNDArray::max (ArrayN<octave_idx_type>& idx_arg, int dim) const
 {
   dim_vector dv = dims ();
   dim_vector dr = dims ();
 
   if (dv.numel () == 0 || dim > dv.length () || dim < 0)
     return ComplexNDArray ();
   
   dr(dim) = 1;
 
   ComplexNDArray result (dr);
   idx_arg.resize (dr);
 
-  int x_stride = 1;
-  int x_len = dv(dim);
+  octave_idx_type x_stride = 1;
+  octave_idx_type x_len = dv(dim);
   for (int i = 0; i < dim; i++)
     x_stride *= dv(i);
 
-  for (int i = 0; i < dr.numel (); i++)
+  for (octave_idx_type i = 0; i < dr.numel (); i++)
     {
-      int x_offset;
+      octave_idx_type x_offset;
       if (x_stride == 1)
 	x_offset = i * x_len;
       else
 	{
-	  int x_offset2 = 0;
+	  octave_idx_type x_offset2 = 0;
 	  x_offset = i;
 	  while (x_offset >= x_stride)
 	    {
 	      x_offset -= x_stride;
 	      x_offset2++;
 	    }
 	  x_offset += x_offset2 * x_stride * x_len;
 	}
 
-      int idx_j;
+      octave_idx_type idx_j;
 
       Complex tmp_max;
 
       double abs_max = octave_NaN;
 
       for (idx_j = 0; idx_j < x_len; idx_j++)
 	{
 	  tmp_max = elem (idx_j * x_stride + x_offset);
 	  
 	  if (! octave_is_NaN_or_NA (tmp_max))
 	    {
 	      abs_max = std::abs(tmp_max);
 	      break;
 	    }
 	}
 
-      for (int j = idx_j+1; j < x_len; j++)
+      for (octave_idx_type j = idx_j+1; j < x_len; j++)
 	{
 	  Complex tmp = elem (j * x_stride + x_offset);
 
 	  if (octave_is_NaN_or_NA (tmp))
 	    continue;
 
 	  double abs_tmp = std::abs (tmp);
 
@@ -771,74 +771,74 @@ ComplexNDArray::max (ArrayN<int>& idx_ar
     }
 
   return result;
 }
 
 ComplexNDArray
 ComplexNDArray::min (int dim) const
 {
-  ArrayN<int> dummy_idx;
+  ArrayN<octave_idx_type> dummy_idx;
   return min (dummy_idx, dim);
 }
 
 ComplexNDArray
-ComplexNDArray::min (ArrayN<int>& idx_arg, int dim) const
+ComplexNDArray::min (ArrayN<octave_idx_type>& idx_arg, int dim) const
 {
   dim_vector dv = dims ();
   dim_vector dr = dims ();
 
   if (dv.numel () == 0 || dim > dv.length () || dim < 0)
     return ComplexNDArray ();
   
   dr(dim) = 1;
 
   ComplexNDArray result (dr);
   idx_arg.resize (dr);
 
-  int x_stride = 1;
-  int x_len = dv(dim);
+  octave_idx_type x_stride = 1;
+  octave_idx_type x_len = dv(dim);
   for (int i = 0; i < dim; i++)
     x_stride *= dv(i);
 
-  for (int i = 0; i < dr.numel (); i++)
+  for (octave_idx_type i = 0; i < dr.numel (); i++)
     {
-      int x_offset;
+      octave_idx_type x_offset;
       if (x_stride == 1)
 	x_offset = i * x_len;
       else
 	{
-	  int x_offset2 = 0;
+	  octave_idx_type x_offset2 = 0;
 	  x_offset = i;
 	  while (x_offset >= x_stride)
 	    {
 	      x_offset -= x_stride;
 	      x_offset2++;
 	    }
 	  x_offset += x_offset2 * x_stride * x_len;
 	}
 
-      int idx_j;
+      octave_idx_type idx_j;
 
       Complex tmp_min;
 
       double abs_min = octave_NaN;
 
       for (idx_j = 0; idx_j < x_len; idx_j++)
 	{
 	  tmp_min = elem (idx_j * x_stride + x_offset);
 	  
 	  if (! octave_is_NaN_or_NA (tmp_min))
 	    {
 	      abs_min = std::abs(tmp_min);
 	      break;
 	    }
 	}
 
-      for (int j = idx_j+1; j < x_len; j++)
+      for (octave_idx_type j = idx_j+1; j < x_len; j++)
 	{
 	  Complex tmp = elem (j * x_stride + x_offset);
 
 	  if (octave_is_NaN_or_NA (tmp))
 	    continue;
 
 	  double abs_tmp = std::abs (tmp);
 
@@ -865,34 +865,34 @@ ComplexNDArray::min (ArrayN<int>& idx_ar
   return result;
 }
 
 NDArray
 ComplexNDArray::abs (void) const
 {
   NDArray retval (dims ());
 
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = std::abs (elem (i));
       
   return retval;
 }
 
 ComplexNDArray&
-ComplexNDArray::insert (const NDArray& a, int r, int c)
+ComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
   
   int n = a_dv.length ();
   
   if (n == dimensions.length ())
     {
-      Array<int> a_ra_idx (a_dv.length (), 0);
+      Array<octave_idx_type> a_ra_idx (a_dv.length (), 0);
       
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
       
       for (int i = 0; i < n; i++)
 	{
 	  if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
 	    {
@@ -900,23 +900,23 @@ ComplexNDArray::insert (const NDArray& a
 		("Array<T>::insert: range error for insert");
 	      return *this;
 	    }
 	}
       
       a_ra_idx.elem (0) = 0;
       a_ra_idx.elem (1) = 0;
       
-      int n_elt = a.numel ();
+      octave_idx_type n_elt = a.numel ();
       
       // IS make_unique () NECCESSARY HERE??
 
-      for (int i = 0; i < n_elt; i++)
+      for (octave_idx_type i = 0; i < n_elt; i++)
 	{
-	  Array<int> ra_idx = a_ra_idx;
+	  Array<octave_idx_type> ra_idx = a_ra_idx;
 	  
 	  ra_idx.elem (0) = a_ra_idx (0) + r;
 	  ra_idx.elem (1) = a_ra_idx (1) + c;
 	  
 	  elem (ra_idx) = a.elem (a_ra_idx);
 
 	  increment_index (a_ra_idx, a_dv);
 	}
@@ -924,24 +924,24 @@ ComplexNDArray::insert (const NDArray& a
   else
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
 
   return *this;
 }
 
 ComplexNDArray&
-ComplexNDArray::insert (const ComplexNDArray& a, int r, int c)
+ComplexNDArray::insert (const ComplexNDArray& a, octave_idx_type r, octave_idx_type c)
 {
   Array<Complex>::insert (a, r, c);
   return *this;
 }
 
 ComplexNDArray&
-ComplexNDArray::insert (const ComplexNDArray& a, const Array<int>& ra_idx)
+ComplexNDArray::insert (const ComplexNDArray& a, const Array<octave_idx_type>& ra_idx)
 {
   Array<Complex>::insert (a, ra_idx);
   return *this;
 }
 
 ComplexMatrix
 ComplexNDArray::matrix_value (void) const
 {
@@ -965,57 +965,57 @@ ComplexNDArray::matrix_value (void) cons
 	("invalid conversion of ComplexNDArray to ComplexMatrix");
       break;
     }
 
   return retval;
 }
 
 void
-ComplexNDArray::increment_index (Array<int>& ra_idx,
+ComplexNDArray::increment_index (Array<octave_idx_type>& ra_idx,
 				 const dim_vector& dimensions,
 				 int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
-int 
-ComplexNDArray::compute_index (Array<int>& ra_idx,
+octave_idx_type 
+ComplexNDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const ComplexNDArray& a)
 {
-  int nel = a.nelem ();
+  octave_idx_type nel = a.nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       os << " ";
       octave_write_complex (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexNDArray& a)
 {
-  int nel = a.nelem ();
+  octave_idx_type nel = a.nelem ();
 
   if (nel < 1 )
     is.clear (std::ios::badbit);
   else
     {
       Complex tmp;
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	  {
 	    tmp = octave_read_complex (is);
 	    if (is)
 	      a.elem (i) = tmp;
 	    else
 	      goto done;
 	  }
     }
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -67,48 +67,47 @@ public:
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   ComplexNDArray cumprod (int dim = -1) const;
   ComplexNDArray cumsum (int dim = -1) const;
   ComplexNDArray prod (int dim = -1) const;
   ComplexNDArray sum (int dim = -1) const;
   ComplexNDArray sumsq (int dim = -1) const;
-  ComplexNDArray concat (const ComplexNDArray& rb, const Array<int>& ra_idx);
-  ComplexNDArray concat (const NDArray& rb, const Array<int>& ra_idx);
+  ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
+  ComplexNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   ComplexNDArray max (int dim = 0) const;
-  ComplexNDArray max (ArrayN<int>& index, int dim = 0) const;
+  ComplexNDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
   ComplexNDArray min (int dim = 0) const;
-  ComplexNDArray min (ArrayN<int>& index, int dim = 0) const;
-
-  ComplexNDArray& insert (const NDArray& a, int r, int c);
-  ComplexNDArray& insert (const ComplexNDArray& a, int r, int c);
-  ComplexNDArray& insert (const ComplexNDArray& a, const Array<int>& ra_idx);
+  ComplexNDArray min (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  ComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
+  ComplexNDArray& insert (const ComplexNDArray& a, octave_idx_type r, octave_idx_type c);
+  ComplexNDArray& insert (const ComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
   
   NDArray abs (void) const;
 
   ComplexNDArray fourier (int dim = 1) const;
   ComplexNDArray ifourier (int dim = 1) const;
 
   ComplexNDArray fourier2d (void) const;
   ComplexNDArray ifourier2d (void) const;
 
   ComplexNDArray fourierNd (void) const;
   ComplexNDArray ifourierNd (void) const;
 
   ComplexMatrix matrix_value (void) const;
 
   ComplexNDArray squeeze (void) const { return MArrayN<Complex>::squeeze (); }
 
-  static void increment_index (Array<int>& ra_idx,
+  static void increment_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
-  static int compute_index (Array<int>& ra_idx,
+  static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions);
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexNDArray& a);
   friend std::istream& operator >> (std::istream& is, ComplexNDArray& a);
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -35,253 +35,253 @@ Software Foundation, 59 Temple Place - S
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const int&, const int&, const Complex&,
-			   const Complex*, const int&, const Complex*,
-			   const int&, const Complex&, Complex*, const int&
+			   const octave_idx_type&, const octave_idx_type&, const Complex&,
+			   const Complex*, const octave_idx_type&, const Complex*,
+			   const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL);
 }
 
 // Complex Row Vector class
 
 ComplexRowVector::ComplexRowVector (const RowVector& a)
   : MArray<Complex> (a.length ())
 {
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     elem (i) = a.elem (i);
 }
 
 bool
 ComplexRowVector::operator == (const ComplexRowVector& a) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len != a.length ())
     return 0;
   return mx_inline_equal (data (), a.data (), len);
 }
 
 bool
 ComplexRowVector::operator != (const ComplexRowVector& a) const
 {
   return !(*this == a);
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexRowVector&
-ComplexRowVector::insert (const RowVector& a, int c)
+ComplexRowVector::insert (const RowVector& a, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (c < 0 || c + a_len > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexRowVector&
-ComplexRowVector::insert (const ComplexRowVector& a, int c)
+ComplexRowVector::insert (const ComplexRowVector& a, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (c < 0 || c + a_len > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
-ComplexRowVector::fill (double val, int c1, int c2)
+ComplexRowVector::fill (double val, octave_idx_type c1, octave_idx_type c2)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
-      for (int i = c1; i <= c2; i++)
+      for (octave_idx_type i = c1; i <= c2; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
-ComplexRowVector::fill (const Complex& val, int c1, int c2)
+ComplexRowVector::fill (const Complex& val, octave_idx_type c1, octave_idx_type c2)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
-      for (int i = c1; i <= c2; i++)
+      for (octave_idx_type i = c1; i <= c2; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector
 ComplexRowVector::append (const RowVector& a) const
 {
-  int len = length ();
-  int nc_insert = len;
+  octave_idx_type len = length ();
+  octave_idx_type nc_insert = len;
   ComplexRowVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ComplexRowVector
 ComplexRowVector::append (const ComplexRowVector& a) const
 {
-  int len = length ();
-  int nc_insert = len;
+  octave_idx_type len = length ();
+  octave_idx_type nc_insert = len;
   ComplexRowVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ComplexColumnVector
 ComplexRowVector::hermitian (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   return ComplexColumnVector (mx_inline_conj_dup (data (), len), len);
 }
 
 ComplexColumnVector
 ComplexRowVector::transpose (void) const
 {
   return ComplexColumnVector (*this);
 }
 
 ComplexRowVector
 conj (const ComplexRowVector& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   ComplexRowVector retval;
   if (a_len > 0)
     retval = ComplexRowVector (mx_inline_conj_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexRowVector
-ComplexRowVector::extract (int c1, int c2) const
+ComplexRowVector::extract (octave_idx_type c1, octave_idx_type c2) const
 {
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
-  int new_c = c2 - c1 + 1;
+  octave_idx_type new_c = c2 - c1 + 1;
 
   ComplexRowVector result (new_c);
 
-  for (int i = 0; i < new_c; i++)
+  for (octave_idx_type i = 0; i < new_c; i++)
     result.elem (i) = elem (c1+i);
 
   return result;
 }
 
 ComplexRowVector
-ComplexRowVector::extract_n (int r1, int n) const
+ComplexRowVector::extract_n (octave_idx_type r1, octave_idx_type n) const
 {
   ComplexRowVector result (n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     result.elem (i) = elem (r1+i);
 
   return result;
 }
 
 // row vector by row vector -> row vector operations
 
 ComplexRowVector&
 ComplexRowVector::operator += (const RowVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -291,19 +291,19 @@ ComplexRowVector::operator += (const Row
 
   mx_inline_add2 (d, a.data (), len);
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::operator -= (const RowVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
@@ -317,32 +317,32 @@ ComplexRowVector::operator -= (const Row
 
 // row vector by matrix -> row vector
 
 ComplexRowVector
 operator * (const ComplexRowVector& v, const ComplexMatrix& a)
 {
   ComplexRowVector retval;
 
-  int len = v.length ();
+  octave_idx_type len = v.length ();
 
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
 	retval.resize (a_nc, 0.0);
       else
 	{
 	  // Transpose A to form A'*x == (x'*A)'
 
-	  int ld = a_nr;
+	  octave_idx_type ld = a_nr;
 
 	  retval.resize (a_nc);
 	  Complex *y = retval.fortran_vec ();
 
 	  F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
 				   a_nr, a_nc, 1.0, a.data (),
 				   ld, v.data (), 1, 0.0, y, 1
 				   F77_CHAR_ARG_LEN (1)));
@@ -372,101 +372,101 @@ ComplexRowVector::map (c_c_Mapper f) con
   return b.apply (f);
 }
 
 RowVector
 ComplexRowVector::map (d_c_Mapper f) const
 {
   const Complex *d = data ();
 
-  int len = length ();
+  octave_idx_type len = length ();
 
   RowVector retval (len);
 
   double *r = retval.fortran_vec ();
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     r[i] = f (d[i]);
 
   return retval;
 }
 
 ComplexRowVector&
 ComplexRowVector::apply (c_c_Mapper f)
 {
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     d[i] = f (d[i]);
 
   return *this;
 }
 
 Complex
 ComplexRowVector::min (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len == 0)
     return Complex (0.0);
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
-  for (int i = 1; i < len; i++)
+  for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) < absres)
       {
 	res = elem (i);
 	absres = std::abs (res);
       }
 
   return res;
 }
 
 Complex
 ComplexRowVector::max (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len == 0)
     return Complex (0.0);
 
   Complex res = elem (0);
   double absres = std::abs (res);
 
-  for (int i = 1; i < len; i++)
+  for (octave_idx_type i = 1; i < len; i++)
     if (std::abs (elem (i)) > absres)
       {
 	res = elem (i);
 	absres = std::abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexRowVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexRowVector& a)
 {
-  int len = a.length();
+  octave_idx_type len = a.length();
 
   if (len < 1)
     is.clear (std::ios::badbit);
   else
     {
       Complex tmp;
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
             a.elem (i) = tmp;
           else
             break;
         }
     }
@@ -482,47 +482,47 @@ operator * (const ComplexRowVector& v, c
 {
   ComplexColumnVector tmp (a);
   return v * tmp;
 }
 
 Complex
 operator * (const ComplexRowVector& v, const ComplexColumnVector& a)
 {
-  int len = v.length ();
+  octave_idx_type len = v.length ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("operator *", len, a_len);
       return 0.0;
     }
 
   Complex retval (0.0, 0.0);
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     retval += v.elem (i) * a.elem (i);
 
   return retval;
 }
 
 // other operations
 
 ComplexRowVector
-linspace (const Complex& x1, const Complex& x2, int n)
+linspace (const Complex& x1, const Complex& x2, octave_idx_type n)
 {
   ComplexRowVector retval;
 
   if (n > 0)
     {
       retval.resize (n);
       Complex delta = (x2 - x1) / (n - 1.0);
       retval.elem (0) = x1;
-      for (int i = 1; i < n-1; i++)
+      for (octave_idx_type i = 1; i < n-1; i++)
 	retval.elem (i) = x1 + 1.0 * i * delta;
       retval.elem (n-1) = x2;
     }
   else if (n == 1)
     {
       if (x1 == x2)
 	{
 	  retval.resize (1);
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -31,19 +31,19 @@ class
 ComplexRowVector : public MArray<Complex>
 {
 friend class ComplexColumnVector;
 
 public:
 
   ComplexRowVector (void) : MArray<Complex> () { }
 
-  explicit ComplexRowVector (int n) : MArray<Complex> (n) { }
+  explicit ComplexRowVector (octave_idx_type n) : MArray<Complex> (n) { }
 
-  ComplexRowVector (int n, const Complex& val) : MArray<Complex> (n, val) { }
+  ComplexRowVector (octave_idx_type n, const Complex& val) : MArray<Complex> (n, val) { }
 
   ComplexRowVector (const ComplexRowVector& a) : MArray<Complex> (a) { }
 
   ComplexRowVector (const MArray<Complex>& a) : MArray<Complex> (a) { }
 
   explicit ComplexRowVector (const RowVector& a);
 
   ComplexRowVector& operator = (const ComplexRowVector& a)
@@ -52,37 +52,37 @@ public:
       return *this;
     }
 
   bool operator == (const ComplexRowVector& a) const;
   bool operator != (const ComplexRowVector& a) const;
 
   // destructive insert/delete/reorder operations
 
-  ComplexRowVector& insert (const RowVector& a, int c);
-  ComplexRowVector& insert (const ComplexRowVector& a, int c);
+  ComplexRowVector& insert (const RowVector& a, octave_idx_type c);
+  ComplexRowVector& insert (const ComplexRowVector& a, octave_idx_type c);
 
   ComplexRowVector& fill (double val);
   ComplexRowVector& fill (const Complex& val);
-  ComplexRowVector& fill (double val, int c1, int c2);
-  ComplexRowVector& fill (const Complex& val, int c1, int c2);
+  ComplexRowVector& fill (double val, octave_idx_type c1, octave_idx_type c2);
+  ComplexRowVector& fill (const Complex& val, octave_idx_type c1, octave_idx_type c2);
 
   ComplexRowVector append (const RowVector& a) const;
   ComplexRowVector append (const ComplexRowVector& a) const;
 
   ComplexColumnVector hermitian (void) const;  // complex conjugate transpose.
   ComplexColumnVector transpose (void) const;
 
   friend ComplexRowVector conj (const ComplexRowVector& a);
 
   // resize is the destructive equivalent for this one
 
-  ComplexRowVector extract (int c1, int c2) const;
+  ComplexRowVector extract (octave_idx_type c1, octave_idx_type c2) const;
 
-  ComplexRowVector extract_n (int c1, int n) const;
+  ComplexRowVector extract_n (octave_idx_type c1, octave_idx_type n) const;
 
   // row vector by row vector -> row vector operations
 
   ComplexRowVector& operator += (const RowVector& a);
   ComplexRowVector& operator -= (const RowVector& a);
 
   // row vector by matrix -> row vector
 
@@ -104,28 +104,28 @@ public:
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
 
 private:
 
-  ComplexRowVector (Complex *d, int l) : MArray<Complex> (d, l) { }
+  ComplexRowVector (Complex *d, octave_idx_type l) : MArray<Complex> (d, l) { }
 };
 
 // row vector by column vector -> scalar
 
 Complex operator * (const ComplexRowVector& a, const ColumnVector& b);
 
 Complex operator * (const ComplexRowVector& a, const ComplexColumnVector& b);
 
 // other operations
 
-ComplexRowVector linspace (const Complex& x1, const Complex& x2, int n);
+ComplexRowVector linspace (const Complex& x1, const Complex& x2, octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, ComplexRowVector, Complex)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -46,196 +46,196 @@ extern "C" {
 #include <umfpack/umfpack.h>
 }
 #endif
 
 // Fortran functions we call.
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (zgbtrf, ZGBTRF) (const int&, const int&, const int&, 
-			     const int&, Complex*, const int&, int*, int&);
+  F77_FUNC (zgbtrf, ZGBTRF) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
+			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (zgbtrs, ZGBTRS) (F77_CONST_CHAR_ARG_DECL, const int&,
-			     const int&, const int&, const int&, 
-			     const Complex*, const int&,
-			     const int*, Complex*, const int&, int&
+  F77_FUNC (zgbtrs, ZGBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
+			     const Complex*, const octave_idx_type&,
+			     const octave_idx_type*, Complex*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zgbcon, ZGBCON) (F77_CONST_CHAR_ARG_DECL, const int&, 
-			     const int&, const int&, Complex*, 
-			     const int&, const int*, const double&, 
-			     double&, Complex*, double*, int&
+  F77_FUNC (zgbcon, ZGBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, const octave_idx_type&, Complex*, 
+			     const octave_idx_type&, const octave_idx_type*, const double&, 
+			     double&, Complex*, double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zpbtrf, ZPBTRF) (F77_CONST_CHAR_ARG_DECL, const int&, 
-			     const int&, Complex*, const int&, int&
+  F77_FUNC (zpbtrf, ZPBTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zpbtrs, ZPBTRS) (F77_CONST_CHAR_ARG_DECL, const int&, 
-			     const int&, const int&, Complex*, const int&, 
-			     Complex*, const int&, int&
+  F77_FUNC (zpbtrs, ZPBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, const octave_idx_type&, Complex*, const octave_idx_type&, 
+			     Complex*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zpbcon, ZPBCON) (F77_CONST_CHAR_ARG_DECL, const int&, 
-			     const int&, Complex*, const int&, 
-			     const double&, double&, Complex*, int*, int&
+  F77_FUNC (zpbcon, ZPBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, Complex*, const octave_idx_type&, 
+			     const double&, double&, Complex*, octave_idx_type*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zgttrf, ZGTTRF) (const int&, Complex*, Complex*, Complex*,
-			     Complex*, int*, int&);
+  F77_FUNC (zgttrf, ZGTTRF) (const octave_idx_type&, Complex*, Complex*, Complex*,
+			     Complex*, octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (zgttrs, ZGTTRS) (F77_CONST_CHAR_ARG_DECL, const int&,
-			     const int&, const Complex*, const Complex*,
-			     const Complex*, const Complex*, const int*,
-			     Complex *, const int&, int&
+  F77_FUNC (zgttrs, ZGTTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
+			     const octave_idx_type&, const Complex*, const Complex*,
+			     const Complex*, const Complex*, const octave_idx_type*,
+			     Complex *, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zptsv, ZPTSV) (const int&, const int&, Complex*, Complex*,
-			   Complex*, const int&, int&);
+  F77_FUNC (zptsv, ZPTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
+			   Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (zgtsv, ZGTSV) (const int&, const int&, Complex*, Complex*,
-			   Complex*, Complex*, const int&, int&);
+  F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
+			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 }
 
 SparseComplexMatrix::SparseComplexMatrix (const SparseMatrix& a)
   : MSparse<Complex> (a.rows (), a.cols (), a.nnz ())
 {
-  int nc = cols ();
-  int nz = nnz ();
-
-  for (int i = 0; i < nc + 1; i++)
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
+
+  for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     {
       data (i) = a.data (i);
       ridx (i) = a.ridx (i);
     }
 }
 
 SparseComplexMatrix::SparseComplexMatrix (const SparseBoolMatrix& a)
   : MSparse<Complex> (a.rows (), a.cols (), a.nnz ())
 {
-  int nc = cols ();
-  int nz = nnz ();
-
-  for (int i = 0; i < nc + 1; i++)
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
+
+  for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     {
       data (i) = a.data (i);
       ridx (i) = a.ridx (i);
     }
 }
 
 bool
 SparseComplexMatrix::operator == (const SparseComplexMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
-  int nr_a = a.rows ();
-  int nc_a = a.cols ();
-  int nz_a = a.nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
+  octave_idx_type nr_a = a.rows ();
+  octave_idx_type nc_a = a.cols ();
+  octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
-  for (int i = 0; i < nc + 1; i++)
+  for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
 	return false;
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
       return false;
 
   return true;
 }
 
 bool
 SparseComplexMatrix::operator != (const SparseComplexMatrix& a) const
 {
   return !(*this == a);
 }
 
 bool
 SparseComplexMatrix::is_hermitian (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (is_square () && nr > 0)
     {
-      for (int i = 0; i < nr; i++)
-	for (int j = i; j < nc; j++)
+      for (octave_idx_type i = 0; i < nr; i++)
+	for (octave_idx_type j = i; j < nc; j++)
 	  if (elem (i, j) != conj (elem (j, i)))
 	    return false;
 
       return true;
     }
 
   return false;
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 SparseComplexMatrix
 SparseComplexMatrix::max (int dim) const
 {
-  Array2<int> dummy_idx;
+  Array2<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::max (Array2<int>& idx_arg, int dim) const
+SparseComplexMatrix::max (Array2<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
 
   if (dv.numel () == 0 || dim > dv.length () || dim < 0)
     return result;
  
-  int nr = dv(0);
-  int nc = dv(1);
+  octave_idx_type nr = dv(0);
+  octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
       idx_arg.resize (1, nc);
-      int nel = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  Complex tmp_max;
 	  double abs_max = octave_NaN;
-	  int idx_j = 0;
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  octave_idx_type idx_j = 0;
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      if (ridx(i) != idx_j)
 		break;
 	      else
 		idx_j++;
 	    }
 
 	  if (idx_j != nr)
 	    {
 	      tmp_max = 0.;
 	      abs_max = 0.;
 	    }
 
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      Complex tmp = data (i);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
 	      double abs_tmp = std::abs (tmp);
 
@@ -249,80 +249,80 @@ SparseComplexMatrix::max (Array2<int>& i
 
  	  idx_arg.elem (j) = octave_is_NaN_or_NA (tmp_max) ? 0 : idx_j;
 	  if (abs_max != 0.)
 	    nel++;
 	}
 
       result = SparseComplexMatrix (1, nc, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx (0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  Complex tmp = elem (idx_arg(j), j);
 	  if (tmp != 0.)
 	    {
 	      result.xdata (ii) = tmp;
 	      result.xridx (ii++) = 0;
 	    }
 	  result.xcidx (j+1) = ii;
 	}
     }
   else
     {
       idx_arg.resize (nr, 1, 0);
 
-      for (int i = cidx(0); i < cidx(1); i++)
+      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
 	idx_arg.elem(ridx(i)) = -1;
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    if (idx_arg.elem(i) != -1)
 	      continue;
 	    bool found = false;
-	    for (int k = cidx(j); k < cidx(j+1); k++)
+	    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
 	      if (ridx(k) == i)
 		{
 		  found = true;
 		  break;
 		}
 	    
 	    if (!found)
 	      idx_arg.elem(i) = j;
 
 	  }
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
-	      int ir = ridx (i);
-	      int ix = idx_arg.elem (ir);
+	      octave_idx_type ir = ridx (i);
+	      octave_idx_type ix = idx_arg.elem (ir);
 	      Complex tmp = data (i);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (ix == -1 || std::abs(tmp) > std::abs(elem (ir, ix)))
 		idx_arg.elem (ir) = j;
 	    }
 	}
 
-      int nel = 0;
-      for (int j = 0; j < nr; j++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nr; j++)
 	if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
 	  nel++;
 
       result = SparseComplexMatrix (nr, 1, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
-      for (int j = 0; j < nr; j++)
+      for (octave_idx_type j = 0; j < nr; j++)
 	{
 	  if (idx_arg(j) == -1)
 	    {
 	      idx_arg(j) = 0;
 	      result.xdata (ii) = Complex_NaN_result;
 	      result.xridx (ii++) = j;
 	    }
 	  else
@@ -338,56 +338,56 @@ SparseComplexMatrix::max (Array2<int>& i
     }
 
   return result;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::min (int dim) const
 {
-  Array2<int> dummy_idx;
+  Array2<octave_idx_type> dummy_idx;
   return min (dummy_idx, dim);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::min (Array2<int>& idx_arg, int dim) const
+SparseComplexMatrix::min (Array2<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
 
   if (dv.numel () == 0 || dim > dv.length () || dim < 0)
     return result;
  
-  int nr = dv(0);
-  int nc = dv(1);
+  octave_idx_type nr = dv(0);
+  octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
       idx_arg.resize (1, nc);
-      int nel = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  Complex tmp_min;
 	  double abs_min = octave_NaN;
-	  int idx_j = 0;
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  octave_idx_type idx_j = 0;
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      if (ridx(i) != idx_j)
 		break;
 	      else
 		idx_j++;
 	    }
 
 	  if (idx_j != nr)
 	    {
 	      tmp_min = 0.;
 	      abs_min = 0.;
 	    }
 
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      Complex tmp = data (i);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
 	      double abs_tmp = std::abs (tmp);
 
@@ -401,80 +401,80 @@ SparseComplexMatrix::min (Array2<int>& i
 
  	  idx_arg.elem (j) = octave_is_NaN_or_NA (tmp_min) ? 0 : idx_j;
 	  if (abs_min != 0.)
 	    nel++;
 	}
 
       result = SparseComplexMatrix (1, nc, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx (0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  Complex tmp = elem (idx_arg(j), j);
 	  if (tmp != 0.)
 	    {
 	      result.xdata (ii) = tmp;
 	      result.xridx (ii++) = 0;
 	    }
 	  result.xcidx (j+1) = ii;
 	}
     }
   else
     {
       idx_arg.resize (nr, 1, 0);
 
-      for (int i = cidx(0); i < cidx(1); i++)
+      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
 	idx_arg.elem(ridx(i)) = -1;
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    if (idx_arg.elem(i) != -1)
 	      continue;
 	    bool found = false;
-	    for (int k = cidx(j); k < cidx(j+1); k++)
+	    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
 	      if (ridx(k) == i)
 		{
 		  found = true;
 		  break;
 		}
 	    
 	    if (!found)
 	      idx_arg.elem(i) = j;
 
 	  }
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
-	      int ir = ridx (i);
-	      int ix = idx_arg.elem (ir);
+	      octave_idx_type ir = ridx (i);
+	      octave_idx_type ix = idx_arg.elem (ir);
 	      Complex tmp = data (i);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (ix == -1 || std::abs(tmp) < std::abs(elem (ir, ix)))
 		idx_arg.elem (ir) = j;
 	    }
 	}
 
-      int nel = 0;
-      for (int j = 0; j < nr; j++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nr; j++)
 	if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
 	  nel++;
 
       result = SparseComplexMatrix (nr, 1, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
-      for (int j = 0; j < nr; j++)
+      for (octave_idx_type j = 0; j < nr; j++)
 	{
 	  if (idx_arg(j) == -1)
 	    {
 	      idx_arg(j) = 0;
 	      result.xdata (ii) = Complex_NaN_result;
 	      result.xridx (ii++) = j;
 	    }
 	  else
@@ -490,154 +490,154 @@ SparseComplexMatrix::min (Array2<int>& i
     }
 
   return result;
 }
 
 // destructive insert/delete/reorder operations
 
 SparseComplexMatrix&
-SparseComplexMatrix::insert (const SparseMatrix& a, int r, int c)
+SparseComplexMatrix::insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   SparseComplexMatrix tmp (a);
   return insert (a, r, c);
 }
 
 SparseComplexMatrix&
-SparseComplexMatrix::insert (const SparseComplexMatrix& a, int r, int c)
+SparseComplexMatrix::insert (const SparseComplexMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   MSparse<Complex>::insert (a, r, c);
   return *this;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::concat (const SparseComplexMatrix& rb, 
-			     const Array<int>& ra_idx)
+			     const Array<octave_idx_type>& ra_idx)
 {
   // Don't use numel to avoid all possiblity of an overflow
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (rb, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::concat (const SparseMatrix& rb, const Array<int>& ra_idx)
+SparseComplexMatrix::concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx)
 {
   SparseComplexMatrix tmp (rb);
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (tmp, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 ComplexMatrix
 SparseComplexMatrix::matrix_value (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   ComplexMatrix retval (nr, nc, Complex (0.0, 0.0));
 
-  for (int j = 0; j < nc; j++)
-    for (int i = cidx(j); i < cidx(j+1); i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
       retval.elem (ridx(i), j) = data (i);
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::hermitian (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
   SparseComplexMatrix retval (nc, nr, nz);
 
   retval.cidx(0) = 0;
-  for (int i = 0, iidx = 0; i < nr; i++)
+  for (octave_idx_type i = 0, iidx = 0; i < nr; i++)
     {
-      for (int j = 0; j < nc; j++)
-	for (int k = cidx(j); k < cidx(j+1); k++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
 	  if (ridx(k) == i)
 	    {
 	      retval.data(iidx) = conj (data(k));
 	      retval.ridx(iidx++) = j;
 	    }
       retval.cidx(i+1) = iidx;
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 conj (const SparseComplexMatrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
-  int nz = a.nnz ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type nz = a.nnz ();
   SparseComplexMatrix retval (nc, nr, nz);
 
-  for (int i = 0; i < nc + 1; i++)
+  for (octave_idx_type i = 0; i < nc + 1; i++)
     retval.cidx (i) = a.cidx (i);
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     {
       retval.data (i) = conj (a.data (i));
       retval.ridx (i) = a.ridx (i);
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::inverse (void) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return inverse (info, rcond, 0, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::inverse (int& info) const
+SparseComplexMatrix::inverse (octave_idx_type& info) const
 {
   double rcond;
   return inverse (info, rcond, 0, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::inverse (int& info, double& rcond, int force, 
+SparseComplexMatrix::inverse (octave_idx_type& info, double& rcond, int force, 
 			int calc_cond) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseComplexMatrix::inverse not implemented yet");
   return SparseComplexMatrix ();
 }
 
 ComplexDET
 SparseComplexMatrix::determinant (void) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 ComplexDET
-SparseComplexMatrix::determinant (int& info) const
+SparseComplexMatrix::determinant (octave_idx_type& info) const
 {
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 ComplexDET
-SparseComplexMatrix::determinant (int& err, double& rcond, int calc_cond) const
+SparseComplexMatrix::determinant (octave_idx_type& err, double& rcond, int calc_cond) const
 {
   ComplexDET retval;
 #ifdef HAVE_UMFPACK
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       Complex d[2];
       d[0] = 1.0;
       d[1] = 0.0;
       retval = ComplexDET (d);
     }
@@ -666,18 +666,18 @@ SparseComplexMatrix::determinant (int& e
       if (!xisnan (tmp))
 	Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU 
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       umfpack_zi_report_control (control);
 
-      const int *Ap = cidx ();
-      const int *Ai = ridx ();
+      const octave_idx_type *Ap = cidx ();
+      const octave_idx_type *Ai = ridx ();
       const Complex *Ax = data ();
 
       umfpack_zi_report_matrix (nr, nc, Ap, Ai, 
 				X_CAST (const double *, Ax), 
 				NULL, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
@@ -748,49 +748,49 @@ SparseComplexMatrix::determinant (int& e
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::dsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseComplexMatrix::dsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 			     double& rcond, solve_singularity_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  retval.resize (b.rows (), b.cols());
 	  if (typ == SparseType::Diagonal)
-	    for (int j = 0; j < b.cols(); j++)
-	      for (int i = 0; i < nr; i++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
-	    for (int j = 0; j < b.cols(); j++)
-	      for (int i = 0; i < nr; i++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		retval(i,j) = b(ridx(i),j) / data (i);
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = std::abs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -799,77 +799,77 @@ SparseComplexMatrix::dsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const SparseMatrix& b,
-		       int& err, double& rcond, solve_singularity_handler) const
+		       octave_idx_type& err, double& rcond, solve_singularity_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
+	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
-	    for (int j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
-	    for (int j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (int i = 0; i < nr; i++)
+		for (octave_idx_type i = 0; i < nr; i++)
 		  {
 		    bool found = false;
-		    int k;
+		    octave_idx_type k;
 		    for (k = b.cidx(j); k < b.cidx(j+1); k++)
 		      if (ridx(i) == b.ridx(k))
 			{
 			  found = true;
 			  break;
 			}
 		    if (found)
 		      {
 			retval.xridx (ii) = i;
 			retval.xdata (ii++) = b.data(k) / data (i);
 		      }
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = std::abs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -878,48 +878,48 @@ SparseComplexMatrix::dsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b,
-		     int& err, double& rcond, solve_singularity_handler) const
+		     octave_idx_type& err, double& rcond, solve_singularity_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  retval.resize (b.rows (), b.cols());
 	  if (typ == SparseType::Diagonal)
-	    for (int j = 0; j < b.cols(); j++)
-	      for (int i = 0; i < nr; i++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
-	    for (int j = 0; j < b.cols(); j++)
-	      for (int i = 0; i < nr; i++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		retval(i,j) = b(ridx(i),j) / data (i);
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = std::abs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -928,78 +928,78 @@ SparseComplexMatrix::dsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
+	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
-	    for (int j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
-	    for (int j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (int i = 0; i < nr; i++)
+		for (octave_idx_type i = 0; i < nr; i++)
 		  {
 		    bool found = false;
-		    int k;
+		    octave_idx_type k;
 		    for (k = b.cidx(j); k < b.cidx(j+1); k++)
 		      if (ridx(i) == b.ridx(k))
 			{
 			  found = true;
 			  break;
 			}
 		    if (found)
 		      {
 			retval.xridx (ii) = i;
 			retval.xdata (ii++) = b.data(k) / data (i);
 		      }
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = std::abs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1007,182 +1007,182 @@ SparseComplexMatrix::dsolve (SparseType 
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::utsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseComplexMatrix::utsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		       double& rcond,
 		       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  int b_cols = b.cols ();
+	  octave_idx_type b_cols = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx+1)-1) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    retval (i, j) = work[p_perm[i]];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = ComplexMatrix (b);
 	      Complex *x_vec = retval.fortran_vec ();
 
-	      for (int j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
-		  int offset = j * nr;
-		  for (int k = nr-1; k >= 0; k--)
+		  octave_idx_type offset = j * nr;
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (x_vec[k+offset] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = x_vec[k+offset] / 
 			    data(cidx(k+1)-1);
 			  x_vec[k+offset] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      x_vec[iidx+offset] = 
 				x_vec[iidx+offset] - tmp * data(i);
 			    }
 			}
 		    }
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -1218,23 +1218,23 @@ SparseComplexMatrix::utsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const SparseMatrix& b,
-			int& err, double& rcond, 
+			octave_idx_type& err, double& rcond, 
 			solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -1244,210 +1244,210 @@ SparseComplexMatrix::utsolve (SparseType
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
-	  int x_nz = b_nz;
+	  octave_idx_type ii = 0;
+	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx+1)-1) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[p_perm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[p_perm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -1482,182 +1482,182 @@ SparseComplexMatrix::utsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  int b_nc = b.cols ();
+	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx+1)-1) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    retval (i, j) = work[p_perm[i]];
 
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = b;
 	      Complex *x_vec = retval.fortran_vec ();
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  int offset = j * nr;
-		  for (int k = nr-1; k >= 0; k--)
+		  octave_idx_type offset = j * nr;
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (x_vec[k+offset] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = x_vec[k+offset] / 
 			    data(cidx(k+1)-1);
 			  x_vec[k+offset] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      x_vec[iidx+offset] = 
 				x_vec[iidx+offset] - tmp * data(i);
 			    }
 			}
 		    }
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -1693,23 +1693,23 @@ SparseComplexMatrix::utsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -1719,210 +1719,210 @@ SparseComplexMatrix::utsolve (SparseType
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
-	  int x_nz = b_nz;
+	  octave_idx_type ii = 0;
+	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx+1)-1) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[p_perm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[p_perm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -1957,183 +1957,183 @@ SparseComplexMatrix::utsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::ltsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseComplexMatrix::ltsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		   double& rcond, solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  int b_cols = b.cols ();
+	  octave_idx_type b_cols = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx)) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    retval (i, j) = work[p_perm[i]];
 
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = ComplexMatrix (b);
 	      Complex *x_vec = retval.fortran_vec ();
 
-	      for (int j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
-		  int offset = j * nr;
-		  for (int k = 0; k < nr; k++)
+		  octave_idx_type offset = j * nr;
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
 		      if (x_vec[k+offset] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = x_vec[k+offset] / 
 			    data(cidx(k));
 			  x_vec[k+offset] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      x_vec[iidx+offset] = 
 				x_vec[iidx+offset] - tmp * data(i);
 			    }
 			}
 		    }
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nr; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2169,23 +2169,23 @@ SparseComplexMatrix::ltsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, 
-			int& err, double& rcond, 
+			octave_idx_type& err, double& rcond, 
 			solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -2195,211 +2195,211 @@ SparseComplexMatrix::ltsolve (SparseType
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
-	  int x_nz = b_nz;
+	  octave_idx_type ii = 0;
+	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx)) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[p_perm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[p_perm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nr; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2436,183 +2436,183 @@ SparseComplexMatrix::ltsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b,
-			int& err, double& rcond,
+			octave_idx_type& err, double& rcond,
 			solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  int b_nc = b.cols ();
+	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx)) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    retval (i, j) = work[p_perm[i]];
 
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = b;
 	      Complex *x_vec = retval.fortran_vec ();
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  int offset = j * nr;
-		  for (int k = 0; k < nr; k++)
+		  octave_idx_type offset = j * nr;
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
 		      if (x_vec[k+offset] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = x_vec[k+offset] / 
 			    data(cidx(k));
 			  x_vec[k+offset] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      x_vec[iidx+offset] = 
 				x_vec[iidx+offset] - tmp * data(i);
 			    }
 			}
 		    }
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nr; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2649,23 +2649,23 @@ SparseComplexMatrix::ltsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -2675,211 +2675,211 @@ SparseComplexMatrix::ltsolve (SparseType
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
-	  int x_nz = b_nz;
+	  octave_idx_type ii = 0;
+	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx)) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[p_perm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[p_perm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nr; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2915,24 +2915,24 @@ SparseComplexMatrix::ltsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::trisolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseComplexMatrix::trisolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 			       double& rcond,
 			       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -2941,46 +2941,46 @@ SparseComplexMatrix::trisolve (SparseTyp
       
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii);
 		  ii += 2;
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		  }
 	    }
 	      
-	  int b_nc = b.cols();
+	  octave_idx_type b_nc = b.cols();
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 
 	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
 				   b.rows(), err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
@@ -2998,49 +2998,49 @@ SparseComplexMatrix::trisolve (SparseTyp
       if (typ == SparseType::Tridiagonal)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii++);
 		  DU[j] = data(ii++);
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		  DU[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j] = data(i);
 		  }
 	    }
 
-	  int b_nc = b.cols();
+	  octave_idx_type b_nc = b.cols();
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 
 	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
 				   b.rows(), err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
@@ -3064,23 +3064,23 @@ SparseComplexMatrix::trisolve (SparseTyp
 	       (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::trisolve (SparseType &mattype, const SparseMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -3090,43 +3090,43 @@ SparseComplexMatrix::trisolve (SparseTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal ||
 	  typ == SparseType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii++);
 		  DU[j] = data(ii++);
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		  DU[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j] = data(i);
 		  }
@@ -3149,29 +3149,29 @@ SparseComplexMatrix::trisolve (SparseTyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile int x_nz = b.nnz ();
-		  int b_nc = b.cols ();
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
-		  volatile int ii = 0;
+		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			work[i] = 0.;
-		      for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 			work[b.ridx(i)] = b.data(i);
 
 		      F77_XFCN (zgttrs, ZGTTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, 1, DL, D, DU, DU2, pipvt, 
 				 work, b.rows (), err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -3179,30 +3179,30 @@ SparseComplexMatrix::trisolve (SparseTyp
 			{
 			  (*current_liboctave_error_handler)
 			    ("unrecoverable error in zgttrs");
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (work[i] != 0.)
 			  new_nnz++;
 
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (work[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = work[i];
 			  }
 		      retval.xcidx(j+1) = ii;
 		    }
 
@@ -3214,23 +3214,23 @@ SparseComplexMatrix::trisolve (SparseTyp
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::trisolve (SparseType &mattype, const ComplexMatrix& b,
-			       int& err, double& rcond, 
+			       octave_idx_type& err, double& rcond, 
 			       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -3240,47 +3240,47 @@ SparseComplexMatrix::trisolve (SparseTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii);
 		  ii += 2;
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		  }
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols();
 	  rcond = 1.;
 
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 		  
 	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
 				   b_nr, err));
 
@@ -3301,50 +3301,50 @@ SparseComplexMatrix::trisolve (SparseTyp
       if (typ == SparseType::Tridiagonal)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii++);
 		  DU[j] = data(ii++);
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		  DU[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j] = data(i);
 		  }
 	    }
 
-	  int b_nr = b.rows();
-	  int b_nc = b.cols();
+	  octave_idx_type b_nr = b.rows();
+	  octave_idx_type b_nc = b.cols();
 	  rcond = 1.;
 
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 	      
 	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
 				   b_nr, err));
 
@@ -3370,23 +3370,23 @@ SparseComplexMatrix::trisolve (SparseTyp
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::trisolve (SparseType &mattype, 
-		     const SparseComplexMatrix& b, int& err, double& rcond, 
+		     const SparseComplexMatrix& b, octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -3396,43 +3396,43 @@ SparseComplexMatrix::trisolve (SparseTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal ||
 	  typ == SparseType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii++);
 		  DU[j] = data(ii++);
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		  DU[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j] = data(i);
 		  }
@@ -3455,31 +3455,31 @@ SparseComplexMatrix::trisolve (SparseTyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 		} 
 	      else 
 		{	
 		  rcond = 1.;
 		  char job = 'N';
-		  int b_nr = b.rows ();
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile int x_nz = b.nnz ();
-		  volatile int ii = 0;
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			Bx[i] = b (i,j);
 
 		      F77_XFCN (zgttrs, ZGTTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, 1, DL, D, DU, DU2, pipvt, 
 				 Bx, b_nr, err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -3496,30 +3496,30 @@ SparseComplexMatrix::trisolve (SparseTyp
 			    ("SparseComplexMatrix::solve solve failed");
 
 			  err = -1;
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0.)
 			  new_nnz++;
 		      
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 			  
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = Bx[i];
 			  }
 
 		      retval.xcidx(j+1) = ii;
 		    }
@@ -3531,55 +3531,55 @@ SparseComplexMatrix::trisolve (SparseTyp
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::bsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseComplexMatrix::bsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Banded_Hermitian)
 	{
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_lower + 1;
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_lower + 1;
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
-		int ri = ridx (i);
+		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  // Calculate the norm of the matrix, for later use.
 	  // double anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
@@ -3606,18 +3606,18 @@ SparseComplexMatrix::bsolve (SparseType 
 		  // Unfortunately, the time to calculate the condition
 		  // number is dominant for narrow banded matrices and
 		  // so we rely on the "err" flag from xPBTRF to flag
 		  // singularity. The commented code below is left here
 		  // for reference
 
 		  //Array<double> z (3 * nr);
 		  //Complex *pz = z.fortran_vec ();
-		  //Array<int> iz (nr);
-		  //int *piz = iz.fortran_vec ();
+		  //Array<octave_idx_type> iz (nr);
+		  //octave_idx_type *piz = iz.fortran_vec ();
 		  //
 		  //F77_XFCN (zpbcon, ZGBCON, 
 		  //	(F77_CONST_CHAR_ARG2 (&job, 1),
 		  //	 nr, n_lower, tmp_data, ldm,
 		  //	 anorm, rcond, pz, piz, err
 		  //	 F77_CHAR_ARG_LEN (1)));
 		  //
 		  //
@@ -3643,17 +3643,17 @@ SparseComplexMatrix::bsolve (SparseType 
 		  //  }
 		  //else
 		  //    REST OF CODE, EXCEPT rcond=1
 
 		  rcond = 1.;
 		  retval = ComplexMatrix (b);
 		  Complex *result = retval.fortran_vec ();
 
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nc = b.cols ();
 
 		  F77_XFCN (zpbtrs, ZPBTRS, 
 			    (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nr, n_lower, b_nc, tmp_data,
 			     ldm, result, b.rows(), err
 			     F77_CHAR_ARG_LEN (1)));
 		    
 		  if (f77_exception_encountered)
@@ -3668,38 +3668,38 @@ SparseComplexMatrix::bsolve (SparseType 
 		    }
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
-	  int n_upper = mattype.nupper ();
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_upper + 2 * n_lower + 1;
+	  octave_idx_type n_upper = mattype.nupper ();
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgbtrf");
 	  else
@@ -3756,17 +3756,17 @@ SparseComplexMatrix::bsolve (SparseType 
 		  //  }
 		  //else
 		  //  REST OF CODE, EXCEPT rcond=1
 
 		  rcond = 1.;
 		  retval = ComplexMatrix (b);
 		  Complex *result = retval.fortran_vec ();
 
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nc = b.cols ();
 
 		  job = 'N';
 		  F77_XFCN (zgbtrs, ZGBTRS, 
 			    (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nr, n_lower, n_upper, b_nc, tmp_data,
 			     ldm, pipvt, result, b.rows(), err
 			     F77_CHAR_ARG_LEN (1)));
 		    
@@ -3780,55 +3780,55 @@ SparseComplexMatrix::bsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::bsolve (SparseType &mattype, const SparseMatrix& b,
-			     int& err, double& rcond, 
+			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Banded_Hermitian)
 	{
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_lower + 1;
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
-		int ri = ridx (i);
+		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
@@ -3843,30 +3843,30 @@ SparseComplexMatrix::bsolve (SparseType 
 		{
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
 		  rcond = 1.;
-		  int b_nr = b.rows ();
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile int x_nz = b.nnz ();
-		  volatile int ii = 0;
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			Bx[i] = b.elem (i, j);
 
 		      F77_XFCN (zpbtrs, ZPBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, n_lower, 1, tmp_data,
 				 ldm, Bx, b_nr, err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -3881,25 +3881,25 @@ SparseComplexMatrix::bsolve (SparseType 
 		      if (err != 0)
 			{
 			  (*current_liboctave_error_handler) 
 			    ("SparseComplexMatrix::solve solve failed");
 			  err = -1;
 			  break;
 			}
 
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			{
 			  Complex tmp = Bx[i];
 			  if (tmp != 0.0)
 			    {
 			      if (ii == x_nz)
 				{
 				  // Resize the sparse matrix
-				  int sz = x_nz * (b_nc - j) / b_nc;
+				  octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
 				  sz = (sz > 10 ? sz : 10) + x_nz;
 				  retval.change_capacity (sz);
 				  x_nz = sz;
 				}
 			      retval.xdata(ii) = tmp;
 			      retval.xridx(ii++) = i;
 			    }
 			}
@@ -3909,38 +3909,38 @@ SparseComplexMatrix::bsolve (SparseType 
 		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
-	  int n_upper = mattype.nupper ();
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_upper + 2 * n_lower + 1;
+	  octave_idx_type n_upper = mattype.nupper ();
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgbtrf");
 	  else
@@ -3955,29 +3955,29 @@ SparseComplexMatrix::bsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile int x_nz = b.nnz ();
-		  int b_nc = b.cols ();
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
-		  volatile int ii = 0;
+		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			work[i] = 0.;
-		      for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 			work[b.ridx(i)] = b.data(i);
 
 		      F77_XFCN (zgbtrs, ZGBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, n_lower, n_upper, 1, tmp_data,
 				 ldm, pipvt, work, b.rows (), err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -3985,30 +3985,30 @@ SparseComplexMatrix::bsolve (SparseType 
 			{
 			  (*current_liboctave_error_handler)
 			    ("unrecoverable error in zgbtrs");
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (work[i] != 0.)
 			  new_nnz++;
 
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (work[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = work[i];
 			  }
 		      retval.xcidx(j+1) = ii;
 		    }
 
@@ -4020,55 +4020,55 @@ SparseComplexMatrix::bsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::bsolve (SparseType &mattype, const ComplexMatrix& b, 
-			     int& err, double& rcond, 
+			     octave_idx_type& err, double& rcond, 
 			     solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Banded_Hermitian)
 	{
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_lower + 1;
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
-		int ri = ridx (i);
+		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
@@ -4085,18 +4085,18 @@ SparseComplexMatrix::bsolve (SparseType 
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
 		  rcond = 1.;
-		  int b_nr = b.rows ();
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval = ComplexMatrix (b);
 		  Complex *result = retval.fortran_vec ();
 
 		  F77_XFCN (zpbtrs, ZPBTRS, 
 			    (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nr, n_lower, b_nc, tmp_data,
 			     ldm, result, b_nr, err
 			     F77_CHAR_ARG_LEN (1)));
@@ -4116,38 +4116,38 @@ SparseComplexMatrix::bsolve (SparseType 
 		    }
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
-	  int n_upper = mattype.nupper ();
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_upper + 2 * n_lower + 1;
+	  octave_idx_type n_upper = mattype.nupper ();
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgbtrf");
 	  else
@@ -4162,17 +4162,17 @@ SparseComplexMatrix::bsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval = ComplexMatrix (b);
 		  Complex *result = retval.fortran_vec ();
 
 		  F77_XFCN (zgbtrs, ZGBTRS, 
 			    (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nr, n_lower, n_upper, b_nc, tmp_data,
 			     ldm, pipvt, result, b.rows (), err
 			     F77_CHAR_ARG_LEN (1)));
@@ -4189,55 +4189,55 @@ SparseComplexMatrix::bsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::bsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Banded_Hermitian)
 	{
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_lower + 1;
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
-		int ri = ridx (i);
+		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
@@ -4255,31 +4255,31 @@ SparseComplexMatrix::bsolve (SparseType 
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 
 		  err = 0;
 		} 
 	      else 
 		{
 		  rcond = 1.;
-		  int b_nr = b.rows ();
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile int x_nz = b.nnz ();
-		  volatile int ii = 0;
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			Bx[i] = b (i,j);
 
 		      F77_XFCN (zpbtrs, ZPBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, n_lower, 1, tmp_data,
 				 ldm, Bx, b_nr, err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -4297,30 +4297,30 @@ SparseComplexMatrix::bsolve (SparseType 
 			    ("SparseMatrix::solve solve failed");
 			  err = -1;
 			  break;
 			}
 
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0.)
 			  new_nnz++;
 			  
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 			  
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = Bx[i];
 			  }
 
 		      retval.xcidx(j+1) = ii;
 		    }
@@ -4328,38 +4328,38 @@ SparseComplexMatrix::bsolve (SparseType 
 		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
-	  int n_upper = mattype.nupper ();
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_upper + 2 * n_lower + 1;
+	  octave_idx_type n_upper = mattype.nupper ();
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  ComplexMatrix m_band (ldm, nc);
 	  Complex *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in xgbtrf");
 	  else
@@ -4374,30 +4374,30 @@ SparseComplexMatrix::bsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		}
 	      else 
 		{
 		  char job = 'N';
-		  volatile int x_nz = b.nnz ();
-		  int b_nc = b.cols ();
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
-		  volatile int ii = 0;
+		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
 
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			Bx[i] = 0.;
 
-		      for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 			Bx[b.ridx(i)] = b.data(i);
 
 		      F77_XFCN (zgbtrs, ZGBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, n_lower, n_upper, 1, tmp_data,
 				 ldm, pipvt, Bx, b.rows (), err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -4405,30 +4405,30 @@ SparseComplexMatrix::bsolve (SparseType 
 			{
 			  (*current_liboctave_error_handler)
 			    ("unrecoverable error in dgbtrs");
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0.)
 			  new_nnz++;
 
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = Bx[i]; 
 			  }
 		      retval.xcidx(j+1) = ii;
 		    }
 
@@ -4439,17 +4439,17 @@ SparseComplexMatrix::bsolve (SparseType 
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 void *
-SparseComplexMatrix::factorize (int& err, double &rcond, Matrix &Control, 
+SparseComplexMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control, 
 				Matrix &Info,
 				solve_singularity_handler sing_handler) const
 {
   // The return values
   void *Numeric;
   err = 0;
 
 #ifdef HAVE_UMFPACK
@@ -4470,21 +4470,21 @@ SparseComplexMatrix::factorize (int& err
 
   // Set whether we are allowed to modify Q or not
   tmp = Voctave_sparse_controls.get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   umfpack_zi_report_control (control);
 
-  const int *Ap = cidx ();
-  const int *Ai = ridx ();
+  const octave_idx_type *Ap = cidx ();
+  const octave_idx_type *Ai = ridx ();
   const Complex *Ax = data ();
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   umfpack_zi_report_matrix (nr, nc, Ap, Ai, X_CAST (const double *, Ax), 
 			    NULL, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = umfpack_zi_qsymbolic (nr, nc, Ap, Ai, 
@@ -4552,24 +4552,24 @@ SparseComplexMatrix::factorize (int& err
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 ComplexMatrix
-SparseComplexMatrix::fsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseComplexMatrix::fsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -4592,47 +4592,47 @@ SparseComplexMatrix::fsolve (SparseType 
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler);
 
 	  if (err == 0)
 	    {
-	      int b_nr = b.rows ();
-	      int b_nc = b.cols ();
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
-	      const int *Ap = cidx ();
-	      const int *Ai = ridx ();
+	      const octave_idx_type *Ap = cidx ();
+	      const octave_idx_type *Ai = ridx ();
 	      const Complex *Ax = data ();
 #ifdef UMFPACK_SEPARATE_SPLIT
 	      const double *Bx = b.fortran_vec ();
 	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-	      for (int i = 0; i < b_nr; i++)
+	      for (octave_idx_type i = 0; i < b_nr; i++)
 		Bz[i] = 0.;
 #else
 	      OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
 	      retval.resize (b_nr, b_nc);
 	      Complex *Xx = retval.fortran_vec ();
 
-	      for (int j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
+	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 #ifdef UMFPACK_SEPARATE_SPLIT
 		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
 					     X_CAST (const double *, Ax), 
 					     NULL,
 					     X_CAST (double *, &Xx[iidx]), 
 					     NULL,
 					     &Bx[iidx], Bz, Numeric, 
 					     control, info);
 #else
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bz[i] = b.elem (i, j);
 
 		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
 					     X_CAST (const double *, Ax), 
 					     NULL,
 					     X_CAST (double *, &Xx[iidx]), 
 					     NULL,
 					     X_CAST (const double *, Bz),
@@ -4684,23 +4684,23 @@ SparseComplexMatrix::fsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::fsolve (SparseType &mattype, const SparseMatrix& b, 
-			     int& err, double& rcond,
+			     octave_idx_type& err, double& rcond,
 			     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -4722,58 +4722,58 @@ SparseComplexMatrix::fsolve (SparseType 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, sing_handler);
 
 	  if (err == 0)
 	    {
-	      int b_nr = b.rows ();
-	      int b_nc = b.cols ();
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
-	      const int *Ap = cidx ();
-	      const int *Ai = ridx ();
+	      const octave_idx_type *Ap = cidx ();
+	      const octave_idx_type *Ai = ridx ();
 	      const Complex *Ax = data ();
 
 #ifdef UMFPACK_SEPARATE_SPLIT
 	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-	      for (int i = 0; i < b_nr; i++)
+	      for (octave_idx_type i = 0; i < b_nr; i++)
 		Bz[i] = 0.;
 #else
 	      OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      int x_nz = b.nnz ();
-	      int ii = 0;
+	      octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 	      
 	      retval.xcidx(0) = 0;
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 
 #ifdef UMFPACK_SEPARATE_SPLIT
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b.elem (i, j);
 
 		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
 					     X_CAST (const double *, Ax),
 					     NULL,
 					     X_CAST (double *, Xx), NULL, 
 					     Bx, Bz, Numeric, control, 
 					     info);
 #else
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bz[i] = b.elem (i, j);
 
 		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
 					     X_CAST (const double *, Ax),
 					     NULL,
 					     X_CAST (double *, Xx), NULL, 
 					     X_CAST (double *, Bz), NULL,
 					     Numeric, control, 
@@ -4786,25 +4786,25 @@ SparseComplexMatrix::fsolve (SparseType 
 
 		      umfpack_zi_report_status (control, status);
 		      
 		      err = -1;
 
 		      break;
 		    }
 
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
 		      Complex tmp = Xx[i];
 		      if (tmp != 0.0)
 			{
 			  if (ii == x_nz)
 			    {
 			      // Resize the sparse matrix
-			      int sz = x_nz * (b_nc - j) / b_nc;
+			      octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
 			      sz = (sz > 10 ? sz : 10) + x_nz;
 			      retval.change_capacity (sz);
 			      x_nz = sz;
 			    }
 			  retval.xdata(ii) = tmp;
 			  retval.xridx(ii++) = i;
 			}
 		    }
@@ -4844,23 +4844,23 @@ SparseComplexMatrix::fsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::fsolve (SparseType &mattype, const ComplexMatrix& b, 
-			     int& err, double& rcond,
+			     octave_idx_type& err, double& rcond,
 			     solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -4882,30 +4882,30 @@ SparseComplexMatrix::fsolve (SparseType 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, sing_handler);
 
 	  if (err == 0)
 	    {
-	      int b_nr = b.rows ();
-	      int b_nc = b.cols ();
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
-	      const int *Ap = cidx ();
-	      const int *Ai = ridx ();
+	      const octave_idx_type *Ap = cidx ();
+	      const octave_idx_type *Ai = ridx ();
 	      const Complex *Ax = data ();
 	      const Complex *Bx = b.fortran_vec ();
 
 	      retval.resize (b_nr, b_nc);
 	      Complex *Xx = retval.fortran_vec ();
 	      
-	      for (int j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
+	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 		  status = 
 		    umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
 				      X_CAST (const double *, Ax), 
 				      NULL, X_CAST (double *, &Xx[iidx]), 
 				      NULL, X_CAST (const double *, &Bx[iidx]), 
 				      NULL, Numeric, control, info);
 		  
@@ -4953,23 +4953,23 @@ SparseComplexMatrix::fsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::fsolve (SparseType &mattype, const SparseComplexMatrix& b,
-			     int& err, double& rcond,
+			     octave_idx_type& err, double& rcond,
 			     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -4991,39 +4991,39 @@ SparseComplexMatrix::fsolve (SparseType 
       if (typ == SparseType::Full)
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, sing_handler);
 
 	  if (err == 0)
 	    {
-	      int b_nr = b.rows ();
-	      int b_nc = b.cols ();
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
-	      const int *Ap = cidx ();
-	      const int *Ai = ridx ();
+	      const octave_idx_type *Ap = cidx ();
+	      const octave_idx_type *Ai = ridx ();
 	      const Complex *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      int x_nz = b.nnz ();
-	      int ii = 0;
+	      octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 	      
 	      retval.xcidx(0) = 0;
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b (i,j);
 
 		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
 					     X_CAST (const double *, Ax), 
 					     NULL, X_CAST (double *, Xx), 
 					     NULL, X_CAST (double *, Bx), 
 					     NULL, Numeric, control, info);
 		  
@@ -5034,25 +5034,25 @@ SparseComplexMatrix::fsolve (SparseType 
 
 		      umfpack_zi_report_status (control, status);
 		  
 		      err = -1;
 
 		      break;
 		    }
 
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
 		      Complex tmp = Xx[i];
 		      if (tmp != 0.0)
 			{
 			  if (ii == x_nz)
 			    {
 			      // Resize the sparse matrix
-			      int sz = x_nz * (b_nc - j) / b_nc;
+			      octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
 			      sz = (sz > 10 ? sz : 10) + x_nz;
 			      retval.change_capacity (sz);
 			      x_nz = sz;
 			    }
 			  retval.xdata(ii) = tmp;
 			  retval.xridx(ii++) = i;
 			}
 		    }
@@ -5093,38 +5093,38 @@ SparseComplexMatrix::fsolve (SparseType 
     }
   
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b, 
-			    int& info) const
+			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b, int& info, 
+SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& info, 
 			    double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b, int& err, 
+SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 			    double& rcond, 
 			    solve_singularity_handler sing_handler) const
 {
   int typ = mattype.type ();
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
@@ -5147,39 +5147,39 @@ SparseComplexMatrix::solve (SparseType &
 	("matrix dimension mismatch solution of linear equations");
       return ComplexMatrix ();
     }
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
-		     int& info) const
+		     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b,
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
-			    int& err, double& rcond,
+			    octave_idx_type& err, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   int typ = mattype.type ();
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
@@ -5201,39 +5201,39 @@ SparseComplexMatrix::solve (SparseType &
 	("matrix dimension mismatch solution of linear equations");
       return SparseComplexMatrix ();
     }
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
-			    int& info) const
+			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   int typ = mattype.type ();
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
@@ -5256,39 +5256,39 @@ SparseComplexMatrix::solve (SparseType &
       return ComplexMatrix ();
     }
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, 
 			    const SparseComplexMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
-		     int& info) const
+		     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
-			    int& err, double& rcond,
+			    octave_idx_type& err, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   int typ = mattype.type ();
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
@@ -5310,421 +5310,421 @@ SparseComplexMatrix::solve (SparseType &
 	("matrix dimension mismatch solution of linear equations");
       return SparseComplexMatrix ();
     }
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b) const
 {
-  int info; double rcond;
+  octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b, 
-			    int& info) const
+			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b, 
-			    int& info, double& rcond) const
+			    octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, const ColumnVector& b, 
-			    int& info, double& rcond,
+			    octave_idx_type& info, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (mattype, tmp, info, rcond, sing_handler).column (0);
+  return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, 
 			    const ComplexColumnVector& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexColumnVector& b,
-			    int& info) const
+			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexColumnVector& b,
-			    int& info, double& rcond) const
+			    octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexColumnVector& b,
-			    int& info, double& rcond,
+			    octave_idx_type& info, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (mattype, tmp, info, rcond, sing_handler).column (0);
+  return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (const Matrix& b, int& info) const
+SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (const Matrix& b, int& info, 
+SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info, 
 		     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (const Matrix& b, int& err, 
+SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& err, 
 			    double& rcond, 
 			    solve_singularity_handler sing_handler) const
 {
   SparseType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b, 
-		     int& info) const
+		     octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b, 
-		     int& err, double& rcond,
+		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
   SparseType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b, 
-			    int& info) const
+			    octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b, 
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b, 
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b, 
-		     int& info) const
+		     octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b, 
-		     int& err, double& rcond,
+		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
   SparseType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b) const
 {
-  int info; double rcond;
+  octave_idx_type info; double rcond;
   return solve (b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ColumnVector& b, int& info) const
+SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ColumnVector& b, int& info, 
+SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
 			    double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ColumnVector& b, int& info, double& rcond,
+SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler).column (0);
+  return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ComplexColumnVector& b, int& info) const
+SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ComplexColumnVector& b, int& info, 
+SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
 		     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ComplexColumnVector& b, int& info, 
+SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
 			    double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler).column (0);
+  return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 SparseComplexMatrix::lssolve (const Matrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
-SparseComplexMatrix::lssolve (const Matrix& b, int& info) const
+SparseComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
-SparseComplexMatrix::lssolve (const Matrix& b, int& info, int& rank) const
+SparseComplexMatrix::lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseComplexMatrix::lssolve not implemented yet");
   return ComplexMatrix ();
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::lssolve (const SparseMatrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseMatrix& b, int& info) const
+SparseComplexMatrix::lssolve (const SparseMatrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseMatrix& b, int& info, 
-			      int& rank) const
+SparseComplexMatrix::lssolve (const SparseMatrix& b, octave_idx_type& info, 
+			      octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseComplexMatrix::lssolve not implemented yet");
   return SparseComplexMatrix ();
 }
 
 ComplexMatrix
 SparseComplexMatrix::lssolve (const ComplexMatrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
-SparseComplexMatrix::lssolve (const ComplexMatrix& b, int& info) const
+SparseComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
-SparseComplexMatrix::lssolve (const ComplexMatrix& b, int& info, 
-			      int& rank) const
+SparseComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
+			      octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseComplexMatrix::lssolve not implemented yet");
   return ComplexMatrix ();
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::lssolve (const SparseComplexMatrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseComplexMatrix& b, int& info) const
+SparseComplexMatrix::lssolve (const SparseComplexMatrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::lssolve (const SparseComplexMatrix& b, int& info, 
-			      int& rank) const
+SparseComplexMatrix::lssolve (const SparseComplexMatrix& b, octave_idx_type& info, 
+			      octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseComplexMatrix::lssolve not implemented yet");
   return SparseComplexMatrix ();
 }
 
 ComplexColumnVector
 SparseComplexMatrix::lssolve (const ColumnVector& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::lssolve (const ColumnVector& b, int& info) const
+SparseComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::lssolve (const ColumnVector& b, int& info, int& rank) const
+SparseComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseComplexMatrix::lssolve not implemented yet");
   return ComplexColumnVector ();
 }
 
 ComplexColumnVector
 SparseComplexMatrix::lssolve (const ComplexColumnVector& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::lssolve (const ComplexColumnVector& b, int& info) const
+SparseComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::lssolve (const ComplexColumnVector& b, int& info,
-			int& rank) const
+SparseComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
+			octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseComplexMatrix::lssolve not implemented yet");
   return ComplexColumnVector ();
 }
 
 // unary operations
 SparseBoolMatrix
 SparseComplexMatrix::operator ! (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz1 = nnz ();
-  int nz2 = nr*nc - nz1;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz1 = nnz ();
+  octave_idx_type nz2 = nr*nc - nz1;
    
   SparseBoolMatrix r (nr, nc, nz2);
    
-  int ii = 0;
-  int jj = 0;
+  octave_idx_type ii = 0;
+  octave_idx_type jj = 0;
   r.cidx (0) = 0;
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     {
-      for (int j = 0; j < nr; j++)
+      for (octave_idx_type j = 0; j < nr; j++)
 	{
 	  if (jj < cidx(i+1) && ridx(jj) == j)
 	    jj++;
 	  else
 	    {
 	      r.data(ii) = true;
 	      r.ridx(ii++) = j;
 	    }
@@ -5760,168 +5760,168 @@ SparseComplexMatrix::index (Array<idx_ve
 }
 SparseComplexMatrix
 SparseComplexMatrix::reshape (const dim_vector& new_dims) const
 {
   return MSparse<Complex>::reshape (new_dims);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::permute (const Array<int>& vec, bool inv) const
+SparseComplexMatrix::permute (const Array<octave_idx_type>& vec, bool inv) const
 {
   return MSparse<Complex>::permute (vec, inv);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::ipermute (const Array<int>& vec) const
+SparseComplexMatrix::ipermute (const Array<octave_idx_type>& vec) const
 {
   return MSparse<Complex>::ipermute (vec);
 }
 
 // other operations
 
 SparseComplexMatrix
 SparseComplexMatrix::map (c_c_Mapper f) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
-  int nel = (f_zero ? 0 : nr*nc - nz);
-  for (int i = 0; i < nz; i++)
+  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
+  for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
   SparseComplexMatrix retval (nr, nc, nel);
 
   if (f_zero)
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      Complex tmp = f (elem (i, j));
 	      if (tmp != 0.0)
 		{
 		  retval.data(ii) = tmp;
 		  retval.ridx(ii++) = i;
 		}
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
   else
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      retval.data(ii) = f (elem(i));
 	      retval.ridx(ii++) = ridx(i);
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseComplexMatrix::map (d_c_Mapper f) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
-  int nel = (f_zero ? 0 : nr*nc - nz);
-  for (int i = 0; i < nz; i++)
+  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
+  for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
   SparseMatrix retval (nr, nc, nel);
 
   if (f_zero)
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = f (elem (i, j));
 	      if (tmp != 0.0)
 		{
 		  retval.data(ii) = tmp;
 		  retval.ridx(ii++) = i;
 		}
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
   else
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      retval.data(ii) = f (elem(i));
 	      retval.ridx(ii++) = ridx(i);
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
 
   return retval;
 }
 
 SparseBoolMatrix
 SparseComplexMatrix::map (b_c_Mapper f) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
   bool f_zero = f(0.0);
 
   // Count number of non-zero elements
-  int nel = (f_zero ? 0 : nr*nc - nz);
-  for (int i = 0; i < nz; i++)
+  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
+  for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
   SparseBoolMatrix retval (nr, nc, nel);
 
   if (f_zero)
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      bool tmp = f (elem (i, j));
 	      if (tmp)
 		{
 		  retval.data(ii) = tmp;
 		  retval.ridx(ii++) = i;
 		}
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
   else
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      retval.data(ii) = f (elem(i));
 	      retval.ridx(ii++) = ridx(i);
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
 
@@ -5933,36 +5933,36 @@ SparseComplexMatrix::apply (c_c_Mapper f
 {
   *this = map (f);
   return *this;
 }
 
 bool
 SparseComplexMatrix::any_element_is_inf_or_nan (void) const
 {
-  int nel = nnz ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nnz ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
 
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
 SparseComplexMatrix::all_elements_are_real (void) const
 {
-  int nel = nnz ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nnz ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double ip = std::imag (data (i));
       
       if (ip != 0.0 || lo_ieee_signbit (ip))
 	return false;
     }
 
   return true;
@@ -5970,25 +5970,25 @@ SparseComplexMatrix::all_elements_are_re
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
 // imaginary) values and return them in MAX_VAL and MIN_VAL. 
 
 bool
 SparseComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
-  int nel = nnz ();
+  octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
 
   max_val = std::real(data (0));
   min_val = std::real(data (0));
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
 	Complex val = data (i);
 
 	double r_val = std::real (val);
 	double i_val = std::imag (val);
 
 	if (r_val > max_val)
 	  max_val = r_val;
@@ -6007,19 +6007,19 @@ SparseComplexMatrix::all_integers (doubl
     }
 
   return true;
 }
 
 bool
 SparseComplexMatrix::too_large_for_float (void) const
 {
-  int nel = nnz ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nnz ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
 	Complex val = data (i);
 
 	double r_val = std::real (val);
 	double i_val = std::imag (val);
 
 	if (r_val > FLT_MAX
 	    || i_val > FLT_MAX
@@ -6085,103 +6085,103 @@ SparseComplexMatrix::sumsq (int dim) con
 			    COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix SparseComplexMatrix::abs (void) const
 {
-  int nz = nnz ();
-  int nc = cols ();
+  octave_idx_type nz = nnz ();
+  octave_idx_type nc = cols ();
 
   SparseMatrix retval (rows(), nc, nz);
 
-  for (int i = 0; i < nc + 1; i++)
+  for (octave_idx_type i = 0; i < nc + 1; i++)
     retval.cidx (i) = cidx (i);
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     {
       retval.data (i) = std::abs (data (i));
       retval.ridx (i) = ridx (i);
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::diag (int k) const
+SparseComplexMatrix::diag (octave_idx_type k) const
 {
-  int nnr = rows ();
-  int nnc = cols ();
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
 
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   SparseComplexMatrix d;
 
   if (nnr > 0 && nnc > 0)
     {
-      int ndiag = (nnr < nnc) ? nnr : nnc;
+      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
       // Count the number of non-zero elements
-      int nel = 0;
+      octave_idx_type nel = 0;
       if (k > 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    if (elem (i, i+k) != 0.)
 	      nel++;
 	}
       else if ( k < 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    if (elem (i-k, i) != 0.)
 	      nel++;
 	}
       else
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    if (elem (i, i) != 0.)
 	      nel++;
 	}
       
       d = SparseComplexMatrix (ndiag, 1, nel);
       d.xcidx (0) = 0;
       d.xcidx (1) = nel;
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       if (k > 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    {
 	      Complex tmp = elem (i, i+k);
 	      if (tmp != 0.)
 		{
 		  d.xdata (ii) = tmp;
 		  d.xridx (ii++) = i;
 		}
 	    }
 	}
       else if ( k < 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    {
 	      Complex tmp = elem (i-k, i);
 	      if (tmp != 0.)
 		{
 		  d.xdata (ii) = tmp;
 		  d.xridx (ii++) = i;
 		}
 	    }
 	}
       else
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    {
 	      Complex tmp = elem (i, i);
 	      if (tmp != 0.)
 		{
 		  d.xdata (ii) = tmp;
 		  d.xridx (ii++) = i;
 		}
 	    }
@@ -6192,73 +6192,73 @@ SparseComplexMatrix::diag (int k) const
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SparseComplexMatrix& a)
 {
-  int nc = a.cols ();
+  octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
-   for (int j = 0; j < nc; j++)  {
+   for (octave_idx_type j = 0; j < nc; j++)  {
       OCTAVE_QUIT;
-      for (int i = a.cidx(j); i < a.cidx(j+1); i++) {
+      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) {
 	os << a.ridx(i) + 1 << " "  << j + 1 << " ";
 	octave_write_complex (os, a.data(i));
 	os << "\n";
       }
    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseComplexMatrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
-  int nz = a.nnz ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type nz = a.nnz ();
 
   if (nr < 1 || nc < 1)
     is.clear (std::ios::badbit);
   else
     {
-      int itmp, jtmp, jold = 0;
+      octave_idx_type itmp, jtmp, jold = 0;
       Complex tmp;
-      int ii = 0;
+      octave_idx_type ii = 0;
        
       a.cidx (0) = 0;
-      for (int i = 0; i < nz; i++)
+      for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  is >> itmp;
 	  itmp--;
 	  is >> jtmp;
 	  jtmp--;
 	  tmp = octave_read_complex (is);
 
 	  if (is)
 	    {
 	      if (jold != jtmp)
 		{
-		  for (int j = jold; j < jtmp; j++)
+		  for (octave_idx_type j = jold; j < jtmp; j++)
 		    a.cidx(j+1) = ii;
 		  
 		  jold = jtmp;
 		}
 	      a.data (ii) = tmp;
 	      a.ridx (ii++) = itmp;
 	    }
 	  else
 	    goto done;
 	}
 
-      for (int j = jold; j < nc; j++)
+      for (octave_idx_type j = jold; j < nc; j++)
 	a.cidx(j+1) = ii;
     }
 
  done:
 
   return is;
 }
 
@@ -6294,29 +6294,29 @@ operator * (const SparseComplexMatrix& m
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 SparseComplexMatrix
 min (const Complex& c, const SparseComplexMatrix& m)
 {
   SparseComplexMatrix result;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
   if (abs(c) == 0.)
     return SparseComplexMatrix (nr, nc);
   else
     {
       result = SparseComplexMatrix (m);
 
-      for (int j = 0; j < nc; j++)
-	for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 	  result.data(i) = xmin(c, m.data(i));
     }
   
   return result;
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& m, const Complex& c)
@@ -6326,41 +6326,41 @@ min (const SparseComplexMatrix& m, const
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   SparseComplexMatrix r;
 
   if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
     {
-      int a_nr = a.rows ();
-      int a_nc = a.cols ();
-
-      int b_nr = b.rows ();
-      int b_nc = b.cols ();
+      octave_idx_type a_nr = a.rows ();
+      octave_idx_type a_nc = a.cols ();
+
+      octave_idx_type b_nr = b.rows ();
+      octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0 || a.nnz () == 0 || b.nnz () == 0)
 	return SparseComplexMatrix (a_nr, a_nc);
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
 	  r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-	  int jx = 0;
+	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
-	  for (int i = 0 ; i < a_nc ; i++)
+	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
-	      int  ja = a.cidx(i);
-	      int  ja_max = a.cidx(i+1);
+	      octave_idx_type  ja = a.cidx(i);
+	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
            
-	      int  jb = b.cidx(i);
-	      int  jb_max = b.cidx(i+1);
+	      octave_idx_type  jb = b.cidx(i);
+	      octave_idx_type  jb_max = b.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
 		  OCTAVE_QUIT;
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
 		    {
@@ -6414,27 +6414,27 @@ min (const SparseComplexMatrix& a, const
   return r;
 }
 
 SparseComplexMatrix
 max (const Complex& c, const SparseComplexMatrix& m)
 {
   SparseComplexMatrix result;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
   // Count the number of non-zero elements
   if (xmax(c, 0.) != 0.)
     {
       result = SparseComplexMatrix (nr, nc, c);
-      for (int j = 0; j < nc; j++)
-	for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 	  result.xdata(m.ridx(i) + j * nr) = xmax (c, m.data(i));
     }
   else
     result = SparseComplexMatrix (m);
 
   return result;
 }
 
@@ -6446,45 +6446,45 @@ max (const SparseComplexMatrix& m, const
 
 SparseComplexMatrix
 max (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   SparseComplexMatrix r;
 
   if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
     {
-      int a_nr = a.rows ();
-      int a_nc = a.cols ();
-
-      int b_nr = b.rows ();
-      int b_nc = b.cols ();
+      octave_idx_type a_nr = a.rows ();
+      octave_idx_type a_nc = a.cols ();
+
+      octave_idx_type b_nr = b.rows ();
+      octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0)
 	return SparseComplexMatrix (a_nr, a_nc);
       if (a.nnz () == 0)
 	return SparseComplexMatrix (b);
       if (b.nnz () == 0)
 	return SparseComplexMatrix (a);
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
 	  r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-	  int jx = 0;
+	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
-	  for (int i = 0 ; i < a_nc ; i++)
+	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
-	      int  ja = a.cidx(i);
-	      int  ja_max = a.cidx(i+1);
+	      octave_idx_type  ja = a.cidx(i);
+	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
            
-	      int  jb = b.cidx(i);
-	      int  jb_max = b.cidx(i+1);
+	      octave_idx_type  jb = b.cidx(i);
+	      octave_idx_type  jb_max = b.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
 		  OCTAVE_QUIT;
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
 		    {
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -42,326 +42,326 @@ class
 SparseComplexMatrix : public MSparse<Complex>
 {
 public:
   
   typedef void (*solve_singularity_handler) (double rcond);
 
   SparseComplexMatrix (void) : MSparse<Complex> () { }
 
-  SparseComplexMatrix (int r, int c) : MSparse<Complex> (r, c) { }
+  SparseComplexMatrix (octave_idx_type r, octave_idx_type c) : MSparse<Complex> (r, c) { }
 
-  explicit SparseComplexMatrix (int r, int c, Complex val) 
+  explicit SparseComplexMatrix (octave_idx_type r, octave_idx_type c, Complex val) 
     : MSparse<Complex> (r, c, val) { }
 
-  SparseComplexMatrix (int r, int c, double val) 
+  SparseComplexMatrix (octave_idx_type r, octave_idx_type c, double val) 
     : MSparse<Complex> (r, c, Complex (val)) { }
 
   SparseComplexMatrix (const SparseComplexMatrix& a) 
     : MSparse<Complex> (a) { }
 
   SparseComplexMatrix (const SparseComplexMatrix& a, const dim_vector& dv) 
     : MSparse<Complex> (a, dv) { }
 
   SparseComplexMatrix (const MSparse<Complex>& a) : MSparse<Complex> (a) { }
 
   explicit SparseComplexMatrix (const ComplexMatrix& a) 
     : MSparse<Complex> (a) { }
 
   explicit SparseComplexMatrix (const ComplexNDArray& a) 
     : MSparse<Complex> (a) { }
 
-  explicit SparseComplexMatrix (const Array<Complex> a, const Array<int>& r, 
-			 const Array<int>& c, int nr = -1, 
-			 int nc = -1, bool sum_terms = true)
+  explicit SparseComplexMatrix (const Array<Complex> a, const Array<octave_idx_type>& r, 
+			 const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
+			 octave_idx_type nc = -1, bool sum_terms = true)
     : MSparse<Complex> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseComplexMatrix (const Array<Complex> a, 
 				const Array<double>& r, 
-				const Array<double>& c, int nr = -1, 
-				int nc = -1, bool sum_terms = true)
+				const Array<double>& c, octave_idx_type nr = -1, 
+				octave_idx_type nc = -1, bool sum_terms = true)
     : MSparse<Complex> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseComplexMatrix (const SparseMatrix& a);
 
   explicit SparseComplexMatrix (const SparseBoolMatrix& a);
 
-  SparseComplexMatrix (int r, int c, int num_nz) 
+  SparseComplexMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) 
     : MSparse<Complex> (r, c, num_nz) { }
 
   SparseComplexMatrix& operator = (const SparseComplexMatrix& a)
     {
       MSparse<Complex>::operator = (a);
       return *this;
     }
 
   bool operator == (const SparseComplexMatrix& a) const;
   bool operator != (const SparseComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
   SparseComplexMatrix max (int dim = 0) const;
-  SparseComplexMatrix max (Array2<int>& index, int dim = 0) const;
+  SparseComplexMatrix max (Array2<octave_idx_type>& index, int dim = 0) const;
   SparseComplexMatrix min (int dim = 0) const;
-  SparseComplexMatrix min (Array2<int>& index, int dim = 0) const;
+  SparseComplexMatrix min (Array2<octave_idx_type>& index, int dim = 0) const;
 
-  SparseComplexMatrix& insert (const SparseComplexMatrix& a, int r, int c);
-  SparseComplexMatrix& insert (const SparseMatrix& a, int r, int c);
+  SparseComplexMatrix& insert (const SparseComplexMatrix& a, octave_idx_type r, octave_idx_type c);
+  SparseComplexMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
 
   SparseComplexMatrix concat (const SparseComplexMatrix& rb,
-			      const Array<int>& ra_idx);
+			      const Array<octave_idx_type>& ra_idx);
   SparseComplexMatrix concat (const SparseMatrix& rb,
-			      const Array<int>& ra_idx);
+			      const Array<octave_idx_type>& ra_idx);
 
   ComplexMatrix matrix_value (void) const;
 
   SparseComplexMatrix hermitian (void) const;  // complex conjugate transpose
   SparseComplexMatrix transpose (void) const
     { return MSparse<Complex>::transpose (); }
 
   friend SparseComplexMatrix conj (const SparseComplexMatrix& a);
 
   SparseComplexMatrix inverse (void) const;
-  SparseComplexMatrix inverse (int& info) const;
-  SparseComplexMatrix inverse (int& info, double& rcond, int force = 0,
+  SparseComplexMatrix inverse (octave_idx_type& info) const;
+  SparseComplexMatrix inverse (octave_idx_type& info, double& rcond, int force = 0,
 			       int calc_cond = 1) const;
 
   ComplexDET determinant (void) const;
-  ComplexDET determinant (int& info) const;
-  ComplexDET determinant (int& info, double& rcond, 
+  ComplexDET determinant (octave_idx_type& info) const;
+  ComplexDET determinant (octave_idx_type& info, double& rcond, 
 				int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
-  ComplexMatrix dsolve (SparseType &typ, const Matrix& b, int& info, 
+  ComplexMatrix dsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 	        double& rcond, solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseComplexMatrix dsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseComplexMatrix dsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix dsolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Upper triangular matrix solvers
-  ComplexMatrix utsolve (SparseType &typ, const Matrix& b, int& info,
+  ComplexMatrix utsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseComplexMatrix utsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseComplexMatrix utsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix utsolve (SparseType &typ, const SparseComplexMatrix& b, 
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Lower triangular matrix solvers
-  ComplexMatrix ltsolve (SparseType &typ, const Matrix& b, int& info, 
+  ComplexMatrix ltsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 	       double& rcond, solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseComplexMatrix ltsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseComplexMatrix ltsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix ltsolve (SparseType &typ, const SparseComplexMatrix& b, 
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Tridiagonal matrix solvers
-  ComplexMatrix trisolve (SparseType &typ, const Matrix& b, int& info, 
+  ComplexMatrix trisolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 	       double& rcond, solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseComplexMatrix trisolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseComplexMatrix trisolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix trisolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Banded matrix solvers (umfpack/cholesky)
-  ComplexMatrix bsolve (SparseType &typ, const Matrix& b, int& info,
+  ComplexMatrix bsolve (SparseType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseComplexMatrix bsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseComplexMatrix bsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix bsolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond,
+		octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  void * factorize (int& err, double &rcond, Matrix &Control, Matrix &Info,
+  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control, Matrix &Info,
 		    solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix fsolve (SparseType &typ, const Matrix& b, int& info, 
+  ComplexMatrix fsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseComplexMatrix fsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseComplexMatrix fsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix fsolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (SparseType &typ, const Matrix& b) const;
-  ComplexMatrix solve (SparseType &typ, const Matrix& b, int& info) const;
-  ComplexMatrix solve (SparseType &typ, const Matrix& b, int& info, 
+  ComplexMatrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info) const;
+  ComplexMatrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond) const;
-  ComplexMatrix solve (SparseType &typ, const Matrix& b, int& info, 
+  ComplexMatrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, 
-		       int& info) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, int& info, 
+		       octave_idx_type& info) const;
+  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		       double& rcond) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b) const;
   SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b, 
-		      int& info) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b, int& info, 
+		      octave_idx_type& info) const;
+  SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		      double& rcond) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseComplexMatrix solve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (SparseType &typ, 
 			     const SparseComplexMatrix& b) const;
   SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, 
-			     int& info) const;
+			     octave_idx_type& info) const;
   SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, 
-			     int& info, double& rcond) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, int& info, 
+			     octave_idx_type& info, double& rcond) const;
+  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, octave_idx_type& info, 
 	       double& rcond, solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (SparseType &typ, const ColumnVector& b) const;
   ComplexColumnVector solve (SparseType &typ, const ColumnVector& b, 
-		      int& info) const;
+		      octave_idx_type& info) const;
   ComplexColumnVector solve (SparseType &typ, const ColumnVector& b, 
-		      int& info, double& rcond) const;
-  ComplexColumnVector solve (SparseType &typ, const ColumnVector& b, int& info,
+		      octave_idx_type& info, double& rcond) const;
+  ComplexColumnVector solve (SparseType &typ, const ColumnVector& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (SparseType &typ, 
 			     const ComplexColumnVector& b) const;
   ComplexColumnVector solve (SparseType &typ, 
-			     const ComplexColumnVector& b, int& info) const;
+			     const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b,
-			     int& info, double& rcond) const;
+			     octave_idx_type& info, double& rcond) const;
   ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b,
-			     int& info, double& rcond,
+			     octave_idx_type& info, double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
-  ComplexMatrix solve (const Matrix& b, int& info) const;
-  ComplexMatrix solve (const Matrix& b, int& info, double& rcond) const;
-  ComplexMatrix solve (const Matrix& b, int& info, double& rcond, 
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond, 
 		       solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, 
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, 
 		       double& rcond) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
 		       solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseMatrix& b) const;
-  SparseComplexMatrix solve (const SparseMatrix& b, int& info) const;
-  SparseComplexMatrix solve (const SparseMatrix& b, int& info, 
+  SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info) const;
+  SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
 			     double& rcond) const;
-  SparseComplexMatrix solve (const SparseMatrix& b, int& info, 
+  SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
 			     double& rcond, 
 		       solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, int& info) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, int& info, 
+  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info) const;
+  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info, 
 			     double& rcond) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, int& info, 
+  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info, 
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
-  ComplexColumnVector solve (const ColumnVector& b, int& info) const;
-  ComplexColumnVector solve (const ColumnVector& b, int& info,
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
-  ComplexColumnVector solve (const ColumnVector& b, int& info, double& rcond,
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   ComplexMatrix lssolve (const Matrix& b) const;
-  ComplexMatrix lssolve (const Matrix& b, int& info) const;
-  ComplexMatrix lssolve (const Matrix& b, int& info, int& rank) const;
+  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info) const;
+  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info,
-			 int& rank) const;
+  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
+  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
+			 octave_idx_type& rank) const;
 
   SparseComplexMatrix lssolve (const SparseMatrix& b) const;
-  SparseComplexMatrix lssolve (const SparseMatrix& b, int& info) const;
-  SparseComplexMatrix lssolve (const SparseMatrix& b, int& info, 
-			       int& rank) const;
+  SparseComplexMatrix lssolve (const SparseMatrix& b, octave_idx_type& info) const;
+  SparseComplexMatrix lssolve (const SparseMatrix& b, octave_idx_type& info, 
+			       octave_idx_type& rank) const;
 
   SparseComplexMatrix lssolve (const SparseComplexMatrix& b) const;
   SparseComplexMatrix lssolve (const SparseComplexMatrix& b, 
-			       int& info) const;
-  SparseComplexMatrix lssolve (const SparseComplexMatrix& b, int& info,
-			       int& rank) const;
+			       octave_idx_type& info) const;
+  SparseComplexMatrix lssolve (const SparseComplexMatrix& b, octave_idx_type& info,
+			       octave_idx_type& rank) const;
 
   ComplexColumnVector lssolve (const ColumnVector& b) const;
-  ComplexColumnVector lssolve (const ColumnVector& b, int& info) const;
-  ComplexColumnVector lssolve (const ColumnVector& b, int& info,
-			       int& rank) const;
+  ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
+			       octave_idx_type& rank) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
-			       int& rank) const;
+  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info,
+			       octave_idx_type& rank) const;
 
   SparseComplexMatrix squeeze (void) const;
 
   SparseComplexMatrix index (idx_vector& i, int resize_ok) const;
 
   SparseComplexMatrix index (idx_vector& i, idx_vector& j, int resize_ok) const;
   
   SparseComplexMatrix index (Array<idx_vector>& ra_idx, int resize_ok) const;
 
   SparseComplexMatrix reshape (const dim_vector& new_dims) const;
 
-  SparseComplexMatrix permute (const Array<int>& vec, bool inv = false) const;
+  SparseComplexMatrix permute (const Array<octave_idx_type>& vec, bool inv = false) const;
 
-  SparseComplexMatrix ipermute (const Array<int>& vec) const;
+  SparseComplexMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   SparseComplexMatrix map (c_c_Mapper f) const;
   SparseMatrix map (d_c_Mapper f) const;
   SparseBoolMatrix map (b_c_Mapper f) const;
 
   SparseComplexMatrix& apply (c_c_Mapper f);
 
   bool any_element_is_inf_or_nan (void) const;
@@ -376,17 +376,17 @@ public:
 
   SparseComplexMatrix cumprod (int dim = -1) const;
   SparseComplexMatrix cumsum (int dim = -1) const;
   SparseComplexMatrix prod (int dim = -1) const;
   SparseComplexMatrix sum (int dim = -1) const;
   SparseComplexMatrix sumsq (int dim = -1) const;
   SparseMatrix abs (void) const;
 
-  SparseComplexMatrix diag (int k = 0) const;
+  SparseComplexMatrix diag (octave_idx_type k = 0) const;
 
   // i/o
   friend std::ostream& operator << (std::ostream& os, 
 				    const SparseComplexMatrix& a);
   friend std::istream& operator >> (std::istream& is, 
 				    SparseComplexMatrix& a);
 };
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,63 @@
+2005-04-08  John W. Eaton  <jwe@octave.org>
+
+	* Initial merge of 64-bit changes from Clinton Chee:
+
+	2005-04-07  John W. Eaton  <jwe@octave.org>
+
+	* MArray-i.cc, Array-i.cc: Instantiate Array<long> and MArray<long>.
+
+	* CSparse.cc, CSparse.h, MSparse.cc, MSparse.h, Sparse-op-defs.h,
+	Sparse.cc, Sparse.h, SparseCmplxLU.cc, SparseType.cc,
+	SparseType.h, SparsedbleLU.cc, boolSparse.cc, boolSparse.h,
+	dSparse.cc, dSparse.h, sparse-base-lu.cc:
+	Use octave_idx_type instead of int where needed.
+
+	2005-03-31  Clinton Chee  <chee@parallel.hpc.unsw.edu.au>
+
+	* Array-util.cc, Array-util.h, Array.cc,Array.h, Array2.h,
+	Array3.h, ArrayN.cc, ArrayN.h, Bounds.cc, Bounds.h, CColVector.cc,
+	CColVector.h, CDiagMatrix.cc, CDiagMatrix.h, CMatrix.cc,
+	CMatrix.h, CNDArray.cc, CNDArray.h, CRowVector.cc, CRowVector.h,
+	CmplxAEPBAL.cc, CmplxAEPBAL.h, CmplxCHOL.cc, CmplxCHOL.h,
+	CmplxHESS.cc, CmplxHESS.h, CmplxLU.cc, CmplxQR.cc, CmplxQRP.cc,
+	CmplxSCHUR.cc, CmplxSCHUR.h, CmplxSVD.cc, CmplxSVD.h, CollocWt.cc,
+	CollocWt.h, DAEFunc.h, DASPK-opts.in,DASPK.cc,DASPK.h,
+	DASRT-opts.in, DASRT.cc, DASRT.h, DASSL-opts.in, DASSL.cc,
+	DASSL.h, DiagArray2.cc, DiagArray2.h, EIG.cc, EIG.h, FEGrid.cc,
+	FEGrid.h, LPsolve.cc, LPsolve.h, LSODE-opts.in, LSODE.cc, LSODE.h,
+	MArray-defs.h, MArray.cc, MArray.h, MArray2.cc, MArray2.h,
+	MArrayN.cc, MDiagArray2.cc, MDiagArray2.h, NLConst.h, NLEqn.cc,
+	NLEqn.h, Quad.cc, Quad.h, Range.cc,Range.cc, Range.h, base-de.h,
+	base-lu.cc, base-lu.h, base-min.h, boolMatrix.cc, boolMatrix.h,
+	boolNDArray.cc, boolNDArray.h, chMatrix.cc, chMatrix.h,
+	chNDArray.cc, chNDArray.h, dColVector.cc, dColVector.h,
+	dDiagMatrix.cc, dDiagMatrix.h, dMatrix.cc, dMatrix.h,
+	dNDArray.cc,dNDArray.cc, dNDArray.h, dRowVector.cc, dRowVector.h,
+	dbleAEPBAL.cc, dbleAEPBAL.h, dbleCHOL.cc, dbleCHOL.h, dbleHESS.cc,
+	dbleHESS.h, dbleLU.cc, dbleQR.cc, dbleQRP.cc, dbleSCHUR.cc,
+	dbleSCHUR.h, dbleSVD.cc, dbleSVD.h, dim-vector.h, idx-vector.cc,
+	idx-vector.h, intNDArray.cc, intNDArray.h, lo-specfun.cc,
+	lo-specfun.h, mach-info.cc, mx-inlines.cc, oct-fftw.cc,
+	oct-fftw.h, oct-rand.cc, oct-rand.h, so-array.cc, so-array.h,
+	str-vec.cc, str-vec.h:
+	Use octave_idx_type instead of int where needed.
+
+	2005-04-01  John W. Eaton  <jwe@octave.org>
+
+	* dim-vector.h, lo-utils.h: Include oct-types.h.
+
+	* oct-types.h.in: New file.
+
+	2005-03-31  Clinton Chee  <chee@parallel.hpc.unsw.edu.au>
+
+	* lo-utils.cc (NINTbig): New function.
+	* lo-utils.h: Provide decl.
+
 2005-04-06  David Bateman  <dbateman@free.fr>
 
 	* Makefile.in: Link to UMFPACK_LIBS.
 
 2005-04-05  John W. Eaton  <jwe@octave.org>
 
 	* Array.cc (assignN): Avoid shadowed declaration in previous change.
 
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -28,45 +28,45 @@ Software Foundation, 59 Temple Place - S
 
 #include "CmplxAEPBAL.h"
 #include "dMatrix.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, Complex*, const int&, int&,
-			     int&, double*, int&
-			     F77_CHAR_ARG_LEN_DECL);
+  F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
+			     Complex*, const octave_idx_type&,
+			     octave_idx_type&, octave_idx_type&, double*,
+			     octave_idx_type& F77_CHAR_ARG_LEN_DECL);
  
   F77_RET_T
-  F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL,
-			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, const int&, double*,
-			     const int&, Complex*, const int&, int&
-			     F77_CHAR_ARG_LEN_DECL
-			     F77_CHAR_ARG_LEN_DECL);
+  F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL, F77_CONST_CHAR_ARG_DECL,
+			     const octave_idx_type&, const octave_idx_type&,
+			     const octave_idx_type&, double*,
+			     const octave_idx_type&, Complex*,
+			     const octave_idx_type&, octave_idx_type&
+			     F77_CHAR_ARG_LEN_DECL  F77_CHAR_ARG_LEN_DECL);
 }
 
-int
+octave_idx_type
 ComplexAEPBALANCE::init (const ComplexMatrix& a,
 			 const std::string& balance_job)
 {
-  int n = a.cols ();
+  octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
       return -1;
     }
 
-  int info;
-  int ilo;
-  int ihi;
+  octave_idx_type info;
+  octave_idx_type ilo;
+  octave_idx_type ihi;
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   Complex *p_balanced_mat = balanced_mat.fortran_vec ();
 
   char job = balance_job[0];
@@ -76,17 +76,17 @@ ComplexAEPBALANCE::init (const ComplexMa
 			     pscale, info
 			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
   else
     {
       balancing_mat = ComplexMatrix (n, n, 0.0);
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	balancing_mat.elem (i, i) = 1.0;
 
       Complex *p_balancing_mat = balancing_mat.fortran_vec ();
 
       char side = 'R';
 
       F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
 				 F77_CONST_CHAR_ARG2 (&side, 1),
diff --git a/liboctave/CmplxAEPBAL.h b/liboctave/CmplxAEPBAL.h
--- a/liboctave/CmplxAEPBAL.h
+++ b/liboctave/CmplxAEPBAL.h
@@ -61,17 +61,17 @@ public:
 
   friend std::ostream& operator << (std::ostream& os, const ComplexAEPBALANCE& a);
 
 private:
 
   ComplexMatrix balanced_mat;
   ComplexMatrix balancing_mat;
 
-  int init (const ComplexMatrix& a, const std::string& balance_job);
+  octave_idx_type init (const ComplexMatrix& a, const std::string& balance_job);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -27,52 +27,52 @@ Software Foundation, 59 Temple Place - S
 #include "CmplxCHOL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, Complex*, const int&, int&
+			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
-int
+octave_idx_type
 ComplexCHOL::init (const ComplexMatrix& a)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
 	("ComplexCHOL requires square matrix");
       return -1;
     }
 
-  int n = a_nc;
-  int info;
+  octave_idx_type n = a_nc;
+  octave_idx_type info;
 
   chol_mat = a;
   Complex *h = chol_mat.fortran_vec ();
 
   F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
 			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zpotrf");
   else
     {
       // If someone thinks of a more graceful way of doing this (or
       // faster for that matter :-)), please let me know!
 
       if (n > 1)
-	for (int j = 0; j < a_nc; j++)
-	  for (int i = j+1; i < a_nr; i++)
+	for (octave_idx_type j = 0; j < a_nc; j++)
+	  for (octave_idx_type i = j+1; i < a_nr; i++)
 	    chol_mat.elem (i, j) = 0.0;
     }
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/CmplxCHOL.h b/liboctave/CmplxCHOL.h
--- a/liboctave/CmplxCHOL.h
+++ b/liboctave/CmplxCHOL.h
@@ -31,17 +31,17 @@ class
 ComplexCHOL
 {
 public:
 
   ComplexCHOL (void) : chol_mat () { }
 
   ComplexCHOL (const ComplexMatrix& a) { init (a); }
 
-  ComplexCHOL (const ComplexMatrix& a, int& info)
+  ComplexCHOL (const ComplexMatrix& a, octave_idx_type& info)
     {
       info = init (a);
     }
 
   ComplexCHOL (const ComplexCHOL& a)
     : chol_mat (a.chol_mat) { }
 
   ComplexCHOL& operator = (const ComplexCHOL& a)
@@ -58,17 +58,17 @@ public:
     }
 
   friend std::ostream& operator << (std::ostream& os, const ComplexCHOL& a);
 
 private:
 
   ComplexMatrix chol_mat;
 
-  int init (const ComplexMatrix& a);
+  octave_idx_type init (const ComplexMatrix& a);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -27,60 +27,60 @@ Software Foundation, 59 Temple Place - S
 #include "CmplxHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, Complex*, const int&,
-			     int&, int&, double*, int&
+			     const octave_idx_type&, Complex*, const octave_idx_type&,
+			     octave_idx_type&, octave_idx_type&, double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
  
   F77_RET_T
-  F77_FUNC (zgehrd, ZGEHRD) (const int&, const int&, const int&,
-			     Complex*, const int&, Complex*,
-			     Complex*, const int&, int&);
+  F77_FUNC (zgehrd, ZGEHRD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     Complex*, const octave_idx_type&, Complex*,
+			     Complex*, const octave_idx_type&, octave_idx_type&);
  
   F77_RET_T
-  F77_FUNC (zunghr, ZUNGHR) (const int&, const int&, const int&,
-			     Complex*, const int&, Complex*,
-			     Complex*, const int&, int&);
+  F77_FUNC (zunghr, ZUNGHR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     Complex*, const octave_idx_type&, Complex*,
+			     Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, const int&, double*,
-			     const int&, Complex*, const int&, int&
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
-int
+octave_idx_type
 ComplexHESS::init (const ComplexMatrix& a)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
 	("ComplexHESS requires square matrix");
       return -1;
     }
 
   char job = 'N';
   char side = 'R';
 
-  int n = a_nc;
-  int lwork = 32 * n;
-  int info;
-  int ilo;
-  int ihi;
+  octave_idx_type n = a_nc;
+  octave_idx_type lwork = 32 * n;
+  octave_idx_type info;
+  octave_idx_type ilo;
+  octave_idx_type ihi;
 
   hess_mat = a;
   Complex *h = hess_mat.fortran_vec ();
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
@@ -125,18 +125,18 @@ ComplexHESS::init (const ComplexMatrix& 
 		  ("unrecoverable error in zgebak");
 	      else
 		{
 		  // If someone thinks of a more graceful way of
 		  // doing this (or faster for that matter :-)),
 		  // please let me know!
 
 		  if (n > 2)
-		    for (int j = 0; j < a_nc; j++)
-		      for (int i = j+2; i < a_nr; i++)
+		    for (octave_idx_type j = 0; j < a_nc; j++)
+		      for (octave_idx_type i = j+2; i < a_nr; i++)
 			hess_mat.elem (i, j) = 0;
 		}
 	    }
 	}
     }
 
   return info;
 }
diff --git a/liboctave/CmplxHESS.h b/liboctave/CmplxHESS.h
--- a/liboctave/CmplxHESS.h
+++ b/liboctave/CmplxHESS.h
@@ -31,17 +31,17 @@ class
 ComplexHESS
 {
 public:
 
   ComplexHESS (void) : hess_mat (), unitary_hess_mat () { }
 
   ComplexHESS (const ComplexMatrix& a) { init (a); }
 
-  ComplexHESS (const ComplexMatrix& a, int& info) { info = init (a); }
+  ComplexHESS (const ComplexMatrix& a, octave_idx_type& info) { info = init (a); }
 
   ComplexHESS (const ComplexHESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   ComplexHESS& operator = (const ComplexHESS& a)
     {
       if (this != &a)
 	{
@@ -62,17 +62,17 @@ public:
 
   friend std::ostream& operator << (std::ostream& os, const ComplexHESS& a);
 
 private:
 
   ComplexMatrix hess_mat;
   ComplexMatrix unitary_hess_mat;
 
-  int init (const ComplexMatrix& a);
+  octave_idx_type init (const ComplexMatrix& a);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -35,39 +35,39 @@ Software Foundation, 59 Temple Place - S
 
 template class base_lu <ComplexMatrix, Complex, Matrix, double>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (zgetrf, ZGETRF) (const int&, const int&, Complex*,
-			     const int&, int*, int&);
+  F77_FUNC (zgetrf, ZGETRF) (const octave_idx_type&, const octave_idx_type&, Complex*,
+			     const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 }
 
 ComplexLU::ComplexLU (const ComplexMatrix& a)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-  int mn = (a_nr < a_nc ? a_nr : a_nc);
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
+  octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
   ipvt.resize (mn);
-  int *pipvt = ipvt.fortran_vec ();
+  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   Complex *tmp_data = a_fact.fortran_vec ();
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
   else
-    ipvt -= 1;
+    ipvt -= static_cast<octave_idx_type> (1);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -26,55 +26,55 @@ Software Foundation, 59 Temple Place - S
 
 #include "CmplxQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (zgeqrf, ZGEQRF) (const int&, const int&, Complex*,
-			     const int&, Complex*, Complex*,
-			     const int&, int&); 
+  F77_FUNC (zgeqrf, ZGEQRF) (const octave_idx_type&, const octave_idx_type&, Complex*,
+			     const octave_idx_type&, Complex*, Complex*,
+			     const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
-  F77_FUNC (zungqr, ZUNGQR) (const int&, const int&, const int&,
-			     Complex*, const int&, Complex*,
-			     Complex*, const int&, int&);
+  F77_FUNC (zungqr, ZUNGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     Complex*, const octave_idx_type&, Complex*,
+			     Complex*, const octave_idx_type&, octave_idx_type&);
 }
 
 ComplexQR::ComplexQR (const ComplexMatrix& a, QR::type qr_type)
   : q (), r ()
 {
   init (a, qr_type);
 }
 
 void
 ComplexQR::init (const ComplexMatrix& a, QR::type qr_type)
 {
-  int m = a.rows ();
-  int n = a.cols ();
+  octave_idx_type m = a.rows ();
+  octave_idx_type n = a.cols ();
 
   if (m == 0 || n == 0)
     {
       (*current_liboctave_error_handler)
 	("ComplexQR must have non-empty matrix");
       return;
     }
 
-  int min_mn = m < n ? m : n;
+  octave_idx_type min_mn = m < n ? m : n;
 
   Array<Complex> tau (min_mn);
   Complex *ptau = tau.fortran_vec ();
 
-  int lwork = 32*n;
+  octave_idx_type lwork = 32*n;
   Array<Complex> work (lwork);
   Complex *pwork = work.fortran_vec ();
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   ComplexMatrix A_fact;
   if (m > n && qr_type != QR::economy)
     {
       A_fact.resize (m, m);
       A_fact.insert (a, 0, 0);
     }
   else
@@ -85,41 +85,41 @@ ComplexQR::init (const ComplexMatrix& a,
   F77_XFCN (zgeqrf, ZGEQRF, (m, n, tmp_data, m, ptau, pwork, lwork, info));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgeqrf");
   else
     {
       if (qr_type == QR::raw)
 	{
-	  for (int j = 0; j < min_mn; j++)
+	  for (octave_idx_type j = 0; j < min_mn; j++)
 	    {
-	      int limit = j < min_mn - 1 ? j : min_mn - 1;
-	      for (int i = limit + 1; i < m; i++)
+	      octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
+	      for (octave_idx_type i = limit + 1; i < m; i++)
 		A_fact.elem (i, j) *= tau.elem (j);
 	    }
 
 	  r = A_fact;
 
 	  if (m > n)
 	    r.resize (m, n);
 	}
       else
 	{
-	  int n2 = (qr_type == QR::economy) ? min_mn : m;
+	  octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
 
 	  if (qr_type == QR::economy && m > n)
 	    r.resize (n, n, 0.0);
 	  else
 	    r.resize (m, n, 0.0);
 
-	  for (int j = 0; j < n; j++)
+	  for (octave_idx_type j = 0; j < n; j++)
 	    {
-	      int limit = j < min_mn-1 ? j : min_mn-1;
-	      for (int i = 0; i <= limit; i++)
+	      octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
+	      for (octave_idx_type i = 0; i <= limit; i++)
 		r.elem (i, j) = A_fact.elem (i, j);
 	    }
 
 	  lwork = 32 * n2;
 	  work.resize (lwork);
 	  Complex *pwork2 = work.fortran_vec ();
 
 	  F77_XFCN (zungqr, ZUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -28,107 +28,107 @@ Software Foundation, 59 Temple Place - S
 
 #include "CmplxQRP.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (zgeqpf, ZGEQPF) (const int&, const int&, Complex*,
-			     const int&, int*, Complex*, Complex*,
-			     double*, int&);
+  F77_FUNC (zgeqpf, ZGEQPF) (const octave_idx_type&, const octave_idx_type&, Complex*,
+			     const octave_idx_type&, octave_idx_type*, Complex*, Complex*,
+			     double*, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (zungqr, ZUNGQR) (const int&, const int&, const int&,
-			     Complex*, const int&, Complex*,
-			     Complex*, const int&, int&);
+  F77_FUNC (zungqr, ZUNGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     Complex*, const octave_idx_type&, Complex*,
+			     Complex*, const octave_idx_type&, octave_idx_type&);
 }
 
 // It would be best to share some of this code with ComplexQR class...
 
 ComplexQRP::ComplexQRP (const ComplexMatrix& a, QR::type qr_type)
   : ComplexQR (), p ()
 {
   init (a, qr_type);
 }
 
 void
 ComplexQRP::init (const ComplexMatrix& a, QR::type qr_type)
 {
   assert (qr_type != QR::raw);
 
-  int m = a.rows ();
-  int n = a.cols ();
+  octave_idx_type m = a.rows ();
+  octave_idx_type n = a.cols ();
 
   if (m == 0 || n == 0)
     {
       (*current_liboctave_error_handler)
 	("ComplexQR must have non-empty matrix");
       return;
     }
 
-  int min_mn = m < n ? m : n;
+  octave_idx_type min_mn = m < n ? m : n;
   Array<Complex> tau (min_mn);
   Complex *ptau = tau.fortran_vec ();
 
-  int lwork = 3*n > 32*m ? 3*n : 32*m;
+  octave_idx_type lwork = 3*n > 32*m ? 3*n : 32*m;
   Array<Complex> work (lwork);
   Complex *pwork = work.fortran_vec ();
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   ComplexMatrix A_fact = a;
   if (m > n && qr_type != QR::economy)
     A_fact.resize (m, m, 0.0);
 
   Complex *tmp_data = A_fact.fortran_vec ();
 
   Array<double> rwork (2*n);
   double *prwork = rwork.fortran_vec ();
 
-  Array<int> jpvt (n, 0);
-  int *pjpvt = jpvt.fortran_vec ();
+  Array<octave_idx_type> jpvt (n, 0);
+  octave_idx_type *pjpvt = jpvt.fortran_vec ();
 
   // Code to enforce a certain permutation could go here...
 
   F77_XFCN (zgeqpf, ZGEQPF, (m, n, tmp_data, m, pjpvt, ptau, pwork,
 			     prwork, info));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgeqpf");
   else
     {
       // Form Permutation matrix (if economy is requested, return the
       // indices only!)
 
       if (qr_type == QR::economy)
 	{
 	  p.resize (1, n, 0.0);
-	  for (int j = 0; j < n; j++)
+	  for (octave_idx_type j = 0; j < n; j++)
 	    p.elem (0, j) = jpvt.elem (j);
 	}
       else
 	{
 	  p.resize (n, n, 0.0);
-	  for (int j = 0; j < n; j++)
+	  for (octave_idx_type j = 0; j < n; j++)
 	    p.elem (jpvt.elem (j) - 1, j) = 1.0;
 	}
 
-      int n2 = (qr_type == QR::economy) ? min_mn : m;
+      octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
 
       if (qr_type == QR::economy && m > n)
 	r.resize (n, n, 0.0);
       else
 	r.resize (m, n, 0.0);
 
-      for (int j = 0; j < n; j++)
+      for (octave_idx_type j = 0; j < n; j++)
 	{
-	  int limit = j < min_mn-1 ? j : min_mn-1;
-	  for (int i = 0; i <= limit; i++)
+	  octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
+	  for (octave_idx_type i = 0; i <= limit; i++)
 	    r.elem (i, j) = A_fact.elem (i, j);
 	}
 
       F77_XFCN (zungqr, ZUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
 				 pwork, lwork, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zungqr");
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -30,43 +30,43 @@ Software Foundation, 59 Temple Place - S
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgeesx, ZGEESX) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
 			     ComplexSCHUR::select_function,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, Complex*, const int&, int&,
-			     Complex*, Complex*, const int&, double&,
-			     double&, Complex*, const int&, double*, int*,
-			     int&
+			     const octave_idx_type&, Complex*, const octave_idx_type&, octave_idx_type&,
+			     Complex*, Complex*, const octave_idx_type&, double&,
+			     double&, Complex*, const octave_idx_type&, double*, octave_idx_type*,
+			     octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
-static int
+static octave_idx_type
 select_ana (const Complex& a)
 {
   return a.real () < 0.0;
 }
 
-static int
+static octave_idx_type
 select_dig (const Complex& a)
 {
   return (abs (a) < 1.0);
 }
 
-int
+octave_idx_type
 ComplexSCHUR::init (const ComplexMatrix& a, const std::string& ord, 
 		    bool calc_unitary)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
 	("ComplexSCHUR requires square matrix");
       return -1;
     }
 
@@ -89,20 +89,20 @@ ComplexSCHUR::init (const ComplexMatrix&
 
   if (ord_char == 'A' || ord_char == 'a')
     selector = select_ana;
   else if (ord_char == 'D' || ord_char == 'd')
     selector = select_dig;
   else
     selector = 0;
 
-  int n = a_nc;
-  int lwork = 8 * n;
-  int info;
-  int sdim;
+  octave_idx_type n = a_nc;
+  octave_idx_type lwork = 8 * n;
+  octave_idx_type info;
+  octave_idx_type sdim;
   double rconde;
   double rcondv;
 
   schur_mat = a;
   if (calc_unitary)
     unitary_mat.resize (n, n);
 
   Complex *s = schur_mat.fortran_vec ();
@@ -113,18 +113,18 @@ ComplexSCHUR::init (const ComplexMatrix&
 
   Array<Complex> w (n);
   Complex *pw = w.fortran_vec ();
 
   Array<Complex> work (lwork);
   Complex *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for non-ordered Schur.
-  Array<int> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
-  int *pbwork = bwork.fortran_vec ();
+  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
+  octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
 			     F77_CONST_CHAR_ARG2 (&sort, 1),
 			     selector,
 			     F77_CONST_CHAR_ARG2 (&sense, 1),
 			     n, s, n, sdim, pw, q, n, rconde, rcondv,
 			     pwork, lwork, prwork, pbwork, info
 			     F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/CmplxSCHUR.h b/liboctave/CmplxSCHUR.h
--- a/liboctave/CmplxSCHUR.h
+++ b/liboctave/CmplxSCHUR.h
@@ -35,17 +35,17 @@ public:
 
   ComplexSCHUR (void)
     : schur_mat (), unitary_mat () { }
 
   ComplexSCHUR (const ComplexMatrix& a, const std::string& ord,
 		bool calc_unitary = true)
     : schur_mat (), unitary_mat () { init (a, ord, calc_unitary); }
 
-  ComplexSCHUR (const ComplexMatrix& a, const std::string& ord, int& info,
+  ComplexSCHUR (const ComplexMatrix& a, const std::string& ord, octave_idx_type& info,
 		bool calc_unitary = true)
     : schur_mat (), unitary_mat () { info = init (a, ord, calc_unitary); }
 
   ComplexSCHUR (const ComplexSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat) { }
 
   ComplexSCHUR& operator = (const ComplexSCHUR& a)
     {
@@ -60,26 +60,26 @@ public:
   ~ComplexSCHUR (void) { }
 
   ComplexMatrix schur_matrix (void) const { return schur_mat; }
 
   ComplexMatrix unitary_matrix (void) const { return unitary_mat; }
 
   friend std::ostream& operator << (std::ostream& os, const ComplexSCHUR& a);
 
-  typedef int (*select_function) (const Complex&);
+  typedef octave_idx_type (*select_function) (const Complex&);
 
 private:
 
   ComplexMatrix schur_mat;
   ComplexMatrix unitary_mat;
 
   select_function selector;
 
-  int init (const ComplexMatrix& a, const std::string& ord, bool calc_unitary);
+  octave_idx_type init (const ComplexMatrix& a, const std::string& ord, bool calc_unitary);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -28,20 +28,20 @@ Software Foundation, 59 Temple Place - S
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgesvd, ZGESVD) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, Complex*,
-			     const int&, double*, Complex*, const int&,
-			     Complex*, const int&, Complex*, const int&,
-			     double*, int&
+			     const octave_idx_type&, const octave_idx_type&, Complex*,
+			     const octave_idx_type&, double*, Complex*, const octave_idx_type&,
+			     Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
+			     double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
 ComplexMatrix
 ComplexSVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
@@ -62,37 +62,37 @@ ComplexSVD::right_singular_matrix (void)
       (*current_liboctave_error_handler)
 	("ComplexSVD: V not computed because type == SVD::sigma_only");
       return ComplexMatrix ();
     }
   else
     return right_sm;
 }
 
-int
+octave_idx_type
 ComplexSVD::init (const ComplexMatrix& a, SVD::type svd_type)
 {
-  int info;
+  octave_idx_type info;
 
-  int m = a.rows ();
-  int n = a.cols ();
+  octave_idx_type m = a.rows ();
+  octave_idx_type n = a.cols ();
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
-  int min_mn = m < n ? m : n;
-  int max_mn = m > n ? m : n;
+  octave_idx_type min_mn = m < n ? m : n;
+  octave_idx_type max_mn = m > n ? m : n;
 
   char jobu = 'A';
   char jobv = 'A';
 
-  int ncol_u = m;
-  int nrow_vt = n;
-  int nrow_s = m;
-  int ncol_s = n;
+  octave_idx_type ncol_u = m;
+  octave_idx_type nrow_vt = n;
+  octave_idx_type nrow_s = m;
+  octave_idx_type ncol_s = n;
 
   switch (svd_type)
     {
     case SVD::economy:
       jobu = jobv = 'S';
       ncol_u = nrow_vt = nrow_s = ncol_s = min_mn;
       break;
 
@@ -125,39 +125,39 @@ ComplexSVD::init (const ComplexMatrix& a
   sigma.resize (nrow_s, ncol_s);
   double *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   Complex *vt = right_sm.fortran_vec ();
 
-  int lrwork = 5*max_mn;
+  octave_idx_type lrwork = 5*max_mn;
 
   Array<double> rwork (lrwork);
 
   // Ask ZGESVD what the dimension of WORK should be.
 
-  int lwork = -1;
+  octave_idx_type lwork = -1;
 
   Array<Complex> work (1);
 
   F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
 			     F77_CONST_CHAR_ARG2 (&jobv, 1),
 			     m, n, tmp_data, m, s_vec, u, m, vt,
 			     nrow_vt, work.fortran_vec (), lwork,
 			     rwork.fortran_vec (), info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgesvd");
   else
     {
-      lwork = static_cast<int> (work(0).real ());
+      lwork = static_cast<octave_idx_type> (work(0).real ());
       work.resize (lwork);
 
       F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
 				 F77_CONST_CHAR_ARG2 (&jobv, 1),
 				 m, n, tmp_data, m, s_vec, u, m, vt,
 				 nrow_vt, work.fortran_vec (), lwork,
 				 rwork.fortran_vec (), info
 				 F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/CmplxSVD.h b/liboctave/CmplxSVD.h
--- a/liboctave/CmplxSVD.h
+++ b/liboctave/CmplxSVD.h
@@ -36,17 +36,17 @@ public:
 
   ComplexSVD (void) { }
 
   ComplexSVD (const ComplexMatrix& a, SVD::type svd_type = SVD::std)
     {
       init (a, svd_type);
     }
 
-  ComplexSVD (const ComplexMatrix& a, int& info,
+  ComplexSVD (const ComplexMatrix& a, octave_idx_type& info,
 	      SVD::type svd_type = SVD::std)
     {
       info = init (a, svd_type);
     }
 
   ComplexSVD (const ComplexSVD& a)
     : type_computed (a.type_computed),
       sigma (a.sigma), left_sm (a.left_sm), right_sm (a.right_sm) { }
@@ -76,17 +76,17 @@ public:
 private:
 
   SVD::type type_computed;
 
   DiagMatrix sigma;
   ComplexMatrix left_sm;
   ComplexMatrix right_sm;
 
-  int init (const ComplexMatrix& a, SVD::type svd_type = SVD::std);
+  octave_idx_type init (const ComplexMatrix& a, SVD::type svd_type = SVD::std);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -28,22 +28,22 @@ Software Foundation, 59 Temple Place - S
 
 #include "CollocWt.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (jcobi, JCOBI) (int&, int&, int&, int&, double&,
+  F77_FUNC (jcobi, JCOBI) (octave_idx_type&, octave_idx_type&, octave_idx_type&, octave_idx_type&, double&,
 			   double&, double*, double*, double*,
 			   double*);
 
   F77_RET_T
-  F77_FUNC (dfopr, DFOPR) (int&, int&, int&, int&, int&, int&,
+  F77_FUNC (dfopr, DFOPR) (octave_idx_type&, octave_idx_type&, octave_idx_type&, octave_idx_type&, octave_idx_type&, octave_idx_type&,
 			   double*, double*, double*, double*,
 			   double*);
 }
 
 // Error handling.
 
 void
 CollocWt::error (const char* msg)
@@ -86,17 +86,17 @@ CollocWt::init (void)
 
   double wid = rb - lb;
   if (wid <= 0.0)
     {
       error ("width less than or equal to zero");
       return;
     }
 
-  int nt = n + inc_left + inc_right;
+  octave_idx_type nt = n + inc_left + inc_right;
 
   if (nt < 0)
     {
       error ("total number of collocation points less than zero");
       return;
     }
   else if (nt == 0)
     return;
@@ -120,39 +120,39 @@ CollocWt::init (void)
 
   double *pr = r.fortran_vec ();
 
   // Compute roots.
 
   F77_FUNC (jcobi, JCOBI) (nt, n, inc_left, inc_right, Alpha, Beta,
 			  pdif1, pdif2, pdif3, pr);
 
-  int id;
+  octave_idx_type id;
 
   // First derivative weights.
 
   id = 1;
-  for (int i = 1; i <= nt; i++)
+  for (octave_idx_type i = 1; i <= nt; i++)
     {
       F77_FUNC (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, pdif1,
 			      pdif2, pdif3, pr, pvect); 
 
-      for (int j = 0; j < nt; j++)
+      for (octave_idx_type j = 0; j < nt; j++)
 	A (i-1, j) = vect.elem (j);
     }
 
   // Second derivative weights.
 
   id = 2;
-  for (int i = 1; i <= nt; i++)
+  for (octave_idx_type i = 1; i <= nt; i++)
     {
       F77_FUNC (dfopr, DFOPR) (nt, n, inc_left, inc_right, i, id, pdif1,
 			      pdif2, pdif3, pr, pvect); 
 
-      for (int j = 0; j < nt; j++)
+      for (octave_idx_type j = 0; j < nt; j++)
 	B (i-1, j) = vect.elem (j);
     }
 
   // Gaussian quadrature weights.
 
   id = 3;
   double *pq = q.fortran_vec ();
   F77_FUNC (dfopr, DFOPR) (nt, n, inc_left, inc_right, id, id, pdif1,
diff --git a/liboctave/CollocWt.h b/liboctave/CollocWt.h
--- a/liboctave/CollocWt.h
+++ b/liboctave/CollocWt.h
@@ -32,29 +32,29 @@ class
 CollocWt
 {
 public:
 
   CollocWt (void)
     : n (0), inc_left (0), inc_right (0), lb (0.0), rb (1.0),
       Alpha (0.0), Beta (0.0), r (), q (), A (), B (), initialized (0) { }
 
-  CollocWt (int nc, int il, int ir)
+  CollocWt (octave_idx_type nc, octave_idx_type il, octave_idx_type ir)
     : n (nc), inc_left (il), inc_right (ir), lb (0.0), rb (1.0),
       Alpha (0.0), Beta (0.0), r (), q (), A (), B (), initialized (0) { }
 
-  CollocWt (int nc, int il, int ir, double l, double rr)
+  CollocWt (octave_idx_type nc, octave_idx_type il, octave_idx_type ir, double l, double rr)
     : n (nc), inc_left (il), inc_right (ir), lb (l), rb (rr),
       Alpha (0.0), Beta (0.0), r (), q (), A (), B (), initialized (0) { }
 
-  CollocWt (int nc, double a, double b, int il, int ir)
+  CollocWt (octave_idx_type nc, double a, double b, octave_idx_type il, octave_idx_type ir)
     : n (nc), inc_left (il), inc_right (ir), lb (0.0), rb (1.0),
       Alpha (a), Beta (b), initialized (0) { }
 
-  CollocWt (int nc, double a, double b, int il, int ir,
+  CollocWt (octave_idx_type nc, double a, double b, octave_idx_type il, octave_idx_type ir,
 		      double ll, double rr)  
     : n (nc), inc_left (il), inc_right (ir), lb (ll), rb (rr),
       Alpha (a), Beta (b), r (), q (), A (), B (), initialized (0) { }
 
   CollocWt (const CollocWt& a)
     : n (a.n), inc_left (a.inc_left), inc_right (a.inc_right),
       lb (a.lb), rb (a.rb), Alpha (a.Alpha), Beta (a.Beta),
       r (a.r), q (a.q), A (a.A), B (a.B),
@@ -75,17 +75,17 @@ public:
 	  B = a.B;
 	  initialized = a.initialized;
 	}
       return *this;
     }
 
   ~CollocWt (void) { }
 
-  CollocWt& resize (int nc)
+  CollocWt& resize (octave_idx_type nc)
     {
       n = nc;
       initialized = 0;
       return *this;
     }
 
   CollocWt& add_left (void)
     {
@@ -128,20 +128,20 @@ public:
 
   CollocWt& set_beta (double val)
     {
       Beta = val;
       initialized = 0;
       return *this;
     }
 
-  int ncol (void) const { return n; }
+  octave_idx_type ncol (void) const { return n; }
 
-  int left_included (void) const { return inc_left; }
-  int right_included (void) const { return inc_right; }
+  octave_idx_type left_included (void) const { return inc_left; }
+  octave_idx_type right_included (void) const { return inc_right; }
 
   double left (void) const { return lb; }
   double right (void) const { return rb; }
 
   double width (void) const { return rb - lb; }
 
   double alpha (void) const { return Alpha; }
   double beta (void) const { return Beta; }
@@ -154,20 +154,20 @@ public:
   Matrix first (void) { if (!initialized) init (); return A; }
 
   Matrix second (void) { if (!initialized) init (); return B; }
 
   friend std::ostream& operator << (std::ostream&, const CollocWt&);
 
 protected:
 
-  int n;
+  octave_idx_type n;
 
-  int inc_left;
-  int inc_right;
+  octave_idx_type inc_left;
+  octave_idx_type inc_right;
 
   double lb;
   double rb;
 
   double Alpha;
   double Beta;
 
   ColumnVector r;
diff --git a/liboctave/DAEFunc.h b/liboctave/DAEFunc.h
--- a/liboctave/DAEFunc.h
+++ b/liboctave/DAEFunc.h
@@ -18,27 +18,29 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_DAEFunc_h)
 #define octave_DAEFunc_h 1
 
+#include "oct-types.h"
+
 class Matrix;
 class ColumnVector;
 
 class
 DAEFunc
 {
 public:
 
   typedef ColumnVector (*DAERHSFunc) (const ColumnVector& x,
 				      const ColumnVector& xdot,
-				      double t, int& ires);
+				      double t, octave_idx_type& ires);
 
   // This is really the form used by DASSL:
   //
   //   PD = DG/DY + CJ * DG/DYPRIME
 
   typedef Matrix (*DAEJacFunc) (const ColumnVector& x,
 				const ColumnVector& xdot,
 				double t, double cj);
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -78,28 +78,28 @@ initial guesses for the unknown componen
 input.  Set this option to 1 to solve the first problem, or 2 to solve
 the second (the default default is 0, so you must provide a set of
 initial conditions that are consistent).
 
 If this option is set to a nonzero value, you must also set the
 @code{\"algebraic variables\"} option to declare which variables in the
 problem are algebraic.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "use initial condition heuristics"
   DOC_ITEM
 Set to a nonzero value to use the initial condition heuristics options
 described below.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "initial condition heuristics"
   DOC_ITEM
 A vector of the following parameters that can be used to control the
@@ -148,46 +148,46 @@ time steps. The default is @code{EPINIT}
 END_OPTION
 
 OPTION
   NAME = "print initial condition info"
   DOC_ITEM
 Set this option to a nonzero value to display detailed information
 about the initial condition calculation (default is 0).
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "exclude algebraic variables from error test"
   DOC_ITEM
 Set to a nonzero value to exclude algebraic variables from the error
 test.  You must also set the @code{\"algebraic variables\"} option to
 declare which variables in the problem are algebraic (default is 0).
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "algebraic variables"
   DOC_ITEM
 A vector of the same length as the state vector.  A nonzero element
 indicates that the corresponding element of the state vector is an
 algebraic variable (i.e., its derivative does not appear explicitly
 in the equation set.
 
 This option is required by the
 @code{compute consistent initial condition\"} and
 @code{\"exclude algebraic variables from error test\"} options.
   END_DOC_ITEM
-  TYPE = "Array<int>"
+  TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
     $OPTVAR.resize (1);
     $OPTVAR(0) = 0;
   END_INIT_BODY
   SET_CODE
     void set_$OPT (int val)
       {
@@ -209,17 +209,17 @@ constraints specified by the @code{\"ine
 option (default is 0).
 
 @enumerate
 @item To have constraint checking only in the initial condition calculation.
 @item To enforce constraint checking during the integration.
 @item To enforce both options 1 and 2.
 @end enumerate
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "inequality constraint types"
   DOC_ITEM
 A vector of the same length as the state specifying the type of
@@ -238,24 +238,24 @@ Not constrained.
 Greater than or equal to zero.
 @item 2
 Greater than zero.
 @end table
 
 This option only has an effect if the
 @code{\"enforce inequality constraints\"} option is nonzero.
   END_DOC_ITEM
-  TYPE = "Array<int>"
+  TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
     $OPTVAR.resize (1);
     $OPTVAR(0) = 0;
   END_INIT_BODY
   SET_CODE
-    void set_$OPT (int val)
+    void set_$OPT (octave_idx_type val)
       {
         $OPTVAR.resize (1);
         $OPTVAR(0) = val;
         reset = true;
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
@@ -277,17 +277,17 @@ automatically).
 END_OPTION
 
 OPTION
   NAME = "maximum order"
   DOC_ITEM
 Restrict the maximum order of the solution method.  This option must
 be between 1 and 5, inclusive (default is 5).
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "5"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
   DOC_ITEM
 Setting the maximum stepsize will avoid passing over very large
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -28,120 +28,120 @@ Software Foundation, 59 Temple Place - S
 #include <cmath>
 
 #include "DASPK.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-sstream.h"
 #include "quit.h"
 
-typedef int (*daspk_fcn_ptr) (const double&, const double*,
+typedef octave_idx_type (*daspk_fcn_ptr) (const double&, const double*,
 			      const double*, const double&,
-			      double*, int&, double*, int*);
+			      double*, octave_idx_type&, double*, octave_idx_type*);
 
-typedef int (*daspk_jac_ptr) (const double&, const double*,
+typedef octave_idx_type (*daspk_jac_ptr) (const double&, const double*,
 			      const double*, double*,
-			      const double&, double*, int*);
+			      const double&, double*, octave_idx_type*);
 
-typedef int (*daspk_psol_ptr) (const int&, const double&,
+typedef octave_idx_type (*daspk_psol_ptr) (const octave_idx_type&, const double&,
 			       const double*, const double*,
 			       const double*, const double&,
-			       const double*, double*, int*,
-			       double*, const double&, int&,
-			       double*, int*);
+			       const double*, double*, octave_idx_type*,
+			       double*, const double&, octave_idx_type&,
+			       double*, octave_idx_type*);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (ddaspk, DDASPK) (daspk_fcn_ptr, const int&, double&,
-			     double*, double*, double&, const int*,
-			     const double*, const double*, int&,
-			     double*, const int&, int*, const int&,
-			     const double*, const int*,
+  F77_FUNC (ddaspk, DDASPK) (daspk_fcn_ptr, const octave_idx_type&, double&,
+			     double*, double*, double&, const octave_idx_type*,
+			     const double*, const double*, octave_idx_type&,
+			     double*, const octave_idx_type&, octave_idx_type*, const octave_idx_type&,
+			     const double*, const octave_idx_type*,
 			     daspk_jac_ptr, daspk_psol_ptr);
 }
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
-static int nn;
+static octave_idx_type nn;
 
-static int
+static octave_idx_type
 ddaspk_f (const double& time, const double *state, const double *deriv,
-	  const double&, double *delta, int& ires, double *, int *)
+	  const double&, double *delta, octave_idx_type& ires, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
-  for (int i = 0; i < nn; i++)
+  for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.length () == 0)
 	ires = -2;
       else
 	{
-	  for (int i = 0; i < nn; i++)
+	  for (octave_idx_type i = 0; i < nn; i++)
 	    delta [i] = tmp_delta.elem (i);
 	}
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 //NEQ, T, Y, YPRIME, SAVR, WK, CJ, WGHT,
 //C                          WP, IWP, B, EPLIN, IER, RPAR, IPAR)
 
-static int
-ddaspk_psol (const int&, const double&, const double *,
+static octave_idx_type
+ddaspk_psol (const octave_idx_type&, const double&, const double *,
 	     const double *, const double *, const double&,
-	     const double *, double *, int *, double *,
-	     const double&, int&, double *, int*)
+	     const double *, double *, octave_idx_type *, double *,
+	     const double&, octave_idx_type&, double *, octave_idx_type*)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   abort ();
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 
-static int
+static octave_idx_type
 ddaspk_j (const double& time, const double *state, const double *deriv,
-	  double *pd, const double& cj, double *, int *)
+	  double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // XXX FIXME XXX -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
-  for (int i = 0; i < nn; i++)
+  for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
-  for (int j = 0; j < nn; j++)
-    for (int i = 0; i < nn; i++)
+  for (octave_idx_type j = 0; j < nn; j++)
+    for (octave_idx_type i = 0; i < nn; i++)
       pd [nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
@@ -155,22 +155,22 @@ DASPK::do_integrate (double tout)
   if (! initialized || restart || DAEFunc::reset|| DASPK_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (20);
 
-      for (int i = 0; i < 20; i++)
+      for (octave_idx_type i = 0; i < 20; i++)
 	info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
-      int n = size ();
+      octave_idx_type n = size ();
 
       nn = n;
 
       info(0) = 0;
 
       if (stop_time_set)
 	{
 	  rwork(0) = stop_time;
@@ -184,17 +184,17 @@ DASPK::do_integrate (double tout)
 
       // DAEFunc
 
       user_fun = DAEFunc::function ();
       user_jac = DAEFunc::jacobian_function ();
 
       if (user_fun)
 	{
-	  int ires = 0;
+	  octave_idx_type ires = 0;
 
 	  ColumnVector res = (*user_fun) (x, xdot, t, ires);
 
 	  if (res.length () != x.length ())
 	    {
 	      (*current_liboctave_error_handler)
 		("daspk: inconsistent sizes for state and residual vectors");
 
@@ -210,19 +210,19 @@ DASPK::do_integrate (double tout)
 	  integration_error = true;
 	  return retval;
 	}
   
       info(4) = user_jac ? 1 : 0;
 
       DAEFunc::reset = false;
 
-      int eiq = enforce_inequality_constraints ();
-      int ccic = compute_consistent_initial_condition ();
-      int eavfet = exclude_algebraic_variables_from_error_test ();
+      octave_idx_type eiq = enforce_inequality_constraints ();
+      octave_idx_type ccic = compute_consistent_initial_condition ();
+      octave_idx_type eavfet = exclude_algebraic_variables_from_error_test ();
 
       liw = 40 + n;
       if (eiq == 1 || eiq == 3)
 	liw += n;
       if (ccic == 1 || eavfet == 1)
 	liw += n;
 
       lrw = 50 + 9*n + n*n;
@@ -235,18 +235,18 @@ DASPK::do_integrate (double tout)
       piwork = iwork.fortran_vec ();
       prwork = rwork.fortran_vec ();
 
       // DASPK_options
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      int abs_tol_len = abs_tol.length ();
-      int rel_tol_len = rel_tol.length ();
+      octave_idx_type abs_tol_len = abs_tol.length ();
+      octave_idx_type rel_tol_len = rel_tol.length ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
 	{
 	  info(1) = 0;
 	}
       else if (abs_tol_len == n && rel_tol_len == n)
 	{
 	  info(1) = 1;
@@ -276,17 +276,17 @@ DASPK::do_integrate (double tout)
       if (h0 >= 0.0)
 	{
 	  rwork(2) = h0;
 	  info(7) = 1;
 	}
       else
 	info(7) = 0;
 
-      int maxord = maximum_order ();
+      octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
 	{
 	  if (maxord > 0 && maxord < 6)
 	    {
 	      info(8) = 1;
 	      iwork(2) = maxord;
 	    }
 	  else
@@ -298,23 +298,23 @@ DASPK::do_integrate (double tout)
 	    }
 	}
 
       switch (eiq)
 	{
 	case 1:
 	case 3:
 	  {
-	    Array<int> ict = inequality_constraint_types ();
+	    Array<octave_idx_type> ict = inequality_constraint_types ();
 
 	    if (ict.length () == n)
 	      {
-		for (int i = 0; i < n; i++)
+		for (octave_idx_type i = 0; i < n; i++)
 		  {
-		    int val = ict(i);
+		    octave_idx_type val = ict(i);
 		    if (val < -2 || val > 2)
 		      {
 			(*current_liboctave_error_handler)
 			  ("daspk: invalid value for inequality constraint type");
 			integration_error = true;
 			return retval;
 		      }
 		    iwork(40+i) = val;
@@ -343,29 +343,29 @@ DASPK::do_integrate (double tout)
 	}
 
       if (ccic)
 	{
 	  if (ccic == 1)
 	    {
 	      // XXX FIXME XXX -- this code is duplicated below.
 
-	      Array<int> av = algebraic_variables ();
+	      Array<octave_idx_type> av = algebraic_variables ();
 
 	      if (av.length () == n)
 		{
-		  int lid;
+		  octave_idx_type lid;
 		  if (eiq == 0 || eiq == 2)
 		    lid = 40;
 		  else if (eiq == 1 || eiq == 3)
 		    lid = 40 + n;
 		  else
 		    abort ();
 
-		  for (int i = 0; i < n; i++)
+		  for (octave_idx_type i = 0; i < n; i++)
 		    iwork(lid+i) = av(i) ? -1 : 1;
 		}
 	      else
 		{
 		  (*current_liboctave_error_handler)
 		    ("daspk: algebraic variables size mismatch");
 		  integration_error = true;
 		  return retval;
@@ -383,59 +383,59 @@ DASPK::do_integrate (double tout)
 	}
 
       if (eavfet)
 	{
 	  info(15) = 1;
 
 	  // XXX FIXME XXX -- this code is duplicated above.
 
-	  Array<int> av = algebraic_variables ();
+	  Array<octave_idx_type> av = algebraic_variables ();
 
 	  if (av.length () == n)
 	    {
-	      int lid;
+	      octave_idx_type lid;
 	      if (eiq == 0 || eiq == 2)
 		lid = 40;
 	      else if (eiq == 1 || eiq == 3)
 		lid = 40 + n;
 	      else
 		abort ();
 
-	      for (int i = 0; i < n; i++)
+	      for (octave_idx_type i = 0; i < n; i++)
 		iwork(lid+i) = av(i) ? -1 : 1;
 	    }
 	}
 
       if (use_initial_condition_heuristics ())
 	{
 	  Array<double> ich = initial_condition_heuristics ();
 
 	  if (ich.length () == 6)
 	    {
-	      iwork(31) = NINT (ich(0));
-	      iwork(32) = NINT (ich(1));
-	      iwork(33) = NINT (ich(2));
-	      iwork(34) = NINT (ich(3));
+	      iwork(31) = NINTbig (ich(0));
+	      iwork(32) = NINTbig (ich(1));
+	      iwork(33) = NINTbig (ich(2));
+	      iwork(34) = NINTbig (ich(3));
 
 	      rwork(13) = ich(4);
 	      rwork(14) = ich(5);
 	    }
 	  else
 	    {
 	      (*current_liboctave_error_handler)
 		("daspk: invalid initial condition heuristics option");
 	      integration_error = true;
 	      return retval;
 	    }
 
 	  info(16) = 1;
 	}
 
-      int pici = print_initial_condition_info ();
+      octave_idx_type pici = print_initial_condition_info ();
       switch (pici)
 	{
 	case 0:
 	case 1:
 	case 2:
 	  info(17) = pici;
 	  break;
 
@@ -448,17 +448,17 @@ DASPK::do_integrate (double tout)
 	}
 
       DASPK_options::reset = false;
 
       restart = false;
     }
 
   static double *dummy = 0;
-  static int *idummy = 0;
+  static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddaspk, DDASPK, (ddaspk_f, nn, t, px, pxdot, tout, pinfo,
 			     prel_tol, pabs_tol, istate, prwork, lrw,
 			     piwork, liw, dummy, idummy, ddaspk_j,
 			     ddaspk_psol));
 
   if (f77_exception_encountered)
     {
@@ -533,38 +533,38 @@ DASPK::do_integrate (const ColumnVector&
   return integrate (tout, dummy);
 }
 
 Matrix
 DASPK::integrate (const ColumnVector& tout, Matrix& xdot_out)
 {
   Matrix retval;
 
-  int n_out = tout.capacity ();
-  int n = size ();
+  octave_idx_type n_out = tout.capacity ();
+  octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  retval.elem (0, i) = x.elem (i);
 	  xdot_out.elem (0, i) = xdot.elem (i);
 	}
 
-      for (int j = 1; j < n_out; j++)
+      for (octave_idx_type j = 1; j < n_out; j++)
 	{
 	  ColumnVector x_next = do_integrate (tout.elem (j));
 
 	  if (integration_error)
 	    return retval;
 
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      retval.elem (j, i) = x_next.elem (i);
 	      xdot_out.elem (j, i) = xdot.elem (i);
 	    }
 	}
     }
 
   return retval;
@@ -578,36 +578,36 @@ DASPK::do_integrate (const ColumnVector&
 }
 
 Matrix
 DASPK::integrate (const ColumnVector& tout, Matrix& xdot_out,
 		  const ColumnVector& tcrit) 
 {
   Matrix retval;
 
-  int n_out = tout.capacity ();
-  int n = size ();
+  octave_idx_type n_out = tout.capacity ();
+  octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  retval.elem (0, i) = x.elem (i);
 	  xdot_out.elem (0, i) = xdot.elem (i);
 	}
 
-      int n_crit = tcrit.capacity ();
+      octave_idx_type n_crit = tcrit.capacity ();
 
       if (n_crit > 0)
 	{
-	  int i_crit = 0;
-	  int i_out = 1;
+	  octave_idx_type i_crit = 0;
+	  octave_idx_type i_out = 1;
 	  double next_crit = tcrit.elem (0);
 	  double next_out;
 	  while (i_out < n_out)
 	    {
 	      bool do_restart = false;
 
 	      next_out = tout.elem (i_out);
 	      if (i_crit < n_crit)
@@ -653,17 +653,17 @@ DASPK::integrate (const ColumnVector& to
 
 	      ColumnVector x_next = do_integrate (t_out);
 
 	      if (integration_error)
 		return retval;
 
 	      if (save_output)
 		{
-		  for (int i = 0; i < n; i++)
+		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      retval.elem (i_out-1, i) = x_next.elem (i);
 		      xdot_out.elem (i_out-1, i) = xdot.elem (i);
 		    }
 		}
 
 	      if (do_restart)
 		force_restart ();
diff --git a/liboctave/DASPK.h b/liboctave/DASPK.h
--- a/liboctave/DASPK.h
+++ b/liboctave/DASPK.h
@@ -56,33 +56,33 @@ public:
 		    const ColumnVector& tcrit); 
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  int liw;  
-  int lrw;
+  octave_idx_type liw;  
+  octave_idx_type lrw;
 
-  Array<int> info;
-  Array<int> iwork;
+  Array<octave_idx_type> info;
+  Array<octave_idx_type> iwork;
 
   Array<double> rwork;
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 
   double *px;
   double *pxdot;
   double *pabs_tol;
   double *prel_tol;
-  int *pinfo;
-  int *piwork;
+  octave_idx_type *pinfo;
+  octave_idx_type *piwork;
   double *prwork;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/DASRT-opts.in b/liboctave/DASRT-opts.in
--- a/liboctave/DASRT-opts.in
+++ b/liboctave/DASRT-opts.in
@@ -73,17 +73,17 @@ problem by specifying an initial stepsiz
 END_OPTION
 
 OPTION
   NAME = "maximum order"
   DOC_ITEM
 Restrict the maximum order of the solution method.  This option must
 be between 1 and 5, inclusive.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "-1"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
   DOC_ITEM
 Setting the maximum stepsize will avoid passing over very large
@@ -95,12 +95,12 @@ regions.
 END_OPTION
 
 OPTION
   NAME = "step limit"
   DOC_ITEM
 Maximum number of integration steps to attempt on a single call to the
 underlying Fortran code.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "-1"
   SET_EXPR = "(val >= 0) ? val : -1"
 END_OPTION
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -28,115 +28,115 @@ Software Foundation, 59 Temple Place - S
 #include <cmath>
 
 #include "DASRT.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-sstream.h"
 #include "quit.h"
 
-typedef int (*dasrt_fcn_ptr) (const double&, const double*, const double*,
-			      double*, int&, double*, int*);
+typedef octave_idx_type (*dasrt_fcn_ptr) (const double&, const double*, const double*,
+			      double*, octave_idx_type&, double*, octave_idx_type*);
 
-typedef int (*dasrt_jac_ptr) (const double&, const double*, const double*,
-			      double*, const double&, double*, int*);
+typedef octave_idx_type (*dasrt_jac_ptr) (const double&, const double*, const double*,
+			      double*, const double&, double*, octave_idx_type*);
 
-typedef int (*dasrt_constr_ptr) (const int&, const double&, const double*,
-				 const int&, double*, double*, int*);
+typedef octave_idx_type (*dasrt_constr_ptr) (const octave_idx_type&, const double&, const double*,
+				 const octave_idx_type&, double*, double*, octave_idx_type*);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (ddasrt, DDASRT) (dasrt_fcn_ptr, const int&, double&,
-			     double*, double*, const double&, int*,
-			     const double*, const double*, int&, double*,
-			     const int&, int*, const int&, double*,
-			     int*, dasrt_jac_ptr, dasrt_constr_ptr,
-			     const int&, int*);
+  F77_FUNC (ddasrt, DDASRT) (dasrt_fcn_ptr, const octave_idx_type&, double&,
+			     double*, double*, const double&, octave_idx_type*,
+			     const double*, const double*, octave_idx_type&, double*,
+			     const octave_idx_type&, octave_idx_type*, const octave_idx_type&, double*,
+			     octave_idx_type*, dasrt_jac_ptr, dasrt_constr_ptr,
+			     const octave_idx_type&, octave_idx_type*);
 }
 
 static DAEFunc::DAERHSFunc user_fsub;
 static DAEFunc::DAEJacFunc user_jsub;
 static DAERTFunc::DAERTConstrFunc user_csub;
 
-static int nn;
+static octave_idx_type nn;
 
-static int
+static octave_idx_type
 ddasrt_f (const double& t, const double *state, const double *deriv,
-	  double *delta, int& ires, double *, int *)
+	  double *delta, octave_idx_type& ires, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
-  for (int i = 0; i < nn; i++)
+  for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_state(i) = state[i];
       tmp_deriv(i) = deriv[i];
     }
 
   ColumnVector tmp_fval = (*user_fsub) (tmp_state, tmp_deriv, t, ires);
 
   if (tmp_fval.length () == 0)
     ires = -2;
   else
     {
-      for (int i = 0; i < nn; i++)
+      for (octave_idx_type i = 0; i < nn; i++)
 	delta[i] = tmp_fval(i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-int
+octave_idx_type
 ddasrt_j (const double& time, const double *state, const double *deriv,
-	  double *pd, const double& cj, double *, int *)
+	  double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // XXX FIXME XXX -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
-  for (int i = 0; i < nn; i++)
+  for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
     }
 
   Matrix tmp_pd = (*user_jsub) (tmp_state, tmp_deriv, time, cj);
 
-  for (int j = 0; j < nn; j++)
-    for (int i = 0; i < nn; i++)
+  for (octave_idx_type j = 0; j < nn; j++)
+    for (octave_idx_type i = 0; i < nn; i++)
       pd [nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-static int
-ddasrt_g (const int& neq, const double& t, const double *state,
-	  const int& ng, double *gout, double *, int *) 
+static octave_idx_type
+ddasrt_g (const octave_idx_type& neq, const double& t, const double *state,
+	  const octave_idx_type& ng, double *gout, double *, octave_idx_type *) 
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  int n = neq;
+  octave_idx_type n = neq;
 
   ColumnVector tmp_state (n);
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     tmp_state(i) = state[i];
 
   ColumnVector tmp_fval = (*user_csub) (tmp_state, t);
 
-  for (int i = 0; i < ng; i++)
+  for (octave_idx_type i = 0; i < ng; i++)
     gout[i] = tmp_fval(i);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 void
@@ -152,38 +152,38 @@ DASRT::integrate (double tout)
       || DAEFunc::reset || DAERTFunc::reset || DASRT_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (15);
 
-      for (int i = 0; i < 15; i++)
+      for (octave_idx_type i = 0; i < 15; i++)
 	info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
-      int n = size ();
+      octave_idx_type n = size ();
 
       nn = n;
 
       // DAERTFunc
 
       user_csub = DAERTFunc::constraint_function ();
 
       if (user_csub)
 	{
 	  ColumnVector tmp = (*user_csub) (x, t);
 	  ng = tmp.length ();
 	}
       else
 	ng = 0;
 
-      int maxord = maximum_order ();
+      octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
 	{
 	  if (maxord > 0 && maxord < 6)
 	    {
 	      info(8) = 1;
 	      iwork(2) = maxord;
 	    }
 	  else
@@ -221,17 +221,17 @@ DASRT::integrate (double tout)
 
       // DAEFunc
 
       user_fsub = DAEFunc::function ();
       user_jsub = DAEFunc::jacobian_function ();
 
       if (user_fsub)
 	{
-	  int ires = 0;
+	  octave_idx_type ires = 0;
 
 	  ColumnVector fval = (*user_fsub) (x, xdot, t, ires);
 
 	  if (fval.length () != x.length ())
 	    {
 	      (*current_liboctave_error_handler)
 		("dasrt: inconsistent sizes for state and residual vectors");
 
@@ -284,18 +284,18 @@ DASRT::integrate (double tout)
 	  iwork(20) = step_limit ();
 	}
       else
 	info(11) = 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      int abs_tol_len = abs_tol.length ();
-      int rel_tol_len = rel_tol.length ();
+      octave_idx_type abs_tol_len = abs_tol.length ();
+      octave_idx_type rel_tol_len = rel_tol.length ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
 	{
 	  info.elem (1) = 0;
 	}
       else if (abs_tol_len == n && rel_tol_len == n)
 	{
 	  info.elem (1) = 1;
@@ -311,17 +311,17 @@ DASRT::integrate (double tout)
 
       pabs_tol = abs_tol.fortran_vec ();
       prel_tol = rel_tol.fortran_vec ();
 
       DASRT_options::reset = false;
     }
 
   static double *dummy = 0;
-  static int *idummy = 0;
+  static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddasrt, DDASRT, (ddasrt_f, nn, t, px, pxdot, tout, pinfo,
 			     prel_tol, pabs_tol, istate, prwork, lrw,
 			     piwork, liw, dummy, idummy, ddasrt_j,
 			     ddasrt_g, ng, pjroot));
 
   if (f77_exception_encountered)
     {
@@ -385,46 +385,46 @@ DASRT_result
 DASRT::integrate (const ColumnVector& tout)
 {
   DASRT_result retval;
 
   Matrix x_out;
   Matrix xdot_out;
   ColumnVector t_out = tout;
 
-  int n_out = tout.capacity ();
-  int n = size ();
+  octave_idx_type n_out = tout.capacity ();
+  octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       x_out.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  x_out(0,i) = x(i);
 	  xdot_out(0,i) = xdot(i);
 	}
 
-      for (int j = 1; j < n_out; j++)
+      for (octave_idx_type j = 1; j < n_out; j++)
 	{
 	  integrate (tout(j));
 
 	  if (integration_error)
 	    {
 	      retval = DASRT_result (x_out, xdot_out, t_out);
 	      return retval;
 	    }
 
           if (istate == 4)
             t_out(j) = t;
           else
             t_out(j) = tout(j);
 
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      x_out(j,i) = x(i);
 	      xdot_out(j,i) = xdot(i);
 	    }
 
           if (istate == 4)
 	    {
 	      x_out.resize (j+1, n);
@@ -444,41 +444,41 @@ DASRT_result
 DASRT::integrate (const ColumnVector& tout, const ColumnVector& tcrit) 
 {
   DASRT_result retval;
 
   Matrix x_out;
   Matrix xdot_out;
   ColumnVector t_outs = tout;
 
-  int n_out = tout.capacity ();
-  int n = size ();
+  octave_idx_type n_out = tout.capacity ();
+  octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       x_out.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      int n_crit = tcrit.capacity ();
+      octave_idx_type n_crit = tcrit.capacity ();
 
       if (n_crit > 0)
 	{
-	  int i_crit = 0;
-	  int i_out = 1;
+	  octave_idx_type i_crit = 0;
+	  octave_idx_type i_out = 1;
 	  double next_crit = tcrit(0);
 	  double next_out;
 	  while (i_out < n_out)
 	    {
 	      bool do_restart = false;
 
 	      next_out = tout(i_out);
 	      if (i_crit < n_crit)
 		next_crit = tcrit(i_crit);
 
-	      int save_output;
+	      octave_idx_type save_output;
 	      double t_out;
 
 	      if (next_crit == next_out)
 		{
 		  set_stop_time (next_crit);
 		  t_out = next_out;
 		  save_output = 1;
 		  i_out++;
@@ -519,17 +519,17 @@ DASRT::integrate (const ColumnVector& to
 		  return retval;
 		}
 
               if (istate == 4)
                 t_out = t;
 
 	      if (save_output)
 		{
-		  for (int i = 0; i < n; i++)
+		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      x_out(i_out-1,i) = x(i);
 		      xdot_out(i_out-1,i) = xdot(i);
 		    }
 
                   t_outs(i_out-1) = t_out;
 
                   if (istate == 4)
diff --git a/liboctave/DASRT.h b/liboctave/DASRT.h
--- a/liboctave/DASRT.h
+++ b/liboctave/DASRT.h
@@ -87,38 +87,38 @@ public:
 			  const ColumnVector& tcrit); 
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  int liw;  
-  int lrw;
+  octave_idx_type liw;  
+  octave_idx_type lrw;
 
-  int ng;
+  octave_idx_type ng;
 
-  Array<int> info;
-  Array<int> iwork;
-  Array<int> jroot;
+  Array<octave_idx_type> info;
+  Array<octave_idx_type> iwork;
+  Array<octave_idx_type> jroot;
 
   Array<double> rwork;
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 
   double *px;
   double *pxdot;
   double *pabs_tol;
   double *prel_tol;
-  int *pinfo;
-  int *piwork;
+  octave_idx_type *pinfo;
+  octave_idx_type *piwork;
   double *prwork;
-  int *pjroot;
+  octave_idx_type *pjroot;
 
   void integrate (double t);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -63,31 +63,31 @@ END_OPTION
 
 OPTION
   NAME = "compute consistent initial condition"
   DOC_ITEM
 If nonzero, @code{dassl} will attempt to compute a consistent set of intial
 conditions.  This is generally not reliable, so it is best to provide
 a consistent set and leave this option set to zero.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "enforce nonnegativity constraints"
   DOC_ITEM
 If you know that the solutions to your equations will always be
 nonnegative, it may help to set this parameter to a nonzero
 value.  However, it is probably best to try leaving this option set to
 zero first, and only setting it to a nonzero value if that doesn't
 work very well.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "initial step size"
   DOC_ITEM
 Differential-algebraic problems may occaisionally suffer from severe
@@ -101,17 +101,17 @@ problem by specifying an initial stepsiz
 END_OPTION
 
 OPTION
   NAME = "maximum order"
   DOC_ITEM
 Restrict the maximum order of the solution method.  This option must
 be between 1 and 5, inclusive.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "-1"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
   DOC_ITEM
 Setting the maximum stepsize will avoid passing over very large
@@ -123,12 +123,12 @@ regions  (default is not specified).
 END_OPTION
 
 OPTION
   NAME = "step limit"
   DOC_ITEM
 Maximum number of integration steps to attempt on a single call to the
 underlying Fortran code.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "-1"
   SET_EXPR = "(val >= 0) ? val : -1"
 END_OPTION
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -28,95 +28,95 @@ Software Foundation, 59 Temple Place - S
 #include <cmath>
 
 #include "DASSL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-sstream.h"
 #include "quit.h"
 
-typedef int (*dassl_fcn_ptr) (const double&, const double*, const double*,
-			      double*, int&, double*, int*);
+typedef octave_idx_type (*dassl_fcn_ptr) (const double&, const double*, const double*,
+			      double*, octave_idx_type&, double*, octave_idx_type*);
 
-typedef int (*dassl_jac_ptr) (const double&, const double*, const double*,
-			      double*, const double&, double*, int*);
+typedef octave_idx_type (*dassl_jac_ptr) (const double&, const double*, const double*,
+			      double*, const double&, double*, octave_idx_type*);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (ddassl, DDASSL) (dassl_fcn_ptr, const int&, double&,
-			     double*, double*, double&, const int*,
-			     const double*, const double*, int&,
-			     double*, const int&, int*, const int&,
-			     const double*, const int*,
+  F77_FUNC (ddassl, DDASSL) (dassl_fcn_ptr, const octave_idx_type&, double&,
+			     double*, double*, double&, const octave_idx_type*,
+			     const double*, const double*, octave_idx_type&,
+			     double*, const octave_idx_type&, octave_idx_type*, const octave_idx_type&,
+			     const double*, const octave_idx_type*,
 			     dassl_jac_ptr);
 }
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
 
-static int nn;
+static octave_idx_type nn;
 
-static int
+static octave_idx_type
 ddassl_f (const double& time, const double *state, const double *deriv,
-	  double *delta, int& ires, double *, int *)
+	  double *delta, octave_idx_type& ires, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // XXX FIXME XXX -- would be nice to avoid copying the data.
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
-  for (int i = 0; i < nn; i++)
+  for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.length () == 0)
 	ires = -2;
       else
 	{
-	  for (int i = 0; i < nn; i++)
+	  for (octave_idx_type i = 0; i < nn; i++)
 	    delta [i] = tmp_delta.elem (i);
 	}
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-static int
+static octave_idx_type
 ddassl_j (const double& time, const double *state, const double *deriv,
-	  double *pd, const double& cj, double *, int *)
+	  double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // XXX FIXME XXX -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
-  for (int i = 0; i < nn; i++)
+  for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
-  for (int j = 0; j < nn; j++)
-    for (int i = 0; i < nn; i++)
+  for (octave_idx_type j = 0; j < nn; j++)
+    for (octave_idx_type i = 0; i < nn; i++)
       pd [nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
@@ -127,22 +127,22 @@ DASSL::do_integrate (double tout)
   if (! initialized || restart || DAEFunc::reset|| DASSL_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (15);
 
-      for (int i = 0; i < 15; i++)
+      for (octave_idx_type i = 0; i < 15; i++)
 	info(i) = 0;
 
       pinfo = info.fortran_vec ();
 
-      int n = size ();
+      octave_idx_type n = size ();
 
       liw = 21 + n;
       lrw = 40 + 9*n + n*n;
 
       nn = n;
 
       iwork.resize (liw);
       rwork.resize (lrw);
@@ -167,17 +167,17 @@ DASSL::do_integrate (double tout)
 
       // DAEFunc
 
       user_fun = DAEFunc::function ();
       user_jac = DAEFunc::jacobian_function ();
 
       if (user_fun)
 	{
-	  int ires = 0;
+	  octave_idx_type ires = 0;
 
 	  ColumnVector res = (*user_fun) (x, xdot, t, ires);
 
 	  if (res.length () != x.length ())
 	    {
 	      (*current_liboctave_error_handler)
 		("dassl: inconsistent sizes for state and residual vectors");
 
@@ -221,44 +221,44 @@ DASSL::do_integrate (double tout)
       if (step_limit () >= 0)
 	{
 	  info(11) = 1;
 	  iwork(20) = step_limit ();
 	}
       else
 	info(11) = 0;
 
-      int maxord = maximum_order ();
+      octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
 	{
 	  if (maxord > 0 && maxord < 6)
 	    {
 	      info(8) = 1;
 	      iwork(2) = maxord;
 	    }
 	  else
 	    {
 	      (*current_liboctave_error_handler)
 		("dassl: invalid value for maximum order");
 	      integration_error = true;
 	      return retval;
 	    }
 	}
 
-      int enc = enforce_nonnegativity_constraints ();
+      octave_idx_type enc = enforce_nonnegativity_constraints ();
       info(9) = enc ? 1 : 0;
 
-      int ccic = compute_consistent_initial_condition ();
+      octave_idx_type ccic = compute_consistent_initial_condition ();
       info(10) = ccic ? 1 : 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      int abs_tol_len = abs_tol.length ();
-      int rel_tol_len = rel_tol.length ();
+      octave_idx_type abs_tol_len = abs_tol.length ();
+      octave_idx_type rel_tol_len = rel_tol.length ();
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
 	{
 	  info(1) = 0;
 	}
       else if (abs_tol_len == n && rel_tol_len == n)
 	{
 	  info(1) = 1;
@@ -274,17 +274,17 @@ DASSL::do_integrate (double tout)
 
       pabs_tol = abs_tol.fortran_vec ();
       prel_tol = rel_tol.fortran_vec ();
 
       DASSL_options::reset = false;
     }
 
   static double *dummy = 0;
-  static int *idummy = 0;
+  static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddassl, DDASSL, (ddassl_f, nn, t, px, pxdot, tout, pinfo,
 			     prel_tol, pabs_tol, istate, prwork, lrw,
 			     piwork, liw, dummy, idummy, ddassl_j));
 
   if (f77_exception_encountered)
     {
       integration_error = true;
@@ -349,38 +349,38 @@ DASSL::do_integrate (const ColumnVector&
   return integrate (tout, dummy);
 }
 
 Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out)
 {
   Matrix retval;
 
-  int n_out = tout.capacity ();
-  int n = size ();
+  octave_idx_type n_out = tout.capacity ();
+  octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  retval.elem (0, i) = x.elem (i);
 	  xdot_out.elem (0, i) = xdot.elem (i);
 	}
 
-      for (int j = 1; j < n_out; j++)
+      for (octave_idx_type j = 1; j < n_out; j++)
 	{
 	  ColumnVector x_next = do_integrate (tout.elem (j));
 
 	  if (integration_error)
 	    return retval;
 
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      retval.elem (j, i) = x_next.elem (i);
 	      xdot_out.elem (j, i) = xdot.elem (i);
 	    }
 	}
     }
 
   return retval;
@@ -394,36 +394,36 @@ DASSL::do_integrate (const ColumnVector&
 }
 
 Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out,
 		  const ColumnVector& tcrit) 
 {
   Matrix retval;
 
-  int n_out = tout.capacity ();
-  int n = size ();
+  octave_idx_type n_out = tout.capacity ();
+  octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  retval.elem (0, i) = x.elem (i);
 	  xdot_out.elem (0, i) = xdot.elem (i);
 	}
 
-      int n_crit = tcrit.capacity ();
+      octave_idx_type n_crit = tcrit.capacity ();
 
       if (n_crit > 0)
 	{
-	  int i_crit = 0;
-	  int i_out = 1;
+	  octave_idx_type i_crit = 0;
+	  octave_idx_type i_out = 1;
 	  double next_crit = tcrit.elem (0);
 	  double next_out;
 	  while (i_out < n_out)
 	    {
 	      bool do_restart = false;
 
 	      next_out = tout.elem (i_out);
 	      if (i_crit < n_crit)
@@ -469,17 +469,17 @@ DASSL::integrate (const ColumnVector& to
 
 	      ColumnVector x_next = do_integrate (t_out);
 
 	      if (integration_error)
 		return retval;
 
 	      if (save_output)
 		{
-		  for (int i = 0; i < n; i++)
+		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      retval.elem (i_out-1, i) = x_next.elem (i);
 		      xdot_out.elem (i_out-1, i) = xdot.elem (i);
 		    }
 		}
 
 	      if (do_restart)
 		force_restart ();
diff --git a/liboctave/DASSL.h b/liboctave/DASSL.h
--- a/liboctave/DASSL.h
+++ b/liboctave/DASSL.h
@@ -56,33 +56,33 @@ public:
 		    const ColumnVector& tcrit); 
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  int liw;  
-  int lrw;
+  octave_idx_type liw;  
+  octave_idx_type lrw;
 
-  Array<int> info;
-  Array<int> iwork;
+  Array<octave_idx_type> info;
+  Array<octave_idx_type> iwork;
 
   Array<double> rwork;
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 
   double *px;
   double *pxdot;
   double *pabs_tol;
   double *prel_tol;
-  int *pinfo;
-  int *piwork;
+  octave_idx_type *pinfo;
+  octave_idx_type *piwork;
   double *prwork;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -32,127 +32,127 @@ Software Foundation, 59 Temple Place - S
 #include "DiagArray2.h"
 
 #include "lo-error.h"
 
 // A two-dimensional array with diagonal elements only.
 
 template <class T>
 T
-DiagArray2<T>::elem (int r, int c) const
+DiagArray2<T>::elem (octave_idx_type r, octave_idx_type c) const
 {
   return (r == c) ? Array<T>::xelem (r) : T (0);
 }
 
 template <class T>
 T
-DiagArray2<T>::checkelem (int r, int c) const
+DiagArray2<T>::checkelem (octave_idx_type r, octave_idx_type c) const
 {
   if (r < 0 || c < 0 || r >= this->dim1 () || c >= this->dim2 ())
     {
       (*current_liboctave_error_handler) ("range error in DiagArray2");
       return T ();
     }
   return (r == c) ? Array<T>::xelem (r) : T (0);
 }
 
 template <class T>
 T
-DiagArray2<T>::operator () (int r, int c) const
+DiagArray2<T>::operator () (octave_idx_type r, octave_idx_type c) const
 {
   if (r < 0 || c < 0 || r >= this->dim1 () || c >= this->dim2 ())
     {
       (*current_liboctave_error_handler) ("range error in DiagArray2");
       return T ();
     }
   return (r == c) ? Array<T>::xelem (r) : T (0);
 }
 
 template <class T>
 T&
-DiagArray2<T>::xelem (int r, int c)
+DiagArray2<T>::xelem (octave_idx_type r, octave_idx_type c)
 {
   static T foo (0);
   return (r == c) ? Array<T>::xelem (r) : foo;
 }
 
 template <class T>
 T
-DiagArray2<T>::xelem (int r, int c) const
+DiagArray2<T>::xelem (octave_idx_type r, octave_idx_type c) const
 {
   return (r == c) ? Array<T>::xelem (r) : T (0);
 }
 
 template <class T>
 void
-DiagArray2<T>::resize (int r, int c)
+DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler) ("can't resize to negative dimensions");
       return;
     }
 
   if (r == this->dim1 () && c == this->dim2 ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = Array<T>::rep;
   const T *old_data = this->data ();
-  int old_len = this->length ();
+  octave_idx_type old_len = this->length ();
 
-  int new_len = r < c ? r : c;
+  octave_idx_type new_len = r < c ? r : c;
 
   Array<T>::rep = new typename Array<T>::ArrayRep (new_len);
 
   this->dimensions = dim_vector (r, c);
 
   if (old_data && old_len > 0)
     {
-      int min_len = old_len < new_len ? old_len : new_len;
+      octave_idx_type min_len = old_len < new_len ? old_len : new_len;
 
-      for (int i = 0; i < min_len; i++)
+      for (octave_idx_type i = 0; i < min_len; i++)
 	xelem (i, i) = old_data[i];
     }
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 void
-DiagArray2<T>::resize (int r, int c, const T& val)
+DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c, const T& val)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler) ("can't resize to negative dimensions");
       return;
     }
 
   if (r == this->dim1 () && c == this->dim2 ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = Array<T>::rep;
   const T *old_data = this->data ();
-  int old_len = this->length ();
+  octave_idx_type old_len = this->length ();
 
-  int new_len = r < c ? r : c;
+  octave_idx_type new_len = r < c ? r : c;
 
   Array<T>::rep = new typename Array<T>::ArrayRep (new_len);
 
   this->dimensions = dim_vector (r, c);
 
-  int min_len = old_len < new_len ? old_len : new_len;
+  octave_idx_type min_len = old_len < new_len ? old_len : new_len;
 
   if (old_data && old_len > 0)
     {
-      for (int i = 0; i < min_len; i++)
+      for (octave_idx_type i = 0; i < min_len; i++)
 	xelem (i, i) = old_data[i];
     }
 
-  for (int i = min_len; i < new_len; i++)
+  for (octave_idx_type i = min_len; i < new_len; i++)
     xelem (i, i) = val;
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -46,25 +46,25 @@ class idx_vector;
 // GABI Software, Sarl., 8 rue du Faisan, F-67000 Strasbourg, France
 
 template <class T>
 class
 DiagArray2 : public Array<T>
 {
 private:
 
-  T get (int i) { return Array<T>::xelem (i); }
+  T get (octave_idx_type i) { return Array<T>::xelem (i); }
 
-  void set (const T& val, int i) { Array<T>::xelem (i) = val; }
+  void set (const T& val, octave_idx_type i) { Array<T>::xelem (i) = val; }
 
   class Proxy
   {
   public:
 
-    Proxy (DiagArray2<T> *ref, int r, int c)
+    Proxy (DiagArray2<T> *ref, octave_idx_type r, octave_idx_type c)
       : i (r), j (c), object (ref) { } 
 
     const Proxy& operator = (const T& val) const
       {
 	if (i == j)
 	  {
 	    if (object)
 	      object->set (val, i);
@@ -90,38 +90,38 @@ private:
   private:
 
     // XXX FIXME XXX -- this is declared private to keep the user from
     // taking the address of a Proxy.  Maybe it should be implemented
     // by means of a companion function in the DiagArray2 class.
 
     T *operator& () const { assert (0); return (T *) 0; }
 
-    int i;
-    int j;
+    octave_idx_type i;
+    octave_idx_type j;
 
     DiagArray2<T> *object;
 
   };
 
 friend class Proxy;
 
 protected:
 
-  DiagArray2 (T *d, int r, int c) : Array<T> (d, r < c ? r : c)
+  DiagArray2 (T *d, octave_idx_type r, octave_idx_type c) : Array<T> (d, r < c ? r : c)
     { Array<T>::dimensions = dim_vector (r, c); }
 
 public:
 
   DiagArray2 (void) : Array<T> (dim_vector (0, 0)) { }
 
-  DiagArray2 (int r, int c) : Array<T> (r < c ? r : c)
+  DiagArray2 (octave_idx_type r, octave_idx_type c) : Array<T> (r < c ? r : c)
     { this->dimensions = dim_vector (r, c); }
 
-  DiagArray2 (int r, int c, const T& val) : Array<T> (r < c ? r : c)
+  DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) : Array<T> (r < c ? r : c)
     {
       this->dimensions = dim_vector (r, c);
 
       fill (val);
     }
 
   DiagArray2 (const Array<T>& a) : Array<T> (a)
     { this->dimensions = dim_vector (a.length (), a.length ()); }
@@ -134,54 +134,54 @@ public:
   DiagArray2<T>& operator = (const DiagArray2<T>& a)
     {
       if (this != &a)
 	Array<T>::operator = (a);
 
       return *this;
     }
 
-  Proxy elem (int r, int c)
+  Proxy elem (octave_idx_type r, octave_idx_type c)
     {
       return Proxy (this, r, c);
     }
 
-  Proxy checkelem (int r, int c)
+  Proxy checkelem (octave_idx_type r, octave_idx_type c)
     {
       if (r < 0 || c < 0 || r >= this->dim1 () || c >= this->dim2 ())
 	{
 	  (*current_liboctave_error_handler) ("range error in DiagArray2");
 	  return Proxy (0, r, c);
 	}
       else
 	return Proxy (this, r, c);
     }
 
-  Proxy operator () (int r, int c)
+  Proxy operator () (octave_idx_type r, octave_idx_type c)
     {
       if (r < 0 || c < 0 || r >= this->dim1 () || c >= this->dim2 ())
 	{
 	  (*current_liboctave_error_handler) ("range error in DiagArray2");
 	  return Proxy (0, r, c);
 	}
       else
 	return Proxy (this, r, c);
   }
 
-  T elem (int r, int c) const;
-  T checkelem (int r, int c) const;
-  T operator () (int r, int c) const;
+  T elem (octave_idx_type r, octave_idx_type c) const;
+  T checkelem (octave_idx_type r, octave_idx_type c) const;
+  T operator () (octave_idx_type r, octave_idx_type c) const;
 
   // No checking.
 
-  T& xelem (int r, int c);
-  T xelem (int r, int c) const;
+  T& xelem (octave_idx_type r, octave_idx_type c);
+  T xelem (octave_idx_type r, octave_idx_type c) const;
 
-  void resize (int n, int m);
-  void resize (int n, int m, const T& val);
+  void resize (octave_idx_type n, octave_idx_type m);
+  void resize (octave_idx_type n, octave_idx_type m, const T& val);
 
   void maybe_delete_elements (idx_vector& i, idx_vector& j);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -29,93 +29,93 @@ Software Foundation, 59 Temple Place - S
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeev, DGEEV) (F77_CONST_CHAR_ARG_DECL,
 			   F77_CONST_CHAR_ARG_DECL,
-			   const int&, double*, const int&, double*,
-			   double*, double*, const int&, double*,
-			   const int&, double*, const int&, int&
+			   const octave_idx_type&, double*, const octave_idx_type&, double*,
+			   double*, double*, const octave_idx_type&, double*,
+			   const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL
 			   F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgeev, ZGEEV) (F77_CONST_CHAR_ARG_DECL,
 			   F77_CONST_CHAR_ARG_DECL,
-			   const int&, Complex*, const int&, Complex*,
-			   Complex*, const int&, Complex*, const int&,
-			   Complex*, const int&, double*, int&
+			   const octave_idx_type&, Complex*, const octave_idx_type&, Complex*,
+			   Complex*, const octave_idx_type&, Complex*, const octave_idx_type&,
+			   Complex*, const octave_idx_type&, double*, octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL
 			   F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dsyev, DSYEV) (F77_CONST_CHAR_ARG_DECL,
 			   F77_CONST_CHAR_ARG_DECL,
-			   const int&, double*, const int&, double*,
-			   double*, const int&, int&
+			   const octave_idx_type&, double*, const octave_idx_type&, double*,
+			   double*, const octave_idx_type&, octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL
 			   F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zheev, ZHEEV) (F77_CONST_CHAR_ARG_DECL,
 			   F77_CONST_CHAR_ARG_DECL,
-			   const int&, Complex*, const int&, double*,
-			   Complex*, const int&, double*, int&
+			   const octave_idx_type&, Complex*, const octave_idx_type&, double*,
+			   Complex*, const octave_idx_type&, double*, octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL
 			   F77_CHAR_ARG_LEN_DECL);
 }
 
-int
+octave_idx_type
 EIG::init (const Matrix& a, bool calc_ev)
 {
   if (a.is_symmetric ())
     return symmetric_init (a, calc_ev);
 
-  int n = a.rows ();
+  octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
   Array<double> wr (n);
   double *pwr = wr.fortran_vec ();
 
   Array<double> wi (n);
   double *pwi = wi.fortran_vec ();
 
-  volatile int nvr = calc_ev ? n : 0;
+  volatile octave_idx_type nvr = calc_ev ? n : 0;
   Matrix vr (nvr, nvr);
   double *pvr = vr.fortran_vec ();
 
-  int lwork = -1;
+  octave_idx_type lwork = -1;
   double dummy_work;
 
   double *dummy = 0;
-  int idummy = 1;
+  octave_idx_type idummy = 1;
 
   F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
 			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			   n, tmp_data, n, pwr, pwi, dummy,
 			   idummy, pvr, n, &dummy_work, lwork, info
 			   F77_CHAR_ARG_LEN (1)
 			   F77_CHAR_ARG_LEN (1)));
 
   if (! f77_exception_encountered && info == 0)
     {
-      lwork = static_cast<int> (dummy_work);
+      lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
 			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			       n, tmp_data, n, pwr, pwi, dummy,
 			       idummy, pvr, n, pwork, lwork, info
 			       F77_CHAR_ARG_LEN (1)
@@ -131,83 +131,83 @@ EIG::init (const Matrix& a, bool calc_ev
 	{
 	  (*current_liboctave_error_handler) ("dgeev failed to converge");
 	  return info;
 	}
 
       lambda.resize (n);
       v.resize (nvr, nvr);
 
-      for (int j = 0; j < n; j++)
+      for (octave_idx_type j = 0; j < n; j++)
 	{
 	  if (wi.elem (j) == 0.0)
 	    {
 	      lambda.elem (j) = Complex (wr.elem (j));
-	      for (int i = 0; i < nvr; i++)
+	      for (octave_idx_type i = 0; i < nvr; i++)
 		v.elem (i, j) = vr.elem (i, j);
 	    }
 	  else
 	    {
 	      if (j+1 >= n)
 		{
 		  (*current_liboctave_error_handler) ("EIG: internal error");
 		  return -1;
 		}
 
 	      lambda.elem(j) = Complex (wr.elem(j), wi.elem(j));
 	      lambda.elem(j+1) = Complex (wr.elem(j+1), wi.elem(j+1));
 
-	      for (int i = 0; i < nvr; i++)
+	      for (octave_idx_type i = 0; i < nvr; i++)
 		{
 		  double real_part = vr.elem (i, j);
 		  double imag_part = vr.elem (i, j+1);
 		  v.elem (i, j) = Complex (real_part, imag_part);
 		  v.elem (i, j+1) = Complex (real_part, -imag_part);
 		}
 	      j++;
 	    }
 	}
     }
   else
     (*current_liboctave_error_handler) ("dgeev workspace query failed");
 
   return info;
 }
 
-int
+octave_idx_type 
 EIG::symmetric_init (const Matrix& a, bool calc_ev)
 {
-  int n = a.rows ();
+  octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
-  int lwork = -1;
+  octave_idx_type lwork = -1;
   double dummy_work;
 
   F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			   F77_CONST_CHAR_ARG2 ("U", 1),
 			   n, tmp_data, n, pwr, &dummy_work, lwork, info
 			   F77_CHAR_ARG_LEN (1)
 			   F77_CHAR_ARG_LEN (1)));
 
   if (! f77_exception_encountered && info == 0)
     {
-      lwork = static_cast<int> (dummy_work);
+      lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			       F77_CONST_CHAR_ARG2 ("U", 1),
 			       n, tmp_data, n, pwr, pwork, lwork, info
 			       F77_CHAR_ARG_LEN (1)
 			       F77_CHAR_ARG_LEN (1)));
@@ -228,62 +228,62 @@ EIG::symmetric_init (const Matrix& a, bo
       v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
     }
   else
     (*current_liboctave_error_handler) ("dsyev workspace query failed");
 
   return info;
 }
 
-int
+octave_idx_type
 EIG::init (const ComplexMatrix& a, bool calc_ev)
 {
   if (a.is_hermitian ())
     return hermitian_init (a, calc_ev);
 
-  int n = a.rows ();
+  octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
   ComplexColumnVector w (n);
   Complex *pw = w.fortran_vec ();
 
-  int nvr = calc_ev ? n : 0;
+  octave_idx_type nvr = calc_ev ? n : 0;
   ComplexMatrix vtmp (nvr, nvr);
   Complex *pv = vtmp.fortran_vec ();
 
-  int lwork = -1;
+  octave_idx_type lwork = -1;
   Complex dummy_work;
 
-  int lrwork = 2*n;
+  octave_idx_type lrwork = 2*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
-  int idummy = 1;
+  octave_idx_type idummy = 1;
 
   F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
 			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			   n, tmp_data, n, pw, dummy, idummy,
 			   pv, n, &dummy_work, lwork, prwork, info
 			   F77_CHAR_ARG_LEN (1)
 			   F77_CHAR_ARG_LEN (1)));
 
   if (! f77_exception_encountered && info == 0)
     {
-      lwork = static_cast<int> (dummy_work.real ());
+      lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
 			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			       n, tmp_data, n, pw, dummy, idummy,
 			       pv, n, pwork, lwork, prwork, info
 			       F77_CHAR_ARG_LEN (1)
@@ -305,52 +305,52 @@ EIG::init (const ComplexMatrix& a, bool 
       v = vtmp;
     }
   else
     (*current_liboctave_error_handler) ("zgeev workspace query failed");
 
   return info;
 }
 
-int
+octave_idx_type
 EIG::hermitian_init (const ComplexMatrix& a, bool calc_ev)
 {
-  int n = a.rows ();
+  octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
-  int lwork = -1;
+  octave_idx_type lwork = -1;
   Complex dummy_work;
 
-  int lrwork = 3*n;
+  octave_idx_type lrwork = 3*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			   F77_CONST_CHAR_ARG2 ("U", 1),
 			   n, tmp_data, n, pwr, &dummy_work, lwork,
 			   prwork, info
 			   F77_CHAR_ARG_LEN (1)
 			   F77_CHAR_ARG_LEN (1)));
 
   if (! f77_exception_encountered && info == 0)
     {
-      lwork = static_cast<int> (dummy_work.real ());
+      lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			       F77_CONST_CHAR_ARG2 ("U", 1),
 			       n, tmp_data, n, pwr, pwork, lwork, prwork, info
 			       F77_CHAR_ARG_LEN (1)
 			       F77_CHAR_ARG_LEN (1)));
diff --git a/liboctave/EIG.h b/liboctave/EIG.h
--- a/liboctave/EIG.h
+++ b/liboctave/EIG.h
@@ -38,23 +38,23 @@ friend class ComplexMatrix;
 public:
 
   EIG (void)
     : lambda (), v () { }
 
   EIG (const Matrix& a, bool calc_eigenvectors = true)
     { init (a, calc_eigenvectors); }
 
-  EIG (const Matrix& a, int& info, bool calc_eigenvectors = true)
+  EIG (const Matrix& a, octave_idx_type& info, bool calc_eigenvectors = true)
     { info = init (a, calc_eigenvectors); }
 
   EIG (const ComplexMatrix& a, bool calc_eigenvectors = true)
     { init (a, calc_eigenvectors); }
 
-  EIG (const ComplexMatrix& a, int& info, bool calc_eigenvectors = true)
+  EIG (const ComplexMatrix& a, octave_idx_type& info, bool calc_eigenvectors = true)
     { info = init (a, calc_eigenvectors); }
 
   EIG (const EIG& a)
     : lambda (a.lambda), v (a.v) { }
 
   EIG& operator = (const EIG& a)
     {
       if (this != &a)
@@ -73,21 +73,21 @@ public:
 
   friend std::ostream&  operator << (std::ostream& os, const EIG& a);
 
 private:
 
   ComplexColumnVector lambda;
   ComplexMatrix v;
 
-  int init (const Matrix& a, bool calc_eigenvectors);
-  int init (const ComplexMatrix& a, bool calc_eigenvectors);
+  octave_idx_type init (const Matrix& a, bool calc_eigenvectors);
+  octave_idx_type init (const ComplexMatrix& a, bool calc_eigenvectors);
 
-  int symmetric_init (const Matrix& a, bool calc_eigenvectors);
-  int hermitian_init (const ComplexMatrix& a, bool calc_eigenvectors);
+  octave_idx_type symmetric_init (const Matrix& a, bool calc_eigenvectors);
+  octave_idx_type hermitian_init (const ComplexMatrix& a, bool calc_eigenvectors);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/FEGrid.cc b/liboctave/FEGrid.cc
--- a/liboctave/FEGrid.cc
+++ b/liboctave/FEGrid.cc
@@ -40,78 +40,78 @@ FEGrid::error (const char* msg) const
 void
 FEGrid::nel_error (void) const
 {
   error ("number of elements less than 1");
 }
 
 // Constructors
 
-FEGrid::FEGrid (int nel, double width)
+FEGrid::FEGrid (octave_idx_type nel, double width)
 {
   if (nel < 1)
     {
       nel_error ();
       return;
     }
 
   elem.resize (nel+1);
 
-  for (int i = 0; i <= nel; i++)
+  for (octave_idx_type i = 0; i <= nel; i++)
     elem.elem (i) = i * width;
 }
 
-FEGrid::FEGrid (int nel, double l, double r)
+FEGrid::FEGrid (octave_idx_type nel, double l, double r)
 {
   if (nel < 1)
     {
       nel_error ();
       return;
     }
 
   elem.resize (nel+1);
 
   double width = (r - l) / nel;
 
-  for (int i = 0; i <= nel; i++)
+  for (octave_idx_type i = 0; i <= nel; i++)
     elem.elem (i) = i * width + l;
 
   check_grid ();
 }
 
-int
+octave_idx_type
 FEGrid::element (double x) const
 {
   if (! in_bounds (x))
     {
       error ("value not within grid boundaries");
       return -1;
     }
 
-  int nel = elem.capacity () - 1;
-  for (int i = 1; i <= nel; i++)
+  octave_idx_type nel = elem.capacity () - 1;
+  for (octave_idx_type i = 1; i <= nel; i++)
     {
       if (x >= elem.elem (i-1) && x <= elem.elem (i))
 	return i;
     }
   return -1;
        
 }
 
 void
 FEGrid::check_grid (void) const
 {
-  int nel = elem.capacity () - 1;
+  octave_idx_type nel = elem.capacity () - 1;
   if (nel < 1)
     {
       nel_error ();
       return;
     }
 
-  for (int i = 1; i <= nel; i++)
+  for (octave_idx_type i = 1; i <= nel; i++)
     {
       if (elem.elem (i-1) > elem.elem (i))
 	{
 	  error ("element boundaries not in ascending order");
 	  return;
 	}
 
       if (elem.elem (i-1) == elem.elem (i))
diff --git a/liboctave/FEGrid.h b/liboctave/FEGrid.h
--- a/liboctave/FEGrid.h
+++ b/liboctave/FEGrid.h
@@ -33,34 +33,34 @@ FEGrid
 public:
 
   FEGrid (void)
     : elem () { }
 
   FEGrid (const ColumnVector& elbnds)
     : elem (elbnds) { check_grid (); }
 
-  FEGrid (int nel, double width);
+  FEGrid (octave_idx_type nel, double width);
 
-  FEGrid (int nel, double left, double right);
+  FEGrid (octave_idx_type nel, double left, double right);
 
   FEGrid (const FEGrid& a)
     : elem (a.elem) { }
 
   FEGrid& operator = (const FEGrid& a)
     {
       if (this != &a)
 	elem = a.elem;
 
       return *this;
     }
 
   ~FEGrid (void) { }
 
-  int element (double x) const;
+  octave_idx_type element (double x) const;
 
   double left (void) const { return elem.elem (0); }
 
   double right (void) const { return elem.elem (elem.capacity () - 1); }
 
   int in_bounds (double x) const { return (x >= left () && x <= right ()); }
 
   ColumnVector element_boundaries (void) const { return elem; }
diff --git a/liboctave/LPsolve.cc b/liboctave/LPsolve.cc
--- a/liboctave/LPsolve.cc
+++ b/liboctave/LPsolve.cc
@@ -24,17 +24,17 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "LPsolve.h"
 #include "dColVector.h"
 #include "lo-error.h"
 
 ColumnVector
-LPsolve::do_minimize (double&, int&, ColumnVector&)
+LPsolve::do_minimize (double&, octave_idx_type&, ColumnVector&)
 {
   (*current_liboctave_error_handler) ("sorry, not implemented");
   return ColumnVector ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/LPsolve.h b/liboctave/LPsolve.h
--- a/liboctave/LPsolve.h
+++ b/liboctave/LPsolve.h
@@ -55,17 +55,17 @@ public:
       if (this != &a)
 	octave_LP::operator = (a);
 
       return *this;
     }
 
   ~LPsolve (void) { }
 
-  ColumnVector do_minimize (double& objf, int& inform, ColumnVector& lambda);
+  ColumnVector do_minimize (double& objf, octave_idx_type& inform, ColumnVector& lambda);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/LSODE-opts.in b/liboctave/LSODE-opts.in
--- a/liboctave/LSODE-opts.in
+++ b/liboctave/LSODE-opts.in
@@ -88,17 +88,17 @@ END_OPTION
 
 OPTION
   NAME = "maximum order"
   DOC_ITEM
 Restrict the maximum order of the solution method.  If using the Adams
 method, this option must be between 1 and 12.  Otherwise, it must be
 between 1 and 5, inclusive.
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "-1"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
   DOC_ITEM
 Setting the maximum stepsize will avoid passing over very large
@@ -119,12 +119,12 @@ The minimum absolute step size allowed (
   SET_EXPR = "(val >= 0.0) ? val : 0.0"
 END_OPTION
 
 OPTION
   NAME = "step limit"
   DOC_ITEM
 Maximum number of steps allowed (default is 100000).
   END_DOC_ITEM
-  TYPE = "int"
+  TYPE = "octave_idx_type"
   INIT_VALUE = "100000"
   SET_EXPR = "val"
 END_OPTION
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -28,106 +28,106 @@ Software Foundation, 59 Temple Place - S
 #include <cmath>
 
 #include "LSODE.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-sstream.h"
 #include "quit.h"
 
-typedef int (*lsode_fcn_ptr) (const int&, const double&, double*,
-			      double*, int&);
+typedef octave_idx_type (*lsode_fcn_ptr) (const octave_idx_type&, const double&, double*,
+			      double*, octave_idx_type&);
 
-typedef int (*lsode_jac_ptr) (const int&, const double&, double*,
-			      const int&, const int&, double*, const
-			      int&);
+typedef octave_idx_type (*lsode_jac_ptr) (const octave_idx_type&, const double&, double*,
+			      const octave_idx_type&, const octave_idx_type&, double*, const
+			      octave_idx_type&);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dlsode, DLSODE) (lsode_fcn_ptr, int&, double*, double&,
-			     double&, int&, double&, const double*, int&,
-			     int&, int&, double*, int&, int*, int&,
-			     lsode_jac_ptr, int&);
+  F77_FUNC (dlsode, DLSODE) (lsode_fcn_ptr, octave_idx_type&, double*, double&,
+			     double&, octave_idx_type&, double&, const double*, octave_idx_type&,
+			     octave_idx_type&, octave_idx_type&, double*, octave_idx_type&, octave_idx_type*, octave_idx_type&,
+			     lsode_jac_ptr, octave_idx_type&);
 }
 
 static ODEFunc::ODERHSFunc user_fun;
 static ODEFunc::ODEJacFunc user_jac;
 static ColumnVector *tmp_x;
 
-static int
-lsode_f (const int& neq, const double& time, double *,
-	 double *deriv, int& ierr) 
+static octave_idx_type
+lsode_f (const octave_idx_type& neq, const double& time, double *,
+	 double *deriv, octave_idx_type& ierr) 
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv;
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_deriv = (*user_fun) (*tmp_x, time);
 
   if (tmp_deriv.length () == 0)
     ierr = -1;
   else
     {
-      for (int i = 0; i < neq; i++)
+      for (octave_idx_type i = 0; i < neq; i++)
 	deriv [i] = tmp_deriv.elem (i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-static int
-lsode_j (const int& neq, const double& time, double *,
-	 const int&, const int&, double *pd, const int& nrowpd)
+static octave_idx_type
+lsode_j (const octave_idx_type& neq, const double& time, double *,
+	 const octave_idx_type&, const octave_idx_type&, double *pd, const octave_idx_type& nrowpd)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   Matrix tmp_jac (neq, neq);
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_jac = (*user_jac) (*tmp_x, time);
 
-  for (int j = 0; j < neq; j++)
-    for (int i = 0; i < neq; i++)
+  for (octave_idx_type j = 0; j < neq; j++)
+    for (octave_idx_type i = 0; i < neq; i++)
       pd [nrowpd * j + i] = tmp_jac (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 LSODE::do_integrate (double tout)
 {
   ColumnVector retval;
 
-  static int nn = 0;
+  static octave_idx_type nn = 0;
 
   if (! initialized || restart || ODEFunc::reset || LSODE_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       istate = 1;
 
-      int n = size ();
+      octave_idx_type n = size ();
 
       nn = n;
 
-      int max_maxord = 0;
+      octave_idx_type max_maxord = 0;
 
       if (integration_method () == "stiff")
 	{
 	  max_maxord = 5;
 
 	  if (jac)
 	    method_flag = 21;
 	  else
@@ -161,22 +161,22 @@ LSODE::do_integrate (double tout)
 		("lsode: invalid value for maximum order");
 	      integration_error = true;
 	      return retval;
 	    }
 	}
 
       iwork.resize (liw);
 
-      for (int i = 4; i < 9; i++)
+      for (octave_idx_type i = 4; i < 9; i++)
 	iwork(i) = 0;
 
       rwork.resize (lrw);
 
-      for (int i = 4; i < 9; i++)
+      for (octave_idx_type i = 4; i < 9; i++)
 	rwork(i) = 0;
 
       if (stop_time_set)
 	{
 	  itask = 4;
 	  rwork(0) = stop_time;
 	  iopt = 1;
 	}
@@ -216,17 +216,17 @@ LSODE::do_integrate (double tout)
 
       ODEFunc::reset = false;
 
       // LSODE_options
 
       rel_tol = relative_tolerance ();
       abs_tol = absolute_tolerance ();
 
-      int abs_tol_len = abs_tol.length ();
+      octave_idx_type abs_tol_len = abs_tol.length ();
 
       if (abs_tol_len == 1)
 	itol = 1;
       else if (abs_tol_len == n)
 	itol = 2;
       else
 	{
 	  (*current_liboctave_error_handler)
@@ -252,17 +252,17 @@ LSODE::do_integrate (double tout)
 
       double minss = minimum_step_size ();
       if (minss >= 0.0)
 	{
 	  rwork(6) = minss;
 	  iopt = 1;
 	}
 
-      int sl = step_limit ();
+      octave_idx_type sl = step_limit ();
       if (sl > 0)
 	{
 	  iwork(5) = sl;
 	  iopt = 1;
 	}
 
       pabs_tol = abs_tol.fortran_vec ();
 
@@ -379,73 +379,73 @@ LSODE::error_message (void) const
   return retval;
 }
 
 Matrix
 LSODE::do_integrate (const ColumnVector& tout)
 {
   Matrix retval;
 
-  int n_out = tout.capacity ();
-  int n = size ();
+  octave_idx_type n_out = tout.capacity ();
+  octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	retval.elem (0, i) = x.elem (i);
 
-      for (int j = 1; j < n_out; j++)
+      for (octave_idx_type j = 1; j < n_out; j++)
 	{
 	  ColumnVector x_next = do_integrate (tout.elem (j));
 
 	  if (integration_error)
 	    return retval;
 
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    retval.elem (j, i) = x_next.elem (i);
 	}
     }
 
   return retval;
 }
 
 Matrix
 LSODE::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
   Matrix retval;
 
-  int n_out = tout.capacity ();
-  int n = size ();
+  octave_idx_type n_out = tout.capacity ();
+  octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	retval.elem (0, i) = x.elem (i);
 
-      int n_crit = tcrit.capacity ();
+      octave_idx_type n_crit = tcrit.capacity ();
 
       if (n_crit > 0)
 	{
-	  int i_crit = 0;
-	  int i_out = 1;
+	  octave_idx_type i_crit = 0;
+	  octave_idx_type i_out = 1;
 	  double next_crit = tcrit.elem (0);
 	  double next_out;
 	  while (i_out < n_out)
 	    {
 	      bool do_restart = false;
 
 	      next_out = tout.elem (i_out);
 	      if (i_crit < n_crit)
 		next_crit = tcrit.elem (i_crit);
 
-	      int save_output;
+	      octave_idx_type save_output;
 	      double t_out;
 
 	      if (next_crit == next_out)
 		{
 		  set_stop_time (next_crit);
 		  t_out = next_out;
 		  save_output = 1;
 		  i_out++;
@@ -480,17 +480,17 @@ LSODE::do_integrate (const ColumnVector&
 
 	      ColumnVector x_next = do_integrate (t_out);
 
 	      if (integration_error)
 		return retval;
 
 	      if (save_output)
 		{
-		  for (int i = 0; i < n; i++)
+		  for (octave_idx_type i = 0; i < n; i++)
 		    retval.elem (i_out-1, i) = x_next.elem (i);
 		}
 
 	      if (do_restart)
 		force_restart ();
 	    }
 	}
       else
diff --git a/liboctave/LSODE.h b/liboctave/LSODE.h
--- a/liboctave/LSODE.h
+++ b/liboctave/LSODE.h
@@ -47,35 +47,35 @@ public:
   Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit);
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  int method_flag;
-  int maxord;
-  int itask;
-  int iopt;
-  int itol;
+  octave_idx_type method_flag;
+  octave_idx_type maxord;
+  octave_idx_type itask;
+  octave_idx_type iopt;
+  octave_idx_type itol;
 
-  int liw;
-  int lrw;
+  octave_idx_type liw;
+  octave_idx_type lrw;
 
-  Array<int> iwork;
+  Array<octave_idx_type> iwork;
   Array<double> rwork;
 
   double rel_tol;
 
   Array<double> abs_tol;
 
   double *px;
   double *pabs_tol;
-  int *piwork;
+  octave_idx_type *piwork;
   double *prwork;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/LinConst.cc b/liboctave/LinConst.cc
--- a/liboctave/LinConst.cc
+++ b/liboctave/LinConst.cc
@@ -35,17 +35,17 @@ void
 LinConst::error (const char* msg)
 {
   (*current_liboctave_error_handler) ("fatal LinConst error: %s", msg);
 }
 
 std::ostream&
 operator << (std::ostream& os, const LinConst& c)
 {
-  for (int i = 0; i < c.size (); i++)
+  for (octave_idx_type i = 0; i < c.size (); i++)
     os << c.lower_bound (i) << " " << c.upper_bound (i) << "\n";
 
   os << "\n";
   os << c.constraint_matrix ();
 
   return os;
 }
 
diff --git a/liboctave/MArray-defs.h b/liboctave/MArray-defs.h
--- a/liboctave/MArray-defs.h
+++ b/liboctave/MArray-defs.h
@@ -1,56 +1,56 @@
 #if !defined (octave_MArray_defs_h)
 #define octave_MArray_defs_h 1
 
 // Nothing like a little CPP abuse to brighten everyone's day.
 
 #define DO_VS_OP(r, l, v, OP, s) \
   if (l > 0) \
     { \
-      for (int i = 0; i < l; i++) \
+      for (octave_idx_type i = 0; i < l; i++) \
 	r[i] = v[i] OP s; \
     }
 
 #define DO_SV_OP(r, l, s, OP, v) \
   if (l > 0) \
     { \
-      for (int i = 0; i < l; i++) \
+      for (octave_idx_type i = 0; i < l; i++) \
 	r[i] = s OP v[i]; \
     }
 
 #define DO_VV_OP(r, l, x, OP, y) \
   if (l > 0) \
     { \
-      for (int i = 0; i < l; i++) \
+      for (octave_idx_type i = 0; i < l; i++) \
 	r[i] = x[i] OP y[i]; \
     }
 
 #define NEG_V(r, l, x) \
   if (l > 0) \
     { \
-      for (int i = 0; i < l; i++) \
+      for (octave_idx_type i = 0; i < l; i++) \
 	r[i] = -x[i]; \
     }
 
 #define DO_VS_OP2(T, a, OP, s) \
-  int l = a.length (); \
+  octave_idx_type l = a.length (); \
   if (l > 0) \
     { \
       T *tmp = a.fortran_vec (); \
-      for (int i = 0; i < l; i++) \
+      for (octave_idx_type i = 0; i < l; i++) \
 	tmp[i] OP s; \
     }
 
 #define DO_VV_OP2(T, a, OP, b) \
   do \
     { \
       T *a_tmp = a.fortran_vec (); \
       const T *b_tmp = b.data (); \
-      for (int i = 0; i < l; i++) \
+      for (octave_idx_type i = 0; i < l; i++) \
 	a_tmp[i] OP b_tmp[i]; \
     } \
   while (0)
 
 // A macro that can be used to declare and instantiate OP= operators.
 #define MARRAY_OP_ASSIGN_DECL(A_T, E_T, OP, PFX, LTGT, RHS_T) \
   PFX A_T<E_T>& \
   operator OP LTGT (A_T<E_T>&, const RHS_T&)
diff --git a/liboctave/MArray-i.cc b/liboctave/MArray-i.cc
--- a/liboctave/MArray-i.cc
+++ b/liboctave/MArray-i.cc
@@ -27,18 +27,20 @@ Software Foundation, 59 Temple Place - S
 #include "oct-inttypes.h"
 
 // Instantiate MArrays of int values.
 
 #include "MArray.h"
 #include "MArray.cc"
 
 template class MArray<int>;
+template class MArray<long>;
 
 INSTANTIATE_MARRAY_FRIENDS (int)
+INSTANTIATE_MARRAY_FRIENDS (long)
 
 template class MArray<octave_int8>;
 template class MArray<octave_int16>;
 template class MArray<octave_int32>;
 template class MArray<octave_int64>;
 
 INSTANTIATE_MARRAY_FRIENDS (octave_int8)
 INSTANTIATE_MARRAY_FRIENDS (octave_int16)
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -51,36 +51,36 @@ operator -= (MArray<T>& a, const T& s)
 }
 
 // Element by element MArray by MArray ops.
 
 template <class T>
 MArray<T>&
 operator += (MArray<T>& a, const MArray<T>& b)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
   if (l > 0)
     {
-      int bl = b.length ();
+      octave_idx_type bl = b.length ();
       if (l != bl)
 	gripe_nonconformant ("operator +=", l, bl);
       else
 	DO_VV_OP2 (T, a, +=, b);
     }
   return a;
 }
 
 template <class T>
 MArray<T>&
 operator -= (MArray<T>& a, const MArray<T>& b)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
   if (l > 0)
     {
-      int bl = b.length ();
+      octave_idx_type bl = b.length ();
       if (l != bl)
 	gripe_nonconformant ("operator -=", l, bl);
       else
 	DO_VV_OP2 (T, a, -=, b);
     }
   return a;
 }
 
@@ -88,17 +88,17 @@ operator -= (MArray<T>& a, const MArray<
 
 #define MARRAY_AS_OP(OP) \
   template <class T> \
   MArray<T> \
   operator OP (const MArray<T>& a, const T& s) \
   { \
     MArray<T> result (a.length ()); \
     T *r = result.fortran_vec (); \
-    int l = a.length (); \
+    octave_idx_type l = a.length (); \
     const T *v = a.data (); \
     DO_VS_OP (r, l, v, OP, s); \
     return result; \
   }
 
 MARRAY_AS_OP (+)
 MARRAY_AS_OP (-)
 MARRAY_AS_OP (*)
@@ -108,17 +108,17 @@ MARRAY_AS_OP (/)
 
 #define MARRAY_SA_OP(OP) \
   template <class T> \
   MArray<T> \
   operator OP (const T& s, const MArray<T>& a) \
   { \
     MArray<T> result (a.length ()); \
     T *r = result.fortran_vec (); \
-    int l = a.length (); \
+    octave_idx_type l = a.length (); \
     const T *v = a.data (); \
     DO_SV_OP (r, l, s, OP, v); \
     return result; \
   }
 
 MARRAY_SA_OP(+)
 MARRAY_SA_OP(-)
 MARRAY_SA_OP(*)
@@ -126,18 +126,18 @@ MARRAY_SA_OP(/)
 
 // Element by element MArray by MArray ops.
 
 #define MARRAY_AA_OP(FCN, OP) \
   template <class T> \
   MArray<T> \
   FCN (const MArray<T>& a, const MArray<T>& b) \
   { \
-    int l = a.length (); \
-    int bl = b.length (); \
+    octave_idx_type l = a.length (); \
+    octave_idx_type bl = b.length (); \
     if (l != bl) \
       { \
 	gripe_nonconformant (#FCN, l, bl); \
 	return MArray<T> (); \
       } \
     if (l == 0) \
       return MArray<T> (); \
     MArray<T> result (l); \
@@ -161,17 +161,17 @@ operator + (const MArray<T>& a)
 {
   return a;
 }
 
 template <class T>
 MArray<T>
 operator - (const MArray<T>& a)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
   MArray<T> result (l);
   T *r = result.fortran_vec ();
   const T *x = a.data ();
   NEG_V (r, l, x);
   return result;
 }
 
 /*
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -35,25 +35,25 @@ Software Foundation, 59 Temple Place - S
 MARRAY_OPS_FORWARD_DECLS (MArray)
 
 template <class T>
 class
 MArray : public Array<T>
 {
 protected:
 
-  MArray (T *d, int l) : Array<T> (d, l) { }
+  MArray (T *d, octave_idx_type l) : Array<T> (d, l) { }
 
 public:
   
   MArray (void) : Array<T> () { }
 
-  explicit MArray (int n) : Array<T> (n) { }
+  explicit MArray (octave_idx_type n) : Array<T> (n) { }
 
-  MArray (int n, const T& val) : Array<T> (n, val) { }
+  MArray (octave_idx_type n, const T& val) : Array<T> (n, val) { }
 
   MArray (const MArray<T>& a) : Array<T> (a) { }
 
   MArray (const Array<T>& a) : Array<T> (a) { }
 
   ~MArray (void) { }
 
   MArray<T>& operator = (const MArray<T>& a)
diff --git a/liboctave/MArray2.cc b/liboctave/MArray2.cc
--- a/liboctave/MArray2.cc
+++ b/liboctave/MArray2.cc
@@ -51,64 +51,64 @@ operator -= (MArray2<T>& a, const T& s)
 }
 
 // Element by element MArray2 by MArray2 ops.
 
 template <class T>
 MArray2<T>&
 operator += (MArray2<T>& a, const MArray2<T>& b)
 {
-  int r = a.rows ();
-  int c = a.cols ();
-  int br = b.rows ();
-  int bc = b.cols ();
+  octave_idx_type r = a.rows ();
+  octave_idx_type c = a.cols ();
+  octave_idx_type br = b.rows ();
+  octave_idx_type bc = b.cols ();
   if (r != br || c != bc)
     gripe_nonconformant ("operator +=", r, c, br, bc);
   else
     {
       if (r > 0 && c > 0)
 	{
-	  int l = a.length ();
+	  octave_idx_type l = a.length ();
 	  DO_VV_OP2 (T, a, +=, b);
 	}
     }
   return a;
 }
 
 template <class T>
 MArray2<T>&
 operator -= (MArray2<T>& a, const MArray2<T>& b)
 {
-  int r = a.rows ();
-  int c = a.cols ();
-  int br = b.rows ();
-  int bc = b.cols ();
+  octave_idx_type r = a.rows ();
+  octave_idx_type c = a.cols ();
+  octave_idx_type br = b.rows ();
+  octave_idx_type bc = b.cols ();
   if (r != br || c != bc)
     gripe_nonconformant ("operator -=", r, c, br, bc);
   else
     {
       if (r > 0 && c > 0)
 	{
-	  int l = a.length ();
+	  octave_idx_type l = a.length ();
 	  DO_VV_OP2 (T, a, -=, b);
 	}
     }
   return a;
 }
 
 // Element by element MArray2 by scalar ops.
 
 #define MARRAY_A2S_OP(OP) \
   template <class T> \
   MArray2<T> \
   operator OP (const MArray2<T>& a, const T& s) \
   { \
     MArray2<T> result (a.rows (), a.cols ()); \
     T *r = result.fortran_vec (); \
-    int l = a.length (); \
+    octave_idx_type l = a.length (); \
     const T *v = a.data (); \
     DO_VS_OP (r, l, v, OP, s); \
     return result; \
   }
 
 MARRAY_A2S_OP (+)
 MARRAY_A2S_OP (-)
 MARRAY_A2S_OP (*)
@@ -118,17 +118,17 @@ MARRAY_A2S_OP (/)
 
 #define MARRAY_SA2_OP(OP) \
   template <class T> \
   MArray2<T> \
   operator OP (const T& s, const MArray2<T>& a) \
   { \
     MArray2<T> result (a.rows (), a.cols ()); \
     T *r = result.fortran_vec (); \
-    int l = a.length (); \
+    octave_idx_type l = a.length (); \
     const T *v = a.data (); \
     DO_SV_OP (r, l, s, OP, v); \
     return result; \
   }
 
 MARRAY_SA2_OP (+)
 MARRAY_SA2_OP (-)
 MARRAY_SA2_OP (*)
@@ -136,28 +136,28 @@ MARRAY_SA2_OP (/)
 
 // Element by element MArray2 by MArray2 ops.
 
 #define MARRAY_A2A2_OP(FCN, OP) \
   template <class T> \
   MArray2<T> \
   FCN (const MArray2<T>& a, const MArray2<T>& b) \
   { \
-    int a_nr = a.rows (); \
-    int a_nc = a.cols (); \
-    int b_nr = b.rows (); \
-    int b_nc = b.cols (); \
+    octave_idx_type a_nr = a.rows (); \
+    octave_idx_type a_nc = a.cols (); \
+    octave_idx_type b_nr = b.rows (); \
+    octave_idx_type b_nc = b.cols (); \
     if (a_nr != b_nr || a_nc != b_nc) \
       { \
         gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
 	return MArray2<T> (); \
       } \
     if (a_nr == 0 || a_nc == 0) \
       return MArray2<T> (a_nr, a_nc); \
-    int l = a.length (); \
+    octave_idx_type l = a.length (); \
     MArray2<T> result (a_nr, a_nc); \
     T *r = result.fortran_vec (); \
     const T *x = a.data (); \
     const T *y = b.data (); \
     DO_VV_OP (r, l, x, OP, y); \
     return result; \
   }
 
@@ -174,17 +174,17 @@ operator + (const MArray2<T>& a)
 {
   return a;
 }
 
 template <class T>
 MArray2<T>
 operator - (const MArray2<T>& a)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
   MArray2<T> result (a.rows (), a.cols ());
   T *r = result.fortran_vec ();
   const T *x = a.data ();
   NEG_V (r, l, x);
   return result;
 }
 
 /*
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -35,39 +35,39 @@ Software Foundation, 59 Temple Place - S
 MARRAY_OPS_FORWARD_DECLS (MArray2)
 
 template <class T>
 class
 MArray2 : public Array2<T>
 {
 protected:
 
-  MArray2 (T *d, int n, int m) : Array2<T> (d, n, m) { }
+  MArray2 (T *d, octave_idx_type n, octave_idx_type m) : Array2<T> (d, n, m) { }
 
 public:
 
   MArray2 (void) : Array2<T> () { }
 
-  MArray2 (int n, int m) : Array2<T> (n, m) { }
+  MArray2 (octave_idx_type n, octave_idx_type m) : Array2<T> (n, m) { }
 
-  MArray2 (int n, int m, const T& val) : Array2<T> (n, m, val) { }
+  MArray2 (octave_idx_type n, octave_idx_type m, const T& val) : Array2<T> (n, m, val) { }
 
   MArray2 (const MArray2<T>& a) : Array2<T> (a) { }
 
   MArray2 (const Array2<T>& a) : Array2<T> (a) { }
 
   ~MArray2 (void) { }
 
   MArray2<T>& operator = (const MArray2<T>& a)
     {
       Array2<T>::operator = (a);
       return *this;
     }
 
-  MArray2<T>& insert (const Array2<T>& a, int r, int c)
+  MArray2<T>& insert (const Array2<T>& a, octave_idx_type r, octave_idx_type c)
   {
     Array2<T>::insert (a, r, c);
     return *this;
   }
 
   MArray2<T> transpose (void) const { return Array2<T>::transpose (); }
 
   // Currently, the OPS functions don't need to be friends, but that
diff --git a/liboctave/MArrayN.cc b/liboctave/MArrayN.cc
--- a/liboctave/MArrayN.cc
+++ b/liboctave/MArrayN.cc
@@ -52,17 +52,17 @@ operator -= (MArrayN<T>& a, const T& s)
 }
 
 // Element by element MArrayN by MArrayN ops.
 
 template <class T>
 MArrayN<T>&
 operator += (MArrayN<T>& a, const MArrayN<T>& b)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
 
   if (l > 0)
     {
       dim_vector a_dims = a.dims ();
       dim_vector b_dims = b.dims ();
 
       if (a_dims != b_dims)
 	gripe_nonconformant ("operator +=", a_dims, b_dims);
@@ -72,17 +72,17 @@ operator += (MArrayN<T>& a, const MArray
 
   return a;
 }
 
 template <class T>
 MArrayN<T>&
 operator -= (MArrayN<T>& a, const MArrayN<T>& b)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
 
   if (l > 0)
     {
       dim_vector a_dims = a.dims ();
       dim_vector b_dims = b.dims ();
 
       if (a_dims != b_dims)
 	gripe_nonconformant ("operator -=", a_dims, b_dims);
@@ -96,17 +96,17 @@ operator -= (MArrayN<T>& a, const MArray
 
 #define MARRAYN_NDS_OP(OP) \
   template <class T> \
   MArrayN<T> \
   operator OP (const MArrayN<T>& a, const T& s) \
     { \
       MArrayN<T> result (a.dims ()); \
       T *r = result.fortran_vec (); \
-      int l = a.length (); \
+      octave_idx_type l = a.length (); \
       const T *v = a.data (); \
       DO_VS_OP (r, l, v, OP, s); \
       return result; \
     }
 
 MARRAYN_NDS_OP (+)
 MARRAYN_NDS_OP (-)
 MARRAYN_NDS_OP (*)
@@ -116,17 +116,17 @@ MARRAYN_NDS_OP (/)
 
 #define MARRAYN_SND_OP(OP) \
   template <class T> \
   MArrayN<T> \
   operator OP (const T& s, const MArrayN<T>& a) \
   { \
     MArrayN<T> result (a.dims ()); \
     T *r = result.fortran_vec (); \
-    int l = a.length (); \
+    octave_idx_type l = a.length (); \
     const T *v = a.data (); \
     DO_SV_OP (r, l, s, OP, v); \
     return result; \
   }
 
 MARRAYN_SND_OP (+)
 MARRAYN_SND_OP (-)
 MARRAYN_SND_OP (*)
@@ -155,17 +155,17 @@ if (a_dims.length () != b_dims.length ()
    } \
  if (!dims_ok) \
    { \
      gripe_nonconformant (#FCN, a_dims, b_dims); \
      return MArrayN<T> (); \
    } \
  if (any_dims_zero) \
    return MArrayN<T> (a_dims); \
- int l = a.length (); \
+ octave_idx_type l = a.length (); \
  MArrayN<T> result (a_dims); \
  T* r = result.fortran_vec (); \
  const T *x = a.data (); \
  const T *y = b.data (); \
  DO_VV_OP (r, l, x, OP, y); \
  return result; \
 }
 
@@ -180,17 +180,17 @@ operator + (const MArrayN<T>& a)
 {
   return a;
 }
 
 template <class T>
 MArrayN<T>
 operator - (const MArrayN<T>& a)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
   MArrayN<T> result (a.dims ());
   T *r = result.fortran_vec ();
   const T *x = a.data ();
   NEG_V (r, l, x);
   return result;
 }
 
 /*
diff --git a/liboctave/MDiagArray2.cc b/liboctave/MDiagArray2.cc
--- a/liboctave/MDiagArray2.cc
+++ b/liboctave/MDiagArray2.cc
@@ -36,109 +36,109 @@ template <class T> MDiagArray2<T> MDiagA
 // Two dimensional diagonal array with math ops.
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 template <class T>
 MDiagArray2<T>&
 operator += (MDiagArray2<T>& a, const MDiagArray2<T>& b)
 {
-  int r = a.rows ();
-  int c = a.cols ();
+  octave_idx_type r = a.rows ();
+  octave_idx_type c = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (r != b_nr || c != b_nc)
     {
       gripe_nonconformant ("operator +=", r, c, b_nr, b_nc);
       return MDiagArray2<T>::nil_array;
     }
   else
     {
-      int l = a.length ();
+      octave_idx_type l = a.length ();
       DO_VV_OP2 (T, a, +=, b);
     }
   return a;
 }
 
 template <class T>
 MDiagArray2<T>&
 operator -= (MDiagArray2<T>& a, const MDiagArray2<T>& b)
 {
-  int r = a.rows ();
-  int c = a.cols ();
+  octave_idx_type r = a.rows ();
+  octave_idx_type c = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (r != b_nr || c != b_nc)
     {
       gripe_nonconformant ("operator -=", r, c, b_nr, b_nc);
       return MDiagArray2<T>::nil_array;
     }
   else
     {
-      int l = a.length ();
+      octave_idx_type l = a.length ();
       DO_VV_OP2 (T, a, -=, b);
     }
   return a;
 }
 
 // Element by element MDiagArray2 by scalar ops.
 
 #define MARRAY_DAS_OP(OP) \
   template <class T> \
   MDiagArray2<T> \
   operator OP (const MDiagArray2<T>& a, const T& s) \
   { \
     MDiagArray2<T> result (a.rows (), a.cols ()); \
     T *r = result.fortran_vec (); \
-    int l = a.length (); \
+    octave_idx_type l = a.length (); \
     const T *v = a.data (); \
     DO_VS_OP (r, l, v, OP, s); \
     return result; \
   }
 
 MARRAY_DAS_OP (*)
 MARRAY_DAS_OP (/)
 
 // Element by element scalar by MDiagArray2 ops.
 
 template <class T>
 MDiagArray2<T>
 operator * (const T& s, const MDiagArray2<T>& a)
 {
   MDiagArray2<T> result (a.rows (), a.cols ()); \
   T *r = result.fortran_vec (); \
-  int l = a.length (); \
+  octave_idx_type l = a.length (); \
   const T *v = a.data (); \
   DO_SV_OP (r, l, s, *, v); \
   return result; \
 }
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 #define MARRAY_DADA_OP(FCN, OP) \
   template <class T> \
   MDiagArray2<T> \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b) \
   { \
-    int a_nr = a.rows (); \
-    int a_nc = a.cols (); \
-    int b_nr = b.rows (); \
-    int b_nc = b.cols (); \
+    octave_idx_type a_nr = a.rows (); \
+    octave_idx_type a_nc = a.cols (); \
+    octave_idx_type b_nr = b.rows (); \
+    octave_idx_type b_nc = b.cols (); \
     if (a_nr != b_nr || a_nc != b_nc) \
       { \
         gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
 	return MDiagArray2<T> (); \
       } \
     if (a_nc == 0 || a_nr == 0) \
       return MDiagArray2<T> (); \
-    int l = a.length (); \
+    octave_idx_type l = a.length (); \
     MDiagArray2<T> result (a_nr, a_nc); \
     T *r = result.fortran_vec (); \
     const T *x = a.data (); \
     const T *y = b.data (); \
     DO_VV_OP (r, l, x, OP, y); \
     return result; \
   }
 
@@ -154,17 +154,17 @@ operator + (const MDiagArray2<T>& a)
 {
   return a;
 }
 
 template <class T>
 MDiagArray2<T>
 operator - (const MDiagArray2<T>& a)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
   MDiagArray2<T> result (a.rows (), a.cols ());
   T *r = result.fortran_vec ();
   const T *x = a.data ();
   NEG_V (r, l, x);
   return result;
 }
 
 /*
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -36,25 +36,25 @@ Software Foundation, 59 Temple Place - S
 MDIAGARRAY2_OPS_FORWARD_DECLS (MDiagArray2)
 
 template <class T>
 class
 MDiagArray2 : public DiagArray2<T>
 {
 protected:
 
-  MDiagArray2 (T *d, int r, int c) : DiagArray2<T> (d, r, c) { }
+  MDiagArray2 (T *d, octave_idx_type r, octave_idx_type c) : DiagArray2<T> (d, r, c) { }
 
 public:
   
   MDiagArray2 (void) : DiagArray2<T> () { }
 
-  MDiagArray2 (int r, int c) : DiagArray2<T> (r, c) { }
+  MDiagArray2 (octave_idx_type r, octave_idx_type c) : DiagArray2<T> (r, c) { }
 
-  MDiagArray2 (int r, int c, const T& val) : DiagArray2<T> (r, c, val) { }
+  MDiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) : DiagArray2<T> (r, c, val) { }
 
   MDiagArray2 (const MDiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   MDiagArray2 (const DiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   explicit MDiagArray2 (const Array<T>& a) : DiagArray2<T> (a) { }
 
   ~MDiagArray2 (void) { }
@@ -62,24 +62,24 @@ public:
   MDiagArray2<T>& operator = (const MDiagArray2<T>& a)
     {
       DiagArray2<T>::operator = (a);
       return *this;
     }
 
   operator MArray2<T> () const
     {
-      int nr = DiagArray2<T>::dim1 ();
-      int nc = DiagArray2<T>::dim2 ();
+      octave_idx_type nr = DiagArray2<T>::dim1 ();
+      octave_idx_type nc = DiagArray2<T>::dim2 ();
 
       MArray2<T> retval (nr, nc,  T (0));
 
-      int len = nr < nc ? nr : nc;
+      octave_idx_type len = nr < nc ? nr : nc;
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	retval.xelem (i, i) = this->xelem (i, i);
 
       return retval;
     }
 
   static MDiagArray2<T> nil_array;
 
   // Currently, the OPS functions don't need to be friends, but that
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -36,37 +36,37 @@ Software Foundation, 59 Temple Place - S
 // Element by element MSparse by MSparse ops.
 
 template <class T>
 MSparse<T>&
 operator += (MSparse<T>& a, const MSparse<T>& b)
 {
     MSparse<T> r;
 
-    int a_nr = a.rows ();
-    int a_nc = a.cols ();
+    octave_idx_type a_nr = a.rows ();
+    octave_idx_type a_nc = a.cols ();
 
-    int b_nr = b.rows ();
-    int b_nc = b.cols ();
+    octave_idx_type b_nr = b.rows ();
+    octave_idx_type b_nc = b.cols ();
 
     if (a_nr != b_nr || a_nc != b_nc)
       gripe_nonconformant ("operator +=" , a_nr, a_nc, b_nr, b_nc);
     else
       {
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-        int jx = 0;
-        for (int i = 0 ; i < a_nc ; i++)
+        octave_idx_type jx = 0;
+        for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
-            int  ja = a.cidx(i);
-            int  ja_max = a.cidx(i+1);
+            octave_idx_type  ja = a.cidx(i);
+            octave_idx_type  ja_max = a.cidx(i+1);
             bool ja_lt_max= ja < ja_max;
            
-            int  jb = b.cidx(i);
-            int  jb_max = b.cidx(i+1);
+            octave_idx_type  jb = b.cidx(i);
+            octave_idx_type  jb_max = b.cidx(i+1);
             bool jb_lt_max = jb < jb_max;
            
             while (ja_lt_max || jb_lt_max )
               {
                 OCTAVE_QUIT;
                 if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                   {
@@ -109,37 +109,37 @@ operator += (MSparse<T>& a, const MSpars
 }
 
 template <class T>
 MSparse<T>&
 operator -= (MSparse<T>& a, const MSparse<T>& b)
 {
     MSparse<T> r;
 
-    int a_nr = a.rows ();
-    int a_nc = a.cols ();
+    octave_idx_type a_nr = a.rows ();
+    octave_idx_type a_nc = a.cols ();
 
-    int b_nr = b.rows ();
-    int b_nc = b.cols ();
+    octave_idx_type b_nr = b.rows ();
+    octave_idx_type b_nc = b.cols ();
 
     if (a_nr != b_nr || a_nc != b_nc)
       gripe_nonconformant ("operator -=" , a_nr, a_nc, b_nr, b_nc);
     else
       {
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-        int jx = 0;
-        for (int i = 0 ; i < a_nc ; i++)
+        octave_idx_type jx = 0;
+        for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
-            int  ja = a.cidx(i);
-            int  ja_max = a.cidx(i+1);
+            octave_idx_type  ja = a.cidx(i);
+            octave_idx_type  ja_max = a.cidx(i+1);
             bool ja_lt_max= ja < ja_max;
            
-            int  jb = b.cidx(i);
-            int  jb_max = b.cidx(i+1);
+            octave_idx_type  jb = b.cidx(i);
+            octave_idx_type  jb_max = b.cidx(i+1);
             bool jb_lt_max = jb < jb_max;
            
             while (ja_lt_max || jb_lt_max )
               {
                 OCTAVE_QUIT;
                 if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                   {
@@ -183,44 +183,44 @@ operator -= (MSparse<T>& a, const MSpars
 
 // Element by element MSparse by scalar ops.
 
 #define SPARSE_A2S_OP_1(OP) \
   template <class T> \
   MArray2<T> \
   operator OP (const MSparse<T>& a, const T& s) \
   { \
-    int nr = a.rows (); \
-    int nc = a.cols (); \
+    octave_idx_type nr = a.rows (); \
+    octave_idx_type nc = a.cols (); \
  \
     MArray2<T> r (nr, nc, (0.0 OP s));	\
  \
-    for (int j = 0; j < nc; j++) \
-      for (int i = a.cidx(j); i < a.cidx(j+1); i++)	\
+    for (octave_idx_type j = 0; j < nc; j++) \
+      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)	\
         r.elem (a.ridx (i), j) = a.data (i) OP s;	\
     return r; \
   }
 
 #define SPARSE_A2S_OP_2(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const MSparse<T>& a, const T& s) \
   { \
-    int nr = a.rows (); \
-    int nc = a.cols (); \
-    int nz = a.nnz (); \
+    octave_idx_type nr = a.rows (); \
+    octave_idx_type nc = a.cols (); \
+    octave_idx_type nz = a.nnz (); \
  \
     MSparse<T> r (nr, nc, nz); \
  \
-    for (int i = 0; i < nz; i++) \
+    for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = a.data(i) OP s; \
 	r.ridx(i) = a.ridx(i); \
       } \
-    for (int i = 0; i < nc + 1; i++) \
+    for (octave_idx_type i = 0; i < nc + 1; i++) \
       r.cidx(i) = a.cidx(i); \
     r.maybe_compress (true); \
     return r; \
   }
 
 
 SPARSE_A2S_OP_1 (+)
 SPARSE_A2S_OP_1 (-)
@@ -229,44 +229,44 @@ SPARSE_A2S_OP_2 (/)
 
 // Element by element scalar by MSparse ops.
 
 #define SPARSE_SA2_OP_1(OP) \
   template <class T> \
   MArray2<T> \
   operator OP (const T& s, const MSparse<T>& a) \
   { \
-    int nr = a.rows (); \
-    int nc = a.cols (); \
+    octave_idx_type nr = a.rows (); \
+    octave_idx_type nc = a.cols (); \
  \
     MArray2<T> r (nr, nc, (s OP 0.0));	\
  \
-    for (int j = 0; j < nc; j++) \
-      for (int i = a.cidx(j); i < a.cidx(j+1); i++)	\
+    for (octave_idx_type j = 0; j < nc; j++) \
+      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)	\
         r.elem (a.ridx (i), j) = s OP a.data (i);	\
     return r; \
   }
 
 #define SPARSE_SA2_OP_2(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const T& s, const MSparse<T>& a) \
   { \
-    int nr = a.rows (); \
-    int nc = a.cols (); \
-    int nz = a.nnz (); \
+    octave_idx_type nr = a.rows (); \
+    octave_idx_type nc = a.cols (); \
+    octave_idx_type nz = a.nnz (); \
  \
     MSparse<T> r (nr, nc, nz); \
  \
-    for (int i = 0; i < nz; i++) \
+    for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = s OP a.data(i); \
 	r.ridx(i) = a.ridx(i); \
       } \
-    for (int i = 0; i < nc + 1; i++) \
+    for (octave_idx_type i = 0; i < nc + 1; i++) \
       r.cidx(i) = a.cidx(i); \
     r.maybe_compress (true); \
     return r; \
   }
 
 SPARSE_SA2_OP_1 (+)
 SPARSE_SA2_OP_1 (-)
 SPARSE_SA2_OP_2 (*)
@@ -276,38 +276,38 @@ SPARSE_SA2_OP_2 (/)
 
 #define SPARSE_A2A2_OP(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const MSparse<T>& a, const MSparse<T>& b) \
   { \
     MSparse<T> r; \
  \
-    int a_nr = a.rows (); \
-    int a_nc = a.cols (); \
+    octave_idx_type a_nr = a.rows (); \
+    octave_idx_type a_nc = a.cols (); \
  \
-    int b_nr = b.rows (); \
-    int b_nc = b.cols (); \
+    octave_idx_type b_nr = b.rows (); \
+    octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant ("operator " # OP, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ())); \
         \
-        int jx = 0; \
+        octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
-        for (int i = 0 ; i < a_nc ; i++) \
+        for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
-            int  ja = a.cidx(i); \
-            int  ja_max = a.cidx(i+1); \
+            octave_idx_type  ja = a.cidx(i); \
+            octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            int  jb = b.cidx(i); \
-            int  jb_max = b.cidx(i+1); \
+            octave_idx_type  jb = b.cidx(i); \
+            octave_idx_type  jb_max = b.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 OCTAVE_QUIT; \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb)))) \
                   { \
@@ -351,38 +351,38 @@ SPARSE_SA2_OP_2 (/)
 
 #define SPARSE_A2A2_FCN_1(FCN, OP)	\
   template <class T> \
   MSparse<T> \
   FCN (const MSparse<T>& a, const MSparse<T>& b) \
   { \
     MSparse<T> r; \
  \
-    int a_nr = a.rows (); \
-    int a_nc = a.cols (); \
+    octave_idx_type a_nr = a.rows (); \
+    octave_idx_type a_nc = a.cols (); \
  \
-    int b_nr = b.rows (); \
-    int b_nc = b.cols (); \
+    octave_idx_type b_nr = b.rows (); \
+    octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
         r = MSparse<T> (a_nr, a_nc, (a.nnz() > b.nnz() ? a.nnz() : b.nnz())); \
         \
-        int jx = 0; \
+        octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
-        for (int i = 0 ; i < a_nc ; i++) \
+        for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
-            int  ja = a.cidx(i); \
-            int  ja_max = a.cidx(i+1); \
+            octave_idx_type  ja = a.cidx(i); \
+            octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            int  jb = b.cidx(i); \
-            int  jb_max = b.cidx(i+1); \
+            octave_idx_type  jb = b.cidx(i); \
+            octave_idx_type  jb_max = b.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 OCTAVE_QUIT; \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb)))) \
                   { \
@@ -417,36 +417,36 @@ SPARSE_SA2_OP_2 (/)
 #define SPARSE_A2A2_FCN_2(FCN, OP)	\
   template <class T> \
   MSparse<T> \
   FCN (const MSparse<T>& a, const MSparse<T>& b) \
   { \
     MSparse<T> r; \
     T Zero = T (); \
  \
-    int a_nr = a.rows (); \
-    int a_nc = a.cols (); \
+    octave_idx_type a_nr = a.rows (); \
+    octave_idx_type a_nc = a.cols (); \
  \
-    int b_nr = b.rows (); \
-    int b_nc = b.cols (); \
+    octave_idx_type b_nr = b.rows (); \
+    octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
         r = MSparse<T>( a_nr, a_nc, (Zero OP Zero)); \
         \
-        for (int i = 0 ; i < a_nc ; i++) \
+        for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
-            int  ja = a.cidx(i); \
-            int  ja_max = a.cidx(i+1); \
+            octave_idx_type  ja = a.cidx(i); \
+            octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            int  jb = b.cidx(i); \
-            int  jb_max = b.cidx(i+1); \
+            octave_idx_type  jb = b.cidx(i); \
+            octave_idx_type  jb_max = b.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 OCTAVE_QUIT; \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb)))) \
                   { \
@@ -488,18 +488,18 @@ operator + (const MSparse<T>& a)
   return a;
 }
 
 template <class T>
 MSparse<T>
 operator - (const MSparse<T>& a)
 {
   MSparse<T> retval (a);
-  int nz = a.nnz ();
-  for (int i = 0; i < nz; i++)
+  octave_idx_type nz = a.nnz ();
+  for (octave_idx_type i = 0; i < nz; i++)
     retval.data(i) = - retval.data(i);
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -37,47 +37,47 @@ SPARSE_OPS_FORWARD_DECLS (MSparse, MArra
 template <class T>
 class
 MSparse : public Sparse<T>
 {
 public:
 
   MSparse (void) : Sparse<T> () { }
 
-  MSparse (int n, int m) : Sparse<T> (n, m) { }
+  MSparse (octave_idx_type n, octave_idx_type m) : Sparse<T> (n, m) { }
 
   MSparse (const MSparse<T>& a) : Sparse<T> (a) { }
 
   MSparse (const MSparse<T>& a, const dim_vector& dv) : Sparse<T> (a, dv) { }
 
   MSparse (const Sparse<T>& a) : Sparse<T> (a) { }
 
-  MSparse (const Array<T> a, const Array<int>& r, 
-	   const Array<int>& c, int nr = -1, 
-	   int nc = -1, bool sum_terms = true)
+  MSparse (const Array<T> a, const Array<octave_idx_type>& r, 
+	   const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
+	   octave_idx_type nc = -1, bool sum_terms = true)
     : Sparse<T> (a, r, c, nr, nc, sum_terms) { }
 
   MSparse (const Array<T> a, const Array<double>& r, 
-	   const Array<double>& c, int nr = -1, 
-	   int nc = -1, bool sum_terms = true)
+	   const Array<double>& c, octave_idx_type nr = -1, 
+	   octave_idx_type nc = -1, bool sum_terms = true)
     : Sparse<T> (a, r, c, nr, nc, sum_terms) { }
 
-  explicit MSparse (int r, int c, T val) : Sparse<T> (r, c, val) { }
+  explicit MSparse (octave_idx_type r, octave_idx_type c, T val) : Sparse<T> (r, c, val) { }
 
-  MSparse (int r, int c, int num_nz) : Sparse<T> (r, c, num_nz) { }
+  MSparse (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<T> (r, c, num_nz) { }
 
   ~MSparse (void) { }
 
   MSparse<T>& operator = (const MSparse<T>& a)
     {
       Sparse<T>::operator = (a);
       return *this;
     }
 
-  MSparse<T>& insert (const Sparse<T>& a, int r, int c)
+  MSparse<T>& insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c)
   {
     Sparse<T>::insert (a, r, c);
     return *this;
   }
 
   MSparse<T> transpose (void) const { return Sparse<T>::transpose (); }
 
   MSparse<T> squeeze (void) const { return Sparse<T>::squeeze (); }
@@ -89,20 +89,20 @@ public:
     { return Sparse<T>::index (i, j, resize_ok); }
   
   MSparse<T> index (Array<idx_vector>& ra_idx, int resize_ok) const 
     { return Sparse<T>::index (ra_idx, resize_ok); }
 
   MSparse<T> reshape (const dim_vector& new_dims) const
     { return Sparse<T>::reshape (new_dims); }
      
-  MSparse<T> permute (const Array<int>& vec, bool inv = false) const
+  MSparse<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const
     { return Sparse<T>::permute (vec, inv); }
 
-  MSparse<T> ipermute (const Array<int>& vec) const
+  MSparse<T> ipermute (const Array<octave_idx_type>& vec) const
     { return Sparse<T>::ipermute (vec); }
 
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
   // SPARSE_OPS_FRIEND_DECLS (MSparse, MArray2)
 };
diff --git a/liboctave/NLConst.h b/liboctave/NLConst.h
--- a/liboctave/NLConst.h
+++ b/liboctave/NLConst.h
@@ -31,17 +31,17 @@ class ColumnVector;
 class
 NLConst : public Bounds, public NLFunc
 {
 public:
 
   NLConst (void)
     : Bounds (), NLFunc () { }
 
-  NLConst (int n)
+  NLConst (octave_idx_type n)
     : Bounds (n), NLFunc () { }
 
   NLConst (const ColumnVector& lb, const NLFunc f, const ColumnVector& ub)
     : Bounds (lb, ub), NLFunc (f) { }
 
   NLConst (const NLConst& a)
     : Bounds (a.lb, a.ub), NLFunc (a.fun, a.jac) { }
 
diff --git a/liboctave/NLEqn.cc b/liboctave/NLEqn.cc
--- a/liboctave/NLEqn.cc
+++ b/liboctave/NLEqn.cc
@@ -25,129 +25,129 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "NLEqn.h"
 #include "dMatrix.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "quit.h"
 
-typedef int (*hybrd1_fcn_ptr) (int*, double*, double*, int*);
+typedef octave_idx_type (*hybrd1_fcn_ptr) (octave_idx_type*, double*, double*, octave_idx_type*);
 
-typedef int (*hybrj1_fcn_ptr) (int*, double*, double*, double*, int*, int*);
+typedef octave_idx_type (*hybrj1_fcn_ptr) (octave_idx_type*, double*, double*, double*, octave_idx_type*, octave_idx_type*);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (hybrd1, HYBRD1) (hybrd1_fcn_ptr, const int&, double*,
-			     double*, const double&, int&, double*,
-			     const int&);
+  F77_FUNC (hybrd1, HYBRD1) (hybrd1_fcn_ptr, const octave_idx_type&, double*,
+			     double*, const double&, octave_idx_type&, double*,
+			     const octave_idx_type&);
 
 
   F77_RET_T
-  F77_FUNC (hybrj1, HYBRJ1) (hybrj1_fcn_ptr, const int&, double*,
-			     double*, double*, const int&, const
-			     double&, int&, double*, const int&);
+  F77_FUNC (hybrj1, HYBRJ1) (hybrj1_fcn_ptr, const octave_idx_type&, double*,
+			     double*, double*, const octave_idx_type&, const
+			     double&, octave_idx_type&, double*, const octave_idx_type&);
 }
 
 static NLFunc::nonlinear_fcn user_fun;
 static NLFunc::jacobian_fcn user_jac;
 
 // error handling
 
 void
 NLEqn::error (const char* msg)
 {
   (*current_liboctave_error_handler) ("fatal NLEqn error: %s", msg);
 }
 
 // Other operations
 
-int
-hybrd1_fcn (int *n, double *x, double *fvec, int *iflag)
+octave_idx_type
+hybrd1_fcn (octave_idx_type *n, double *x, double *fvec, octave_idx_type *iflag)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  int nn = *n;
+  octave_idx_type nn = *n;
   ColumnVector tmp_f (nn);
   ColumnVector tmp_x (nn);
 
-  for (int i = 0; i < nn; i++)
+  for (octave_idx_type i = 0; i < nn; i++)
     tmp_x.elem (i) = x[i];
 
   tmp_f = (*user_fun) (tmp_x);
 
   if (tmp_f.length () == 0)
     *iflag = -1;
   else
     {
-      for (int i = 0; i < nn; i++)
+      for (octave_idx_type i = 0; i < nn; i++)
 	fvec[i] = tmp_f.elem (i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-int
-hybrj1_fcn (int *n, double *x, double *fvec, double *fjac,
-	    int *ldfjac, int *iflag)
+octave_idx_type
+hybrj1_fcn (octave_idx_type *n, double *x, double *fvec, double *fjac,
+	    octave_idx_type *ldfjac, octave_idx_type *iflag)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  int nn = *n;
+  octave_idx_type nn = *n;
   ColumnVector tmp_x (nn);
 
-  for (int i = 0; i < nn; i++)
+  for (octave_idx_type i = 0; i < nn; i++)
     tmp_x.elem (i) = x[i];
 
-  int flag = *iflag;
+  octave_idx_type flag = *iflag;
   if (flag == 1)
     {
       ColumnVector tmp_f (nn);
 
       tmp_f = (*user_fun) (tmp_x);
 
       if (tmp_f.length () == 0)
 	*iflag = -1;
       else
 	{
-	  for (int i = 0; i < nn; i++)
+	  for (octave_idx_type i = 0; i < nn; i++)
 	    fvec[i] = tmp_f.elem (i);
 	}
     }
   else
     {
       Matrix tmp_fj (nn, nn);
 
       tmp_fj = (*user_jac) (tmp_x);
 
       if (tmp_fj.rows () == 0 || tmp_fj.columns () == 0)
 	*iflag = -1;
       else
 	{
-	  int ld = *ldfjac;
-	  for (int j = 0; j < nn; j++)
-	    for (int i = 0; i < nn; i++)
+	  octave_idx_type ld = *ldfjac;
+	  for (octave_idx_type j = 0; j < nn; j++)
+	    for (octave_idx_type i = 0; i < nn; i++)
 	      fjac[j*ld+i] = tmp_fj.elem (i, j);
 	}
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
-NLEqn::solve (int& info)
+NLEqn::solve (octave_idx_type& info)
 {
   ColumnVector retval;
 
-  int n = x.capacity ();
+  octave_idx_type n = x.capacity ();
 
   if (n == 0)
     {
       error ("equation set not initialized");
       return retval;
     }
 
   double tol = tolerance ();
@@ -158,17 +158,17 @@ NLEqn::solve (int& info)
   user_fun = fun;
   user_jac = jac;
 
   if (jac)
     {
       Array<double> fvec (n);
       double *pfvec = fvec.fortran_vec ();
 
-      int lwa = (n*(n+13))/2;
+      octave_idx_type lwa = (n*(n+13))/2;
       Array<double> wa (lwa);
       double *pwa = wa.fortran_vec ();
 
       Array<double> fjac (n*n);
       double *pfjac = fjac.fortran_vec ();
 
       F77_XFCN (hybrj1, HYBRJ1, (hybrj1_fcn, n, px, pfvec, pfjac, n,
 				 tol, info, pwa, lwa));
@@ -178,17 +178,17 @@ NLEqn::solve (int& info)
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in hybrj1");
     }
   else
     {
       Array<double> fvec (n);
       double *pfvec = fvec.fortran_vec ();
 
-      int lwa = (n*(3*n+13))/2;
+      octave_idx_type lwa = (n*(3*n+13))/2;
       Array<double> wa (lwa);
       double *pwa = wa.fortran_vec ();
 
       F77_XFCN (hybrd1, HYBRD1, (hybrd1_fcn, n, px, pfvec, tol, info,
 				 pwa, lwa));
 
       solution_status = info;
 
@@ -201,17 +201,17 @@ NLEqn::solve (int& info)
 
 std::string
 NLEqn::error_message (void) const
 {
   std::string retval;
 
   std::string prefix;
 
-  int info = solution_status;
+  octave_idx_type info = solution_status;
   if (info < 0)
     info = -info;
 
   switch (info)
     {
     case 0:
       retval = "improper input parameters";
       break;
diff --git a/liboctave/NLEqn.h b/liboctave/NLEqn.h
--- a/liboctave/NLEqn.h
+++ b/liboctave/NLEqn.h
@@ -57,49 +57,49 @@ public:
     }
 
   ~NLEqn (void) { }
 
   void set_states (const ColumnVector& xx) { x = xx; }
 
   ColumnVector states (void) const { return x; }
 
-  int size (void) const { return x.capacity (); }
+  octave_idx_type size (void) const { return x.capacity (); }
 
   ColumnVector solve (void)
     {
-      int info;
+      octave_idx_type info;
       return solve (info);
     }
 
   ColumnVector solve (const ColumnVector& xvec)
     {
       set_states (xvec);
-      int info;
+      octave_idx_type info;
       return solve (info);
     }
 
-  ColumnVector solve (const ColumnVector& xvec, int& info)
+  ColumnVector solve (const ColumnVector& xvec, octave_idx_type& info)
     {
       set_states (xvec);
       return solve (info);
     }
 
-  ColumnVector solve (int& info);
+  ColumnVector solve (octave_idx_type& info);
 
-  int solution_state (void) const { return solution_status; }
+  octave_idx_type solution_state (void) const { return solution_status; }
 
   bool solution_ok (void) const { return solution_status == 1; }
 
   std::string error_message (void) const;
 
 private:
 
   ColumnVector x;
-  int solution_status;
+  octave_idx_type solution_status;
 
   void error (const char* msg);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -33,35 +33,35 @@ Software Foundation, 59 Temple Place - S
 static integrand_fcn user_fcn;
 
 // XXX FIXME XXX -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 int quad_integration_error = 0;
 
-typedef int (*quad_fcn_ptr) (double*, int&, double*);
+typedef octave_idx_type (*quad_fcn_ptr) (double*, int&, double*);
 			      
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dqagp, DQAGP) (quad_fcn_ptr, const double&, const double&,
-			   const int&, const double*, const double&,
-			   const double&, double&, double&, int&,
-			   int&, const int&, const int&, int&, int*,
+			   const octave_idx_type&, const double*, const double&,
+			   const double&, double&, double&, octave_idx_type&,
+			   octave_idx_type&, const octave_idx_type&, const octave_idx_type&, octave_idx_type&, octave_idx_type*,
 			   double*);
 
   F77_RET_T
-  F77_FUNC (dqagi, DQAGI) (quad_fcn_ptr, const double&, const int&,
+  F77_FUNC (dqagi, DQAGI) (quad_fcn_ptr, const double&, const octave_idx_type&,
 			   const double&, const double&, double&,
-			   double&, int&, int&, const int&,
-			   const int&, int&, int*, double*); 
+			   double&, octave_idx_type&, octave_idx_type&, const octave_idx_type&,
+			   const octave_idx_type&, octave_idx_type&, octave_idx_type*, double*); 
 }
 
-static int
+static octave_idx_type
 user_function (double *x, int& ierr, double *result)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
 #if defined (sun) && defined (__GNUC__)
   double xx = access_double (x);
 #else
   double xx = *x;
@@ -81,64 +81,64 @@ user_function (double *x, int& ierr, dou
     ierr = -1;
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 double
-DefQuad::do_integrate (int& ier, int& neval, double& abserr)
+DefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
 {
-  int npts = singularities.capacity () + 2;
+  octave_idx_type npts = singularities.capacity () + 2;
   double *points = singularities.fortran_vec ();
   double result = 0.0;
 
-  int leniw = 183*npts - 122;
-  Array<int> iwork (leniw);
-  int *piwork = iwork.fortran_vec ();
+  octave_idx_type leniw = 183*npts - 122;
+  Array<octave_idx_type> iwork (leniw);
+  octave_idx_type *piwork = iwork.fortran_vec ();
 
-  int lenw = 2*leniw - npts;
+  octave_idx_type lenw = 2*leniw - npts;
   Array<double> work (lenw);
   double *pwork = work.fortran_vec ();
 
   user_fcn = f;
-  int last;
+  octave_idx_type last;
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
   F77_XFCN (dqagp, DQAGP, (user_function, lower_limit, upper_limit,
 			   npts, points, abs_tol, rel_tol, result,
 			   abserr, neval, ier, leniw, lenw, last,
 			   piwork, pwork));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dqagp");
 
   return result;
 }
 
 double
-IndefQuad::do_integrate (int& ier, int& neval, double& abserr)
+IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
 {
   double result = 0.0;
 
-  int leniw = 128;
-  Array<int> iwork (leniw);
-  int *piwork = iwork.fortran_vec ();
+  octave_idx_type leniw = 128;
+  Array<octave_idx_type> iwork (leniw);
+  octave_idx_type *piwork = iwork.fortran_vec ();
 
-  int lenw = 8*leniw;
+  octave_idx_type lenw = 8*leniw;
   Array<double> work (lenw);
   double *pwork = work.fortran_vec ();
 
   user_fcn = f;
-  int last;
+  octave_idx_type last;
 
-  int inf;
+  octave_idx_type inf;
   switch (type)
     {
     case bound_to_inf:
       inf = 1;
       break;
 
     case neg_inf_to_bound:
       inf = -1;
diff --git a/liboctave/Quad.h b/liboctave/Quad.h
--- a/liboctave/Quad.h
+++ b/liboctave/Quad.h
@@ -50,40 +50,40 @@ Quad : public Quad_options
 
   Quad (integrand_fcn fcn)
     : Quad_options (), f (fcn) { }
 
   virtual ~Quad (void) { }
 
   virtual double integrate (void)
     {
-      int ier, neval;
+      octave_idx_type ier, neval;
       double abserr;
       return do_integrate (ier, neval, abserr);
     }
 
-  virtual double integrate (int& ier)
+  virtual double integrate (octave_idx_type& ier)
     {
-      int neval;
+      octave_idx_type neval;
       double abserr;
       return do_integrate (ier, neval, abserr);
     }
 
-  virtual double integrate (int& ier, int& neval)
+  virtual double integrate (octave_idx_type& ier, octave_idx_type& neval)
     {
       double abserr;
       return do_integrate (ier, neval, abserr);
     }
 
-  virtual double integrate (int& ier, int& neval, double& abserr)
+  virtual double integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
     {
       return do_integrate (ier, neval, abserr);
     }
 
-  virtual double do_integrate (int& ier, int& neval, double& abserr) = 0;
+  virtual double do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr) = 0;
 
  protected:
 
   integrand_fcn f;
 };
 
 class
 DefQuad : public Quad
@@ -102,17 +102,17 @@ DefQuad : public Quad
       singularities (sing) { }
 
   DefQuad (integrand_fcn fcn, const ColumnVector& sing)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0),
       singularities (sing) { }
 
   ~DefQuad (void) { }
 
-  double do_integrate (int& ier, int& neval, double& abserr);
+  double do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr);
 
  private:
 
   double lower_limit;
   double upper_limit;
 
   ColumnVector singularities;
 };
@@ -127,17 +127,17 @@ IndefQuad : public Quad
   IndefQuad (integrand_fcn fcn)
     : Quad (fcn), bound (0.0), type (bound_to_inf) { }
 
   IndefQuad (integrand_fcn fcn, double b, IntegralType t)
     : Quad (fcn), bound (b), type (t) { }
 
   ~IndefQuad (void) { }
 
-  double do_integrate (int& ier, int& neval, double& abserr);
+  double do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr);
 
  private:
 
   double bound;
   IntegralType type;
   int integration_error;
 };
 
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -36,29 +36,29 @@ Software Foundation, 59 Temple Place - S
 
 bool
 Range::all_elements_are_ints (void) const
 {
   // If the base and increment are ints, the final value in the range
   // will also be an integer, even if the limit is not.
 
   return (! (xisnan (rng_base) || xisnan (rng_inc))
-	  && NINT (rng_base) == rng_base
-	  && NINT (rng_inc) == rng_inc);
+	  && NINTbig (rng_base) == rng_base
+	  && NINTbig (rng_inc) == rng_inc);
 }
 
 Matrix
 Range::matrix_value (void) const
 {
   if (rng_nelem > 0 && cache.rows () == 0)
     {
       cache.resize (1, rng_nelem);
       double b = rng_base;
       double increment = rng_inc;
-      for (int i = 0; i < rng_nelem; i++)
+      for (octave_idx_type i = 0; i < rng_nelem; i++)
 	cache(i) = b + i * increment;
 
       // On some machines (x86 with extended precision floating point
       // arithmetic, for example) it is possible that we can overshoot
       // the limit by approximately the machine precision even though
       // we were very careful in our calculation of the number of
       // elements.
 
@@ -129,19 +129,19 @@ Range::sort (void)
     }
 }
 
 std::ostream&
 operator << (std::ostream& os, const Range& a)
 {
   double b = a.base ();
   double increment = a.inc ();
-  int num_elem = a.nelem ();
+  octave_idx_type num_elem = a.nelem ();
 
-  for (int i = 0; i < num_elem-1; i++)
+  for (octave_idx_type i = 0; i < num_elem-1; i++)
     os << b + i * increment << " ";
 
   // Prevent overshoot.  See comment in the matrix_value method
   // above.
 
   os << (increment > 0 ? a.max () : a.min ()) << "\n";
 
   return os;
@@ -242,34 +242,34 @@ static inline bool
 teq (double u, double v, double ct = 3.0 * DBL_EPSILON)
 {
   double tu = fabs (u);
   double tv = fabs (v);
 
   return fabs (u - v) < ((tu > tv ? tu : tv) * ct);
 }
 
-int
+octave_idx_type
 Range::nelem_internal (void) const
 {
-  int retval = -1;
+  octave_idx_type retval = -1;
 
   if (rng_inc == 0
       || (rng_limit > rng_base && rng_inc < 0)
       || (rng_limit < rng_base && rng_inc > 0))
     {
       retval = 0;
     }
   else
     {
       double ct = 3.0 * DBL_EPSILON;
 
       double tmp = tfloor ((rng_limit - rng_base + rng_inc) / rng_inc, ct);
 
-      int n_elt = (tmp > 0.0 ? static_cast<int> (tmp) : 0);
+      octave_idx_type n_elt = (tmp > 0.0 ? static_cast<octave_idx_type> (tmp) : 0);
 
       // If the final element that we would compute for the range is
       // equal to the limit of the range, or is an adjacent floating
       // point number, accept it.  Otherwise, try a range with one
       // fewer element.  If that fails, try again with one more
       // element.
       //
       // I'm not sure this is very good, but it seems to work better than
diff --git a/liboctave/Range.h b/liboctave/Range.h
--- a/liboctave/Range.h
+++ b/liboctave/Range.h
@@ -44,17 +44,17 @@ Range
 
   Range (double b, double l, double i)
     : rng_base (b), rng_limit (l), rng_inc (i),
       rng_nelem (nelem_internal ()), cache () { }
 
   double base (void) const { return rng_base; }
   double limit (void) const { return rng_limit; }
   double inc (void) const { return rng_inc; }
-  int nelem (void) const { return rng_nelem; }
+  octave_idx_type nelem (void) const { return rng_nelem; }
 
   bool all_elements_are_ints (void) const;
 
   Matrix matrix_value (void) const;
 
   double min (void) const;
   double max (void) const;
 
@@ -93,21 +93,21 @@ Range
   void print_range (void);
 
  private:
 
   double rng_base;
   double rng_limit;
   double rng_inc;
 
-  int rng_nelem;
+  octave_idx_type rng_nelem;
 
   mutable Matrix cache;
 
-  int nelem_internal (void) const;
+  octave_idx_type nelem_internal (void) const;
 
   void clear_cache (void) const { cache.resize (0, 0); }
 };
 
 extern Range operator - (const Range& r);
 
 #endif
 
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -40,43 +40,43 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BIN_OP_DECL (R1, operator -, M, S); \
   SPARSE_BIN_OP_DECL (R2, operator *, M, S); \
   SPARSE_BIN_OP_DECL (R2, operator /, M, S);
 
 #define SPARSE_SMS_BIN_OP_1(R, F, OP, M, S)	\
   R \
   F (const M& m, const S& s) \
   { \
-    int nr = m.rows (); \
-    int nc = m.cols (); \
+    octave_idx_type nr = m.rows (); \
+    octave_idx_type nc = m.cols (); \
  \
     R r (nr, nc, (0.0 OP s)); \
  \
-    for (int j = 0; j < nc; j++) \
-      for (int i = m.cidx (j); i < m.cidx (j+1); i++) \
+    for (octave_idx_type j = 0; j < nc; j++) \
+      for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
         r.elem (m.ridx (i), j) = m.data (i) OP s; \
     return r; \
   }
 
 #define SPARSE_SMS_BIN_OP_2(R, F, OP, M, S)	\
   R \
   F (const M& m, const S& s) \
   { \
-    int nr = m.rows (); \
-    int nc = m.cols (); \
-    int nz = m.nnz (); \
+    octave_idx_type nr = m.rows (); \
+    octave_idx_type nc = m.cols (); \
+    octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
-    for (int i = 0; i < nz; i++) \
+    for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = m.data(i) OP s; \
 	r.ridx(i) = m.ridx(i); \
       } \
-    for (int i = 0; i < nc + 1; i++) \
+    for (octave_idx_type i = 0; i < nc + 1; i++) \
       r.cidx(i) = m.cidx(i); \
     \
     r.maybe_compress (true); \
     return r; \
   }
 
 #define SPARSE_SMS_BIN_OPS(R1, R2, M, S) \
   SPARSE_SMS_BIN_OP_1 (R1, operator +, +, M, S) \
@@ -96,55 +96,55 @@ Software Foundation, 59 Temple Place - S
   SPARSE_CMP_OP_DECL (mx_el_eq, M, S); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M, S);
 
 #define SPARSE_SMS_CMP_OP(F, OP, M, MZ, MC, S, SZ, SC)	\
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     /* Count num of non-zero elements */ \
-    int nel = 0; \
-    int nz = m.nnz (); \
+    octave_idx_type nel = 0; \
+    octave_idx_type nz = m.nnz (); \
     if (MC (MZ) OP SC (s))   \
       nel += m.numel() - nz; \
-    for (int i = 0; i < nz; i++) \
+    for (octave_idx_type i = 0; i < nz; i++) \
       if (MC (m.data (i)) OP SC (s)) \
         nel++;	\
     \
-    int nr = m.rows (); \
-    int nc = m.cols (); \
+    octave_idx_type nr = m.rows (); \
+    octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r (nr, nc, nel); \
     \
     if (nr > 0 && nc > 0) \
       { \
 	if (MC (MZ) OP SC (s))	\
 	  { \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < nc; j++) \
+	    for (octave_idx_type j = 0; j < nc; j++) \
 	      { \
-		for (int i = 0; i < nr; i++) \
+		for (octave_idx_type i = 0; i < nr; i++) \
 		  { \
 		    bool el =  MC (m.elem(i, j)) OP SC (s); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
 		  } \
 		r.cidx(j+1) = ii; \
 	      } \
 	  } \
 	else \
 	  { \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < nc; j++) \
+	    for (octave_idx_type j = 0; j < nc; j++) \
 	      { \
-		for (int i = m.cidx(j); i < m.cidx(j+1); i++) \
+		for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
 		  { \
 		    bool el =  MC (m.data(i)) OP SC (s); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = m.ridx(i); \
 		      } \
 		  } \
@@ -171,55 +171,55 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BOOL_OP_DECL (mx_el_and, M, S); \
   SPARSE_BOOL_OP_DECL (mx_el_or,  M, S);
 
 #define SPARSE_SMS_BOOL_OP(F, OP, M, S, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     /* Count num of non-zero elements */ \
-    int nel = 0; \
-    int nz = m.nnz (); \
+    octave_idx_type nel = 0; \
+    octave_idx_type nz = m.nnz (); \
     if (LHS_ZERO OP (s != RHS_ZERO)) \
       nel += m.numel() - nz; \
-    for (int i = 0; i < nz; i++) \
+    for (octave_idx_type i = 0; i < nz; i++) \
       if ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO))\
         nel++;	\
     \
-    int nr = m.rows (); \
-    int nc = m.cols (); \
+    octave_idx_type nr = m.rows (); \
+    octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r (nr, nc, nel); \
     \
     if (nr > 0 && nc > 0) \
       { \
 	if (LHS_ZERO OP (s != RHS_ZERO)) \
 	  { \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < nc; j++) \
+	    for (octave_idx_type j = 0; j < nc; j++) \
 	      { \
-		for (int i = 0; i < nr; i++) \
+		for (octave_idx_type i = 0; i < nr; i++) \
 		  { \
 		    bool el = (m.elem(i, j) != LHS_ZERO) OP (s != RHS_ZERO); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
 		  } \
 		r.cidx(j+1) = ii; \
 	      } \
 	  } \
 	else \
 	  { \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < nc; j++) \
+	    for (octave_idx_type j = 0; j < nc; j++) \
 	      { \
-		for (int i = m.cidx(j); i < m.cidx(j+1); i++) \
+		for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
 		  { \
 		    bool el = (m.data(i) != LHS_ZERO) OP (s != RHS_ZERO); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = m.ridx(i); \
 		      } \
 		  } \
@@ -249,44 +249,44 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BIN_OP_DECL (R1, operator -, S, M); \
   SPARSE_BIN_OP_DECL (R2, operator *, S, M); \
   SPARSE_BIN_OP_DECL (R2, operator /, S, M);
 
 #define SPARSE_SSM_BIN_OP_1(R, F, OP, S, M) \
   R \
   F (const S& s, const M& m) \
   { \
-    int nr = m.rows (); \
-    int nc = m.cols (); \
+    octave_idx_type nr = m.rows (); \
+    octave_idx_type nc = m.cols (); \
  \
     R r (nr, nc, (s OP 0.0)); \
  \
-    for (int j = 0; j < nc; j++) \
-      for (int i = m.cidx (j); i < m.cidx (j+1); i++) \
+    for (octave_idx_type j = 0; j < nc; j++) \
+      for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
         r.elem (m.ridx (i), j) = s OP m.data (i); \
  \
     return r; \
   }
 
 #define SPARSE_SSM_BIN_OP_2(R, F, OP, S, M) \
   R \
   F (const S& s, const M& m) \
   { \
-    int nr = m.rows (); \
-    int nc = m.cols (); \
-    int nz = m.nnz (); \
+    octave_idx_type nr = m.rows (); \
+    octave_idx_type nc = m.cols (); \
+    octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
-    for (int i = 0; i < nz; i++) \
+    for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = s OP m.data(i); \
 	r.ridx(i) = m.ridx(i); \
       } \
-    for (int i = 0; i < nc + 1; i++) \
+    for (octave_idx_type i = 0; i < nc + 1; i++) \
       r.cidx(i) = m.cidx(i); \
  \
     r.maybe_compress(true); \
     return r; \
   }
 
 #define SPARSE_SSM_BIN_OPS(R1, R2, S, M) \
   SPARSE_SSM_BIN_OP_1 (R1, operator +, +, S, M) \
@@ -306,55 +306,55 @@ Software Foundation, 59 Temple Place - S
   SPARSE_CMP_OP_DECL (mx_el_eq, S, M); \
   SPARSE_CMP_OP_DECL (mx_el_ne, S, M);
 
 #define SPARSE_SSM_CMP_OP(F, OP, S, SZ, SC, M, MZ, MC)	\
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     /* Count num of non-zero elements */ \
-    int nel = 0; \
-    int nz = m.nnz (); \
+    octave_idx_type nel = 0; \
+    octave_idx_type nz = m.nnz (); \
     if (SC (s) OP MC (MZ))   \
       nel += m.numel() - nz; \
-    for (int i = 0; i < nz; i++) \
+    for (octave_idx_type i = 0; i < nz; i++) \
       if (SC (s) OP MC (m.data (i))) \
         nel++;	\
     \
-    int nr = m.rows (); \
-    int nc = m.cols (); \
+    octave_idx_type nr = m.rows (); \
+    octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r (nr, nc, nel); \
     \
     if (nr > 0 && nc > 0) \
       { \
 	if (SC (s) OP MC (MZ))\
 	  { \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < nc; j++) \
+	    for (octave_idx_type j = 0; j < nc; j++) \
 	      { \
-		for (int i = 0; i < nr; i++) \
+		for (octave_idx_type i = 0; i < nr; i++) \
 		  { \
 		    bool el = SC (s) OP MC (m.elem(i, j)); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
 		  } \
 		r.cidx(j+1) = ii; \
 	      } \
 	  } \
 	else \
 	  { \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < nc; j++) \
+	    for (octave_idx_type j = 0; j < nc; j++) \
 	      { \
-		for (int i = m.cidx(j); i < m.cidx(j+1); i++) \
+		for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
 		  { \
 		    bool el =  SC (s) OP MC (m.data(i)); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = m.ridx(i); \
 		      } \
 		  } \
@@ -381,55 +381,55 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BOOL_OP_DECL (mx_el_and, S, M); \
   SPARSE_BOOL_OP_DECL (mx_el_or,  S, M); \
 
 #define SPARSE_SSM_BOOL_OP(F, OP, S, M, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     /* Count num of non-zero elements */ \
-    int nel = 0; \
-    int nz = m.nnz (); \
+    octave_idx_type nel = 0; \
+    octave_idx_type nz = m.nnz (); \
     if ((s != LHS_ZERO) OP  RHS_ZERO) \
       nel += m.numel() - nz; \
-    for (int i = 0; i < nz; i++) \
+    for (octave_idx_type i = 0; i < nz; i++) \
       if ((s != LHS_ZERO) OP m.data(i) != RHS_ZERO) \
         nel++;	\
     \
-    int nr = m.rows (); \
-    int nc = m.cols (); \
+    octave_idx_type nr = m.rows (); \
+    octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r (nr, nc, nel); \
     \
     if (nr > 0 && nc > 0) \
       { \
 	if ((s != LHS_ZERO) OP RHS_ZERO) \
 	  { \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < nc; j++) \
+	    for (octave_idx_type j = 0; j < nc; j++) \
 	      { \
-		for (int i = 0; i < nr; i++) \
+		for (octave_idx_type i = 0; i < nr; i++) \
 		  { \
 		    bool el = (s != LHS_ZERO) OP (m.elem(i, j) != RHS_ZERO); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
 		  } \
 		r.cidx(j+1) = ii; \
 	      } \
 	  } \
 	else \
 	  { \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < nc; j++) \
+	    for (octave_idx_type j = 0; j < nc; j++) \
 	      { \
-		for (int i = m.cidx(j); i < m.cidx(j+1); i++) \
+		for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
 		  { \
 		    bool el = (s != LHS_ZERO) OP (m.data(i) != RHS_ZERO); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = m.ridx(i); \
 		      } \
 		  } \
@@ -461,38 +461,38 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2);
 
 #define SPARSE_SMSM_BIN_OP_1(R, F, OP, M1, M2)	\
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
  \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
 	r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
         \
-        int jx = 0; \
+        octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
-        for (int i = 0 ; i < m1_nc ; i++) \
+        for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            int  ja = m1.cidx(i); \
-            int  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx(i); \
+            octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            int  jb = m2.cidx(i); \
-            int  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx(i); \
+            octave_idx_type  jb_max = m2.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 OCTAVE_QUIT; \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
                   { \
@@ -535,38 +535,38 @@ Software Foundation, 59 Temple Place - S
   }
 
 #define SPARSE_SMSM_BIN_OP_2(R, F, OP, M1, M2)	\
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
  \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
         \
-        int jx = 0; \
+        octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
-        for (int i = 0 ; i < m1_nc ; i++) \
+        for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            int  ja = m1.cidx(i); \
-            int  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx(i); \
+            octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            int  jb = m2.cidx(i); \
-            int  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx(i); \
+            octave_idx_type  jb_max = m2.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 OCTAVE_QUIT; \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
                   { \
@@ -599,38 +599,38 @@ Software Foundation, 59 Temple Place - S
   }
 
 #define SPARSE_SMSM_BIN_OP_3(R, F, OP, M1, M2)	\
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
  \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
  \
         /* XXX FIXME XXX Kludge... Always double/Complex, so Complex () */ \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ())); \
         \
-        for (int i = 0 ; i < m1_nc ; i++) \
+        for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            int  ja = m1.cidx(i); \
-            int  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx(i); \
+            octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            int  jb = m2.cidx(i); \
-            int  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx(i); \
+            octave_idx_type  jb_max = m2.cidx(i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 OCTAVE_QUIT; \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
                   { \
@@ -686,40 +686,40 @@ Software Foundation, 59 Temple Place - S
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
 
 #define SPARSE_SMSM_CMP_OP(F, OP, M1, C1, M2, C2)	\
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
     \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
-	    int nel = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
-	      for (int i = 0; i < m1_nr; i++) \
+	    octave_idx_type nel = 0; \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
+	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
 		  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      { \
-	        for (int i = 0; i < m1_nr; i++) \
+	        for (octave_idx_type i = 0; i < m1_nr; i++) \
 		  { \
 		    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
 		  } \
@@ -752,41 +752,41 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2);
 
 #define SPARSE_SMSM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
     \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
-	    int nel = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
-	      for (int i = 0; i < m1_nr; i++) \
+	    octave_idx_type nel = 0; \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
+	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if ((m1.elem(i, j) != LHS_ZERO) \
 		    OP (m2.elem(i, j) != RHS_ZERO)) \
 		  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      { \
-	        for (int i = 0; i < m1_nr; i++) \
+	        for (octave_idx_type i = 0; i < m1_nr; i++) \
 		  { \
 		    bool el = (m1.elem(i, j) != LHS_ZERO) \
 		      OP (m2.elem(i, j) != RHS_ZERO);	  \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
@@ -824,65 +824,65 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2);
 
 #define SPARSE_MSM_BIN_OP_1(R, F, OP, M1, M2)	\
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
  \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc); \
         \
-        for (int j = 0; j < m1_nc; j++) \
-	  for (int i = 0; i < m1_nr; i++) \
+        for (octave_idx_type j = 0; j < m1_nc; j++) \
+	  for (octave_idx_type i = 0; i < m1_nr; i++) \
 	    r.elem (i, j) = m1.elem (i, j) OP m2.elem (i, j); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_BIN_OP_2(R, F, OP, M1, M2, ZERO) \
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
  \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
 	/* Count num of non-zero elements */ \
-	int nel = 0; \
-	for (int j = 0; j < m1_nc; j++) \
-	  for (int i = 0; i < m1_nr; i++) \
+	octave_idx_type nel = 0; \
+	for (octave_idx_type j = 0; j < m1_nc; j++) \
+	  for (octave_idx_type i = 0; i < m1_nr; i++) \
 	    if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
 	      nel++; \
 	\
         r = R (m1_nr, m1_nc, nel); \
         \
-	int ii = 0; \
+	octave_idx_type ii = 0; \
 	r.cidx (0) = 0; \
-        for (int j = 0 ; j < m1_nc ; j++) \
+        for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
           { \
-	    for (int i = 0 ; i < m1_nr ; i++)	\
+	    for (octave_idx_type i = 0 ; i < m1_nr ; i++)	\
 	      {	\
 	        if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
 		  { \
 		    r.data (ii) = m1.elem(i, j) OP m2.elem(i,j); \
 		    r.ridx (ii++) = i; \
 		  } \
 	      } \
 	    r.cidx(j+1) = ii; \
@@ -912,40 +912,40 @@ Software Foundation, 59 Temple Place - S
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
 
 #define SPARSE_MSM_CMP_OP(F, OP, M1, C1, M2, C2)	\
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
     \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
-	    int nel = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
-	      for (int i = 0; i < m1_nr; i++) \
+	    octave_idx_type nel = 0; \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
+	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
 		  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      { \
-	        for (int i = 0; i < m1_nr; i++) \
+	        for (octave_idx_type i = 0; i < m1_nr; i++) \
 		  { \
 		    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
 		  } \
@@ -978,41 +978,41 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2);
 
 #define SPARSE_MSM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
     \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
-	    int nel = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
-	      for (int i = 0; i < m1_nr; i++) \
+	    octave_idx_type nel = 0; \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
+	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if ((m1.elem(i, j) != LHS_ZERO) \
 		    OP (m2.elem(i, j) != RHS_ZERO)) \
 		  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      { \
-	        for (int i = 0; i < m1_nr; i++) \
+	        for (octave_idx_type i = 0; i < m1_nr; i++) \
 		  { \
 		    bool el = (m1.elem(i, j) != LHS_ZERO) \
 		      OP (m2.elem(i, j) != RHS_ZERO);	  \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
@@ -1050,65 +1050,65 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2);
 
 #define SPARSE_SMM_BIN_OP_1(R, F, OP, M1, M2)	\
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
  \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc); \
         \
-        for (int j = 0; j < m1_nc; j++) \
-	  for (int i = 0; i < m1_nr; i++) \
+        for (octave_idx_type j = 0; j < m1_nc; j++) \
+	  for (octave_idx_type i = 0; i < m1_nr; i++) \
 	    r.elem (i, j) = m1.elem (i, j) OP m2.elem (i, j); \
       } \
     return r; \
   }
 
 #define SPARSE_SMM_BIN_OP_2(R, F, OP, M1, M2, ZERO) \
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
  \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
 	/* Count num of non-zero elements */ \
-	int nel = 0; \
-	for (int j = 0; j < m1_nc; j++) \
-	  for (int i = 0; i < m1_nr; i++) \
+	octave_idx_type nel = 0; \
+	for (octave_idx_type j = 0; j < m1_nc; j++) \
+	  for (octave_idx_type i = 0; i < m1_nr; i++) \
 	    if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
 	      nel++; \
 	\
         r = R (m1_nr, m1_nc, nel); \
         \
-	int ii = 0; \
+	octave_idx_type ii = 0; \
 	r.cidx (0) = 0; \
-        for (int j = 0 ; j < m1_nc ; j++) \
+        for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
           { \
-	    for (int i = 0 ; i < m1_nr ; i++)	\
+	    for (octave_idx_type i = 0 ; i < m1_nr ; i++)	\
 	      {	\
 	        if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
 		  { \
 		    r.data (ii) = m1.elem(i, j) OP m2.elem(i,j); \
 		    r.ridx (ii++) = i; \
 		  } \
 	      } \
 	    r.cidx(j+1) = ii; \
@@ -1138,40 +1138,40 @@ Software Foundation, 59 Temple Place - S
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2);
 
 #define SPARSE_SMM_CMP_OP(F, OP, M1, C1, M2, C2)	\
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
     \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
-	    int nel = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
-	      for (int i = 0; i < m1_nr; i++) \
+	    octave_idx_type nel = 0; \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
+	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
 		  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      { \
-	        for (int i = 0; i < m1_nr; i++) \
+	        for (octave_idx_type i = 0; i < m1_nr; i++) \
 		  { \
 		    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
 		  } \
@@ -1204,41 +1204,41 @@ Software Foundation, 59 Temple Place - S
   SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2);
 
 #define SPARSE_SMM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
-    int m1_nr = m1.rows (); \
-    int m1_nc = m1.cols (); \
+    octave_idx_type m1_nr = m1.rows (); \
+    octave_idx_type m1_nc = m1.cols (); \
     \
-    int m2_nr = m2.rows (); \
-    int m2_nc = m2.cols (); \
+    octave_idx_type m2_nr = m2.rows (); \
+    octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
-	    int nel = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
-	      for (int i = 0; i < m1_nr; i++) \
+	    octave_idx_type nel = 0; \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
+	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if ((m1.elem(i, j) != LHS_ZERO) \
 		    OP (m2.elem(i, j) != RHS_ZERO)) \
 		  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    int ii = 0; \
+	    octave_idx_type ii = 0; \
 	    r.cidx (0) = 0; \
-	    for (int j = 0; j < m1_nc; j++) \
+	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      { \
-	        for (int i = 0; i < m1_nr; i++) \
+	        for (octave_idx_type i = 0; i < m1_nr; i++) \
 		  { \
 		    bool el = (m1.elem(i, j) != LHS_ZERO) \
 		      OP (m2.elem(i, j) != RHS_ZERO);	  \
 		    if (el) \
 		      { \
 			r.data(ii) = el; \
 			r.ridx(ii++) = i; \
 		      } \
@@ -1266,64 +1266,64 @@ Software Foundation, 59 Temple Place - S
   SPARSE_SMM_BIN_OP_DECLS (R1, R2, M1, M2) \
   SPARSE_SMM_CMP_OP_DECLS (M1, M2) \
   SPARSE_SMM_BOOL_OP_DECLS (M1, M2)
 
 // Avoid some code duplication.  Maybe we should use templates.
 
 #define SPARSE_CUMSUM(RET_TYPE, ELT_TYPE, FCN)	\
  \
-  int nr = rows (); \
-  int nc = cols (); \
+  octave_idx_type nr = rows (); \
+  octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
 	/* Ugly!! Is there a better way? */ \
         retval = transpose (). FCN (0) .transpose (); \
       else \
 	{ \
-          int nel = 0; \
-	  for (int i = 0; i < nc; i++) \
+          octave_idx_type nel = 0; \
+	  for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (); \
-	      for (int j = cidx (i); j < cidx (i+1); j++)	\
+	      for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)	\
                 { \
                   t += data(j); \
                   if (t != ELT_TYPE ()) \
                     if (j == cidx(i+1) - 1) \
 		      nel += nr - ridx(j); \
                     else \
 		      nel += ridx(j+1) - ridx(j); \
                 } \
 	    } \
 	  retval = RET_TYPE (nr, nc, nel); \
           retval.cidx(0) = 0; \
-	  int ii = 0; \
-	  for (int i = 0; i < nc; i++) \
+	  octave_idx_type ii = 0; \
+	  for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (); \
-	      for (int j = cidx (i); j < cidx (i+1); j++)	\
+	      for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)	\
                 { \
                   t += data(j); \
                   if (t != ELT_TYPE ()) \
                     { \
                       if (j == cidx(i+1) - 1) \
                         { \
-                          for (int k = ridx(j); k < nr; k++) \
+                          for (octave_idx_type k = ridx(j); k < nr; k++) \
                             { \
                                retval.data (ii) = t; \
                                retval.ridx (ii++) = k; \
                             } \
                         } \
 		      else \
 			{ \
-                          for (int k = ridx(j); k < ridx(j+1); k++) \
+                          for (octave_idx_type k = ridx(j); k < ridx(j+1); k++) \
                             { \
                                retval.data (ii) = t; \
                                retval.ridx (ii++) = k; \
                             } \
                         } \
                     } \
                 } \
               retval.cidx(i+1) = ii; \
@@ -1333,51 +1333,51 @@ Software Foundation, 59 Temple Place - S
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
 
 #define SPARSE_CUMPROD(RET_TYPE, ELT_TYPE, FCN)	\
  \
-  int nr = rows (); \
-  int nc = cols (); \
+  octave_idx_type nr = rows (); \
+  octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
 	/* Ugly!! Is there a better way? */ \
         retval = transpose (). FCN (0) .transpose (); \
       else \
 	{ \
-          int nel = 0; \
-	  for (int i = 0; i < nc; i++) \
+          octave_idx_type nel = 0; \
+	  for (octave_idx_type i = 0; i < nc; i++) \
             { \
-	      int jj = 0; \
-	      for (int j = cidx (i); j < cidx (i+1); j++) \
+	      octave_idx_type jj = 0; \
+	      for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
                 { \
 		  if (jj == ridx(j)) \
                     { \
                       nel++; \
                       jj++; \
                     } \
                   else \
                     break; \
                 } \
 	    } \
 	  retval = RET_TYPE (nr, nc, nel); \
           retval.cidx(0) = 0; \
-	  int ii = 0; \
-	  for (int i = 0; i < nc; i++) \
+	  octave_idx_type ii = 0; \
+	  for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (1.); \
-	      int jj = 0; \
-	      for (int j = cidx (i); j < cidx (i+1); j++) \
+	      octave_idx_type jj = 0; \
+	      for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
                 { \
 		  if (jj == ridx(j)) \
                     { \
                       t *= data(j); \
                       retval.data(ii) = t; \
                       retval.ridx(ii++) = jj++; \
                     } \
                   else \
@@ -1390,105 +1390,107 @@ Software Foundation, 59 Temple Place - S
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
 #define SPARSE_BASE_REDUCTION_OP(RET_TYPE, EL_TYPE, ROW_EXPR, COL_EXPR, \
 			         INIT_VAL, MT_RESULT) \
  \
-  int nr = rows (); \
-  int nc = cols (); \
+  octave_idx_type nr = rows (); \
+  octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
 	{ \
 	  OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nr); \
           \
-	  for (int i = 0; i < nr; i++) \
+	  for (octave_idx_type i = 0; i < nr; i++) \
 	    { \
 	      tmp[i] = INIT_VAL; \
-	      for (int j = 0; j < nc; j++) \
+	      for (octave_idx_type j = 0; j < nc; j++) \
 		{ \
 		  ROW_EXPR; \
 		} \
 	    } \
-	  int nel = 0; \
-	  for (int i = 0; i < nr; i++) \
+	  octave_idx_type nel = 0; \
+	  for (octave_idx_type i = 0; i < nr; i++) \
 	    if (tmp[i] != EL_TYPE ())  \
 	      nel++ ; \
-	  retval = RET_TYPE (nr, 1, nel); \
+	  retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nel); \
 	  retval.cidx(0) = 0; \
 	  retval.cidx(1) = nel; \
 	  nel = 0; \
-	  for (int i = 0; i < nr; i++) \
+	  for (octave_idx_type i = 0; i < nr; i++) \
 	    if (tmp[i] != EL_TYPE ())  \
 	      { \
 		retval.data(nel) = tmp[i]; \
 		retval.ridx(nel++) = i; \
 	      } \
 	} \
       else \
 	{ \
 	  OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nc); \
           \
-	  for (int j = 0; j < nc; j++) \
+	  for (octave_idx_type j = 0; j < nc; j++) \
 	    { \
 	      tmp[j] = INIT_VAL; \
-	      for (int i = 0; i < nr; i++) \
+	      for (octave_idx_type i = 0; i < nr; i++) \
 		{ \
 		  COL_EXPR; \
 		} \
 	    } \
-	  int nel = 0; \
-	  for (int i = 0; i < nc; i++) \
+	  octave_idx_type nel = 0; \
+	  for (octave_idx_type i = 0; i < nc; i++) \
 	    if (tmp[i] != EL_TYPE ())  \
 	      nel++ ; \
-	  retval = RET_TYPE (1, nc, nel); \
+	  retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nel); \
 	  retval.cidx(0) = 0; \
 	  nel = 0; \
-	  for (int i = 0; i < nc; i++) \
+	  for (octave_idx_type i = 0; i < nc; i++) \
 	    if (tmp[i] != EL_TYPE ())  \
 	      { \
 		retval.data(nel) = tmp[i]; \
 		retval.ridx(nel++) = 0; \
 		retval.cidx(i+1) = retval.cidx(i) + 1; \
 	      } \
 	    else \
 	      retval.cidx(i+1) = retval.cidx(i); \
 	} \
     } \
   else if (nc == 0 && (nr == 0 || (nr == 1 && dim == -1))) \
     { \
-      retval = RET_TYPE (1, 1, 1); \
+      retval = RET_TYPE (static_cast<octave_idx_type> (1), \
+                         static_cast<octave_idx_type> (1), \
+                         static_cast<octave_idx_type> (1)); \
       retval.cidx(0) = 0; \
       retval.cidx(1) = 1; \
       retval.ridx(0) = 0; \
       retval.data(0) = MT_RESULT; \
     } \
   else if (nr == 0 && (dim == 0 || dim == -1)) \
     { \
-      retval = RET_TYPE (1, nc, nc); \
+      retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nc); \
       retval.cidx (0) = 0; \
-      for (int i = 0; i < nc ; i++) \
+      for (octave_idx_type i = 0; i < nc ; i++) \
         { \
           retval.ridx (i) = 0; \
           retval.cidx (i+1) = i; \
 	  retval.data (i) = MT_RESULT; \
 	} \
     } \
   else if (nc == 0 && dim == 1) \
     { \
-      retval = RET_TYPE (nr, 1, nr); \
+      retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nr); \
       retval.cidx(0) = 0; \
       retval.cidx(1) = nr; \
-      for (int i = 0; i < nr; i++) \
+      for (octave_idx_type i = 0; i < nr; i++) \
 	{ \
 	  retval.ridx(i) = i; \
 	  retval.data(i) = MT_RESULT; \
 	} \
     } \
   else \
     retval.resize (nr > 0, nc > 0); \
  \
@@ -1526,72 +1528,72 @@ Software Foundation, 59 Temple Place - S
 			SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
 			INIT_VAL, INIT_VAL)
 
 #define SPARSE_ALL_OP(DIM) SPARSE_ANY_ALL_OP (DIM, true, ==, false)
 
 #define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, !=, true)
 
 #define SPARSE_SPARSE_MUL( RET_TYPE, EL_TYPE ) \
-  int nr = m.rows (); \
-  int nc = m.cols (); \
+  octave_idx_type nr = m.rows (); \
+  octave_idx_type nc = m.cols (); \
   \
-  int a_nr = a.rows (); \
-  int a_nc = a.cols (); \
+  octave_idx_type a_nr = a.rows (); \
+  octave_idx_type a_nc = a.cols (); \
   \
   if (nc != a_nr) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       OCTAVE_LOCAL_BUFFER (EL_TYPE, Xcol, nr); \
       \
-      int nel = 0; \
+      octave_idx_type nel = 0; \
       \
-      for (int i = 0; i < a_nc; i++) \
+      for (octave_idx_type i = 0; i < a_nc; i++) \
         { \
           OCTAVE_QUIT; \
-          for (int k = 0; k < nr; k++) \
+          for (octave_idx_type k = 0; k < nr; k++) \
 	    Xcol[k]= 0.; \
-          for (int j = a.cidx(i); j < a.cidx(i+1); j++) \
+          for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
             { \
-              int  col = a.ridx(j); \
-              for (int k = m.cidx(col) ; k < m.cidx(col+1); k++) \
+              octave_idx_type  col = a.ridx(j); \
+              for (octave_idx_type k = m.cidx(col) ; k < m.cidx(col+1); k++) \
 		if (Xcol[m.ridx(k)] == 0.) \
                   { \
 		    Xcol[m.ridx(k)] = 1.; \
 		    nel++; \
 		  } \
 	    } \
 	} \
       \
       if (nel == 0) \
 	return RET_TYPE (nr, a_nc); \
       else \
 	{  \
 	  RET_TYPE retval (nr, a_nc, nel); \
 	  \
-	  int ii = 0; \
+	  octave_idx_type ii = 0; \
 	  \
 	  retval.cidx(0) = 0; \
-	  for (int i = 0; i < a_nc ; i++) \
+	  for (octave_idx_type i = 0; i < a_nc ; i++) \
 	    { \
               OCTAVE_QUIT; \
-	      for (int k = 0; k < nr; k++) \
+	      for (octave_idx_type k = 0; k < nr; k++) \
 		Xcol[k]= 0.; \
-	      for (int j = a.cidx(i); j < a.cidx(i+1); j++) \
+	      for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
 		{ \
-                  int col = a.ridx(j); \
+                  octave_idx_type col = a.ridx(j); \
                   EL_TYPE tmpval = a.data(j); \
-		  for (int k = m.cidx(col) ; k < m.cidx(col+1); k++) \
+		  for (octave_idx_type k = m.cidx(col) ; k < m.cidx(col+1); k++) \
 		    Xcol[m.ridx(k)] += tmpval * m.data(k); \
 		} \
-	      for (int k = 0; k < nr; k++) \
+	      for (octave_idx_type k = 0; k < nr; k++) \
 		{ \
 		  if (Xcol[k] !=0. ) \
 		    { \
 		      retval.ridx (ii) = k; \
 		      retval.data (ii++) = Xcol[k]; \
 		    } \
 		} \
 	      retval.cidx(i+1) = ii; \
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -40,117 +40,117 @@ Software Foundation, 59 Temple Place - S
 #include "quit.h"
 
 #include "Sparse.h"
 #include "sparse-sort.h"
 #include "oct-spparms.h"
 
 template <class T>
 T&
-Sparse<T>::SparseRep::elem (int _r, int _c)
+Sparse<T>::SparseRep::elem (octave_idx_type _r, octave_idx_type _c)
 {
-  int i;
+  octave_idx_type i;
 
   if (nnz > 0)
     {
       for (i = c[_c]; i < c[_c + 1]; i++)
 	if (r[i] == _r)
 	  return d[i];
 	else if (r[i] > _r)
 	  break;
 
       // Ok, If we've gotten here, we're in trouble.. Have to create a 
       // new element in the sparse array. This' gonna be slow!!!
       if (c[ncols+1] == nnz)
 	{
 	  (*current_liboctave_error_handler)
-	    ("Sparse::SparseRep::elem (int, int): sparse matrix filled");
+	    ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
 	  return *d;
 	}
 
-      int to_move = c[ncols] - i;
+      octave_idx_type to_move = c[ncols] - i;
       if (to_move != 0)
 	{
-	  for (int j = c[ncols]; j > i; j--)
+	  for (octave_idx_type j = c[ncols]; j > i; j--)
 	    {
 	      d[j] = d[j-1];
 	      r[j] = r[j-1];
 	    }
 	}
 
-      for (int j = _c + 1; j < ncols + 1; j++)
+      for (octave_idx_type j = _c + 1; j < ncols + 1; j++)
 	c[j] = c[j] + 1;
       
       d[i] = 0.;
       r[i] = _r;
 
       return d[i];
     }
   else
     {
       (*current_liboctave_error_handler)
-	("Sparse::SparseRep::elem (int, int): sparse matrix filled");
+	("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
       return *d;
     }
 }
 
 template <class T>
 T
-Sparse<T>::SparseRep::celem (int _r, int _c) const
+Sparse<T>::SparseRep::celem (octave_idx_type _r, octave_idx_type _c) const
 {
   if (nnz > 0)
-    for (int i = c[_c]; i < c[_c + 1]; i++)
+    for (octave_idx_type i = c[_c]; i < c[_c + 1]; i++)
       if (r[i] == _r)
 	return d[i];
   return T ();
 }
 
 template <class T>
 void
 Sparse<T>::SparseRep::maybe_compress (bool remove_zeros)
 {
-  int ndel = nnz - c[ncols];
-  int nzero = 0;
+  octave_idx_type ndel = nnz - c[ncols];
+  octave_idx_type nzero = 0;
 
   if (remove_zeros)
-    for (int i = 0; i < nnz - ndel; i++)
+    for (octave_idx_type i = 0; i < nnz - ndel; i++)
       if (d[i] == T ())
 	nzero++;
 
   if (!ndel && !nzero)
     return;
 
   if (!nzero)
     {
-      int new_nnz = nnz - ndel;
+      octave_idx_type new_nnz = nnz - ndel;
 
       T *new_data = new T [new_nnz];
-      for (int i = 0; i < new_nnz; i++)
+      for (octave_idx_type i = 0; i < new_nnz; i++)
 	new_data[i] = d[i];
       delete [] d;
       d = new_data;
 
-      int *new_ridx = new int [new_nnz];
-      for (int i = 0; i < new_nnz; i++)
+      octave_idx_type *new_ridx = new octave_idx_type [new_nnz];
+      for (octave_idx_type i = 0; i < new_nnz; i++)
 	new_ridx[i] = r[i];
       delete [] r;
       r = new_ridx;
     }
   else
     {
-      int new_nnz = nnz - ndel - nzero;
+      octave_idx_type new_nnz = nnz - ndel - nzero;
 
       T *new_data = new T [new_nnz];
-      int *new_ridx = new int [new_nnz];
-
-      int ii = 0;
-      int ic = 0;
-      for (int j = 0; j < ncols; j++)
+      octave_idx_type *new_ridx = new octave_idx_type [new_nnz];
+
+      octave_idx_type ii = 0;
+      octave_idx_type ic = 0;
+      for (octave_idx_type j = 0; j < ncols; j++)
 	{
-	  for (int k = ic; k < c[j+1]; k++)
+	  for (octave_idx_type k = ic; k < c[j+1]; k++)
 	    if (d[k] != T ())
 	      {
 		new_data [ii] = d[k];
 		new_ridx [ii++] = r[k];
 	      }
 	  ic = c[j+1];
 	  c[j+1] = ii;
 	}
@@ -162,38 +162,38 @@ Sparse<T>::SparseRep::maybe_compress (bo
       r = new_ridx;
     }
 
   nnz -= ndel + nzero;
 }
 
 template <class T>
 void
-Sparse<T>::SparseRep::change_length (int nz)
+Sparse<T>::SparseRep::change_length (octave_idx_type nz)
 {
   if (nz != nnz)
     {
-      int min_nnz = (nz < nnz ? nz : nnz);
-
-      int * new_ridx = new int [nz];
-      for (int i = 0; i < min_nnz; i++)
+      octave_idx_type min_nnz = (nz < nnz ? nz : nnz);
+
+      octave_idx_type * new_ridx = new octave_idx_type [nz];
+      for (octave_idx_type i = 0; i < min_nnz; i++)
 	new_ridx[i] = r[i];
 
       delete [] r;
       r = new_ridx;
 
       T * new_data = new T [nz];
-      for (int i = 0; i < min_nnz; i++)
+      for (octave_idx_type i = 0; i < min_nnz; i++)
 	new_data[i] = d[i];
 
       delete [] d;
       d = new_data;
 
       if (nz < nnz)
-	for (int i = 0; i <= ncols; i++)
+	for (octave_idx_type i = 0; i <= ncols; i++)
 	  if (c[i] > nz)
 	    c[i] = nz;
 
       nnz = nz;
     }
 }
 
 template <class T>
@@ -202,39 +202,39 @@ Sparse<T>::Sparse (const Sparse<U>& a)
   : dimensions (a.dimensions), idx (0), idx_count (0)
 {
   if (a.nnz () == 0)
     rep = new typename Sparse<T>::SparseRep (rows (), cols());
   else
     {
       rep = new typename Sparse<T>::SparseRep (rows (), cols (), a.nnz ());
       
-      int nz = nnz ();
-      int nc = cols ();
-      for (int i = 0; i < nz; i++)
+      octave_idx_type nz = nnz ();
+      octave_idx_type nc = cols ();
+      for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  xdata (i) = T (a.data (i));
 	  xridx (i) = a.ridx (i);
 	}
-      for (int i = 0; i < nc + 1; i++)
+      for (octave_idx_type i = 0; i < nc + 1; i++)
 	xcidx (i) = a.cidx (i);
     }
 }
 
 template <class T>
-Sparse<T>::Sparse (int nr, int nc, T val)
+Sparse<T>::Sparse (octave_idx_type nr, octave_idx_type nc, T val)
   : rep (new typename Sparse<T>::SparseRep (nr, nc, nr*nc)),
     dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
 { 
 
-  int ii = 0;
+  octave_idx_type ii = 0;
   xcidx (0) = 0;
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  xdata (ii) = val;
 	  xridx (ii++) = i;
 	} 
       xcidx (j+1) = ii;
     }
 }
 
@@ -261,81 +261,81 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
     static_cast<unsigned long long>(dv (1));
 
   if (a_nel != dv_nel)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Sparse&, const dim_vector&): dimension mismatch");
   else
     {
       dim_vector old_dims = a.dims();
-      int new_nnz = a.nnz ();
-      int new_nr = dv (0);
-      int new_nc = dv (1);
-      int old_nr = old_dims (0);
-      int old_nc = old_dims (1);
+      octave_idx_type new_nnz = a.nnz ();
+      octave_idx_type new_nr = dv (0);
+      octave_idx_type new_nc = dv (1);
+      octave_idx_type old_nr = old_dims (0);
+      octave_idx_type old_nc = old_dims (1);
 
       rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nnz);
 
-      int kk = 0;
+      octave_idx_type kk = 0;
       xcidx(0) = 0;
-      for (int i = 0; i < old_nc; i++)
-	for (int j = a.cidx(i); j < a.cidx(i+1); j++)
+      for (octave_idx_type i = 0; i < old_nc; i++)
+	for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++)
 	  {
-	    int tmp = i * old_nr + a.ridx(j);
-	    int ii = tmp % new_nr;
-	    int jj = (tmp - ii) / new_nr; 
-	    for (int k = kk; k < jj; k++)
+	    octave_idx_type tmp = i * old_nr + a.ridx(j);
+	    octave_idx_type ii = tmp % new_nr;
+	    octave_idx_type jj = (tmp - ii) / new_nr; 
+	    for (octave_idx_type k = kk; k < jj; k++)
 	      xcidx(k+1) = j;
 	    kk = jj;
 	    xdata(j) = a.data(j);
 	    xridx(j) = ii;
 	  }
-      for (int k = kk; k < new_nc; k++)
+      for (octave_idx_type k = kk; k < new_nc; k++)
 	xcidx(k+1) = new_nnz;
     }
 }
 
 template <class T>
-Sparse<T>::Sparse (const Array<T>& a, const Array<int>& r, 
-		   const Array<int>& c, int nr,
-		   int nc, bool sum_terms)
+Sparse<T>::Sparse (const Array<T>& a, const Array<octave_idx_type>& r, 
+		   const Array<octave_idx_type>& c, octave_idx_type nr,
+		   octave_idx_type nc, bool sum_terms)
   : dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
 {
-  int a_len = a.length ();
-  int r_len = r.length ();
-  int c_len = c.length ();
+  octave_idx_type a_len = a.length ();
+  octave_idx_type r_len = r.length ();
+  octave_idx_type c_len = c.length ();
   bool ri_scalar = (r_len == 1); 
   bool ci_scalar = (c_len == 1);
   bool cf_scalar = (a_len == 1);
   
   if ((a_len != r_len && !cf_scalar && !ri_scalar) ||
       (a_len != c_len && !cf_scalar && !ci_scalar) ||
       (r_len != c_len && !ri_scalar && !ci_scalar) || nr < 0 || nc < 0)
     {
       (*current_liboctave_error_handler)
-	("Sparse::Sparse (const Array<T>&, const Array<int>&, ...): dimension mismatch");
+	("Sparse::Sparse (const Array<T>&, const Array<octave_idx_type>&, ...): dimension mismatch");
       rep = nil_rep ();
       dimensions = dim_vector (0, 0);
     }
   else
     {
-      int max_nnz = (r_len > c_len ? r_len : c_len);
+      octave_idx_type max_nnz = (r_len > c_len ? r_len : c_len);
 
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nnz);
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nnz);
 
-      for (int i = 0; i < max_nnz; i++)
+      for (octave_idx_type i = 0; i < max_nnz; i++)
 	sidx[i] = &sidxX[i];
 
-      int actual_nnz = 0;
+      octave_idx_type actual_nnz = 0;
       OCTAVE_QUIT;
-      for (int i = 0; i < max_nnz; i++) 
+      for (octave_idx_type i = 0; i < max_nnz; i++) 
 	{
-	  int rowidx =  (ri_scalar ? r(0) : r(i));
-	  int colidx = (ci_scalar ? c(0) : c(i));
+	  octave_idx_type rowidx =  (ri_scalar ? r(0) : r(i));
+	  octave_idx_type colidx = (ci_scalar ? c(0) : c(i));
 	  if (rowidx < nr && rowidx >= 0 &&
 	      colidx < nc && colidx >= 0 ) 
 	    {
 	      if ( a (cf_scalar ? 0 : i ) != T ()) 
 		{
 		  sidx[actual_nnz]->r = rowidx;
 		  sidx[actual_nnz]->c = colidx;
 		  sidx[actual_nnz]->idx = i;
@@ -360,43 +360,43 @@ Sparse<T>::Sparse (const Array<T>& a, co
 	  OCTAVE_QUIT;
 	  octave_sort<octave_sparse_sort_idxl *> 
 	    sort (octave_sparse_sidxl_comp);
 
 	  sort.sort (sidx, actual_nnz);
 	  OCTAVE_QUIT;
 
 	  // Now count the unique non-zero values
-	  int real_nnz = 1;
-	  for (int i = 1; i < actual_nnz; i++) 
+	  octave_idx_type real_nnz = 1;
+	  for (octave_idx_type i = 1; i < actual_nnz; i++) 
 	    if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
 	      real_nnz++;
 
 	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nnz);
 
-	  int cx = 0;
-	  int prev_rval = -1;
-	  int prev_cval = -1;
-	  int ii = -1;
+	  octave_idx_type cx = 0;
+	  octave_idx_type prev_rval = -1;
+	  octave_idx_type prev_cval = -1;
+	  octave_idx_type ii = -1;
 	  xcidx (0) = 0;
-	  for (int i = 0; i < actual_nnz; i++) 
+	  for (octave_idx_type i = 0; i < actual_nnz; i++) 
 	    {
 	      OCTAVE_QUIT;
-	      int iidx = sidx[i]->idx;
-	      int rval = sidx[i]->r;
-	      int cval = sidx[i]->c;
+	      octave_idx_type iidx = sidx[i]->idx;
+	      octave_idx_type rval = sidx[i]->r;
+	      octave_idx_type cval = sidx[i]->c;
 
 	      if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
 		{
-		  int ci = static_cast<int> (c (ci_scalar ? 0 : iidx));
+		  octave_idx_type ci = static_cast<octave_idx_type> (c (ci_scalar ? 0 : iidx));
 		  ii++;
 		  while (cx < ci) 
 		    xcidx (++cx) = ii;
 		  xdata(ii) = a (cf_scalar ? 0 : iidx);
-		  xridx(ii) = static_cast<int> (r (ri_scalar ? 0 : iidx));
+		  xridx(ii) = static_cast<octave_idx_type> (r (ri_scalar ? 0 : iidx));
 		} 
 	      else 
 		{
 		  if (sum_terms)
 		    xdata(ii) += a (cf_scalar ? 0 : iidx);
 		  else
 		    xdata(ii) =  a (cf_scalar ? 0 : iidx);
 		}
@@ -407,53 +407,53 @@ Sparse<T>::Sparse (const Array<T>& a, co
 	  while (cx < nc) 
 	    xcidx (++cx) = ii + 1;
 	}
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a, const Array<double>& r, 
-		   const Array<double>& c, int nr,
-		   int nc, bool sum_terms)
+		   const Array<double>& c, octave_idx_type nr,
+		   octave_idx_type nc, bool sum_terms)
   : dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
 {
-  int a_len = a.length ();
-  int r_len = r.length ();
-  int c_len = c.length ();
+  octave_idx_type a_len = a.length ();
+  octave_idx_type r_len = r.length ();
+  octave_idx_type c_len = c.length ();
   bool ri_scalar = (r_len == 1); 
   bool ci_scalar = (c_len == 1);
   bool cf_scalar = (a_len == 1);
 
   if ((a_len != r_len && !cf_scalar && !ri_scalar) ||
       (a_len != c_len && !cf_scalar && !ci_scalar) ||
       (r_len != c_len && !ri_scalar && !ci_scalar) || nr < 0 || nc < 0)
     {
       (*current_liboctave_error_handler)
 	("Sparse::Sparse (const Array<T>&, const Array<double>&, ...): dimension mismatch");
       rep = nil_rep ();
       dimensions = dim_vector (0, 0);
     }
   else
     {
-      int max_nnz = (r_len > c_len ? r_len : c_len);
+      octave_idx_type max_nnz = (r_len > c_len ? r_len : c_len);
   
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nnz);
       OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nnz);
 
-      for (int i = 0; i < max_nnz; i++)
+      for (octave_idx_type i = 0; i < max_nnz; i++)
 	sidx[i] = &sidxX[i];
 
-      int actual_nnz = 0;
+      octave_idx_type actual_nnz = 0;
       OCTAVE_QUIT;
 
-      for (int i = 0; i < max_nnz; i++) 
+      for (octave_idx_type i = 0; i < max_nnz; i++) 
 	{
-	  int rowidx = static_cast<int> (ri_scalar ? r(0) : r(i));
-	  int colidx = static_cast<int> (ci_scalar ? c(0) : c(i));
+	  octave_idx_type rowidx = static_cast<octave_idx_type> (ri_scalar ? r(0) : r(i));
+	  octave_idx_type colidx = static_cast<octave_idx_type> (ci_scalar ? c(0) : c(i));
 	  if (rowidx < nr && rowidx >= 0 &&
 	      colidx < nc && colidx >= 0 ) 
 	    {
 	      if ( a (cf_scalar ? 0 : i ) != T ()) 
 		{
 		  sidx[actual_nnz]->r = rowidx;
 		  sidx[actual_nnz]->c = colidx;
 		  sidx[actual_nnz]->idx = i;
@@ -478,44 +478,44 @@ Sparse<T>::Sparse (const Array<T>& a, co
 	  OCTAVE_QUIT;
 	  octave_sort<octave_sparse_sort_idxl *> 
 	    sort (octave_sparse_sidxl_comp);
 
 	  sort.sort (sidx, actual_nnz);
 	  OCTAVE_QUIT;
 
 	  // Now count the unique non-zero values
-	  int real_nnz = 1;
-	  for (int i = 1; i < actual_nnz; i++) 
+	  octave_idx_type real_nnz = 1;
+	  for (octave_idx_type i = 1; i < actual_nnz; i++) 
 	    if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
 	      real_nnz++;
 
 	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nnz);
 
-	  int cx = 0;
-	  int prev_rval = -1;
-	  int prev_cval = -1;
-	  int ii = -1;
+	  octave_idx_type cx = 0;
+	  octave_idx_type prev_rval = -1;
+	  octave_idx_type prev_cval = -1;
+	  octave_idx_type ii = -1;
 	  xcidx (0) = 0;
-	  for (int i = 0; i < actual_nnz; i++) 
+	  for (octave_idx_type i = 0; i < actual_nnz; i++) 
 	    {
 	      OCTAVE_QUIT;
-	      int iidx = sidx[i]->idx;
-	      int rval = sidx[i]->r;
-	      int cval = sidx[i]->c;
+	      octave_idx_type iidx = sidx[i]->idx;
+	      octave_idx_type rval = sidx[i]->r;
+	      octave_idx_type cval = sidx[i]->c;
 
 	      if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
 		{
-		  int ci = static_cast<int> (c (ci_scalar ? 0 : iidx));
+		  octave_idx_type ci = static_cast<octave_idx_type> (c (ci_scalar ? 0 : iidx));
 		  ii++;
 
 		  while (cx < ci) 
 		    xcidx (++cx) = ii;
 		  xdata(ii) = a (cf_scalar ? 0 : iidx);
-		  xridx(ii) = static_cast<int> (r (ri_scalar ? 0 : iidx));
+		  xridx(ii) = static_cast<octave_idx_type> (r (ri_scalar ? 0 : iidx));
 		} 
 	      else 
 		{
 		  if (sum_terms)
 		    xdata(ii) += a (cf_scalar ? 0 : iidx);
 		  else
 		    xdata(ii) =  a (cf_scalar ? 0 : iidx);
 		}
@@ -528,33 +528,33 @@ Sparse<T>::Sparse (const Array<T>& a, co
 	}
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array2<T>& a)
   : dimensions (a.dims ()), idx (0), idx_count (0)
 {
-  int nr = rows ();
-  int nc = cols ();
-  int len = a.length ();
-  int new_nnz = 0;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type len = a.length ();
+  octave_idx_type new_nnz = 0;
 
   // First count the number of non-zero terms
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     if (a(i) != T ())
       new_nnz++;
 
   rep = new typename Sparse<T>::SparseRep (nr, nc, new_nnz);
 
-  int ii = 0;
+  octave_idx_type ii = 0;
   xcidx(0) = 0;
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	if (a.elem (i,j) != T ())
 	  {
 	    xdata(ii) = a.elem (i,j);
 	    xridx(ii++) = i;
 	  }
       xcidx(j+1) = ii;
     }
 }
@@ -563,33 +563,33 @@ template <class T>
 Sparse<T>::Sparse (const Array<T>& a)
   : dimensions (a.dims ()), idx (0), idx_count (0)
 {
   if (dimensions.length () > 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
   else
     {
-      int nr = rows ();
-      int nc = cols ();
-      int len = a.length ();
-      int new_nnz = 0;
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+      octave_idx_type len = a.length ();
+      octave_idx_type new_nnz = 0;
 
       // First count the number of non-zero terms
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	if (a(i) != T ())
 	  new_nnz++;
 
       rep = new typename Sparse<T>::SparseRep (nr, nc, new_nnz);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       xcidx(0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    if (a.elem (i,j) != T ())
 	      {
 		xdata(ii) = a.elem (i,j);
 		xridx(ii++) = i;
 	      }
 	  xcidx(j+1) = ii;
 	}
     }
@@ -600,22 +600,22 @@ Sparse<T>::~Sparse (void)
 {
   if (--rep->count <= 0)
     delete rep;
 
   delete [] idx;
 }
 
 template <class T>
-int
-Sparse<T>::compute_index (const Array<int>& ra_idx) const
+octave_idx_type
+Sparse<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
-  int retval = -1;
-
-  int n = dimensions.length ();
+  octave_idx_type retval = -1;
+
+  octave_idx_type n = dimensions.length ();
 
   if (n > 0 && n == ra_idx.length ())
     {
       retval = ra_idx(--n);
 
       while (--n >= 0)
 	{
 	  retval *= dimensions(n);
@@ -626,91 +626,91 @@ Sparse<T>::compute_index (const Array<in
     (*current_liboctave_error_handler)
       ("Sparse<T>::compute_index: invalid ra_idxing operation");
 
   return retval;
 }
 
 template <class T>
 T
-Sparse<T>::range_error (const char *fcn, int n) const
+Sparse<T>::range_error (const char *fcn, octave_idx_type n) const
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
   return T ();
 }
 
 template <class T>
 T&
-Sparse<T>::range_error (const char *fcn, int n)
+Sparse<T>::range_error (const char *fcn, octave_idx_type n)
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
   static T foo;
   return foo;
 }
 
 template <class T>
 T
-Sparse<T>::range_error (const char *fcn, int i, int j) const
+Sparse<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j) const
 {
   (*current_liboctave_error_handler)
     ("%s (%d, %d): range error", fcn, i, j);
   return T ();
 }
 
 template <class T>
 T&
-Sparse<T>::range_error (const char *fcn, int i, int j)
+Sparse<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j)
 {
   (*current_liboctave_error_handler)
     ("%s (%d, %d): range error", fcn, i, j);
   static T foo;
   return foo;
 }
 
 template <class T>
 T
-Sparse<T>::range_error (const char *fcn, const Array<int>& ra_idx) const
+Sparse<T>::range_error (const char *fcn, const Array<octave_idx_type>& ra_idx) const
 {
   OSSTREAM buf;
 
   buf << fcn << " (";
 
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
   if (n > 0)
     buf << ra_idx(0);
 
-  for (int i = 1; i < n; i++)
+  for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
 
   buf << OSSTREAM_ENDS;
 
   (*current_liboctave_error_handler) (OSSTREAM_C_STR (buf));
 
   OSSTREAM_FREEZE (buf);
 
   return T ();
 }
 
 template <class T>
 T&
-Sparse<T>::range_error (const char *fcn, const Array<int>& ra_idx)
+Sparse<T>::range_error (const char *fcn, const Array<octave_idx_type>& ra_idx)
 {
   OSSTREAM buf;
 
   buf << fcn << " (";
 
-  int n = ra_idx.length ();
+  octave_idx_type n = ra_idx.length ();
 
   if (n > 0)
     buf << ra_idx(0);
 
-  for (int i = 1; i < n; i++)
+  for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
 
   buf << OSSTREAM_ENDS;
 
   (*current_liboctave_error_handler) (OSSTREAM_C_STR (buf));
 
@@ -725,67 +725,67 @@ Sparse<T>
 Sparse<T>::reshape (const dim_vector& new_dims) const
 {
   Sparse<T> retval;
 
   if (dimensions != new_dims)
     {
       if (dimensions.numel () == new_dims.numel ())
 	{
-	  int new_nnz = nnz ();
-	  int new_nr = new_dims (0);
-	  int new_nc = new_dims (1);
-	  int old_nr = rows ();
-	  int old_nc = cols ();
+	  octave_idx_type new_nnz = nnz ();
+	  octave_idx_type new_nr = new_dims (0);
+	  octave_idx_type new_nc = new_dims (1);
+	  octave_idx_type old_nr = rows ();
+	  octave_idx_type old_nc = cols ();
 	  retval = Sparse<T> (new_nr, new_nc, new_nnz);
 
-	  int kk = 0;
+	  octave_idx_type kk = 0;
 	  retval.xcidx(0) = 0;
-	  for (int i = 0; i < old_nc; i++)
-	    for (int j = cidx(i); j < cidx(i+1); j++)
+	  for (octave_idx_type i = 0; i < old_nc; i++)
+	    for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
 	      {
-		int tmp = i * old_nr + ridx(j);
-		int ii = tmp % new_nr;
-		int jj = (tmp - ii) / new_nr; 
-		for (int k = kk; k < jj; k++)
+		octave_idx_type tmp = i * old_nr + ridx(j);
+		octave_idx_type ii = tmp % new_nr;
+		octave_idx_type jj = (tmp - ii) / new_nr; 
+		for (octave_idx_type k = kk; k < jj; k++)
 		  retval.xcidx(k+1) = j;
 		kk = jj;
 		retval.xdata(j) = data(j);
 		retval.xridx(j) = ii;
 	      }
-	  for (int k = kk; k < new_nc; k++)
+	  for (octave_idx_type k = kk; k < new_nc; k++)
 	    retval.xcidx(k+1) = new_nnz;
 	}
       else
 	(*current_liboctave_error_handler) ("reshape: size mismatch");
     }
   else
     retval = *this;
 
   return retval;
 }
 
 template <class T>
 Sparse<T>
-Sparse<T>::permute (const Array<int>& perm_vec, bool) const
+Sparse<T>::permute (const Array<octave_idx_type>& perm_vec, bool) const
 {
   dim_vector dv = dims ();
   dim_vector dv_new;
 
-  int nd = dv.length ();
+  octave_idx_type nd = dv.length ();
 
   dv_new.resize (nd);
 
   // Need this array to check for identical elements in permutation array.
   Array<bool> checked (nd, false);
 
   // Find dimension vector of permuted array.
-  for (int i = 0; i < nd; i++)
+  for (octave_idx_type i = 0; i < nd; i++)
     {
-      int perm_el = perm_vec.elem (i);
+      octave_idx_type perm_el = perm_vec.elem (i);
 
       if (perm_el > dv.length () || perm_el < 1)
 	{
 	  (*current_liboctave_error_handler)
 	    ("permutation vector contains an invalid element");
 
 	  return Sparse<T> ();
 	}
@@ -808,99 +808,99 @@ Sparse<T>::permute (const Array<int>& pe
   else
     return transpose ();
 }
 
 template <class T>
 void
 Sparse<T>::resize_no_fill (const dim_vector& dv)
 {
-  int n = dv.length ();
+  octave_idx_type n = dv.length ();
 
   if (n != 2)
     {
       (*current_liboctave_error_handler) ("sparse array must be 2-D");
       return;
     }
 
   resize_no_fill (dv(0), dv(1));
 }
 
 template <class T>
 void
-Sparse<T>::resize_no_fill (int r, int c)
+Sparse<T>::resize_no_fill (octave_idx_type r, octave_idx_type c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
   if (ndims () == 0)
     dimensions = dim_vector (0, 0);
 
   if (r == dim1 () && c == dim2 ())
     return;
 
   typename Sparse<T>::SparseRep *old_rep = Sparse<T>::rep;
-  int nc = cols ();
-  int nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nr = rows ();
 
   if (nnz () == 0 || r == 0 || c == 0)
     // Special case of redimensioning to/from a sparse matrix with 
     // no elements
     rep = new typename Sparse<T>::SparseRep (r, c);
   else
     {
-      int n = 0;
+      octave_idx_type n = 0;
       Sparse<T> tmpval;
       if (r >= nr)
 	{
 	  if (c > nc)
 	    n = cidx(nc);
 	  else
 	    n = cidx(c);
 
 	  tmpval = Sparse<T> (r, c, n);
 
 	  if (c > nc)
 	    {
-	      for (int i = 0; i < nc; i++)
+	      for (octave_idx_type i = 0; i < nc; i++)
 		tmpval.cidx(i) = cidx(i);
-	      for (int i = nc+2; i < c; i++)
+	      for (octave_idx_type i = nc+2; i < c; i++)
 		tmpval.cidx(i) = tmpval.cidx(i-1);
 	    }
 	  else if (c <= nc)
-	    for (int i = 0; i < c; i++)
+	    for (octave_idx_type i = 0; i < c; i++)
 	      tmpval.cidx(i) = cidx(i);
 	  
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      tmpval.data(i) = data(i);
 	      tmpval.ridx(i) = ridx(i);
 	    }
 	}
       else
 	{
 	  // Count how many non zero terms before we do anything
-	  for (int i = 0; i < c; i++)
-	    for (int j = cidx(i); j < cidx(i+1); j++)
+	  for (octave_idx_type i = 0; i < c; i++)
+	    for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
 	      if (ridx(j) < r)
 		n++;
 
 	  if (n)
 	    {
 	      // Now that we know the size we can do something
 	      tmpval = Sparse<T> (r, c, n);
 
 	      tmpval.cidx(0);
-	      for (int i = 0, ii = 0; i < c; i++)
+	      for (octave_idx_type i = 0, ii = 0; i < c; i++)
 		{
-		  for (int j = cidx(i); j < cidx(i+1); j++)
+		  for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
 		    if (ridx(j) < r)
 		      {
 			tmpval.data(ii) = data(j);
 			tmpval.ridx(ii++) = ridx(j);
 		      }
 		  tmpval.cidx(i+1) = ii;
 		}
 	    }
@@ -915,101 +915,101 @@ Sparse<T>::resize_no_fill (int r, int c)
   dimensions = dim_vector (r, c);
 
   if (--old_rep->count <= 0)
     delete old_rep;
 }
 
 template <class T>
 Sparse<T>&
-Sparse<T>::insert (const Sparse<T>& a, int r, int c)
+Sparse<T>::insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_rows = a.rows ();
-  int a_cols = a.cols ();
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type a_rows = a.rows ();
+  octave_idx_type a_cols = a.cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (r < 0 || r + a_rows > rows () || c < 0 || c + a_cols > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   // First count the number of elements in the final array
-  int nel = cidx(c) + a.nnz ();
+  octave_idx_type nel = cidx(c) + a.nnz ();
 
   if (c + a_cols < nc)
     nel += cidx(nc) - cidx(c + a_cols);
 
-  for (int i = c; i < c + a_cols; i++)
-    for (int j = cidx(i); j < cidx(i+1); j++)
+  for (octave_idx_type i = c; i < c + a_cols; i++)
+    for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
       if (ridx(j) < r || ridx(j) >= r + a_rows)
 	nel++;
 
   Sparse<T> tmp (*this);
   --rep->count;
   rep = new typename Sparse<T>::SparseRep (nr, nc, nel);
 
-  for (int i = 0; i < tmp.cidx(c); i++)
+  for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
     {
       data(i) = tmp.data(i);
       ridx(i) = tmp.ridx(i);
     }
-  for (int i = 0; i < c + 1; i++)
+  for (octave_idx_type i = 0; i < c + 1; i++)
     cidx(i) = tmp.cidx(i);
 
-  int ii = cidx(c);
-
-  for (int i = c; i < c + a_cols; i++)
+  octave_idx_type ii = cidx(c);
+
+  for (octave_idx_type i = c; i < c + a_cols; i++)
     {
       OCTAVE_QUIT;
 
-      for (int j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
+      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 	if (tmp.ridx(j) < r)
 	  {
 	    data(ii) = tmp.data(j);
 	    ridx(ii++) = tmp.ridx(j);
 	  }
 
       OCTAVE_QUIT;
 
-      for (int j = a.cidx(i-c); j < a.cidx(i-c+1); j++)
+      for (octave_idx_type j = a.cidx(i-c); j < a.cidx(i-c+1); j++)
 	{
 	  data(ii) = a.data(j);
 	  ridx(ii++) = r + a.ridx(j);
 	}
 
       OCTAVE_QUIT;
 
-      for (int j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
+      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 	if (tmp.ridx(j) >= r + a_rows)
 	  {
 	    data(ii) = tmp.data(j);
 	    ridx(ii++) = tmp.ridx(j);
 	  }
 
       cidx(i+1) = ii;
     }
 
-  for (int i = c + a_cols; i < nc; i++)
+  for (octave_idx_type i = c + a_cols; i < nc; i++)
     {
-      for (int j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
+      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 	{
 	  data(ii) = tmp.data(j);
 	  ridx(ii++) = tmp.ridx(j);
 	}
       cidx(i+1) = ii;
     }
 
   return *this;
 }
 
 template <class T>
 Sparse<T>&
-Sparse<T>::insert (const Sparse<T>& a, const Array<int>& ra_idx)
+Sparse<T>::insert (const Sparse<T>& a, const Array<octave_idx_type>& ra_idx)
 {
 
   if (ra_idx.length () != 2)
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
@@ -1017,26 +1017,26 @@ Sparse<T>::insert (const Sparse<T>& a, c
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::transpose (void) const
 {
   assert (ndims () == 2);
 
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
   Sparse<T> retval (nc, nr, nz);
 
   retval.cidx(0) = 0;
-  for (int i = 0, iidx = 0; i < nr; i++)
+  for (octave_idx_type i = 0, iidx = 0; i < nr; i++)
     {
-      for (int j = 0; j < nc; j++)
-	for (int k = cidx(j); k < cidx(j+1); k++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
 	  if (ridx(k) == i)
 	    {
 	      retval.data(iidx) = data(k);
 	      retval.ridx(iidx++) = j;
 	    }
       retval.cidx(i+1) = iidx;
     }
 
@@ -1051,51 +1051,51 @@ Sparse<T>::clear_index (void)
   idx = 0;
   idx_count = 0;
 }
 
 template <class T>
 void
 Sparse<T>::set_index (const idx_vector& idx_arg)
 {
-  int nd = ndims ();
+  octave_idx_type nd = ndims ();
 
   if (! idx && nd > 0)
     idx = new idx_vector [nd];
 
   if (idx_count < nd)
     {
       idx[idx_count++] = idx_arg;
     }
   else
     {
       idx_vector *new_idx = new idx_vector [idx_count+1];
 
-      for (int i = 0; i < idx_count; i++)
+      for (octave_idx_type i = 0; i < idx_count; i++)
 	new_idx[i] = idx[i];
 
       new_idx[idx_count++] = idx_arg;
 
       delete [] idx;
 
       idx = new_idx;
     }
 }
 
 template <class T>
 void
 Sparse<T>::maybe_delete_elements (idx_vector& idx_arg)
 {
-  int nr = dim1 ();
-  int nc = dim2 ();
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
 
   if (nr == 0 && nc == 0)
     return;
 
-  int n;
+  octave_idx_type n;
   if (nr == 1)
     n = nc;
   else if (nc == 1)
     n = nr;
   else
     {
       // Reshape to row vector for Matlab compatibility.
 
@@ -1112,28 +1112,28 @@ Sparse<T>::maybe_delete_elements (idx_ve
       // A(idx,:) = [] (delete rows) or A(:,idx) (delete columns).
 
       resize_no_fill (0, 0);
       return;
     }
 
   idx_arg.sort (true);
 
-  int num_to_delete = idx_arg.length (n);
+  octave_idx_type num_to_delete = idx_arg.length (n);
 
   if (num_to_delete != 0)
     {
-      int new_n = n;
-      int new_nnz = nnz ();
-
-      int iidx = 0;
+      octave_idx_type new_n = n;
+      octave_idx_type new_nnz = nnz ();
+
+      octave_idx_type iidx = 0;
 
       const Sparse<T> tmp (*this);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  OCTAVE_QUIT;
 
 	  if (i == idx_arg.elem (iidx))
 	    {
 	      iidx++;
 	      new_n--;
 
@@ -1149,20 +1149,20 @@ Sparse<T>::maybe_delete_elements (idx_ve
 	{
 	  rep->count--;
 
 	  if (nr == 1)
 	    rep = new typename Sparse<T>::SparseRep (1, new_n, new_nnz);
 	  else
 	    rep = new typename Sparse<T>::SparseRep (new_n, 1, new_nnz);
 
-	  int ii = 0;
-	  int jj = 0;
+	  octave_idx_type ii = 0;
+	  octave_idx_type jj = 0;
 	  iidx = 0;
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      OCTAVE_QUIT;
 
 	      if (iidx < num_to_delete && i == idx_arg.elem (iidx))
 		iidx++;
 	      else
 		{
 		  T el = tmp.elem (i);
@@ -1176,17 +1176,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 	    }
 
 	  dimensions.resize (2);
 
 	  if (nr == 1)
 	    {
 	      ii = 0;
 	      cidx(0) = 0;
-	      for (int i = 0; i < new_n; i++)
+	      for (octave_idx_type i = 0; i < new_n; i++)
 		{
 		  OCTAVE_QUIT;
 		  if (ridx(ii) == i)
 		    ridx(ii++) = 0;
 		  cidx(i+1) = ii;
 		}
 
 	      dimensions(0) = 1;
@@ -1207,18 +1207,18 @@ Sparse<T>::maybe_delete_elements (idx_ve
 }
 
 template <class T>
 void
 Sparse<T>::maybe_delete_elements (idx_vector& idx_i, idx_vector& idx_j)
 {
   assert (ndims () == 2);
 
-  int nr = dim1 ();
-  int nc = dim2 ();
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
 
   if (nr == 0 && nc == 0)
     return;
 
   if (idx_i.is_colon ())
     {
       if (idx_j.is_colon ())
 	{
@@ -1253,30 +1253,30 @@ Sparse<T>::maybe_delete_elements (idx_ve
   if (idx_i.is_colon_equiv (nr, 1))
     {
       if (idx_j.is_colon_equiv (nc, 1))
 	resize_no_fill (0, 0);
       else
 	{
 	  idx_j.sort (true);
 
-	  int num_to_delete = idx_j.length (nc);
+	  octave_idx_type num_to_delete = idx_j.length (nc);
 
 	  if (num_to_delete != 0)
 	    {
 	      if (nr == 1 && num_to_delete == nc)
 		resize_no_fill (0, 0);
 	      else
 		{
-		  int new_nc = nc;
-		  int new_nnz = nnz ();
-
-		  int iidx = 0;
-
-		  for (int j = 0; j < nc; j++)
+		  octave_idx_type new_nc = nc;
+		  octave_idx_type new_nnz = nnz ();
+
+		  octave_idx_type iidx = 0;
+
+		  for (octave_idx_type j = 0; j < nc; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (j == idx_j.elem (iidx))
 			{
 			  iidx++;
 			  new_nc--;
 			  
@@ -1288,29 +1288,29 @@ Sparse<T>::maybe_delete_elements (idx_ve
 		    }
 
 		  if (new_nc > 0)
 		    {
 		      const Sparse<T> tmp (*this);
 		      --rep->count;
 		      rep = new typename Sparse<T>::SparseRep (nr, new_nc, 
 							       new_nnz);
-		      int ii = 0;
-		      int jj = 0;
+		      octave_idx_type ii = 0;
+		      octave_idx_type jj = 0;
 		      iidx = 0;
 		      cidx(0) = 0;
-		      for (int j = 0; j < nc; j++)
+		      for (octave_idx_type j = 0; j < nc; j++)
 			{
 			  OCTAVE_QUIT;
 
 			  if (iidx < num_to_delete && j == idx_j.elem (iidx))
 			    iidx++;
 			  else
 			    {
-			      for (int i = tmp.cidx(j); 
+			      for (octave_idx_type i = tmp.cidx(j); 
 				   i < tmp.cidx(j+1); i++)
 				{
 				  data(jj) = tmp.data(i);
 				  ridx(jj++) = tmp.ridx(i);
 				}
 			      cidx(++ii) = jj;
 			    }
 			}
@@ -1328,64 +1328,64 @@ Sparse<T>::maybe_delete_elements (idx_ve
   else if (idx_j.is_colon_equiv (nc, 1))
     {
       if (idx_i.is_colon_equiv (nr, 1))
 	resize_no_fill (0, 0);
       else
 	{
 	  idx_i.sort (true);
 
-	  int num_to_delete = idx_i.length (nr);
+	  octave_idx_type num_to_delete = idx_i.length (nr);
 
 	  if (num_to_delete != 0)
 	    {
 	      if (nc == 1 && num_to_delete == nr)
 		resize_no_fill (0, 0);
 	      else
 		{
-		  int new_nr = nr;
-		  int new_nnz = nnz ();
-
-		  int iidx = 0;
-
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nr = nr;
+		  octave_idx_type new_nnz = nnz ();
+
+		  octave_idx_type iidx = 0;
+
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (i == idx_i.elem (iidx))
 			{
 			  iidx++;
 			  new_nr--;
 			  
-			  for (int j = 0; j < nnz (); j++)
+			  for (octave_idx_type j = 0; j < nnz (); j++)
 			    if (ridx(j) == i)
 			      new_nnz--;
 
 			  if (iidx == num_to_delete)
 			    break;
 			}
 		    }
 
 		  if (new_nr > 0)
 		    {
 		      const Sparse<T> tmp (*this);
 		      --rep->count;
 		      rep = new typename Sparse<T>::SparseRep (new_nr, nc, 
 							       new_nnz);
 
-		      int jj = 0;
+		      octave_idx_type jj = 0;
 		      cidx(0) = 0;
-		      for (int i = 0; i < nc; i++)
+		      for (octave_idx_type i = 0; i < nc; i++)
 			{
 			  iidx = 0;
-			  for (int j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
+			  for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 			    {
 			      OCTAVE_QUIT;
 
-			      int ri = tmp.ridx(j);
+			      octave_idx_type ri = tmp.ridx(j);
 
 			      while (iidx < num_to_delete && 
 				     ri > idx_i.elem (iidx))
 				{
 				  iidx++;
 				}
 
 			      if (iidx == num_to_delete ||
@@ -1456,244 +1456,244 @@ Sparse<T>::value (void)
 template <class T>
 Sparse<T>
 Sparse<T>::index (idx_vector& idx_arg, int resize_ok) const
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
-  int nr = dim1 ();
-  int nc = dim2 ();
-  int nz = nnz ();
-
-  int orig_len = nr * nc;
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
+  octave_idx_type nz = nnz ();
+
+  octave_idx_type orig_len = nr * nc;
 
   dim_vector idx_orig_dims = idx_arg.orig_dimensions ();
 
-  int idx_orig_rows = idx_arg.orig_rows ();
-  int idx_orig_columns = idx_arg.orig_columns ();
+  octave_idx_type idx_orig_rows = idx_arg.orig_rows ();
+  octave_idx_type idx_orig_columns = idx_arg.orig_columns ();
 
   if (idx_orig_dims.length () > 2)
     (*current_liboctave_error_handler)
       ("Sparse<T>::index: Can not index Sparse<T> with an N-D Array");
   else if (idx_arg.is_colon ())
     {
       // Fast magic colon processing.
       retval = Sparse<T> (nr * nc, 1, nz);
 
-      for (int i = 0; i < nc; i++)
-	for (int j = cidx(i); j < cidx(i+1); j++)
+      for (octave_idx_type i = 0; i < nc; i++)
+	for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
 	  {
 	    OCTAVE_QUIT;
 	    retval.xdata(j) = data(j); 
 	    retval.xridx(j) = ridx(j) + i * nr;
 	  }
       retval.xcidx(0) = 0;
       retval.xcidx(1) = nz;
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
       // then want to make a dense matrix with sparse 
       // representation. Ok, we'll do it, but you deserve what 
       // you get!!
-      int n = idx_arg.freeze (length (), "sparse vector", resize_ok);
+      octave_idx_type n = idx_arg.freeze (length (), "sparse vector", resize_ok);
       if (n == 0)
 	if (idx_arg.one_zero_only ())
 	  retval = Sparse<T> (dim_vector (0, 0));
 	else
 	  retval = Sparse<T> (dim_vector (0, 1));
       else if (nz < 1)
 	if (n >= idx_orig_dims.numel ())
 	  retval = Sparse<T> (idx_orig_dims);
 	else
 	  retval = Sparse<T> (dim_vector (n, 1));
       else if (n >= idx_orig_dims.numel ())
 	{
 	  T el = elem (0);
-	  int new_nr = idx_orig_rows;
-	  int new_nc = idx_orig_columns;
-	  for (int i = 2; i < idx_orig_dims.length (); i++)
+	  octave_idx_type new_nr = idx_orig_rows;
+	  octave_idx_type new_nc = idx_orig_columns;
+	  for (octave_idx_type i = 2; i < idx_orig_dims.length (); i++)
 	    new_nc *= idx_orig_dims (i);
 		
 	  retval = Sparse<T> (new_nr, new_nc, idx_arg.ones_count ());
 
-	  int ic = 0;
-	  for (int i = 0; i < n; i++)
+	  octave_idx_type ic = 0;
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      if (i % new_nr == 0)
 		retval.xcidx(i % new_nr) = ic;
 
-	      int ii = idx_arg.elem (i);
+	      octave_idx_type ii = idx_arg.elem (i);
 	      if (ii == 0)
 		{
 		  OCTAVE_QUIT;
 		  retval.xdata(ic) = el;
 		  retval.xridx(ic++) = i % new_nr;
 		}
 	    }
 	  retval.xcidx (new_nc) = ic;
 	}
       else
 	{
 	  T el = elem (0);
 	  retval = Sparse<T> (n, 1, nz);
   	 
-	  for (int i = 0; i < nz; i++) 
+	  for (octave_idx_type i = 0; i < nz; i++) 
 	    {
 	      OCTAVE_QUIT;
 	      retval.xdata(i) = el;
 	      retval.xridx(i) = i;
 	    }
 	  retval.xcidx(0) = 0; 	 
 	  retval.xcidx(1) = n; 	 
 	}
     }
   else if (nr == 1 || nc == 1)
     {
       // If indexing a vector with a matrix, return value has same
       // shape as the index.  Otherwise, it has same orientation as
       // indexed object.
-      int len = length ();
-      int n = idx_arg.freeze (len, "sparse vector", resize_ok);
+      octave_idx_type len = length ();
+      octave_idx_type n = idx_arg.freeze (len, "sparse vector", resize_ok);
 
       if (n == 0)
 	if (nr == 1)
 	  retval = Sparse<T> (dim_vector (1, 0));
 	else
 	  retval = Sparse<T> (dim_vector (0, 1));
       else if (nz < 1)
 	if ((n != 0 && idx_arg.one_zero_only ())
 	    || idx_orig_rows == 1 || idx_orig_columns == 1)
 	  retval = Sparse<T> ((nr == 1 ? 1 : n), (nr == 1 ? n : 1));
 	else
 	  retval = Sparse<T> (idx_orig_dims);
       else
 	{
 
-	  int new_nnz = 0;
+	  octave_idx_type new_nnz = 0;
 	  if (nr == 1)
-	    for (int i = 0; i < n; i++)
+	    for (octave_idx_type i = 0; i < n; i++)
 	      {
 		OCTAVE_QUIT;
 
-		int ii = idx_arg.elem (i);
+		octave_idx_type ii = idx_arg.elem (i);
 		if (ii < len)
 		  if (cidx(ii) != cidx(ii+1))
 		    new_nnz++;
 	      }
 	  else
-	    for (int i = 0; i < n; i++)
+	    for (octave_idx_type i = 0; i < n; i++)
 	      {
-		int ii = idx_arg.elem (i);
+		octave_idx_type ii = idx_arg.elem (i);
 		if (ii < len)
-		  for (int j = 0; j < nz; j++)
+		  for (octave_idx_type j = 0; j < nz; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (ridx(j) == ii)
 			new_nnz++;
 		      if (ridx(j) >= ii)
 			break;
 		    }
 	      }
 
 	  if (idx_arg.one_zero_only () || idx_orig_rows == 1 || 
 	      idx_orig_columns == 1)
 	    {
 	      if (nr == 1)
 		{
 		  retval = Sparse<T> (1, n, new_nnz);
-		  int jj = 0;
+		  octave_idx_type jj = 0;
 		  retval.xcidx(0) = 0;
-		  for (int i = 0; i < n; i++)
+		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      OCTAVE_QUIT;
 
-		      int ii = idx_arg.elem (i);
+		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
 			if (cidx(ii) != cidx(ii+1))
 			  {
 			    retval.xdata(jj) = data(cidx(ii));
 			    retval.xridx(jj++) = 0;
 			  }
 		      retval.xcidx(i+1) = jj;
 		    }
 		}
 	      else
 		{
 		  retval = Sparse<T> (n, 1, new_nnz);
 		  retval.xcidx(0) = 0;
 		  retval.xcidx(1) = new_nnz;
-		  int jj = 0;
-		  for (int i = 0; i < n; i++)
+		  octave_idx_type jj = 0;
+		  for (octave_idx_type i = 0; i < n; i++)
 		    {
-		      int ii = idx_arg.elem (i);
+		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
-			for (int j = 0; j < nz; j++)
+			for (octave_idx_type j = 0; j < nz; j++)
 			  {
 			    OCTAVE_QUIT;
 
 			    if (ridx(j) == ii)
 			      {
 				retval.xdata(jj) = data(j);
 				retval.xridx(jj++) = i;
 			      }
 			    if (ridx(j) >= ii)
 			      break;
 			  }
 		    }
 		}
 	    }
 	  else 
 	    {
-	      int new_nr;
-	      int new_nc;
+	      octave_idx_type new_nr;
+	      octave_idx_type new_nc;
 	      if (n >= idx_orig_dims.numel ())
 		{
 		  new_nr = idx_orig_rows;
 		  new_nc = idx_orig_columns;
 		}
 	      else
 		{
 		  new_nr = n;
 		  new_nc = 1;
 		}
 
 	      retval = Sparse<T> (new_nr, new_nc, new_nnz);
 
 	      if (nr == 1)
 		{
-		  int jj = 0;
+		  octave_idx_type jj = 0;
 		  retval.xcidx(0) = 0;
-		  for (int i = 0; i < n; i++)
+		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      OCTAVE_QUIT;
 
-		      int ii = idx_arg.elem (i);
+		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
 			if (cidx(ii) != cidx(ii+1))
 			  {
 			    retval.xdata(jj) = data(cidx(ii));
 			    retval.xridx(jj++) = 0;
 			  }
 		      retval.xcidx(i/new_nr+1) = jj;
 		    }
 		}
 	      else
 		{
-		  int jj = 0;
+		  octave_idx_type jj = 0;
 		  retval.xcidx(0) = 0;
-		  for (int i = 0; i < n; i++)
+		  for (octave_idx_type i = 0; i < n; i++)
 		    {
-		      int ii = idx_arg.elem (i);
+		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
-			for (int j = 0; j < nz; j++)
+			for (octave_idx_type j = 0; j < nz; j++)
 			  {
 			    OCTAVE_QUIT;
 
 			    if (ridx(j) == ii)
 			      {
 				retval.xdata(jj) = data(j);
 				retval.xridx(jj++) = i;
 			      }
@@ -1717,71 +1717,71 @@ Sparse<T>::index (idx_vector& idx_arg, i
 
       // This code is only for indexing matrices.  The vector
       // cases are handled above.
 
       idx_arg.freeze (nr * nc, "matrix", resize_ok);
 
       if (idx_arg)
 	{
-	  int result_nr = idx_orig_rows;
-	  int result_nc = idx_orig_columns;
+	  octave_idx_type result_nr = idx_orig_rows;
+	  octave_idx_type result_nc = idx_orig_columns;
 
 	  if (idx_arg.one_zero_only ())
 	    {
 	      result_nr = idx_arg.ones_count ();
 	      result_nc = (result_nr > 0 ? 1 : 0);
 	    }
 
 	  if (nz < 1)
 	      retval = Sparse<T> (result_nr, result_nc);
 	  else
 	    {
 	      // Count number of non-zero elements
-	      int new_nnz = 0;
-	      int kk = 0;
-	      for (int j = 0; j < result_nc; j++)
+	      octave_idx_type new_nnz = 0;
+	      octave_idx_type kk = 0;
+	      for (octave_idx_type j = 0; j < result_nc; j++)
 		{
-		  for (int i = 0; i < result_nr; i++)
+		  for (octave_idx_type i = 0; i < result_nr; i++)
 		    {
 		      OCTAVE_QUIT;
 		      
-		      int ii = idx_arg.elem (kk++);
+		      octave_idx_type ii = idx_arg.elem (kk++);
 		      if (ii < orig_len)
 			{
-			  int fr = ii % nr;
-			  int fc = (ii - fr) / nr;
-			  for (int k = cidx(fc); k < cidx(fc+1); k++)
+			  octave_idx_type fr = ii % nr;
+			  octave_idx_type fc = (ii - fr) / nr;
+			  for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
 			    {
 			      if (ridx(k) == fr)
 				new_nnz++;
 			      if (ridx(k) >= fr)
 				break;
 			    }
 			}
 		    }
 		}
 	      
 	      retval = Sparse<T> (result_nr, result_nc, new_nnz);
 
 	      kk = 0;
-	      int jj = 0;
+	      octave_idx_type jj = 0;
 	      retval.xcidx(0) = 0;
-	      for (int j = 0; j < result_nc; j++)
+	      for (octave_idx_type j = 0; j < result_nc; j++)
 		{
-		  for (int i = 0; i < result_nr; i++)
+		  for (octave_idx_type i = 0; i < result_nr; i++)
 		    {
 		      OCTAVE_QUIT;
 
-		      int ii = idx_arg.elem (kk++);
+		      octave_idx_type ii = idx_arg.elem (kk++);
 		      if (ii < orig_len)
 			{
-			  int fr = ii % nr;
-			  int fc = (ii - fr) / nr;
-			  for (int k = cidx(fc); k < cidx(fc+1); k++)
+			  octave_idx_type fr = ii % nr;
+			  octave_idx_type fc = (ii - fr) / nr;
+			  for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
 			    {
 			      if (ridx(k) == fr)
 				{
 				  retval.xdata(jj) = data(k);
 				  retval.xridx(jj++) = i;
 				}
 			      if (ridx(k) >= fr)
 				break;
@@ -1801,72 +1801,72 @@ Sparse<T>::index (idx_vector& idx_arg, i
 template <class T>
 Sparse<T>
 Sparse<T>::index (idx_vector& idx_i, idx_vector& idx_j, int resize_ok) const
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
-  int nr = dim1 ();
-  int nc = dim2 ();
-
-  int n = idx_i.freeze (nr, "row", resize_ok);
-  int m = idx_j.freeze (nc, "column", resize_ok);
+  octave_idx_type nr = dim1 ();
+  octave_idx_type nc = dim2 ();
+
+  octave_idx_type n = idx_i.freeze (nr, "row", resize_ok);
+  octave_idx_type m = idx_j.freeze (nc, "column", resize_ok);
 
   if (idx_i && idx_j)
     {
       if (idx_i.orig_empty () || idx_j.orig_empty () || n == 0 || m == 0)
 	{
 	  retval.resize_no_fill (n, m);
 	}
       else if (idx_i.is_colon_equiv (nr) && idx_j.is_colon_equiv (nc))
 	{
 	  retval = *this;
 	}
       else
 	{
 	  // First count the number of non-zero elements
-	  int new_nnz = 0;
-	  for (int j = 0; j < m; j++)
+	  octave_idx_type new_nnz = 0;
+	  for (octave_idx_type j = 0; j < m; j++)
 	    {
-	      int jj = idx_j.elem (j);
-	      for (int i = 0; i < n; i++)
+	      octave_idx_type jj = idx_j.elem (j);
+	      for (octave_idx_type i = 0; i < n; i++)
 		{
 		  OCTAVE_QUIT;
 
-		  int ii = idx_i.elem (i);
+		  octave_idx_type ii = idx_i.elem (i);
 		  if (ii < nr && jj < nc)
 		    {
-		      for (int k = cidx(jj); k < cidx(jj+1); k++)
+		      for (octave_idx_type k = cidx(jj); k < cidx(jj+1); k++)
 			{
 			  if (ridx(k) == ii)
 			    new_nnz++;
 			  if (ridx(k) >= ii)
 			    break;
 			}
 		    }
 		}
 	    }
 
 	  retval = Sparse<T> (n, m, new_nnz);
 
-	  int kk = 0;
+	  octave_idx_type kk = 0;
 	  retval.xcidx(0) = 0;
-	  for (int j = 0; j < m; j++)
+	  for (octave_idx_type j = 0; j < m; j++)
 	    {
-	      int jj = idx_j.elem (j);
-	      for (int i = 0; i < n; i++)
+	      octave_idx_type jj = idx_j.elem (j);
+	      for (octave_idx_type i = 0; i < n; i++)
 		{
 		  OCTAVE_QUIT;
 
-		  int ii = idx_i.elem (i);
+		  octave_idx_type ii = idx_i.elem (i);
 		  if (ii < nr && jj < nc)
 		    {
-		      for (int k = cidx(jj); k < cidx(jj+1); k++)
+		      for (octave_idx_type k = cidx(jj); k < cidx(jj+1); k++)
 			{
 			  if (ridx(k) == ii)
 			    {
 			      retval.xdata(kk) = data(k);
 			      retval.xridx(kk++) = i;
 			    }
 			  if (ridx(k) >= ii)
 			    break;
@@ -1905,18 +1905,18 @@ int
 assign1 (Sparse<LT>& lhs, const Sparse<RT>& rhs)
 {
   int retval = 1;
 
   idx_vector *idx_tmp = lhs.get_idx ();
 
   idx_vector lhs_idx = idx_tmp[0];
 
-  int lhs_len = lhs.numel ();
-  int rhs_len = rhs.numel ();
+  octave_idx_type lhs_len = lhs.numel ();
+  octave_idx_type rhs_len = rhs.numel ();
 
   unsigned EIGHT_BYTE_INT long_lhs_len = 
     static_cast<unsigned EIGHT_BYTE_INT> (lhs.rows ()) *
     static_cast<unsigned EIGHT_BYTE_INT> (lhs.cols ());
 
   unsigned EIGHT_BYTE_INT long_rhs_len = 
     static_cast<unsigned EIGHT_BYTE_INT> (rhs.rows ()) *
     static_cast<unsigned EIGHT_BYTE_INT> (rhs.cols ());
@@ -1928,62 +1928,62 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	("A(I) = X: Matrix dimensions too large to ensure correct\n",
 	 "operation. This is an limitation that should be removed\n",
 	 "in the future.");
 
       lhs.clear_index ();
       return 0;
     }
 
-  int nr = lhs.rows ();
-  int nc = lhs.cols ();
-  int nz = lhs.nnz ();
-
-  int n = lhs_idx.freeze (lhs_len, "vector", true, liboctave_wrore_flag);
+  octave_idx_type nr = lhs.rows ();
+  octave_idx_type nc = lhs.cols ();
+  octave_idx_type nz = lhs.nnz ();
+
+  octave_idx_type n = lhs_idx.freeze (lhs_len, "vector", true, liboctave_wrore_flag);
 
   if (n != 0)
     {
-      int max_idx = lhs_idx.max () + 1;
+      octave_idx_type max_idx = lhs_idx.max () + 1;
       max_idx = max_idx < lhs_len ? lhs_len : max_idx;
 
       // Take a constant copy of lhs. This means that elem won't 
       // create missing elements.
       const Sparse<LT> c_lhs (lhs);
 
       if (rhs_len == n)
 	{
-	  int new_nnz = lhs.nnz ();
+	  octave_idx_type new_nnz = lhs.nnz ();
 
 	  // First count the number of non-zero elements
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      OCTAVE_QUIT;
 
-	      int ii = lhs_idx.elem (i);
+	      octave_idx_type ii = lhs_idx.elem (i);
 	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 		new_nnz--;
 	      if (rhs.elem(i) != RT ())
 		new_nnz++;
 	    }
 
 	  if (nr > 1)
 	    {
 	      Sparse<LT> tmp (max_idx, 1, new_nnz);
 	      tmp.cidx(0) = 0;
 	      tmp.cidx(1) = tmp.nnz ();
 
-	      int i = 0;
-	      int ii = 0;
+	      octave_idx_type i = 0;
+	      octave_idx_type ii = 0;
 	      if (i < nz)
 		ii = c_lhs.ridx(i);
 
-	      int j = 0;
-	      int jj = lhs_idx.elem(j);
-
-	      int kk = 0;
+	      octave_idx_type j = 0;
+	      octave_idx_type jj = lhs_idx.elem(j);
+
+	      octave_idx_type kk = 0;
 
 	      while (j < n || i < nz)
 		{
 		  if (j == n || (i < nz && ii < jj))
 		    {
 		      tmp.xdata (kk) = c_lhs.data (i);
 		      tmp.xridx (kk++) = ii;
 		      if (++i < nz)
@@ -2007,26 +2007,26 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 		}
 
 	      lhs = tmp;
 	    }
 	  else
 	    {
 	      Sparse<LT> tmp (1, max_idx, new_nnz);
 
-	      int i = 0;
-	      int ii = 0;
+	      octave_idx_type i = 0;
+	      octave_idx_type ii = 0;
 	      while (ii < nc && c_lhs.cidx(ii+1) <= i)
 		ii++;
 
-	      int j = 0;
-	      int jj = lhs_idx.elem(j);
-
-	      int kk = 0;
-	      int ic = 0;
+	      octave_idx_type j = 0;
+	      octave_idx_type jj = lhs_idx.elem(j);
+
+	      octave_idx_type kk = 0;
+	      octave_idx_type ic = 0;
 
 	      while (j < n || i < nz)
 		{
 		  if (j == n || (i < nz && ii < jj))
 		    {
 		      while (ic <= ii)
 			tmp.xcidx (ic++) = kk;
 		      tmp.xdata (kk) = c_lhs.data (i);
@@ -2050,55 +2050,55 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 			}
 		      j++;
 		      if (j < n)
 			jj = lhs_idx.elem(j);
 		    }
 		  tmp.xridx (kk++) = 0;
 		}
 
-	      for (int iidx = ic; iidx < max_idx+1; iidx++)
+	      for (octave_idx_type iidx = ic; iidx < max_idx+1; iidx++)
 		tmp.xcidx(iidx) = kk;
 
 	      lhs = tmp;
 	    }
 	}
       else if (rhs_len == 1)
 	{
-	  int new_nnz = lhs.nnz ();
+	  octave_idx_type new_nnz = lhs.nnz ();
 	  RT scalar = rhs.elem (0);
 	  bool scalar_non_zero = (scalar != RT ());
 
 	  // First count the number of non-zero elements
 	  if (scalar != RT ())
 	    new_nnz += n;
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      OCTAVE_QUIT;
 
-	      int ii = lhs_idx.elem (i);
+	      octave_idx_type ii = lhs_idx.elem (i);
 	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 		new_nnz--;
 	    }
 
 	  if (nr > 1)
 	    {
 	      Sparse<LT> tmp (max_idx, 1, new_nnz);
 	      tmp.cidx(0) = 0;
 	      tmp.cidx(1) = tmp.nnz ();
 
-	      int i = 0;
-	      int ii = 0;
+	      octave_idx_type i = 0;
+	      octave_idx_type ii = 0;
 	      if (i < nz)
 		ii = c_lhs.ridx(i);
 
-	      int j = 0;
-	      int jj = lhs_idx.elem(j);
-
-	      int kk = 0;
+	      octave_idx_type j = 0;
+	      octave_idx_type jj = lhs_idx.elem(j);
+
+	      octave_idx_type kk = 0;
 
 	      while (j < n || i < nz)
 		{
 		  if (j == n || (i < nz && ii < jj))
 		    {
 		      tmp.xdata (kk) = c_lhs.data (i);
 		      tmp.xridx (kk++) = ii;
 		      if (++i < nz)
@@ -2121,26 +2121,26 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 		}
 
 	      lhs = tmp;
 	    }
 	  else
 	    {
 	      Sparse<LT> tmp (1, max_idx, new_nnz);
 
-	      int i = 0;
-	      int ii = 0;
+	      octave_idx_type i = 0;
+	      octave_idx_type ii = 0;
 	      while (ii < nc && c_lhs.cidx(ii+1) <= i)
 		ii++;
 
-	      int j = 0;
-	      int jj = lhs_idx.elem(j);
-
-	      int kk = 0;
-	      int ic = 0;
+	      octave_idx_type j = 0;
+	      octave_idx_type jj = lhs_idx.elem(j);
+
+	      octave_idx_type kk = 0;
+	      octave_idx_type ic = 0;
 
 	      while (j < n || i < nz)
 		{
 		  if (j == n || (i < nz && ii < jj))
 		    {
 		      while (ic <= ii)
 			tmp.xcidx (ic++) = kk;
 		      tmp.xdata (kk) = c_lhs.data (i);
@@ -2162,17 +2162,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 			}
 		      j++;
 		      if (j < n)
 			jj = lhs_idx.elem(j);
 		    }
 		  tmp.xridx (kk++) = 0;
 		}
 
-	      for (int iidx = ic; iidx < max_idx+1; iidx++)
+	      for (octave_idx_type iidx = ic; iidx < max_idx+1; iidx++)
 		tmp.xcidx(iidx) = kk;
 
 	      lhs = tmp;
 	    }
 	}
       else
 	{
 	  (*current_liboctave_error_handler)
@@ -2181,33 +2181,33 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	  retval = 0;
 	}
     }
   else if (lhs_idx.is_colon ())
     {
       if (lhs_len == 0)
 	{
 
-	  int new_nnz = rhs.nnz ();
+	  octave_idx_type new_nnz = rhs.nnz ();
 	  Sparse<LT> tmp (1, rhs_len, new_nnz);
 
-	  int ii = 0;
-	  int jj = 0;
-	  for (int i = 0; i < rhs.cols(); i++)
-	    for (int j = rhs.cidx(i); j < rhs.cidx(i+1); j++)
+	  octave_idx_type ii = 0;
+	  octave_idx_type jj = 0;
+	  for (octave_idx_type i = 0; i < rhs.cols(); i++)
+	    for (octave_idx_type j = rhs.cidx(i); j < rhs.cidx(i+1); j++)
 	      {
 		OCTAVE_QUIT;
-		for (int k = jj; k <= i * rhs.rows() + rhs.ridx(j); k++)
+		for (octave_idx_type k = jj; k <= i * rhs.rows() + rhs.ridx(j); k++)
 		  tmp.cidx(jj++) = ii;
 
 		tmp.data(ii) = rhs.data(j);
 		tmp.ridx(ii++) = 0;
 	      }
 
-	  for (int i = jj; i < rhs_len + 1; i++)
+	  for (octave_idx_type i = jj; i < rhs_len + 1; i++)
 	    tmp.cidx(i) = ii;
 
 	  lhs = tmp;
 	}
       else
 	(*current_liboctave_error_handler)
 	  ("A(:) = X: A must be the same size as X");
     }
@@ -2227,22 +2227,22 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 template <class LT, class RT>
 int
 assign (Sparse<LT>& lhs, const Sparse<RT>& rhs)
 {
   int retval = 1;
 
   int n_idx = lhs.index_count ();
 
-  int lhs_nr = lhs.rows ();
-  int lhs_nc = lhs.cols ();
-  int lhs_nz = lhs.nnz ();
-
-  int rhs_nr = rhs.rows ();
-  int rhs_nc = rhs.cols ();
+  octave_idx_type lhs_nr = lhs.rows ();
+  octave_idx_type lhs_nc = lhs.cols ();
+  octave_idx_type lhs_nz = lhs.nnz ();
+
+  octave_idx_type rhs_nr = rhs.rows ();
+  octave_idx_type rhs_nc = rhs.cols ();
 
   idx_vector *tmp = lhs.get_idx ();
 
   idx_vector idx_i;
   idx_vector idx_j;
 
   if (n_idx > 2)
     {
@@ -2254,20 +2254,20 @@ assign (Sparse<LT>& lhs, const Sparse<RT
   if (n_idx > 1)
     idx_j = tmp[1];
 
   if (n_idx > 0)
     idx_i = tmp[0];
 
   if (n_idx == 2)
     {
-      int n = idx_i.freeze (lhs_nr, "row", true, liboctave_wrore_flag);
+      octave_idx_type n = idx_i.freeze (lhs_nr, "row", true, liboctave_wrore_flag);
       idx_i.sort (true);
 
-      int m = idx_j.freeze (lhs_nc, "column", true, liboctave_wrore_flag);
+      octave_idx_type m = idx_j.freeze (lhs_nc, "column", true, liboctave_wrore_flag);
       idx_j.sort (true);
 
 
       int idx_i_is_colon = idx_i.is_colon ();
       int idx_j_is_colon = idx_j.is_colon ();
 
       if (idx_i_is_colon)
 	n = lhs_nr > 0 ? lhs_nr : rhs_nr;
@@ -2285,42 +2285,42 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 	    {
 	      if (rhs_nr == 1 && rhs_nc == 1 && n >= 0 && m >= 0)
 		{
 		  // No need to do anything if either of the indices
 		  // are empty.
 
 		  if (n > 0 && m > 0)
 		    {
-		      int max_row_idx = idx_i_is_colon ? rhs_nr : 
+		      octave_idx_type max_row_idx = idx_i_is_colon ? rhs_nr : 
 			idx_i.max () + 1;
-		      int max_col_idx = idx_j_is_colon ? rhs_nc : 
+		      octave_idx_type max_col_idx = idx_j_is_colon ? rhs_nc : 
 			idx_j.max () + 1;
-		      int new_nr = max_row_idx > lhs_nr ? max_row_idx : 
+		      octave_idx_type new_nr = max_row_idx > lhs_nr ? max_row_idx : 
 			lhs_nr;
-		      int new_nc = max_col_idx > lhs_nc ? max_col_idx : 
+		      octave_idx_type new_nc = max_col_idx > lhs_nc ? max_col_idx : 
 			lhs_nc;
 		      RT scalar = rhs.elem (0, 0);
 
 		      // Count the number of non-zero terms
-		      int new_nnz = lhs.nnz ();
-		      for (int j = 0; j < m; j++)
+		      octave_idx_type new_nnz = lhs.nnz ();
+		      for (octave_idx_type j = 0; j < m; j++)
 			{
-			  int jj = idx_j.elem (j);
+			  octave_idx_type jj = idx_j.elem (j);
 			  if (jj < lhs_nc)
 			    {
-			      for (int i = 0; i < n; i++)
+			      for (octave_idx_type i = 0; i < n; i++)
 				{
 				  OCTAVE_QUIT;
 
-				  int ii = idx_i.elem (i);
+				  octave_idx_type ii = idx_i.elem (i);
 			      
 				  if (ii < lhs_nr)
 				    {
-				      for (int k = lhs.cidx(jj); 
+				      for (octave_idx_type k = lhs.cidx(jj); 
 					   k < lhs.cidx(jj+1); k++)
 					{
 					  if (lhs.ridx(k) == ii)
 					    new_nnz--;
 					  if (lhs.ridx(k) >= ii)
 					    break;
 					}
 				    }
@@ -2328,43 +2328,43 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			    }
 			}
 
 		      if (scalar != RT())
 			new_nnz += m * n;
 
 		      Sparse<LT> stmp (new_nr, new_nc, new_nnz);
 
-		      int jji = 0;
-		      int jj = idx_j.elem (jji);
-		      int kk = 0;
+		      octave_idx_type jji = 0;
+		      octave_idx_type jj = idx_j.elem (jji);
+		      octave_idx_type kk = 0;
 		      stmp.cidx(0) = 0;
-		      for (int j = 0; j < new_nc; j++)
+		      for (octave_idx_type j = 0; j < new_nc; j++)
 			{
 			  if (jji < m && jj == j)
 			    {
-			      int iii = 0;
-			      int ii = idx_i.elem (iii);
-			      for (int i = 0; i < new_nr; i++)
+			      octave_idx_type iii = 0;
+			      octave_idx_type ii = idx_i.elem (iii);
+			      for (octave_idx_type i = 0; i < new_nr; i++)
 				{
 				  OCTAVE_QUIT;
 
 				  if (iii < n && ii == i)
 				    {
 				      if (scalar != RT ())
 					{
 					  stmp.data(kk) = scalar;
 					  stmp.ridx(kk++) = i;
 					}
 				      if (++iii < n)
 					ii = idx_i.elem(iii);
 				    }
 				  else if (j < lhs.cols()) 
 				    {
-				      for (int k = lhs.cidx(j); 
+				      for (octave_idx_type k = lhs.cidx(j); 
 					   k < lhs.cidx(j+1); k++)
 					{
 					  if (lhs.ridx(k) == i)
 					    {
 					      stmp.data(kk) = lhs.data(k);
 					      stmp.ridx(kk++) = i;
 					    }
 					  if (lhs.ridx(k) >= i)
@@ -2372,58 +2372,58 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 					}
 				    }
 				}
 			      if (++jji < m)
 				jj = idx_j.elem(jji);
 			    }
 			  else if (j < lhs.cols()) 
 			    {
-			      for (int i = lhs.cidx(j); 
+			      for (octave_idx_type i = lhs.cidx(j); 
 				   i < lhs.cidx(j+1); i++)
 				{
 				  stmp.data(kk) = lhs.data(i);
 				  stmp.ridx(kk++) = lhs.ridx(i);
 				}
 			    }
 			  stmp.cidx(j+1) = kk;
 			}
 		      
 		      lhs = stmp;
 		    }
 		}
 	      else if (n == rhs_nr && m == rhs_nc)
 		{
 		  if (n > 0 && m > 0)
 		    {
-		      int max_row_idx = idx_i_is_colon ? rhs_nr : 
+		      octave_idx_type max_row_idx = idx_i_is_colon ? rhs_nr : 
 			idx_i.max () + 1;
-		      int max_col_idx = idx_j_is_colon ? rhs_nc : 
+		      octave_idx_type max_col_idx = idx_j_is_colon ? rhs_nc : 
 			idx_j.max () + 1;
-		      int new_nr = max_row_idx > lhs_nr ? max_row_idx : 
+		      octave_idx_type new_nr = max_row_idx > lhs_nr ? max_row_idx : 
 			lhs_nr;
-		      int new_nc = max_col_idx > lhs_nc ? max_col_idx : 
+		      octave_idx_type new_nc = max_col_idx > lhs_nc ? max_col_idx : 
 			lhs_nc;
 
 		      // Count the number of non-zero terms
-		      int new_nnz = lhs.nnz ();
-		      for (int j = 0; j < m; j++)
+		      octave_idx_type new_nnz = lhs.nnz ();
+		      for (octave_idx_type j = 0; j < m; j++)
 			{
-			  int jj = idx_j.elem (j);
-			  for (int i = 0; i < n; i++)
+			  octave_idx_type jj = idx_j.elem (j);
+			  for (octave_idx_type i = 0; i < n; i++)
 			    {
 			      OCTAVE_QUIT;
 
 			      if (jj < lhs_nc)
 				{
-				  int ii = idx_i.elem (i);
+				  octave_idx_type ii = idx_i.elem (i);
 			      
 				  if (ii < lhs_nr)
 				    {
-				      for (int k = lhs.cidx(jj); 
+				      for (octave_idx_type k = lhs.cidx(jj); 
 					   k < lhs.cidx(jj+1); k++)
 					{
 					  if (lhs.ridx(k) == ii)
 					    new_nnz--;
 					  if (lhs.ridx(k) >= ii)
 					    break;
 					}
 				    }
@@ -2431,44 +2431,44 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			      
 			      if (rhs.elem(i,j) != RT ())
 				new_nnz++;
 			    }
 			}
 
 		      Sparse<LT> stmp (new_nr, new_nc, new_nnz);
 
-		      int jji = 0;
-		      int jj = idx_j.elem (jji);
-		      int kk = 0;
+		      octave_idx_type jji = 0;
+		      octave_idx_type jj = idx_j.elem (jji);
+		      octave_idx_type kk = 0;
 		      stmp.cidx(0) = 0;
-		      for (int j = 0; j < new_nc; j++)
+		      for (octave_idx_type j = 0; j < new_nc; j++)
 			{
 			  if (jji < m && jj == j)
 			    {
-			      int iii = 0;
-			      int ii = idx_i.elem (iii);
-			      for (int i = 0; i < new_nr; i++)
+			      octave_idx_type iii = 0;
+			      octave_idx_type ii = idx_i.elem (iii);
+			      for (octave_idx_type i = 0; i < new_nr; i++)
 				{
 				  OCTAVE_QUIT;
 
 				  if (iii < n && ii == i)
 				    {
 				      RT rtmp = rhs.elem (iii, jji);
 				      if (rtmp != RT ())
 					{
 					  stmp.data(kk) = rtmp;
 					  stmp.ridx(kk++) = i;
 					}
 				      if (++iii < n)
 					ii = idx_i.elem(iii);
 				    }
 				  else if (j < lhs.cols()) 
 				    {
-				      for (int k = lhs.cidx(j); 
+				      for (octave_idx_type k = lhs.cidx(j); 
 					   k < lhs.cidx(j+1); k++)
 					{
 					  if (lhs.ridx(k) == i)
 					    {
 					      stmp.data(kk) = lhs.data(k);
 					      stmp.ridx(kk++) = i;
 					    }
 					  if (lhs.ridx(k) >= i)
@@ -2476,17 +2476,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 					}
 				    }
 				}
 			      if (++jji < m)
 				jj = idx_j.elem(jji);
 			    }
 			  else if (j < lhs.cols()) 
 			    {
-			      for (int i = lhs.cidx(j); 
+			      for (octave_idx_type i = lhs.cidx(j); 
 				   i < lhs.cidx(j+1); i++)
 				{
 				  stmp.data(kk) = lhs.data(i);
 				  stmp.ridx(kk++) = lhs.ridx(i);
 				}
 			    }
 			  stmp.cidx(j+1) = kk;
 			}
@@ -2521,19 +2521,19 @@ assign (Sparse<LT>& lhs, const Sparse<RT
       // idx_vector::freeze() printed an error message for us.
     }
   else if (n_idx == 1)
     {
       int lhs_is_empty = lhs_nr == 0 || lhs_nc == 0;
 
       if (lhs_is_empty || (lhs_nr == 1 && lhs_nc == 1))
 	{
-	  int lhs_len = lhs.length ();
-
-	  int n = idx_i.freeze (lhs_len, 0, true, liboctave_wrore_flag);
+	  octave_idx_type lhs_len = lhs.length ();
+
+	  octave_idx_type n = idx_i.freeze (lhs_len, 0, true, liboctave_wrore_flag);
 	  idx_i.sort (true);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		{
 		  if (n != 0 && (lhs_nr != 0 || lhs_nc != 0))
 		    lhs.maybe_delete_elements (idx_i);
@@ -2546,18 +2546,18 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			  && idx_i.is_colon ()
 			  && ! (rhs_nr == 1 || rhs_nc == 1))
 			{
 			  (*current_liboctave_warning_handler)
 			    ("A(:) = X: X is not a vector or scalar");
 			}
 		      else
 			{
-			  int idx_nr = idx_i.orig_rows ();
-			  int idx_nc = idx_i.orig_columns ();
+			  octave_idx_type idx_nr = idx_i.orig_rows ();
+			  octave_idx_type idx_nc = idx_i.orig_columns ();
 
 			  if (! (rhs_nr == idx_nr && rhs_nc == idx_nc))
 			    (*current_liboctave_warning_handler)
 			      ("A(I) = X: X does not have same shape as I");
 			}
 		    }
 
 		  if (! assign1 ((Sparse<LT>&) lhs, (Sparse<RT>&) rhs))
@@ -2599,19 +2599,19 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 	  if (liboctave_wfi_flag
 	      && ! (idx_i.is_colon ()
 		    || (idx_i.one_zero_only ()
 			&& idx_i.orig_rows () == lhs_nr
 			&& idx_i.orig_columns () == lhs_nc)))
 	    (*current_liboctave_warning_handler)
 	      ("single index used for matrix");
 
-	  int lhs_len = lhs.length ();
-
-	  int len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
+	  octave_idx_type lhs_len = lhs.length ();
+
+	  octave_idx_type len = idx_i.freeze (lhs_nr * lhs_nc, "matrix");
 	  idx_i.sort (true);
 
 	  if (idx_i)
 	    {
 	      // Take a constant copy of lhs. This means that elem won't 
 	      // create missing elements.
 	      const Sparse<LT> c_lhs (lhs);
 
@@ -2621,49 +2621,49 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 		{
 		  if (! ((rhs_nr == 1 && rhs_nc == 1)
 			 || (rhs_nr == 0 || rhs_nc == 0)))
 		    (*current_liboctave_error_handler)
 		      ("A([]) = X: X must be an empty matrix or scalar");
 		}
 	      else if (len == rhs_nr * rhs_nc)
 		{
-		  int new_nnz = lhs_nz;
+		  octave_idx_type new_nnz = lhs_nz;
 
 		  // First count the number of non-zero elements
-		  for (int i = 0; i < len; i++)
+		  for (octave_idx_type i = 0; i < len; i++)
 		    {
 		      OCTAVE_QUIT;
 		      
-		      int ii = idx_i.elem (i);
+		      octave_idx_type ii = idx_i.elem (i);
 		      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 			new_nnz--;
 		      if (rhs.elem(i) != RT ())
 			new_nnz++;
 		    }
 
 		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nnz);
 
-		  int i = 0;
-		  int ii = 0;
-		  int ic = 0;
+		  octave_idx_type i = 0;
+		  octave_idx_type ii = 0;
+		  octave_idx_type ic = 0;
 		  if (i < lhs_nz)
 		    {
 		      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
 			ic++;
 		      ii = ic * lhs_nr + c_lhs.ridx(i);
 		    }
 
-		  int j = 0;
-		  int jj = idx_i.elem (j);
-		  int jr = jj % lhs_nr;
-		  int jc = (jj - jr) / lhs_nr;
-
-		  int kk = 0;
-		  int kc = 0;
+		  octave_idx_type j = 0;
+		  octave_idx_type jj = idx_i.elem (j);
+		  octave_idx_type jr = jj % lhs_nr;
+		  octave_idx_type jc = (jj - jr) / lhs_nr;
+
+		  octave_idx_type kk = 0;
+		  octave_idx_type kc = 0;
 
 		  while (j < len || i < lhs_nz)
 		    {
 		      if (j == len || (i < lhs_nz && ii < jj))
 			{
 			  while (kc <= ic)
 			    stmp.xcidx (kc++) = kk;
 			  stmp.xdata (kk) = c_lhs.data (i);
@@ -2697,57 +2697,57 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			    {
 			      jj = idx_i.elem (j);
 			      jr = jj % lhs_nr;
 			      jc = (jj - jr) / lhs_nr;
 			    }
 			}
 		    }
 
-		  for (int iidx = kc; iidx < lhs_nc+1; iidx++)
+		  for (octave_idx_type iidx = kc; iidx < lhs_nc+1; iidx++)
 		    stmp.xcidx(iidx) = kk;
 		  
 
 		  lhs = stmp;
 		}
 	      else if (rhs_nr == 1 && rhs_nc == 1)
 		{
 		  RT scalar = rhs.elem (0, 0);
-		  int new_nnz = lhs_nz;
+		  octave_idx_type new_nnz = lhs_nz;
 
 		  // First count the number of non-zero elements
 		  if (scalar != RT ())
 		    new_nnz += len;
-		  for (int i = 0; i < len; i++)
+		  for (octave_idx_type i = 0; i < len; i++)
 		    {
 		      OCTAVE_QUIT;
-		      int ii = idx_i.elem (i);
+		      octave_idx_type ii = idx_i.elem (i);
 		      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
 			new_nnz--;
 		    }
 
 		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nnz);
 
-		  int i = 0;
-		  int ii = 0;
-		  int ic = 0;
+		  octave_idx_type i = 0;
+		  octave_idx_type ii = 0;
+		  octave_idx_type ic = 0;
 		  if (i < lhs_nz)
 		    {
 		      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
 			ic++;
 		      ii = ic * lhs_nr + c_lhs.ridx(i);
 		    }
 
-		  int j = 0;
-		  int jj = idx_i.elem (j);
-		  int jr = jj % lhs_nr;
-		  int jc = (jj - jr) / lhs_nr;
-
-		  int kk = 0;
-		  int kc = 0;
+		  octave_idx_type j = 0;
+		  octave_idx_type jj = idx_i.elem (j);
+		  octave_idx_type jr = jj % lhs_nr;
+		  octave_idx_type jc = (jj - jr) / lhs_nr;
+
+		  octave_idx_type kk = 0;
+		  octave_idx_type kc = 0;
 
 		  while (j < len || i < lhs_nz)
 		    {
 		      if (j == len || (i < lhs_nz && ii < jj))
 			{
 			  while (kc <= ic)
 			    stmp.xcidx (kc++) = kk;
 			  stmp.xdata (kk) = c_lhs.data (i);
@@ -2780,17 +2780,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			    {
 			      jj = idx_i.elem (j);
 			      jr = jj % lhs_nr;
 			      jc = (jj - jr) / lhs_nr;
 			    }
 			}
 		    }
 
-		  for (int iidx = kc; iidx < lhs_nc+1; iidx++)
+		  for (octave_idx_type iidx = kc; iidx < lhs_nc+1; iidx++)
 		    stmp.xcidx(iidx) = kk;
 		  
 		  lhs = stmp;
 		}
 	      else
 		{
 		  (*current_liboctave_error_handler)
       ("A(I) = X: X must be a scalar or a matrix with the same size as I");
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -47,86 +47,86 @@ protected:
   // The real representation of all Sparse arrays.
   //--------------------------------------------------------------------
 
   class SparseRep
   {
   public:
 
     T *d;
-    int *r;
-    int *c;
-    int nnz;
-    int nrows;
-    int ncols;
+    octave_idx_type *r;
+    octave_idx_type *c;
+    octave_idx_type nnz;
+    octave_idx_type nrows;
+    octave_idx_type ncols;
     int count;
 
-    SparseRep (void) : d (0), r (0), c (new int [1]), nnz (0), nrows (0),
+    SparseRep (void) : d (0), r (0), c (new octave_idx_type [1]), nnz (0), nrows (0),
 		       ncols (0), count (1) { c[0] = 0; }
 
-    SparseRep (int n) : d (0), r (0), c (new int [n+1]), nnz (0), nrows (n),
+    SparseRep (octave_idx_type n) : d (0), r (0), c (new octave_idx_type [n+1]), nnz (0), nrows (n),
       ncols (n), count (1)
       { 
-	for (int i = 0; i < n + 1; i++)
+	for (octave_idx_type i = 0; i < n + 1; i++)
 	  c[i] = 0;
       }
 
-    SparseRep (int nr, int nc) : d (0), r (0), c (new int [nc+1]), nnz (0), 
+    SparseRep (octave_idx_type nr, octave_idx_type nc) : d (0), r (0), c (new octave_idx_type [nc+1]), nnz (0), 
       nrows (nr), ncols (nc), count (1)
       { 
-	for (int i = 0; i < nc + 1; i++)
+	for (octave_idx_type i = 0; i < nc + 1; i++)
 	  c[i] = 0;
       }
 
-    SparseRep (int nr, int nc, int nz) : d (new T [nz]), 
-      r (new int [nz]), c (new int [nc+1]), nnz (nz), nrows (nr), 
+    SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz) : d (new T [nz]), 
+      r (new octave_idx_type [nz]), c (new octave_idx_type [nc+1]), nnz (nz), nrows (nr), 
       ncols (nc), count (1)
       { 
-	for (int i = 0; i < nc + 1; i++)
+	for (octave_idx_type i = 0; i < nc + 1; i++)
 	  c[i] = 0;
       }
 
     SparseRep (const SparseRep& a)
-      : d (new T [a.nnz]), r (new int [a.nnz]), c (new int [a.ncols + 1]), 
+      : d (new T [a.nnz]), r (new octave_idx_type [a.nnz]), c (new octave_idx_type [a.ncols + 1]), 
       nnz (a.nnz), nrows (a.nrows), ncols (a.ncols), count (1)
       {
-	for (int i = 0; i < nnz; i++)
+	for (octave_idx_type i = 0; i < nnz; i++)
 	  {
 	    d[i] = a.d[i];
 	    r[i] = a.r[i];
 	  }
-	for (int i = 0; i < ncols + 1; i++)
+	for (octave_idx_type i = 0; i < ncols + 1; i++)
 	  c[i] = a.c[i];
       }
  
     ~SparseRep (void) { delete [] d; delete [] r; delete [] c; }
 
-    int length (void) const { return nnz; }
+    octave_idx_type length (void) const { return nnz; }
 
-    int nonzero (void) const { return c [ncols]; }
+    octave_idx_type nonzero (void) const { return c [ncols]; }
 
-    T& elem (int _r, int _c);
+    T& elem (octave_idx_type _r, octave_idx_type _c);
 
-    T celem (int _r, int _c) const;
+    T celem (octave_idx_type _r, octave_idx_type _c) const;
 
-    T& data (int i) { return d[i]; }
+    T& data (octave_idx_type i) { return d[i]; }
 
-    T cdata (int i) const { return d[i]; }
+    T cdata (octave_idx_type i) const { return d[i]; }
 
-    int& ridx (int i) { return r[i]; }
+    octave_idx_type& ridx (octave_idx_type i) { return r[i]; }
 
-    int cridx (int i) const { return r[i]; }
+    octave_idx_type cridx (octave_idx_type i) const { return r[i]; }
 
-    int& cidx (int i) { return c[i]; }
+    octave_idx_type& cidx (octave_idx_type i) { return c[i]; }
 
-    int ccidx (int i) const { return c[i]; }
+    octave_idx_type ccidx (octave_idx_type i) const { return c[i]; }
 
     void maybe_compress (bool remove_zeros);
 
-    void change_length (int nz);
+    void change_length (octave_idx_type nz);
 
   private:
 
     // No assignment!
 
     SparseRep& operator = (const SparseRep& a);
   };
 
@@ -147,17 +147,17 @@ public:
   // should not access these data members directly!
 
   typename Sparse<T>::SparseRep *rep;
 
   dim_vector dimensions;
 
 protected:
   idx_vector *idx;
-  int idx_count;
+  octave_idx_type idx_count;
 
 private:
 
   typename Sparse<T>::SparseRep *nil_rep (void) const
     {
       static typename Sparse<T>::SparseRep *nr
 	= new typename Sparse<T>::SparseRep ();
 
@@ -167,31 +167,31 @@ private:
     }
 
 public:
 
   Sparse (void)
     : rep (nil_rep ()), dimensions (dim_vector(0,0)),
       idx (0), idx_count (0) { }
 
-  explicit Sparse (int n)
+  explicit Sparse (octave_idx_type n)
     : rep (new typename Sparse<T>::SparseRep (n)), 
       dimensions (dim_vector (n, n)), idx (0), idx_count (0) { }
 
-  explicit Sparse (int nr, int nc)
+  explicit Sparse (octave_idx_type nr, octave_idx_type nc)
     : rep (new typename Sparse<T>::SparseRep (nr, nc)), 
       dimensions (dim_vector (nr, nc)), idx (0), idx_count (0) { }
 
-  explicit Sparse (int nr, int nc, T val);
+  explicit Sparse (octave_idx_type nr, octave_idx_type nc, T val);
 
-  Sparse (const dim_vector& dv, int nz)
+  Sparse (const dim_vector& dv, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (dv(0), dv(1), nz)),
     dimensions (dv), idx (0), idx_count (0) { }
 
-  Sparse (int nr, int nc, int nz)
+  Sparse (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (nr, nc, nz)),
       dimensions (dim_vector (nr, nc)), idx (0), idx_count (0) { }
 
   // Type conversion case.
   template <class U> Sparse (const Sparse<U>& a);
 
   // No type conversion case.
   Sparse (const Sparse<T>& a)
@@ -201,21 +201,21 @@ public:
     }
 
 public:
 
   Sparse (const dim_vector& dv);
 
   Sparse (const Sparse<T>& a, const dim_vector& dv);
 
-  Sparse (const Array<T>& a, const Array<int>& r, const Array<int>& c,
-	  int nr, int nc, bool sum_terms);
+  Sparse (const Array<T>& a, const Array<octave_idx_type>& r, const Array<octave_idx_type>& c,
+	  octave_idx_type nr, octave_idx_type nc, bool sum_terms);
 
   Sparse (const Array<T>& a, const Array<double>& r, const Array<double>& c,
-	  int nr, int nc, bool sum_terms);
+	  octave_idx_type nr, octave_idx_type nc, bool sum_terms);
 
   // Sparsify a normal matrix
   Sparse (const Array2<T>& a);
   Sparse (const Array<T>& a);
 
   virtual ~Sparse (void);
 
   Sparse<T>& operator = (const Sparse<T>& a)
@@ -234,260 +234,260 @@ public:
       idx_count = 0;
       idx = 0;
 
       return *this;
     }
 
   // Note that capacity and nnz are the amount of storage for non-zero
   // elements, while nonzero is the actual number of non-zero terms
-  int capacity (void) const { return rep->length (); }
-  int nnz (void) const { return capacity (); }
-  int nonzero (void) const { return rep->nonzero (); }
+  octave_idx_type capacity (void) const { return rep->length (); }
+  octave_idx_type nnz (void) const { return capacity (); }
+  octave_idx_type nonzero (void) const { return rep->nonzero (); }
 
   // Paranoid number of elements test for case of dims = (-1,-1)
-  int numel (void) const 
+  octave_idx_type numel (void) const 
     { 
       if (dim1() < 0 || dim2() < 0)
         return 0;
       else
         return dimensions.numel (); 
     }
 
-  int nelem (void) const { return capacity (); }
-  int length (void) const { return numel (); }
+  octave_idx_type nelem (void) const { return capacity (); }
+  octave_idx_type length (void) const { return numel (); }
 
-  int dim1 (void) const { return dimensions(0); }
-  int dim2 (void) const { return dimensions(1); }
+  octave_idx_type dim1 (void) const { return dimensions(0); }
+  octave_idx_type dim2 (void) const { return dimensions(1); }
 
-  int rows (void) const { return dim1 (); }
-  int cols (void) const { return dim2 (); }
-  int columns (void) const { return dim2 (); }
+  octave_idx_type rows (void) const { return dim1 (); }
+  octave_idx_type cols (void) const { return dim2 (); }
+  octave_idx_type columns (void) const { return dim2 (); }
 
-  int get_row_index (int k) { return ridx (k); }
-  int get_col_index (int k)
+  octave_idx_type get_row_index (octave_idx_type k) { return ridx (k); }
+  octave_idx_type get_col_index (octave_idx_type k)
     {
-      int ret = 0;
+      octave_idx_type ret = 0;
       while (cidx(ret+1) < k)
         ret++;
       return ret;
     }
-  size_t byte_size (void) const { return (cols () + 1) * sizeof (int) +
-      capacity () * (sizeof (T) + sizeof (int)); }
+  size_t byte_size (void) const { return (cols () + 1) * sizeof (octave_idx_type) +
+      capacity () * (sizeof (T) + sizeof (octave_idx_type)); }
 
   dim_vector dims (void) const { return dimensions; }
 
   Sparse<T> squeeze (void) const { return *this; }
   
-  int compute_index (const Array<int>& ra_idx) const;
+  octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
-  T range_error (const char *fcn, int n) const;
-  T& range_error (const char *fcn, int n);
+  T range_error (const char *fcn, octave_idx_type n) const;
+  T& range_error (const char *fcn, octave_idx_type n);
 
-  T range_error (const char *fcn, int i, int j) const;
-  T& range_error (const char *fcn, int i, int j);
+  T range_error (const char *fcn, octave_idx_type i, octave_idx_type j) const;
+  T& range_error (const char *fcn, octave_idx_type i, octave_idx_type j);
 
-  T range_error (const char *fcn, const Array<int>& ra_idx) const;
-  T& range_error (const char *fcn, const Array<int>& ra_idx);
+  T range_error (const char *fcn, const Array<octave_idx_type>& ra_idx) const;
+  T& range_error (const char *fcn, const Array<octave_idx_type>& ra_idx);
 
   // No checking, even for multiple references, ever.
 
-  T& xelem (int n) 
+  T& xelem (octave_idx_type n) 
     { 
-      int i = n % rows (), j = n / rows(); 
+      octave_idx_type i = n % rows (), j = n / rows(); 
       return xelem (i, j); 
     }
 
-  T xelem (int n) const 
+  T xelem (octave_idx_type n) const 
     { 
-      int i = n % rows (), j = n / rows(); 
+      octave_idx_type i = n % rows (), j = n / rows(); 
       return xelem (i, j); 
     }
   
-  T& xelem (int i, int j) { return rep->elem (i, j); }
-  T xelem (int i, int j) const { return rep->celem (i, j); }
+  T& xelem (octave_idx_type i, octave_idx_type j) { return rep->elem (i, j); }
+  T xelem (octave_idx_type i, octave_idx_type j) const { return rep->celem (i, j); }
 
-  T& xelem (const Array<int>& ra_idx)
+  T& xelem (const Array<octave_idx_type>& ra_idx)
     { return xelem (compute_index (ra_idx)); }
 
-  T xelem (const Array<int>& ra_idx) const
+  T xelem (const Array<octave_idx_type>& ra_idx) const
     { return xelem (compute_index (ra_idx)); }
 
   // XXX FIXME XXX -- would be nice to fix this so that we don't
   // unnecessarily force a copy, but that is not so easy, and I see no
   // clean way to do it.
 
-  T& checkelem (int n)
+  T& checkelem (octave_idx_type n)
     {
       if (n < 0 || n >= numel ())
 	return range_error ("T& Sparse<T>::checkelem", n);
       else
 	{
 	  make_unique ();
 	  return xelem (n);
 	}
     }
 
-  T& checkelem (int i, int j)
+  T& checkelem (octave_idx_type i, octave_idx_type j)
     {
       if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
 	return range_error ("T& Sparse<T>::checkelem", i, j);
       else
 	{
 	  make_unique ();
 	  return xelem (i, j);
 	}
     }
 
-  T& checkelem (const Array<int>& ra_idx)
+  T& checkelem (const Array<octave_idx_type>& ra_idx)
     {
-      int i = compute_index (ra_idx);
+      octave_idx_type i = compute_index (ra_idx);
 
       if (i < 0)
 	return range_error ("T& Sparse<T>::checkelem", ra_idx);
       else
 	return elem (i);
     }
 
-  T& elem (int n)
+  T& elem (octave_idx_type n)
     {
       make_unique ();
       return xelem (n);
     }
 
-  T& elem (int i, int j) 
+  T& elem (octave_idx_type i, octave_idx_type j) 
     { 
       make_unique ();
       return xelem (i, j); 
     }
 
-  T& elem (const Array<int>& ra_idx)
+  T& elem (const Array<octave_idx_type>& ra_idx)
     { return Sparse<T>::elem (compute_index (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
-  T& operator () (int n) { return checkelem (n); }
-  T& operator () (int i, int j) { return checkelem (i, j); }
-  T& operator () (const Array<int>& ra_idx) { return checkelem (ra_idx); }
+  T& operator () (octave_idx_type n) { return checkelem (n); }
+  T& operator () (octave_idx_type i, octave_idx_type j) { return checkelem (i, j); }
+  T& operator () (const Array<octave_idx_type>& ra_idx) { return checkelem (ra_idx); }
 #else
-  T& operator () (int n) { return elem (n); }
-  T& operator () (int i, int j) { return elem (i, j); }
-  T& operator () (const Array<int>& ra_idx) { return elem (ra_idx); }
+  T& operator () (octave_idx_type n) { return elem (n); }
+  T& operator () (octave_idx_type i, octave_idx_type j) { return elem (i, j); }
+  T& operator () (const Array<octave_idx_type>& ra_idx) { return elem (ra_idx); }
 #endif
 
-  T checkelem (int n) const
+  T checkelem (octave_idx_type n) const
     {
       if (n < 0 || n >= numel ())
 	return range_error ("T Sparse<T>::checkelem", n);
       else
 	return xelem (n);
     }
 
-  T checkelem (int i, int j) const
+  T checkelem (octave_idx_type i, octave_idx_type j) const
     {
       if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
 	return range_error ("T Sparse<T>::checkelem", i, j);
       else
 	return xelem (i, j);
     }
 
-  T checkelem (const Array<int>& ra_idx) const
+  T checkelem (const Array<octave_idx_type>& ra_idx) const
     {
-      int i = compute_index (ra_idx);
+      octave_idx_type i = compute_index (ra_idx);
 
       if (i < 0)
 	return range_error ("T Sparse<T>::checkelem", ra_idx);
       else
 	return Sparse<T>::elem (i);
     }
 
-  T elem (int n) const { return xelem (n); }
+  T elem (octave_idx_type n) const { return xelem (n); }
 
-  T elem (int i, int j) const { return xelem (i, j); }
+  T elem (octave_idx_type i, octave_idx_type j) const { return xelem (i, j); }
 
-  T elem (const Array<int>& ra_idx) const
+  T elem (const Array<octave_idx_type>& ra_idx) const
     { return Sparse<T>::elem (compute_index (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
-  T operator () (int n) const { return checkelem (n); }
-  T operator () (int i, int j) const { return checkelem (i, j); }
-  T operator () (const Array<int>& ra_idx) const { return checkelem (ra_idx); }
+  T operator () (octave_idx_type n) const { return checkelem (n); }
+  T operator () (octave_idx_type i, octave_idx_type j) const { return checkelem (i, j); }
+  T operator () (const Array<octave_idx_type>& ra_idx) const { return checkelem (ra_idx); }
 #else
-  T operator () (int n) const { return elem (n); }
-  T operator () (int i, int j) const { return elem (i, j); }
-  T operator () (const Array<int>& ra_idx) const { return elem (ra_idx); }
+  T operator () (octave_idx_type n) const { return elem (n); }
+  T operator () (octave_idx_type i, octave_idx_type j) const { return elem (i, j); }
+  T operator () (const Array<octave_idx_type>& ra_idx) const { return elem (ra_idx); }
 #endif
 
   Sparse<T> maybe_compress (bool remove_zeros = false) 
   { rep->maybe_compress (remove_zeros); return (*this); }
 
   Sparse<T> reshape (const dim_vector& new_dims) const;
 
   // !!! WARNING !!! -- the following resize_no_fill functions are 
   // public because template friends don't work properly with versions
   // of gcc earlier than 3.3.  You should use these functions only in 
   // classes that are derived from Sparse<T>.
 
   // protected:
 
-  void resize_no_fill (int r, int c);
+  void resize_no_fill (octave_idx_type r, octave_idx_type c);
 
   void resize_no_fill (const dim_vector& dv);
 
 public:
-  Sparse<T> permute (const Array<int>& vec, bool inv = false) const;
+  Sparse<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
 
-  Sparse<T> ipermute (const Array<int>& vec) const
+  Sparse<T> ipermute (const Array<octave_idx_type>& vec) const
     { return permute (vec, true); }
 
-  void resize (int r, int c) { resize_no_fill (r, c); }
+  void resize (octave_idx_type r, octave_idx_type c) { resize_no_fill (r, c); }
 
   void resize (const dim_vector& dv) { resize_no_fill (dv); }
 
-  void change_capacity (int nz) { rep->change_length (nz); }
+  void change_capacity (octave_idx_type nz) { rep->change_length (nz); }
 
-  Sparse<T>& insert (const Sparse<T>& a, int r, int c);
-  Sparse<T>& insert (const Sparse<T>& a, const Array<int>& idx);
+  Sparse<T>& insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c);
+  Sparse<T>& insert (const Sparse<T>& a, const Array<octave_idx_type>& idx);
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
   bool is_empty (void) const { return (rows () < 1 && cols () < 1); }
 
   Sparse<T> transpose (void) const;
 
   T* data (void) { make_unique (); return rep->d; }
-  T& data (int i) { make_unique (); return rep->data (i); }
+  T& data (octave_idx_type i) { make_unique (); return rep->data (i); }
   T* xdata (void) { return rep->d; }
-  T& xdata (int i) { return rep->data (i); }
+  T& xdata (octave_idx_type i) { return rep->data (i); }
 
-  T data (int i) const { return rep->data (i); }
+  T data (octave_idx_type i) const { return rep->data (i); }
   T* data (void) const { return rep->d; }
 
-  int* ridx (void) { make_unique (); return rep->r; }
-  int& ridx (int i) { make_unique (); return rep->ridx (i); }
-  int* xridx (void) { return rep->r; }
-  int& xridx (int i) { return rep->ridx (i); }
+  octave_idx_type* ridx (void) { make_unique (); return rep->r; }
+  octave_idx_type& ridx (octave_idx_type i) { make_unique (); return rep->ridx (i); }
+  octave_idx_type* xridx (void) { return rep->r; }
+  octave_idx_type& xridx (octave_idx_type i) { return rep->ridx (i); }
 
-  int ridx (int i) const { return rep->cridx (i); }
-  int* ridx (void) const { return rep->r; }
+  octave_idx_type ridx (octave_idx_type i) const { return rep->cridx (i); }
+  octave_idx_type* ridx (void) const { return rep->r; }
 
-  int* cidx (void) { make_unique (); return rep->c; }
-  int& cidx (int i) { make_unique (); return rep->cidx (i); }
-  int* xcidx (void) { return rep->c; }
-  int& xcidx (int i) { return rep->cidx (i); }
+  octave_idx_type* cidx (void) { make_unique (); return rep->c; }
+  octave_idx_type& cidx (octave_idx_type i) { make_unique (); return rep->cidx (i); }
+  octave_idx_type* xcidx (void) { return rep->c; }
+  octave_idx_type& xcidx (octave_idx_type i) { return rep->cidx (i); }
 
-  int cidx (int i) const { return rep->ccidx (i); }
-  int* cidx (void) const { return rep->c; }
+  octave_idx_type cidx (octave_idx_type i) const { return rep->ccidx (i); }
+  octave_idx_type* cidx (void) const { return rep->c; }
 
-  int ndims (void) const { return dimensions.length (); }
+  octave_idx_type ndims (void) const { return dimensions.length (); }
 
   void clear_index (void);
 
   void set_index (const idx_vector& i);
 
-  int index_count (void) const { return idx_count; }
+  octave_idx_type index_count (void) const { return idx_count; }
 
   idx_vector *get_idx (void) const { return idx; }
 
   void maybe_delete_elements (idx_vector& i);
 
   void maybe_delete_elements (idx_vector& i, idx_vector& j);
 
   void maybe_delete_elements (Array<idx_vector>& ra_idx);
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -43,18 +43,18 @@ extern "C" {
 #include <umfpack/umfpack.h>
 }
 #endif
 
 SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a, 
 				  double piv_thres)
 {
 #ifdef HAVE_UMFPACK
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   umfpack_zi_defaults (control);
 
   double tmp = Voctave_sparse_controls.get_key ("spumoni");
   if (!xisnan (tmp))
@@ -80,18 +80,18 @@ SparseComplexLU::SparseComplexLU (const 
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   // Turn-off UMFPACK scaling for LU 
   Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
   umfpack_zi_report_control (control);
 
-  const int *Ap = a.cidx ();
-  const int *Ai = a.ridx ();
+  const octave_idx_type *Ap = a.cidx ();
+  const octave_idx_type *Ai = a.ridx ();
   const Complex *Ax = a.data ();
 
   umfpack_zi_report_matrix (nr, nc, Ap, Ai, X_CAST (const double *, Ax), 
 			    NULL, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
@@ -148,31 +148,34 @@ SparseComplexLU::SparseComplexLU (const 
 
 	      umfpack_zi_free_numeric (&Numeric);
 	    }
 	  else
 	    {
 	      int n_inner = (nr < nc ? nr : nc);
 
 	      if (lnz < 1)
-		Lfact = SparseComplexMatrix (n_inner, nr, 1);
+		Lfact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nr,
+					     static_cast<octave_idx_type> (1));
 	      else
-		Lfact = SparseComplexMatrix (n_inner, nr, lnz);
+		Lfact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nr,
+					     static_cast<octave_idx_type> (lnz));
 
-	      int *Ltp = Lfact.cidx ();
-	      int *Ltj = Lfact.ridx ();
+	      octave_idx_type *Ltp = Lfact.cidx ();
+	      octave_idx_type *Ltj = Lfact.ridx ();
 	      Complex *Ltx = Lfact.data ();
 
 	      if (unz < 1)
-		Ufact = SparseComplexMatrix (n_inner, nc, 1);
+		Ufact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nc,
+					     static_cast<octave_idx_type> (1));
 	      else
-		Ufact = SparseComplexMatrix (n_inner, nc, unz);
+		Ufact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nc, unz);
 
-	      int *Up = Ufact.cidx ();
-	      int *Uj = Ufact.ridx ();
+	      octave_idx_type *Up = Ufact.cidx ();
+	      octave_idx_type *Uj = Ufact.ridx ();
 	      Complex *Ux = Ufact.data ();
 	      
 	      P.resize (nr);
 	      int *p = P.fortran_vec ();
 
 	      Q.resize (nc);
 	      int *q = Q.fortran_vec ();
 
@@ -218,18 +221,18 @@ SparseComplexLU::SparseComplexLU (const 
 #endif
 }
 
 SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a, 
 				  const ColumnVector& Qinit, 
 				  double piv_thres, bool FixedQ)
 {
 #ifdef HAVE_UMFPACK
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   umfpack_zi_defaults (control);
 
   double tmp = Voctave_sparse_controls.get_key ("spumoni");
   if (!xisnan (tmp))
@@ -260,18 +263,18 @@ SparseComplexLU::SparseComplexLU (const 
 	Control (UMFPACK_FIXQ) = tmp;
     }
 
   // Turn-off UMFPACK scaling for LU 
   Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
   umfpack_zi_report_control (control);
 
-  const int *Ap = a.cidx ();
-  const int *Ai = a.ridx ();
+  const octave_idx_type *Ap = a.cidx ();
+  const octave_idx_type *Ai = a.ridx ();
   const Complex *Ax = a.data ();
 
   umfpack_zi_report_matrix (nr, nc, Ap, Ai, X_CAST (const double *, Ax), NULL,
 			    1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
@@ -337,31 +340,34 @@ SparseComplexLU::SparseComplexLU (const 
 
 	      umfpack_zi_free_numeric (&Numeric);
 	    }
 	  else
 	    {
 	      int n_inner = (nr < nc ? nr : nc);
 
 	      if (lnz < 1)
-		Lfact = SparseComplexMatrix (n_inner, nr, 1);
+		Lfact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nr,
+					     static_cast<octave_idx_type> (1));
 	      else
-		Lfact = SparseComplexMatrix (n_inner, nr, lnz);
+		Lfact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nr,
+					     static_cast<octave_idx_type> (lnz));
 
-	      int *Ltp = Lfact.cidx ();
-	      int *Ltj = Lfact.ridx ();
+	      octave_idx_type *Ltp = Lfact.cidx ();
+	      octave_idx_type *Ltj = Lfact.ridx ();
 	      Complex *Ltx = Lfact.data ();
 
 	      if (unz < 1)
-		Ufact = SparseComplexMatrix (n_inner, nc, 1);
+		Ufact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nc,
+					     static_cast<octave_idx_type> (1));
 	      else
-		Ufact = SparseComplexMatrix (n_inner, nc, unz);
+		Ufact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nc, unz);
 
-	      int *Up = Ufact.cidx ();
-	      int *Uj = Ufact.ridx ();
+	      octave_idx_type *Up = Ufact.cidx ();
+	      octave_idx_type *Uj = Ufact.ridx ();
 	      Complex *Ux = Ufact.data ();
 	      
 	      P.resize (nr);
 	      int *p = P.fortran_vec ();
 
 	      Q.resize (nc);
 	      int *q = Q.fortran_vec ();
 
diff --git a/liboctave/SparseType.cc b/liboctave/SparseType.cc
--- a/liboctave/SparseType.cc
+++ b/liboctave/SparseType.cc
@@ -32,46 +32,46 @@ Software Foundation, 59 Temple Place - S
 
 SparseType::SparseType (const SparseType &a) : typ (a.typ), 
     sp_bandden (a.sp_bandden), bandden (a.bandden), 
     upper_band (a.upper_band), lower_band (a.lower_band), 
     dense (a.dense), nperm (a.nperm)
 { 
   if (nperm != 0)
     {
-      row_perm = new int [nperm];
-      col_perm = new int [nperm];
-      for (int i = 0; i < nperm; i++)
+      row_perm = new octave_idx_type [nperm];
+      col_perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
 	{
 	  row_perm[i] = a.row_perm[i];
 	  col_perm[i] = a.col_perm[i];
 	}
     }
 }
 
 SparseType::SparseType (const SparseMatrix &a)
 {
-  int nrows = a.rows ();
-  int ncols = a.cols ();
-  int nnz = a.nnz ();
+  octave_idx_type nrows = a.rows ();
+  octave_idx_type ncols = a.cols ();
+  octave_idx_type nnz = a.nnz ();
 
   nperm = 0;
 
   if (nrows != ncols)
     typ = SparseType::Rectangular;
   else
     {
       sp_bandden = Voctave_sparse_controls.get_key ("bandden");
       bool maybe_hermitian = false;
       typ = SparseType::Full;
 
       if (nnz == ncols)
 	{
 	  matrix_type tmp_typ = SparseType::Diagonal;
-	  int i;
+	  octave_idx_type i;
 	  // Maybe the matrix is diagonal
 	  for (i = 0; i < ncols; i++)
 	    {
 	      if (a.cidx(i+1) != a.cidx(i) + 1)
 		{
 		  tmp_typ = Full;
 		  break;
 		}
@@ -81,22 +81,22 @@ SparseType::SparseType (const SparseMatr
 		  break;
 		}
 	    }
 	  
 	  if (tmp_typ == SparseType::Permuted_Diagonal)
 	    {
 	      bool found [ncols];
 
-	      for (int j = 0; j < i; j++)
+	      for (octave_idx_type j = 0; j < i; j++)
 		found [j] = true;
-	      for (int j = i; j < ncols; j++)
+	      for (octave_idx_type j = i; j < ncols; j++)
 		found [j] = false;
 	      
-	      for (int j = i; j < ncols; j++)
+	      for (octave_idx_type j = i; j < ncols; j++)
 		{
 		  if ((a.cidx(j+1) != a.cidx(j) + 1) || found [a.ridx(j)])
 		    {
 		      tmp_typ = Full;
 		      break;
 		    }
 		  found [a.ridx(j)] = true;
 		}
@@ -105,36 +105,36 @@ SparseType::SparseType (const SparseMatr
 	}
 
       if (typ == Full)
 	{
 	  // Search for banded, upper and lower triangular matrices
 	  bool singular = false;
 	  upper_band = 0;
 	  lower_band = 0;
-	  for (int j = 0; j < ncols; j++)
+	  for (octave_idx_type j = 0; j < ncols; j++)
 	    {
 	      bool zero_on_diagonal = true;
-	      for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 		if (a.ridx(i) == j)
 		  {
 		    zero_on_diagonal = false;
 		    break;
 		  }
 
 	      if (zero_on_diagonal)
 		{
 		  singular = true;
 		  break;
 		}
 
 	      if (a.cidx(j+1) - a.cidx(j) > 0)
 		{
-		  int ru = a.ridx(a.cidx(j));
-		  int rl = a.ridx(a.cidx(j+1)-1);
+		  octave_idx_type ru = a.ridx(a.cidx(j));
+		  octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
 
 		  if (j - ru > upper_band)
 		    upper_band = j - ru;
 		  
 		  if (rl - j > lower_band)
 		    lower_band = rl - j;
 		}
 	    }
@@ -149,17 +149,17 @@ SparseType::SparseType (const SparseMatr
 
 	      if (sp_bandden != 1. && bandden > sp_bandden)
 		{
 		  if (upper_band == 1 && lower_band == 1)
 		    typ = SparseType::Tridiagonal;
 		  else
 		    typ = SparseType::Banded;
 
-		  int nnz_in_band = (upper_band + lower_band + 1) * nrows -
+		  octave_idx_type nnz_in_band = (upper_band + lower_band + 1) * nrows -
 		    (1 + upper_band) * upper_band / 2 -
 		    (1 + lower_band) * lower_band / 2;
 		  if (nnz_in_band == nnz)
 		    dense = true;
 		  else 
 		    dense = false;
 		}
 	      else if (upper_band == 0)
@@ -184,36 +184,36 @@ SparseType::SparseType (const SparseMatr
       if (maybe_hermitian && (typ == Full || typ == Tridiagonal || 
 			      typ == Banded))
 	{
 	  // Check for symmetry, with positive real diagonal, which
 	  // has a very good chance of being symmetric positive
 	  // definite..
 	  bool is_herm = true;
 
-	  for (int j = 0; j < ncols; j++)
+	  for (octave_idx_type j = 0; j < ncols; j++)
 	    {
 	      bool diag_positive = false;
 
-	      for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 		{
-		  int ri = a.ridx(i);
+		  octave_idx_type ri = a.ridx(i);
 
 		  if (ri == j)
 		    {
 		      if (a.data(i) == std::abs(a.data(i)))
 			diag_positive = true;
 		      else
 			break;
 		    }
 		  else
 		    {
 		      bool found = false;
 
-		      for (int k = a.cidx(ri); k < a.cidx(ri+1); k++)
+		      for (octave_idx_type k = a.cidx(ri); k < a.cidx(ri+1); k++)
 			{
 			  if (a.ridx(k) == j)
 			    {
 			      if (a.data(i) == conj (a.data(k)))
 				found = true;
 			      break;
 			    }
 			}
@@ -243,34 +243,34 @@ SparseType::SparseType (const SparseMatr
 		typ = Tridiagonal_Hermitian;
 	    }
 	}
     }
 }
 
 SparseType::SparseType (const SparseComplexMatrix &a)
 {
-  int nrows = a.rows ();
-  int ncols = a.cols ();
-  int nnz = a.nnz ();
+  octave_idx_type nrows = a.rows ();
+  octave_idx_type ncols = a.cols ();
+  octave_idx_type nnz = a.nnz ();
 
   nperm = 0;
 
   if (nrows != ncols)
     typ = SparseType::Rectangular;
   else
     {
       sp_bandden = Voctave_sparse_controls.get_key ("bandden");
       bool maybe_hermitian = false;
       typ = SparseType::Full;
 
       if (nnz == ncols)
 	{
 	  matrix_type tmp_typ = SparseType::Diagonal;
-	  int i;
+	  octave_idx_type i;
 	  // Maybe the matrix is diagonal
 	  for (i = 0; i < ncols; i++)
 	    {
 	      if (a.cidx(i+1) != a.cidx(i) + 1)
 		{
 		  tmp_typ = Full;
 		  break;
 		}
@@ -280,22 +280,22 @@ SparseType::SparseType (const SparseComp
 		  break;
 		}
 	    }
 	  
 	  if (tmp_typ == SparseType::Permuted_Diagonal)
 	    {
 	      bool found [ncols];
 
-	      for (int j = 0; j < i; j++)
+	      for (octave_idx_type j = 0; j < i; j++)
 		found [j] = true;
-	      for (int j = i; j < ncols; j++)
+	      for (octave_idx_type j = i; j < ncols; j++)
 		found [j] = false;
 	      
-	      for (int j = i; j < ncols; j++)
+	      for (octave_idx_type j = i; j < ncols; j++)
 		{
 		  if ((a.cidx(j+1) != a.cidx(j) + 1) || found [a.ridx(j)])
 		    {
 		      tmp_typ = Full;
 		      break;
 		    }
 		  found [a.ridx(j)] = true;
 		}
@@ -304,36 +304,36 @@ SparseType::SparseType (const SparseComp
 	}
 
       if (typ == Full)
 	{
 	  // Search for banded, upper and lower triangular matrices
 	  bool singular = false;
 	  upper_band = 0;
 	  lower_band = 0;
-	  for (int j = 0; j < ncols; j++)
+	  for (octave_idx_type j = 0; j < ncols; j++)
 	    {
 	      bool zero_on_diagonal = true;
-	      for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 		if (a.ridx(i) == j)
 		  {
 		    zero_on_diagonal = false;
 		    break;
 		  }
 
 	      if (zero_on_diagonal)
 		{
 		  singular = true;
 		  break;
 		}
 
 	      if (a.cidx(j+1) - a.cidx(j) > 0)
 		{
-		  int ru = a.ridx(a.cidx(j));
-		  int rl = a.ridx(a.cidx(j+1)-1);
+		  octave_idx_type ru = a.ridx(a.cidx(j));
+		  octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
 
 		  if (j - ru > upper_band)
 		    upper_band = j - ru;
 		  
 		  if (rl - j > lower_band)
 		    lower_band = rl - j;
 		}
 	    }
@@ -348,17 +348,17 @@ SparseType::SparseType (const SparseComp
 
 	      if (sp_bandden != 1. && bandden > sp_bandden)
 		{
 		  if (upper_band == 1 && lower_band == 1)
 		    typ = SparseType::Tridiagonal;
 		  else
 		    typ = SparseType::Banded;
 
-		  int nnz_in_band = (upper_band + lower_band + 1) * nrows -
+		  octave_idx_type nnz_in_band = (upper_band + lower_band + 1) * nrows -
 		    (1 + upper_band) * upper_band / 2 -
 		    (1 + lower_band) * lower_band / 2;
 		  if (nnz_in_band == nnz)
 		    dense = true;
 		  else 
 		    dense = false;
 		}
 	      else if (upper_band == 0)
@@ -383,36 +383,36 @@ SparseType::SparseType (const SparseComp
       if (maybe_hermitian && (typ == Full || typ == Tridiagonal || 
 			      typ == Banded))
 	{
 	  // Check for symmetry, with positive real diagonal, which
 	  // has a very good chance of being symmetric positive
 	  // definite..
 	  bool is_herm = true;
 
-	  for (int j = 0; j < ncols; j++)
+	  for (octave_idx_type j = 0; j < ncols; j++)
 	    {
 	      bool diag_positive = false;
 
-	      for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 		{
-		  int ri = a.ridx(i);
+		  octave_idx_type ri = a.ridx(i);
 
 		  if (ri == j)
 		    {
 		      if (a.data(i) == std::abs(a.data(i)))
 			diag_positive = true;
 		      else
 			break;
 		    }
 		  else
 		    {
 		      bool found = false;
 
-		      for (int k = a.cidx(ri); k < a.cidx(ri+1); k++)
+		      for (octave_idx_type k = a.cidx(ri); k < a.cidx(ri+1); k++)
 			{
 			  if (a.ridx(k) == j)
 			    {
 			      if (a.data(i) == a.data(k))
 				found = true;
 			      break;
 			    }
 			}
@@ -464,19 +464,19 @@ SparseType::operator = (const SparseType
       bandden = a.bandden;
       upper_band = a.upper_band;
       lower_band = a.lower_band;
       dense = a.dense;
       nperm = a.nperm;
 
       if (nperm != 0)
 	{
-	  row_perm = new int [nperm];
-	  col_perm = new int [nperm];
-	  for (int i = 0; i < nperm; i++)
+	  row_perm = new octave_idx_type [nperm];
+	  col_perm = new octave_idx_type [nperm];
+	  for (octave_idx_type i = 0; i < nperm; i++)
 	    {
 	      row_perm[i] = a.row_perm[i];
 	      col_perm[i] = a.col_perm[i];
 	    }
     }
 
     }
   return *this;
@@ -506,19 +506,19 @@ SparseType::type (const SparseMatrix &a)
   bandden = tmp_typ.bandden;
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      row_perm = new int [nperm];
-      col_perm = new int [nperm];
-      for (int i = 0; i < nperm; i++)
+      row_perm = new octave_idx_type [nperm];
+      col_perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
 	{
 	  row_perm[i] = tmp_typ.row_perm[i];
 	  col_perm[i] = tmp_typ.col_perm[i];
 	}
     }
 
   return typ;
 }
@@ -547,19 +547,19 @@ SparseType::type (const SparseComplexMat
   bandden = tmp_typ.bandden;
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      row_perm = new int [nperm];
-      col_perm = new int [nperm];
-      for (int i = 0; i < nperm; i++)
+      row_perm = new octave_idx_type [nperm];
+      col_perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
 	{
 	  row_perm[i] = tmp_typ.row_perm[i];
 	  col_perm[i] = tmp_typ.col_perm[i];
 	}
     }
 
   return typ;
 }
@@ -643,22 +643,22 @@ SparseType::mark_as_unsymmetric (void)
 	   typ == SparseType::Banded_Hermitian)
     typ = SparseType::Banded;
   else if (typ == SparseType::Full || typ == SparseType::Hermitian || 
 	   typ == SparseType::Unknown)
     typ = SparseType::Full;
 }
 
 void
-SparseType::mark_as_permuted (const int np, const int *pr, const int *pc)
+SparseType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *pr, const octave_idx_type *pc)
 {
   nperm = np;
-  row_perm = new int [nperm];
-  col_perm = new int [nperm];
-  for (int i = 0; i < nperm; i++)
+  row_perm = new octave_idx_type [nperm];
+  col_perm = new octave_idx_type [nperm];
+  for (octave_idx_type i = 0; i < nperm; i++)
     {
       row_perm[i] = pr[i];
       col_perm[i] = pc[i];
     }
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     typ = SparseType::Permuted_Diagonal;
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
diff --git a/liboctave/SparseType.h b/liboctave/SparseType.h
--- a/liboctave/SparseType.h
+++ b/liboctave/SparseType.h
@@ -94,61 +94,61 @@ public:
   bool is_rectangular (void) const { return (typ == Rectangular); }
 
   bool is_known (void) const { return (typ != Unknown); }
 
   bool is_unknown (void) const { return (typ == Unknown); }
 
   void info (void) const;
 
-  int * triangular_row_perm (void) const { return row_perm; }
+  octave_idx_type * triangular_row_perm (void) const { return row_perm; }
 
-  int * triangular_col_perm (void) const { return col_perm; }
+  octave_idx_type * triangular_col_perm (void) const { return col_perm; }
 
   void invaldate_type (void) { typ = Unknown; }
 
   void mark_as_diagonal (void) { typ = Diagonal; }
 
   void mark_as_upper_triangular (void) { typ = Upper; }
 
   void mark_as_lower_triangular (void) { typ = Lower; }
 
   void mark_as_tridiagonal (void) {typ = Tridiagonal; }
 
-  void mark_as_banded (const int ku, const int kl)
+  void mark_as_banded (const octave_idx_type ku, const octave_idx_type kl)
     { typ = Banded; upper_band = ku; lower_band = kl; }
 
   void mark_as_full (void) { typ = Full; }
 
   void mark_as_rectangular (void) { typ = Rectangular; }
 
   void mark_as_dense (void) { dense = true; }
 
   void mark_as_not_dense (void) { dense = false; }
 
   void mark_as_symmetric (void);
 
   void mark_as_unsymmetric (void);
 
-  void mark_as_permuted (const int np, const int *pr, const int *pc);
+  void mark_as_permuted (const octave_idx_type np, const octave_idx_type *pr, const octave_idx_type *pc);
 
   void mark_as_unpermuted (void);
 
 private:
   void type (int new_typ) { typ = static_cast<matrix_type>(new_typ); }
 
   matrix_type typ;
   double sp_bandden;
   double bandden;
-  int upper_band;
-  int lower_band;
+  octave_idx_type upper_band;
+  octave_idx_type lower_band;
   bool dense;
-  int nperm;
-  int *row_perm;
-  int *col_perm;
+  octave_idx_type nperm;
+  octave_idx_type *row_perm;
+  octave_idx_type *col_perm;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -42,18 +42,18 @@ template class sparse_base_lu <SparseMat
 extern "C" {
 #include <umfpack/umfpack.h>
 }
 #endif
 
 SparseLU::SparseLU (const SparseMatrix& a, double piv_thres)
 {
 #ifdef HAVE_UMFPACK
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   umfpack_di_defaults (control);
 
   double tmp = Voctave_sparse_controls.get_key ("spumoni");
   if (!xisnan (tmp))
@@ -80,18 +80,18 @@ SparseLU::SparseLU (const SparseMatrix& 
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   // Turn-off UMFPACK scaling for LU 
   Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
   umfpack_di_report_control (control);
 
-  const int *Ap = a.cidx ();
-  const int *Ai = a.ridx ();
+  const octave_idx_type *Ap = a.cidx ();
+  const octave_idx_type *Ai = a.ridx ();
   const double *Ax = a.data ();
 
   umfpack_di_report_matrix (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = umfpack_di_qsymbolic (nr, nc, Ap, Ai, Ax, NULL,
@@ -146,31 +146,35 @@ SparseLU::SparseLU (const SparseMatrix& 
 
 	      umfpack_di_free_numeric (&Numeric);
 	    }
 	  else
 	    {
 	      int n_inner = (nr < nc ? nr : nc);
 
 	      if (lnz < 1)
-		Lfact = SparseMatrix (n_inner, nr, 1);
+		Lfact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nr,
+				      static_cast<octave_idx_type> (1));
 	      else
-		Lfact = SparseMatrix (n_inner, nr, lnz);
+		Lfact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nr,
+				      static_cast<octave_idx_type> (lnz));
 
-	      int *Ltp = Lfact.cidx ();
-	      int *Ltj = Lfact.ridx ();
+	      octave_idx_type *Ltp = Lfact.cidx ();
+	      octave_idx_type *Ltj = Lfact.ridx ();
 	      double *Ltx = Lfact.data ();
 
 	      if (unz < 1)
-		Ufact = SparseMatrix (n_inner, nc, 1);
+		Ufact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nc,
+				      static_cast<octave_idx_type> (1));
 	      else
-		Ufact = SparseMatrix (n_inner, nc, unz);
+		Ufact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nc,
+				      static_cast<octave_idx_type> (unz));
 
-	      int *Up = Ufact.cidx ();
-	      int *Uj = Ufact.ridx ();
+	      octave_idx_type *Up = Ufact.cidx ();
+	      octave_idx_type *Uj = Ufact.ridx ();
 	      double *Ux = Ufact.data ();
 
 	      P.resize (nr);
 	      int *p = P.fortran_vec ();
 
 	      Q.resize (nc);
 	      int *q = Q.fortran_vec ();
 
@@ -211,18 +215,18 @@ SparseLU::SparseLU (const SparseMatrix& 
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
 
 SparseLU::SparseLU (const SparseMatrix& a, const ColumnVector& Qinit,
 		    double piv_thres, bool FixedQ)
 {
 #ifdef HAVE_UMFPACK
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   umfpack_di_defaults (control);
 
   double tmp = Voctave_sparse_controls.get_key ("spumoni");
   if (!xisnan (tmp))
@@ -253,18 +257,18 @@ SparseLU::SparseLU (const SparseMatrix& 
 	Control (UMFPACK_FIXQ) = tmp;
     }
 
   // Turn-off UMFPACK scaling for LU 
   Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
   umfpack_di_report_control (control);
 
-  const int *Ap = a.cidx ();
-  const int *Ai = a.ridx ();
+  const octave_idx_type *Ap = a.cidx ();
+  const octave_idx_type *Ai = a.ridx ();
   const double *Ax = a.data ();
 
   umfpack_di_report_matrix (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status;
@@ -329,31 +333,35 @@ SparseLU::SparseLU (const SparseMatrix& 
 
 	      umfpack_di_free_numeric (&Numeric);
 	    }
 	  else
 	    {
 	      int n_inner = (nr < nc ? nr : nc);
 
 	      if (lnz < 1)
-		Lfact = SparseMatrix (n_inner, nr, 1);
+		Lfact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nr,
+				      static_cast<octave_idx_type> (1));
 	      else
-		Lfact = SparseMatrix (n_inner, nr, lnz);
+		Lfact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nr,
+				      static_cast<octave_idx_type> (lnz));
 
-	      int *Ltp = Lfact.cidx ();
-	      int *Ltj = Lfact.ridx ();
+	      octave_idx_type *Ltp = Lfact.cidx ();
+	      octave_idx_type *Ltj = Lfact.ridx ();
 	      double *Ltx = Lfact.data ();
 
 	      if (unz < 1)
-		Ufact = SparseMatrix (n_inner, nc, 1);
+		Ufact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nc,
+				      static_cast<octave_idx_type> (1));
 	      else
-		Ufact = SparseMatrix (n_inner, nc, unz);
+		Ufact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nc,
+				      static_cast<octave_idx_type> (unz));
 
-	      int *Up = Ufact.cidx ();
-	      int *Uj = Ufact.ridx ();
+	      octave_idx_type *Up = Ufact.cidx ();
+	      octave_idx_type *Uj = Ufact.ridx ();
 	      double *Ux = Ufact.data ();
 
 	      P.resize (nr);
 	      int *p = P.fortran_vec ();
 
 	      Q.resize (nc);
 	      int *q = Q.fortran_vec ();
 
diff --git a/liboctave/base-de.h b/liboctave/base-de.h
--- a/liboctave/base-de.h
+++ b/liboctave/base-de.h
@@ -67,17 +67,17 @@ public:
     {
       x = x0;
       t = t0;
       integration_error = false;
       istate = 0;
       force_restart ();
     }
 
-  int size (void) const { return x.capacity (); }
+  octave_idx_type size (void) const { return x.capacity (); }
 
   ColumnVector state (void) const { return x; }
 
   double time (void) const { return t; }
 
   void set_stop_time (double tt)
     {
       stop_time_set = true;
@@ -90,17 +90,17 @@ public:
       stop_time_set = false;
       force_restart ();
     }
 
   virtual void force_restart (void) { restart = true; }
 
   bool integration_ok (void) const { return ! integration_error; }
 
-  int integration_state (void) const { return istate; }
+  octave_idx_type integration_state (void) const { return istate; }
 
   virtual std::string error_message (void) const = 0;
 
 protected:
 
   ColumnVector x;
 
   double t;
@@ -108,17 +108,17 @@ protected:
   double stop_time;
 
   bool stop_time_set;
 
   bool restart;
 
   bool integration_error;
 
-  int istate;
+  octave_idx_type istate;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/base-lu.cc b/liboctave/base-lu.cc
--- a/liboctave/base-lu.cc
+++ b/liboctave/base-lu.cc
@@ -25,79 +25,79 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "base-lu.h"
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 lu_type
 base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: L (void) const
 {
-  int a_nr = a_fact.rows ();
-  int a_nc = a_fact.cols ();
-  int mn = (a_nr < a_nc ? a_nr : a_nc);
+  octave_idx_type a_nr = a_fact.rows ();
+  octave_idx_type a_nc = a_fact.cols ();
+  octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
   lu_type l (a_nr, mn, lu_elt_type (0.0));
 
-  for (int i = 0; i < a_nr; i++)
+  for (octave_idx_type i = 0; i < a_nr; i++)
     {
       if (i < a_nc)
 	l.xelem (i, i) = 1.0;
 
-      for (int j = 0; j < (i < a_nc ? i : a_nc); j++)
+      for (octave_idx_type j = 0; j < (i < a_nc ? i : a_nc); j++)
 	l.xelem (i, j) = a_fact.xelem (i, j);
     }
 
   return l;
 }
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 lu_type
 base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: U (void) const
 {
-  int a_nr = a_fact.rows ();
-  int a_nc = a_fact.cols ();
-  int mn = (a_nr < a_nc ? a_nr : a_nc);
+  octave_idx_type a_nr = a_fact.rows ();
+  octave_idx_type a_nc = a_fact.cols ();
+  octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
   lu_type u (mn, a_nc, lu_elt_type (0.0));
 
-  for (int i = 0; i < mn; i++)
+  for (octave_idx_type i = 0; i < mn; i++)
     {
-      for (int j = i; j < a_nc; j++)
+      for (octave_idx_type j = i; j < a_nc; j++)
 	u.xelem (i, j) = a_fact.xelem (i, j);
     }
 
   return u;
 }
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 p_type
 base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: P (void) const
 {
-  int a_nr = a_fact.rows ();
+  octave_idx_type a_nr = a_fact.rows ();
 
-  Array<int> pvt (a_nr);
+  Array<octave_idx_type> pvt (a_nr);
 
-  for (int i = 0; i < a_nr; i++)
+  for (octave_idx_type i = 0; i < a_nr; i++)
     pvt.xelem (i) = i;
 
-  for (int i = 0; i < ipvt.length(); i++)
+  for (octave_idx_type i = 0; i < ipvt.length(); i++)
     {
-      int k = ipvt.xelem (i);
+      octave_idx_type k = ipvt.xelem (i);
 
       if (k != i)
 	{
-	  int tmp = pvt.xelem (k);
+	  octave_idx_type tmp = pvt.xelem (k);
 	  pvt.xelem (k) = pvt.xelem (i);
 	  pvt.xelem (i) = tmp;
 	}
     }
 
   p_type p (a_nr, a_nr, p_elt_type (0.0));
 
-  for (int i = 0; i < a_nr; i++)
+  for (octave_idx_type i = 0; i < a_nr; i++)
     p.xelem (i, pvt.xelem (i)) = 1.0;
 
   return p;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/base-lu.h b/liboctave/base-lu.h
--- a/liboctave/base-lu.h
+++ b/liboctave/base-lu.h
@@ -51,17 +51,17 @@ public:
 
   lu_type U (void) const;
 
   p_type P (void) const;
 
 protected:
 
   lu_type a_fact;
-  MArray<int> ipvt;
+  MArray<octave_idx_type> ipvt;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/base-min.h b/liboctave/base-min.h
--- a/liboctave/base-min.h
+++ b/liboctave/base-min.h
@@ -44,82 +44,82 @@ public:
 	x = a.x;
 
       return *this;
     }
 
   // Derived classes must provide a function to actually do the
   // minimization.
 
-  virtual ColumnVector do_minimize (double& objf, int& inform,
+  virtual ColumnVector do_minimize (double& objf, octave_idx_type& inform,
 				    ColumnVector& lambda) = 0;
 
   // Lots of ways to call the single function and optionally set and
   // get additional information.
 
   virtual ColumnVector minimize (void)
     {
       double objf;
-      int inform;
+      octave_idx_type inform;
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (double& objf)
     {
-      int inform;
+      octave_idx_type inform;
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
-  virtual ColumnVector minimize (double& objf, int& inform)
+  virtual ColumnVector minimize (double& objf, octave_idx_type& inform)
     {
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
-  virtual ColumnVector minimize (double& objf, int& inform,
+  virtual ColumnVector minimize (double& objf, octave_idx_type& inform,
 				 ColumnVector& lambda)
     {
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (const ColumnVector& x0)
     {
       x = x0;
       double objf;
-      int inform;
+      octave_idx_type inform;
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (const ColumnVector& x0, double& objf)
     {
       x = x0;
-      int inform;
+      octave_idx_type inform;
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (const ColumnVector& x0, double& objf,
-				 int& inform)
+				 octave_idx_type& inform)
     {
       x = x0;
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (const ColumnVector& x0, double& objf,
-				 int& inform, ColumnVector& lambda)
+				 octave_idx_type& inform, ColumnVector& lambda)
     {
       x = x0;
       return do_minimize (objf, inform, lambda);
     }
 
-  int size (void) const { return x.capacity (); }
+  octave_idx_type size (void) const { return x.capacity (); }
 
 protected:
 
   ColumnVector x;
 };
 
 #endif
 
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -46,34 +46,34 @@ boolMatrix::operator == (const boolMatri
 
 bool
 boolMatrix::operator != (const boolMatrix& a) const
 {
   return !(*this == a);
 }
 
 boolMatrix&
-boolMatrix::insert (const boolMatrix& a, int r, int c)
+boolMatrix::insert (const boolMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   Array2<bool>::insert (a, r, c);
   return *this;
 }
 
 // unary operations
 
 boolMatrix
 boolMatrix::operator ! (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   boolMatrix b (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       b.elem (i, j) = ! elem (i, j);
 
   return b;
 }
 
 // other operations
 
 // XXX FIXME XXX Do these really belong here?  Maybe they should be
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -29,35 +29,35 @@ Software Foundation, 59 Temple Place - S
 #include "mx-op-defs.h"
 
 class
 boolMatrix : public Array2<bool>
 {
 public:
 
   boolMatrix (void) : Array2<bool> () { }
-  boolMatrix (int r, int c) : Array2<bool> (r, c) { }
-  boolMatrix (int r, int c, bool val) : Array2<bool> (r, c, val) { }
+  boolMatrix (octave_idx_type r, octave_idx_type c) : Array2<bool> (r, c) { }
+  boolMatrix (octave_idx_type r, octave_idx_type c, bool val) : Array2<bool> (r, c, val) { }
   boolMatrix (const Array2<bool>& a) : Array2<bool> (a) { }
   boolMatrix (const boolMatrix& a) : Array2<bool> (a) { }
 
   boolMatrix& operator = (const boolMatrix& a)
     {
       Array2<bool>::operator = (a);
       return *this;
     }
 
   bool operator == (const boolMatrix& a) const;
   bool operator != (const boolMatrix& a) const;
 
   boolMatrix transpose (void) const { return Array2<bool>::transpose (); }
 
   // destructive insert/delete/reorder operations
 
-  boolMatrix& insert (const boolMatrix& a, int r, int c);
+  boolMatrix& insert (const boolMatrix& a, octave_idx_type r, octave_idx_type c);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
   boolMatrix all (int dim = -1) const;
@@ -69,17 +69,17 @@ public:
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
   static bool resize_fill_value (void) { return false; }
 
 private:
 
-  boolMatrix (bool *b, int r, int c) : Array2<bool> (b, r, c) { }
+  boolMatrix (bool *b, octave_idx_type r, octave_idx_type c) : Array2<bool> (b, r, c) { }
 };
 
 MM_CMP_OP_DECLS (boolMatrix, boolMatrix)
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -32,17 +32,17 @@ Software Foundation, 59 Temple Place - S
 
 // unary operations
 
 boolNDArray
 boolNDArray::operator ! (void) const
 {
   boolNDArray b (dims ());
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     b.elem (i) = ! elem (i);
 
   return b;
 }
 
 // XXX FIXME XXX -- this is not quite the right thing.
 
 boolNDArray
@@ -53,32 +53,32 @@ boolNDArray::all (int dim) const
 
 boolNDArray
 boolNDArray::any (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION (MX_ND_ANY_EVAL (MX_ND_ANY_EXPR), false);
 }
 
 boolNDArray
-boolNDArray::concat (const boolNDArray& rb, const Array<int>& ra_idx)
+boolNDArray::concat (const boolNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 boolNDArray&
-boolNDArray::insert (const boolNDArray& a, int r, int c)
+boolNDArray::insert (const boolNDArray& a, octave_idx_type r, octave_idx_type c)
 {
   Array<bool>::insert (a, r, c);
   return *this;
 }
 
 boolNDArray&
-boolNDArray::insert (const boolNDArray& a, const Array<int>& ra_idx)
+boolNDArray::insert (const boolNDArray& a, const Array<octave_idx_type>& ra_idx)
 {
   Array<bool>::insert (a, ra_idx);
   return *this;
 }
 
 
 
 boolMatrix
@@ -104,25 +104,25 @@ boolNDArray::matrix_value (void) const
 	("invalid conversion of boolNDArray to boolMatrix");
       break;
     }
 
   return retval;
 }
 
 void
-boolNDArray::increment_index (Array<int>& ra_idx,
+boolNDArray::increment_index (Array<octave_idx_type>& ra_idx,
 			      const dim_vector& dimensions,
 			      int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
-int
-boolNDArray::compute_index (Array<int>& ra_idx,
+octave_idx_type
+boolNDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 NDND_BOOL_OPS (boolNDArray, boolNDArray, false)
 NDND_CMP_OPS (boolNDArray, , boolNDArray, )
 
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -61,30 +61,30 @@ public:
 
   boolNDArray operator ! (void) const;
 
   // XXX FIXME XXX -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
-  boolNDArray concat (const boolNDArray& rb, const Array<int>& ra_idx);
+  boolNDArray concat (const boolNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
-  boolNDArray& insert (const boolNDArray& a, int r, int c);
-  boolNDArray& insert (const boolNDArray& a, const Array<int>& ra_idx);
+  boolNDArray& insert (const boolNDArray& a, octave_idx_type r, octave_idx_type c);
+  boolNDArray& insert (const boolNDArray& a, const Array<octave_idx_type>& ra_idx);
 
   boolMatrix matrix_value (void) const;
 
   boolNDArray squeeze (void) const { return ArrayN<bool>::squeeze (); }
 
-  static void increment_index (Array<int>& ra_idx,
+  static void increment_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
-  static int compute_index (Array<int>& ra_idx,
+  static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const NDArray& a);
   // friend std::istream& operator >> (std::istream& is, NDArray& a);
 
   static bool resize_fill_value (void) { return false; }
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -33,76 +33,76 @@ Software Foundation, 59 Temple Place - S
 
 #include "boolSparse.h"
 
 // SparseBoolMatrix class.
 
 bool
 SparseBoolMatrix::operator == (const SparseBoolMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
-  int nr_a = a.rows ();
-  int nc_a = a.cols ();
-  int nz_a = a.nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
+  octave_idx_type nr_a = a.rows ();
+  octave_idx_type nc_a = a.cols ();
+  octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
-  for (int i = 0; i < nc + 1; i++)
+  for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
 	return false;
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
       return false;
 
   return true;
 }
 
 bool
 SparseBoolMatrix::operator != (const SparseBoolMatrix& a) const
 {
   return !(*this == a);
 }
 
 SparseBoolMatrix&
-SparseBoolMatrix::insert (const SparseBoolMatrix& a, int r, int c)
+SparseBoolMatrix::insert (const SparseBoolMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   Sparse<bool>::insert (a, r, c);
   return *this;
 }
 
 SparseBoolMatrix
-SparseBoolMatrix::concat (const SparseBoolMatrix& rb, const Array<int>& ra_idx)
+SparseBoolMatrix::concat (const SparseBoolMatrix& rb, const Array<octave_idx_type>& ra_idx)
 {
   // Don't use numel to avoid all possiblity of an overflow
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (rb, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 // unary operations
 
 SparseBoolMatrix
 SparseBoolMatrix::operator ! (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz1 = nnz ();
-  int nz2 = nr*nc - nz1;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz1 = nnz ();
+  octave_idx_type nz2 = nr*nc - nz1;
    
   SparseBoolMatrix r (nr, nc, nz2);
    
-  int ii = 0;
-  int jj = 0;
-  for (int i = 0; i < nc; i++)
+  octave_idx_type ii = 0;
+  octave_idx_type jj = 0;
+  for (octave_idx_type i = 0; i < nc; i++)
     {
-      for (int j = 0; j < nr; j++)
+      for (octave_idx_type j = 0; j < nr; j++)
 	{
 	  if (jj < cidx(i+1) && ridx(jj) == j)
 	    jj++;
 	  else
 	    {
 	      r.data(ii) = true;
 	      r.ridx(ii++) = j;
 	    }
@@ -128,84 +128,84 @@ SparseBoolMatrix
 SparseBoolMatrix::any (int dim) const
 {
   SPARSE_ANY_OP (dim);
 }
 
 boolMatrix
 SparseBoolMatrix::matrix_value (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   boolMatrix retval (nr, nc, false);
-  for (int j = 0; j < nc; j++)
-    for (int i = cidx(j); i < cidx(j+1); i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
       retval.elem (ridx(i), j) = data (i);
 
   return retval;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SparseBoolMatrix& a)
 {
-  int nc = a.cols ();
+  octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
-   for (int j = 0; j < nc; j++)  
+   for (octave_idx_type j = 0; j < nc; j++)  
      {
        OCTAVE_QUIT;
-       for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	 os << a.ridx(i) + 1 << " "  << j + 1 << " " << a.data(i) << "\n";
      }
    
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
-  int nz = a.nnz ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type nz = a.nnz ();
 
   if (nr < 1 || nc < 1)
     is.clear (std::ios::badbit);
   else
     {
-      int itmp, jtmp, jold = 0;
+      octave_idx_type itmp, jtmp, jold = 0;
       bool tmp;
-      int ii = 0;
+      octave_idx_type ii = 0;
        
       a.cidx (0) = 0;
-      for (int i = 0; i < nz; i++)
+      for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  is >> itmp;
 	  itmp--;
 	  is >> jtmp;
 	  jtmp--;
 	  is >> tmp;
 	  if (is)
 	    {
 	      if (jold != jtmp)
 		{
-		  for (int j = jold; j < jtmp; j++)
+		  for (octave_idx_type j = jold; j < jtmp; j++)
 		    a.cidx(j+1) = ii;
 		  
 		  jold = jtmp;
 		}
 	      a.data (ii) = tmp;
 	      a.ridx (ii++) = itmp;
 	    }
 	  else
 	    goto done;
 	}
 
-      for (int j = jold; j < nc; j++)
+      for (octave_idx_type j = jold; j < nc; j++)
 	a.cidx(j+1) = ii;
     }
 
  done:
 
   return is;
 }
 
@@ -235,23 +235,23 @@ SparseBoolMatrix::index (Array<idx_vecto
 
 SparseBoolMatrix
 SparseBoolMatrix::reshape (const dim_vector& new_dims) const
 {
   return Sparse<bool>::reshape (new_dims);
 }
 
 SparseBoolMatrix
-SparseBoolMatrix::permute (const Array<int>& vec, bool inv) const
+SparseBoolMatrix::permute (const Array<octave_idx_type>& vec, bool inv) const
 {
   return Sparse<bool>::permute (vec, inv);
 }
 
 SparseBoolMatrix
-SparseBoolMatrix::ipermute (const Array<int>& vec) const
+SparseBoolMatrix::ipermute (const Array<octave_idx_type>& vec) const
 {
   return Sparse<bool>::ipermute (vec);
 }
 
 SPARSE_SMS_EQNE_OPS (SparseBoolMatrix, false, , bool, false, )
 SPARSE_SMS_BOOL_OPS (SparseBoolMatrix, bool, false)
 
 SPARSE_SSM_EQNE_OPS (bool, false, , SparseBoolMatrix, false, )
diff --git a/liboctave/boolSparse.h b/liboctave/boolSparse.h
--- a/liboctave/boolSparse.h
+++ b/liboctave/boolSparse.h
@@ -28,78 +28,78 @@ Software Foundation, 59 Temple Place - S
 
 class
 SparseBoolMatrix : public Sparse<bool>
 {
 public:
 
   SparseBoolMatrix (void) : Sparse<bool> () { }
 
-  SparseBoolMatrix (int r, int c) : Sparse<bool> (r, c) { }
+  SparseBoolMatrix (octave_idx_type r, octave_idx_type c) : Sparse<bool> (r, c) { }
 
-  explicit SparseBoolMatrix (int r, int c, bool val) 
+  explicit SparseBoolMatrix (octave_idx_type r, octave_idx_type c, bool val) 
     : Sparse<bool> (r, c, val) { }
 
   SparseBoolMatrix (const Sparse<bool>& a) : Sparse<bool> (a) { }
 
   SparseBoolMatrix (const SparseBoolMatrix& a) : Sparse<bool> (a) { }
 
   SparseBoolMatrix (const SparseBoolMatrix& a, const dim_vector& dv) 
     : Sparse<bool> (a, dv) { }
 
   explicit SparseBoolMatrix (const boolMatrix& a) : Sparse<bool> (a) { }
 
   explicit SparseBoolMatrix (const boolNDArray& a) : Sparse<bool> (a) { }
 
-  explicit SparseBoolMatrix (const Array<bool> a, const Array<int>& r, 
-			     const Array<int>& c, int nr = -1, 
-			     int nc = -1, bool sum_terms = true)
+  explicit SparseBoolMatrix (const Array<bool> a, const Array<octave_idx_type>& r, 
+			     const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
+			     octave_idx_type nc = -1, bool sum_terms = true)
     : Sparse<bool> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseBoolMatrix (const Array<bool> a, const Array<double>& r, 
-			     const Array<double>& c, int nr = -1, 
-			     int nc = -1, bool sum_terms = true)
+			     const Array<double>& c, octave_idx_type nr = -1, 
+			     octave_idx_type nc = -1, bool sum_terms = true)
     : Sparse<bool> (a, r, c, nr, nc, sum_terms) { }
 
-  SparseBoolMatrix (int r, int c, int num_nz) : Sparse<bool> (r, c, num_nz) { }
+  SparseBoolMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<bool> (r, c, num_nz) { }
 
   SparseBoolMatrix& operator = (const SparseBoolMatrix& a)
     {
       Sparse<bool>::operator = (a);
       return *this;
     }
 
   bool operator == (const SparseBoolMatrix& a) const;
   bool operator != (const SparseBoolMatrix& a) const;
 
   SparseBoolMatrix transpose (void) const 
     { return Sparse<bool>::transpose (); }
 
   // destructive insert/delete/reorder operations
 
-  SparseBoolMatrix& insert (const SparseBoolMatrix& a, int r, int c);
+  SparseBoolMatrix& insert (const SparseBoolMatrix& a, octave_idx_type r, octave_idx_type c);
 
   SparseBoolMatrix concat (const SparseBoolMatrix& rb, 
-			   const Array<int>& ra_idx);
+			   const Array<octave_idx_type>& ra_idx);
 
   boolMatrix matrix_value (void) const;
 
   SparseBoolMatrix squeeze (void) const;
 
   SparseBoolMatrix index (idx_vector& i, int resize_ok) const;
 
   SparseBoolMatrix index (idx_vector& i, idx_vector& j, int resize_ok) const;
   
   SparseBoolMatrix index (Array<idx_vector>& ra_idx, int resize_ok) const;
 
   SparseBoolMatrix reshape (const dim_vector& new_dims) const;
 
-  SparseBoolMatrix permute (const Array<int>& vec, bool inv = false) const;
+  SparseBoolMatrix permute (const Array<octave_idx_type>& vec, bool inv = false) const;
 
-  SparseBoolMatrix ipermute (const Array<int>& vec) const;
+  SparseBoolMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   // unary operations
 
   SparseBoolMatrix operator ! (void) const;
 
   // other operations
 
   SparseBoolMatrix all (int dim = -1) const;
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -33,57 +33,57 @@ Software Foundation, 59 Temple Place - S
 #include "mx-base.h"
 #include "mx-inlines.cc"
 
 // charMatrix class.
 
 charMatrix::charMatrix (char c)
   : MArray2<char> ()
 {
-  int nc = 1;
-  int nr = 1;
+  octave_idx_type nc = 1;
+  octave_idx_type nr = 1;
 
   resize (nr, nc);
 
   elem (0, 0) = c;
 }
 
 charMatrix::charMatrix (const char *s)
   : MArray2<char> ()
 {
-  int nc = s ? strlen (s) : 0;
-  int nr = s && nc > 0 ? 1 : 0;
+  octave_idx_type nc = s ? strlen (s) : 0;
+  octave_idx_type nr = s && nc > 0 ? 1 : 0;
 
   resize (nr, nc);
 
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     elem (0, i) = s[i];
 }
 
 charMatrix::charMatrix (const std::string& s)
   : MArray2<char> ()
 {
-  int nc = s.length ();
-  int nr = nc > 0 ? 1 : 0;
+  octave_idx_type nc = s.length ();
+  octave_idx_type nr = nc > 0 ? 1 : 0;
 
   resize (nr, nc);
 
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     elem (0, i) = s[i];
 }
 
 charMatrix::charMatrix (const string_vector& s)
   : MArray2<char> (s.length (), s.max_length (), 0)
 {
-  int nr = rows ();
+  octave_idx_type nr = rows ();
 
-  for (int i = 0; i < nr; i++)
+  for (octave_idx_type i = 0; i < nr; i++)
     {
-      int nc = s[i].length ();
-      for (int j = 0; j < nc; j++)
+      octave_idx_type nc = s[i].length ();
+      for (octave_idx_type j = 0; j < nc; j++)
 	elem (i, j) = s[i][j];
     }
 }
 
 bool
 charMatrix::operator == (const charMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
@@ -94,61 +94,61 @@ charMatrix::operator == (const charMatri
 
 bool
 charMatrix::operator != (const charMatrix& a) const
 {
   return !(*this == a);
 }
 
 charMatrix&
-charMatrix::insert (const char *s, int r, int c)
+charMatrix::insert (const char *s, octave_idx_type r, octave_idx_type c)
 {
   if (s)
     {
-      int s_len = strlen (s);
+      octave_idx_type s_len = strlen (s);
 
       if (r < 0 || r >= rows () || c < 0 || c + s_len - 1 > cols ())
 	{
 	  (*current_liboctave_error_handler) ("range error for insert");
 	  return *this;
 	}
 
-      for (int i = 0; i < s_len; i++)
+      for (octave_idx_type i = 0; i < s_len; i++)
 	elem (r, c+i) = s[i];
     }
   return *this;
 }
 
 charMatrix&
-charMatrix::insert (const charMatrix& a, int r, int c)
+charMatrix::insert (const charMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   Array2<char>::insert (a, r, c);
   return *this;
 }
 
 std::string
-charMatrix::row_as_string (int r, bool strip_ws, bool raw) const 
+charMatrix::row_as_string (octave_idx_type r, bool strip_ws, bool raw) const 
 {
   std::string retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (r == 0 && nr == 0 && nc == 0)
     return retval;
 
   if (r < 0 || r >= nr)
     {
       (*current_liboctave_error_handler) ("range error for row_as_string");
       return retval;
     }
 
   retval.resize (nc, '\0');
 
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     retval[i] = elem (r, i);
 
   if (! raw)
     {
       if (strip_ws)
 	{
 	  while (--nc >= 0)
 	    {
@@ -166,28 +166,28 @@ charMatrix::row_as_string (int r, bool s
 
       retval.resize (nc+1);
     }
 
   return retval;
 }
 
 charMatrix
-charMatrix::extract (int r1, int c1, int r2, int c2) const
+charMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
-  int new_r = r2 - r1 + 1;
-  int new_c = c2 - c1 + 1;
+  octave_idx_type new_r = r2 - r1 + 1;
+  octave_idx_type new_c = c2 - c1 + 1;
 
   charMatrix result (new_r, new_c);
 
-  for (int j = 0; j < new_c; j++)
-    for (int i = 0; i < new_r; i++)
+  for (octave_idx_type j = 0; j < new_c; j++)
+    for (octave_idx_type i = 0; i < new_r; i++)
       result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // XXX FIXME XXX Do these really belong here?  Maybe they should be
 // in a base class?
 
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -33,18 +33,18 @@ Software Foundation, 59 Temple Place - S
 class
 charMatrix : public MArray2<char>
 {
 friend class ComplexMatrix;
 
 public:
 
   charMatrix (void) : MArray2<char> () { }
-  charMatrix (int r, int c) : MArray2<char> (r, c) { }
-  charMatrix (int r, int c, char val) : MArray2<char> (r, c, val) { }
+  charMatrix (octave_idx_type r, octave_idx_type c) : MArray2<char> (r, c) { }
+  charMatrix (octave_idx_type r, octave_idx_type c, char val) : MArray2<char> (r, c, val) { }
   charMatrix (const MArray2<char>& a) : MArray2<char> (a) { }
   charMatrix (const charMatrix& a) : MArray2<char> (a) { }
   charMatrix (char c);
   charMatrix (const char *s);
   charMatrix (const std::string& s);
   charMatrix (const string_vector& s);
 
   charMatrix& operator = (const charMatrix& a)
@@ -55,40 +55,40 @@ public:
 
   bool operator == (const charMatrix& a) const;
   bool operator != (const charMatrix& a) const;
 
   charMatrix transpose (void) const { return MArray2<char>::transpose (); }
 
   // destructive insert/delete/reorder operations
 
-  charMatrix& insert (const char *s, int r, int c);
-  charMatrix& insert (const charMatrix& a, int r, int c);
+  charMatrix& insert (const char *s, octave_idx_type r, octave_idx_type c);
+  charMatrix& insert (const charMatrix& a, octave_idx_type r, octave_idx_type c);
 
-  std::string row_as_string (int, bool strip_ws = false, bool raw = false) const;
+  std::string row_as_string (octave_idx_type, bool strip_ws = false, bool raw = false) const;
 
   // resize is the destructive equivalent for this one
 
-  charMatrix extract (int r1, int c1, int r2, int c2) const;
+  charMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
   static char resize_fill_value (void) { return '\0'; }
 
 private:
 
-  charMatrix (char *ch, int r, int c) : MArray2<char> (ch, r, c) { }
+  charMatrix (char *ch, octave_idx_type r, octave_idx_type c) : MArray2<char> (ch, r, c) { }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -41,68 +41,68 @@ charNDArray::all (int dim) const
 
 boolNDArray
 charNDArray::any (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION (MX_ND_ANY_EVAL (elem (iter_idx) != ' '), false);
 }
 
 charNDArray
-charNDArray::concat (const charNDArray& rb, const Array<int>& ra_idx)
+charNDArray::concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 charNDArray
-charNDArray::concat (const NDArray& rb, const Array<int>& ra_idx)
+charNDArray::concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   charNDArray tmp (rb.dims ());
-  int nel = rb.numel ();
+  octave_idx_type nel = rb.numel ();
 
   if (rb.numel () == 0)
     return *this;
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = rb.elem (i);
 
       if (xisnan (d))
 	{
 	  (*current_liboctave_error_handler)
 	    ("invalid conversion from NaN to character");
 	  return *this;
 	}
       else
 	{
-	  int ival = NINT (d);
+	  octave_idx_type ival = NINTbig (d);
 
 	  if (ival < 0 || ival > UCHAR_MAX)
 	    // XXX FIXME XXX -- is there something
 	    // better we could do? Should we warn the user?
 	    ival = 0;
 
 	  tmp.elem (i) = static_cast<char>(ival);
 	}
     }
 
   insert (tmp, ra_idx);
   return *this;
 }
 
 charNDArray&
-charNDArray::insert (const charNDArray& a, int r, int c)
+charNDArray::insert (const charNDArray& a, octave_idx_type r, octave_idx_type c)
 {
   Array<char>::insert (a, r, c);
   return *this;
 }
 
 charNDArray&
-charNDArray::insert (const charNDArray& a, const Array<int>& ra_idx)
+charNDArray::insert (const charNDArray& a, const Array<octave_idx_type>& ra_idx)
 {
   Array<char>::insert (a, ra_idx);
   return *this;
 }
 
 charMatrix
 charNDArray::matrix_value (void) const
 {
@@ -126,25 +126,25 @@ charNDArray::matrix_value (void) const
 	("invalid conversion of charNDArray to charMatrix");
       break;
     }
 
   return retval;
 }
 
 void
-charNDArray::increment_index (Array<int>& ra_idx,
+charNDArray::increment_index (Array<octave_idx_type>& ra_idx,
 			      const dim_vector& dimensions,
 			      int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
-int 
-charNDArray::compute_index (Array<int>& ra_idx,
+octave_idx_type 
+charNDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -59,31 +59,31 @@ public:
       MArrayN<char>::operator = (a);
       return *this;
     }
 
   // XXX FIXME XXX -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
-  charNDArray concat (const charNDArray& rb, const Array<int>& ra_idx);
-  charNDArray concat (const NDArray& rb, const Array<int>& ra_idx);
+  charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
+  charNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
 
-  charNDArray& insert (const charNDArray& a, int r, int c);
-  charNDArray& insert (const charNDArray& a, const Array<int>& ra_idx);
+  charNDArray& insert (const charNDArray& a, octave_idx_type r, octave_idx_type c);
+  charNDArray& insert (const charNDArray& a, const Array<octave_idx_type>& ra_idx);
   
   charMatrix matrix_value (void) const;
 
   charNDArray squeeze (void) const { return ArrayN<char>::squeeze (); }
 
-  static void increment_index (Array<int>& ra_idx,
+  static void increment_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
-  static int compute_index (Array<int>& ra_idx,
+  static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
   static char resize_fill_value (void) { return '\0'; }
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -35,188 +35,188 @@ Software Foundation, 59 Temple Place - S
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const int&, const int&, const double&,
-			   const double*, const int&, const double*,
-			   const int&, const double&, double*,
-			   const int&
+			   const octave_idx_type&, const octave_idx_type&, const double&,
+			   const double*, const octave_idx_type&, const double*,
+			   const octave_idx_type&, const double&, double*,
+			   const octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL);
 }
 
 // Column Vector class.
 
 bool
 ColumnVector::operator == (const ColumnVector& a) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len != a.length ())
     return 0;
   return mx_inline_equal (data (), a.data (), len);
 }
 
 bool
 ColumnVector::operator != (const ColumnVector& a) const
 {
   return !(*this == a);
 }
 
 ColumnVector&
-ColumnVector::insert (const ColumnVector& a, int r)
+ColumnVector::insert (const ColumnVector& a, octave_idx_type r)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ColumnVector&
 ColumnVector::fill (double val)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ColumnVector&
-ColumnVector::fill (double val, int r1, int r2)
+ColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
   if (r2 >= r1)
     {
       make_unique ();
 
-      for (int i = r1; i <= r2; i++)
+      for (octave_idx_type i = r1; i <= r2; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 ColumnVector
 ColumnVector::stack (const ColumnVector& a) const
 {
-  int len = length ();
-  int nr_insert = len;
+  octave_idx_type len = length ();
+  octave_idx_type nr_insert = len;
   ColumnVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 RowVector
 ColumnVector::transpose (void) const
 {
   return RowVector (*this);
 }
 
 ColumnVector
 real (const ComplexColumnVector& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   ColumnVector retval;
   if (a_len > 0)
     retval = ColumnVector (mx_inline_real_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 ColumnVector
 imag (const ComplexColumnVector& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   ColumnVector retval;
   if (a_len > 0)
     retval = ColumnVector (mx_inline_imag_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 // resize is the destructive equivalent for this one
 
 ColumnVector
-ColumnVector::extract (int r1, int r2) const
+ColumnVector::extract (octave_idx_type r1, octave_idx_type r2) const
 {
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
 
-  int new_r = r2 - r1 + 1;
+  octave_idx_type new_r = r2 - r1 + 1;
 
   ColumnVector result (new_r);
 
-  for (int i = 0; i < new_r; i++)
+  for (octave_idx_type i = 0; i < new_r; i++)
     result.xelem (i) = elem (r1+i);
 
   return result;
 }
 
 ColumnVector
-ColumnVector::extract_n (int r1, int n) const
+ColumnVector::extract_n (octave_idx_type r1, octave_idx_type n) const
 {
   ColumnVector result (n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     result.xelem (i) = elem (r1+i);
 
   return result;
 }
 
 // matrix by column vector -> column vector operations
 
 ColumnVector
 operator * (const Matrix& m, const ColumnVector& a)
 {
   ColumnVector retval;
 
-  int nr = m.rows ();
-  int nc = m.cols ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.cols ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
 	retval.resize (nr, 0.0);
       else
 	{
-	  int ld = nr;
+	  octave_idx_type ld = nr;
 
 	  retval.resize (nr);
 	  double *y = retval.fortran_vec ();
 
 	  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
 				   nr, nc, 1.0, m.data (), ld,
 				   a.data (), 1, 0.0, y, 1
 				   F77_CHAR_ARG_LEN (1)));
@@ -232,35 +232,35 @@ operator * (const Matrix& m, const Colum
 
 // diagonal matrix by column vector -> column vector operations
 
 ColumnVector
 operator * (const DiagMatrix& m, const ColumnVector& a)
 {
   ColumnVector retval;
 
-  int nr = m.rows ();
-  int nc = m.cols ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.cols ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
 	retval.resize (nr, 0.0);
       else
 	{
 	  retval.resize (nr);
 
-	  for (int i = 0; i < a_len; i++)
+	  for (octave_idx_type i = 0; i < a_len; i++)
 	    retval.elem (i) = a.elem (i) * m.elem (i, i);
 
-	  for (int i = a_len; i < nr; i++)
+	  for (octave_idx_type i = a_len; i < nr; i++)
 	    retval.elem (i) = 0.0;
 	}
     }
 
   return retval;
 }
 
 // other operations
@@ -272,74 +272,74 @@ ColumnVector::map (d_d_Mapper f) const
   return b.apply (f);
 }
 
 ColumnVector&
 ColumnVector::apply (d_d_Mapper f)
 {
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     d[i] = f (d[i]);
 
   return *this;
 }
 
 double
 ColumnVector::min (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
 
   double res = elem (0);
 
-  for (int i = 1; i < len; i++)
+  for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) < res)
       res = elem (i);
 
   return res;
 }
 
 double
 ColumnVector::max (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
 
   double res = elem (0);
 
-  for (int i = 1; i < len; i++)
+  for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) > res)
       res = elem (i);
 
   return res;
 }
 
 std::ostream&
 operator << (std::ostream& os, const ColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ColumnVector& a)
 {
-  int len = a.length();
+  octave_idx_type len = a.length();
 
   if (len < 1)
     is.clear (std::ios::badbit);
   else
     {
       double tmp;
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
             a.elem (i) = tmp;
           else
             break;
         }
     }
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -29,52 +29,52 @@ Software Foundation, 59 Temple Place - S
 
 class
 ColumnVector : public MArray<double>
 {
 public:
 
   ColumnVector (void) : MArray<double> () { }
 
-  explicit ColumnVector (int n) : MArray<double> (n) { }
+  explicit ColumnVector (octave_idx_type n) : MArray<double> (n) { }
 
-  ColumnVector (int n, double val) : MArray<double> (n, val) { }
+  ColumnVector (octave_idx_type n, double val) : MArray<double> (n, val) { }
 
   ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
 
   ColumnVector (const MArray<double>& a) : MArray<double> (a) { }
 
   ColumnVector& operator = (const ColumnVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const ColumnVector& a) const;
   bool operator != (const ColumnVector& a) const;
 
   // destructive insert/delete/reorder operations
 
-  ColumnVector& insert (const ColumnVector& a, int r);
+  ColumnVector& insert (const ColumnVector& a, octave_idx_type r);
 
   ColumnVector& fill (double val);
-  ColumnVector& fill (double val, int r1, int r2);
+  ColumnVector& fill (double val, octave_idx_type r1, octave_idx_type r2);
 
   ColumnVector stack (const ColumnVector& a) const;
 
   RowVector transpose (void) const;
 
   friend ColumnVector real (const ComplexColumnVector& a);
   friend ColumnVector imag (const ComplexColumnVector& a);
 
   // resize is the destructive equivalent for this one
 
-  ColumnVector extract (int r1, int r2) const;
+  ColumnVector extract (octave_idx_type r1, octave_idx_type r2) const;
 
-  ColumnVector extract_n (int r1, int n) const;
+  ColumnVector extract_n (octave_idx_type r1, octave_idx_type n) const;
 
   // matrix by column vector -> column vector operations
 
   friend ColumnVector operator * (const Matrix& a, const ColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
   friend ColumnVector operator * (const DiagMatrix& a, const ColumnVector& b);
@@ -90,17 +90,17 @@ public:
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ColumnVector& a);
   friend std::istream& operator >> (std::istream& is, ColumnVector& a);
 
 private:
 
-  ColumnVector (double *d, int l) : MArray<double> (d, l) { }
+  ColumnVector (double *d, octave_idx_type l) : MArray<double> (d, l) { }
 };
 
 MARRAY_FORWARD_DEFS (MArray, ColumnVector, double)
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -48,153 +48,153 @@ bool
 DiagMatrix::operator != (const DiagMatrix& a) const
 {
   return !(*this == a);
 }
 
 DiagMatrix&
 DiagMatrix::fill (double val)
 {
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     elem (i, i) = val;
   return *this;
 }
 
 DiagMatrix&
-DiagMatrix::fill (double val, int beg, int end)
+DiagMatrix::fill (double val, octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = beg; i <= end; i++)
+  for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a)
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (a.length () != len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
-DiagMatrix::fill (const ColumnVector& a, int beg)
+DiagMatrix::fill (const ColumnVector& a, octave_idx_type beg)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
-DiagMatrix::fill (const RowVector& a, int beg)
+DiagMatrix::fill (const RowVector& a, octave_idx_type beg)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix
 DiagMatrix::transpose (void) const
 {
   return DiagMatrix (mx_inline_dup (data (), length ()), cols (), rows ());
 }
 
 DiagMatrix
 real (const ComplexDiagMatrix& a)
 {
   DiagMatrix retval;
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = DiagMatrix (mx_inline_real_dup (a.data (), a_len), a.rows (),
 			 a.cols ());
   return retval;
 }
 
 DiagMatrix
 imag (const ComplexDiagMatrix& a)
 {
   DiagMatrix retval;
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   if (a_len > 0)
     retval = DiagMatrix (mx_inline_imag_dup (a.data (), a_len), a.rows (),
 			 a.cols ());
   return retval;
 }
 
 Matrix
-DiagMatrix::extract (int r1, int c1, int r2, int c2) const
+DiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
-  int new_r = r2 - r1 + 1;
-  int new_c = c2 - c1 + 1;
+  octave_idx_type new_r = r2 - r1 + 1;
+  octave_idx_type new_c = c2 - c1 + 1;
 
   Matrix result (new_r, new_c);
 
-  for (int j = 0; j < new_c; j++)
-    for (int i = 0; i < new_r; i++)
+  for (octave_idx_type j = 0; j < new_c; j++)
+    for (octave_idx_type i = 0; i < new_r; i++)
       result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // extract row or column i.
 
 RowVector
-DiagMatrix::row (int i) const
+DiagMatrix::row (octave_idx_type i) const
 {
-  int r = rows ();
-  int c = cols ();
+  octave_idx_type r = rows ();
+  octave_idx_type c = cols ();
   if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 
   RowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
@@ -209,31 +209,31 @@ DiagMatrix::row (char *s) const
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return row (0);
+    return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 }
 
 ColumnVector
-DiagMatrix::column (int i) const
+DiagMatrix::column (octave_idx_type i) const
 {
-  int r = rows ();
-  int c = cols ();
+  octave_idx_type r = rows ();
+  octave_idx_type c = cols ();
   if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 
   ColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
@@ -248,17 +248,17 @@ DiagMatrix::column (char *s) const
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return column (0);
+    return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 }
@@ -268,29 +268,29 @@ DiagMatrix::inverse (void) const
 {
   int info;
   return inverse (info);
 }
 
 DiagMatrix
 DiagMatrix::inverse (int &info) const
 {
-  int r = rows ();
-  int c = cols ();
-  int len = length ();
+  octave_idx_type r = rows ();
+  octave_idx_type c = cols ();
+  octave_idx_type len = length ();
   if (r != c)
     {
       (*current_liboctave_error_handler) ("inverse requires square matrix");
       return DiagMatrix ();
     }
 
   DiagMatrix retval (r, c);
 
   info = 0;
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     {
       if (elem (i, i) == 0.0)
 	{
 	  info = -1;
 	  return *this;
 	}
       else
 	retval.elem (i, i) = 1.0 / elem (i, i);
@@ -301,36 +301,36 @@ DiagMatrix::inverse (int &info) const
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 DiagMatrix
 operator * (const DiagMatrix& a, const DiagMatrix& b)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     {
       gripe_nonconformant ("operaotr *", a_nr, a_nc, b_nr, b_nc);
       return DiagMatrix ();
     }
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return DiagMatrix (a_nr, a_nc, 0.0);
 
   DiagMatrix c (a_nr, b_nc);
 
-  int len = a_nr < b_nc ? a_nr : b_nc;
+  octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     {
       double a_element = a.elem (i, i);
       double b_element = b.elem (i, i);
 
       if (a_element == 0.0 || b_element == 0.0)
         c.elem (i, i) = 0.0;
       else if (a_element == 1.0)
         c.elem (i, i) = b_element;
@@ -349,64 +349,64 @@ ColumnVector
 DiagMatrix::diag (void) const
 {
   return diag (0);
 }
 
 // Could be optimized...
 
 ColumnVector
-DiagMatrix::diag (int k) const
+DiagMatrix::diag (octave_idx_type k) const
 {
-  int nnr = rows ();
-  int nnc = cols ();
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ColumnVector d;
 
   if (nnr > 0 && nnc > 0)
     {
-      int ndiag = (nnr < nnc) ? nnr : nnc;
+      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
       d.resize (ndiag);
 
       if (k > 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i+k);
 	}
       else if ( k < 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i-k, i);
 	}
       else
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i);
 	}
     }
   else
     (*current_liboctave_error_handler)
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
 std::ostream&
 operator << (std::ostream& os, const DiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
 
-  for (int i = 0; i < a.rows (); i++)
+  for (octave_idx_type i = 0; i < a.rows (); i++)
     {
-      for (int j = 0; j < a.cols (); j++)
+      for (octave_idx_type j = 0; j < a.cols (); j++)
 	{
 	  if (i == j)
 	    os << " " /* setw (field_width) */ << a.elem (i, i);
 	  else
 	    os << " " /* setw (field_width) */ << 0.0;
 	}
       os << "\n";
     }
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -35,19 +35,19 @@ DiagMatrix : public MDiagArray2<double>
 {
 friend class SVD;
 friend class ComplexSVD;
 
 public:
 
   DiagMatrix (void) : MDiagArray2<double> () { }
 
-  DiagMatrix (int r, int c) : MDiagArray2<double> (r, c) { }
+  DiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<double> (r, c) { }
 
-  DiagMatrix (int r, int c, double val) : MDiagArray2<double> (r, c, val) { }
+  DiagMatrix (octave_idx_type r, octave_idx_type c, double val) : MDiagArray2<double> (r, c, val) { }
 
   DiagMatrix (const DiagMatrix& a) : MDiagArray2<double> (a) { }
 
   DiagMatrix (const MDiagArray2<double>& a) : MDiagArray2<double> (a) { }
 
   explicit DiagMatrix (const RowVector& a) : MDiagArray2<double> (a) { }
 
   explicit DiagMatrix (const ColumnVector& a) : MDiagArray2<double> (a) { }
@@ -57,54 +57,54 @@ public:
       MDiagArray2<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const DiagMatrix& a) const;
   bool operator != (const DiagMatrix& a) const;
 
   DiagMatrix& fill (double val);
-  DiagMatrix& fill (double val, int beg, int end);
+  DiagMatrix& fill (double val, octave_idx_type beg, octave_idx_type end);
   DiagMatrix& fill (const ColumnVector& a);
   DiagMatrix& fill (const RowVector& a);
-  DiagMatrix& fill (const ColumnVector& a, int beg);
-  DiagMatrix& fill (const RowVector& a, int beg);
+  DiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
+  DiagMatrix& fill (const RowVector& a, octave_idx_type beg);
 
   DiagMatrix transpose (void) const;
 
   friend DiagMatrix real (const ComplexDiagMatrix& a);
   friend DiagMatrix imag (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
-  Matrix extract (int r1, int c1, int r2, int c2) const;
+  Matrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   // extract row or column i.
 
-  RowVector row (int i) const;
+  RowVector row (octave_idx_type i) const;
   RowVector row (char *s) const;
 
-  ColumnVector column (int i) const;
+  ColumnVector column (octave_idx_type i) const;
   ColumnVector column (char *s) const;
 
   DiagMatrix inverse (void) const;
   DiagMatrix inverse (int& info) const;
 
   // other operations
 
   ColumnVector diag (void) const;
-  ColumnVector diag (int k) const;
+  ColumnVector diag (octave_idx_type k) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const DiagMatrix& a);
 
 private:
 
-  DiagMatrix (double *d, int nr, int nc) : MDiagArray2<double> (d, nr, nc) { }
+  DiagMatrix (double *d, octave_idx_type nr, octave_idx_type nc) : MDiagArray2<double> (d, nr, nc) { }
 };
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 DiagMatrix
 operator * (const DiagMatrix& a, const DiagMatrix& b);
 
 MDIAGARRAY2_FORWARD_DEFS (MDiagArray2, DiagMatrix, double)
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -53,139 +53,139 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, double*, const int&, int&,
-			     int&, double*, int&
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
+			     octave_idx_type&, double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, const int&, double*,
-			     const int&, double*, const int&, int&
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
 
   F77_RET_T
   F77_FUNC (dgemm, DGEMM) (F77_CONST_CHAR_ARG_DECL,
 			   F77_CONST_CHAR_ARG_DECL,
-			   const int&, const int&, const int&,
-			   const double&, const double*, const int&,
-			   const double*, const int&, const double&,
-			   double*, const int&
+			   const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			   const double&, const double*, const octave_idx_type&,
+			   const double*, const octave_idx_type&, const double&,
+			   double*, const octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL
 			   F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dgetrf, DGETRF) (const int&, const int&, double*, const int&,
-		      int*, int&);
+  F77_FUNC (dgetrf, DGETRF) (const octave_idx_type&, const octave_idx_type&, double*, const octave_idx_type&,
+		      octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (dgetrs, DGETRS) (F77_CONST_CHAR_ARG_DECL, const int&, const int&, 
-			     const double*, const int&,
-			     const int*, double*, const int&, int&
+  F77_FUNC (dgetrs, DGETRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, const octave_idx_type&, 
+			     const double*, const octave_idx_type&,
+			     const octave_idx_type*, double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dgetri, DGETRI) (const int&, double*, const int&, const int*,
-			     double*, const int&, int&);
+  F77_FUNC (dgetri, DGETRI) (const octave_idx_type&, double*, const octave_idx_type&, const octave_idx_type*,
+			     double*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (dgecon, DGECON) (F77_CONST_CHAR_ARG_DECL, const int&, double*, 
-			     const int&, const double&, double&, 
-			     double*, int*, int&
+  F77_FUNC (dgecon, DGECON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, double*, 
+			     const octave_idx_type&, const double&, double&, 
+			     double*, octave_idx_type*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dgelss, DGELSS) (const int&, const int&, const int&,
-			     double*, const int&, double*,
-			     const int&, double*, double&, int&,
-			     double*, const int&, int&);
+  F77_FUNC (dgelss, DGELSS) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     double*, const octave_idx_type&, double*,
+			     const octave_idx_type&, double*, double&, octave_idx_type&,
+			     double*, const octave_idx_type&, octave_idx_type&);
 
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
   // implicit double precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
   F77_RET_T
-  F77_FUNC (cffti, CFFTI) (const int&, Complex*);
+  F77_FUNC (cffti, CFFTI) (const octave_idx_type&, Complex*);
 
   F77_RET_T
-  F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
+  F77_FUNC (cfftf, CFFTF) (const octave_idx_type&, Complex*, Complex*);
 
   F77_RET_T
-  F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
+  F77_FUNC (cfftb, CFFTB) (const octave_idx_type&, Complex*, Complex*);
 
   F77_RET_T
   F77_FUNC (dlartg, DLARTG) (const double&, const double&, double&,
 			     double&, double&);
 
   F77_RET_T
   F77_FUNC (dtrsyl, DTRSYL) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, const int&,
-			     const double*, const int&, const double*,
-			     const int&, const double*, const int&,
-			     double&, int&
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     const double*, const octave_idx_type&, const double*,
+			     const octave_idx_type&, const double*, const octave_idx_type&,
+			     double&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL, const int&,
-			       const int&, const double*,
-			       const int&, double*, double&
+  F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
+			       const octave_idx_type&, const double*,
+			       const octave_idx_type&, double*, double&
 			       F77_CHAR_ARG_LEN_DECL); 
 }
 
 // Matrix class.
 
 Matrix::Matrix (const RowVector& rv)
   : MArray2<double> (1, rv.length (), 0.0)
 {
-  for (int i = 0; i < rv.length (); i++)
+  for (octave_idx_type i = 0; i < rv.length (); i++)
     elem (0, i) = rv.elem (i);
 }
 
 Matrix::Matrix (const ColumnVector& cv)
   : MArray2<double> (cv.length (), 1, 0.0)
 {
-  for (int i = 0; i < cv.length (); i++)
+  for (octave_idx_type i = 0; i < cv.length (); i++)
     elem (i, 0) = cv.elem (i);
 }
 
 Matrix::Matrix (const DiagMatrix& a)
   : MArray2<double> (a.rows (), a.cols (), 0.0)
 {
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // XXX FIXME XXX -- could we use a templated mixed-type copy function
 // here?
 
 Matrix::Matrix (const boolMatrix& a)
   : MArray2<double> (a.rows (), a.cols ())
 {
-  for (int i = 0; i < a.rows (); i++)
-    for (int j = 0; j < a.cols (); j++)
+  for (octave_idx_type i = 0; i < a.rows (); i++)
+    for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = a.elem (i, j);
 }
 
 Matrix::Matrix (const charMatrix& a)
   : MArray2<double> (a.rows (), a.cols ())
 {
-  for (int i = 0; i < a.rows (); i++)
-    for (int j = 0; j < a.cols (); j++)
+  for (octave_idx_type i = 0; i < a.rows (); i++)
+    for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = a.elem (i, j);
 }
 
 bool
 Matrix::operator == (const Matrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return false;
@@ -199,506 +199,506 @@ Matrix::operator != (const Matrix& a) co
   return !(*this == a);
 }
 
 bool
 Matrix::is_symmetric (void) const
 {
   if (is_square () && rows () > 0)
     {
-      for (int i = 0; i < rows (); i++)
-	for (int j = i+1; j < cols (); j++)
+      for (octave_idx_type i = 0; i < rows (); i++)
+	for (octave_idx_type j = i+1; j < cols (); j++)
 	  if (elem (i, j) != elem (j, i))
 	    return false;
 
       return true;
     }
 
   return false;
 }
 
 Matrix&
-Matrix::insert (const Matrix& a, int r, int c)
+Matrix::insert (const Matrix& a, octave_idx_type r, octave_idx_type c)
 {
   Array2<double>::insert (a, r, c);
   return *this;
 }
 
 Matrix&
-Matrix::insert (const RowVector& a, int r, int c)
+Matrix::insert (const RowVector& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 Matrix&
-Matrix::insert (const ColumnVector& a, int r, int c)
+Matrix::insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 Matrix&
-Matrix::insert (const DiagMatrix& a, int r, int c)
+Matrix::insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 Matrix&
 Matrix::fill (double val)
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       make_unique ();
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  xelem (i, j) = val;
     }
 
   return *this;
 }
 
 Matrix&
-Matrix::fill (double val, int r1, int c1, int r2, int c2)
+Matrix::fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
-      for (int j = c1; j <= c2; j++)
-	for (int i = r1; i <= r2; i++)
+      for (octave_idx_type j = c1; j <= c2; j++)
+	for (octave_idx_type i = r1; i <= r2; i++)
 	  xelem (i, j) = val;
     }
 
   return *this;
 }
 
 Matrix
 Matrix::append (const Matrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return Matrix ();
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const RowVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != 1)
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return Matrix ();
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + a.length ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const ColumnVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.length ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return Matrix ();
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const DiagMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nr != a.rows ())
     {
       (*current_liboctave_error_handler) ("row dimension mismatch for append");
       return *this;
     }
 
-  int nc_insert = nc;
+  octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::stack (const Matrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return Matrix ();
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const RowVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return Matrix ();
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   Matrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const ColumnVector& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != 1)
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return Matrix ();
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.length (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const DiagMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   if (nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("column dimension mismatch for stack");
       return Matrix ();
     }
 
-  int nr_insert = nr;
+  octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 real (const ComplexMatrix& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   Matrix retval;
   if (a_len > 0)
     retval = Matrix (mx_inline_real_dup (a.data (), a_len),
 		     a.rows (), a.cols ());
   return retval;
 }
 
 Matrix
 imag (const ComplexMatrix& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   Matrix retval;
   if (a_len > 0)
     retval = Matrix (mx_inline_imag_dup (a.data (), a_len),
 		     a.rows (), a.cols ());
   return retval;
 }
 
 Matrix
-Matrix::extract (int r1, int c1, int r2, int c2) const
+Matrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
 {
-  if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
-
-  int new_r = r2 - r1 + 1;
-  int new_c = c2 - c1 + 1;
+  if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
+
+  octave_idx_type new_r = r2 - r1 + 1;
+  octave_idx_type new_c = c2 - c1 + 1;
 
   Matrix result (new_r, new_c);
 
-  for (int j = 0; j < new_c; j++)
-    for (int i = 0; i < new_r; i++)
+  for (octave_idx_type j = 0; j < new_c; j++)
+    for (octave_idx_type i = 0; i < new_r; i++)
       result.xelem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 Matrix
-Matrix::extract_n (int r1, int c1, int nr, int nc) const
+Matrix::extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const
 {
   Matrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       result.xelem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 // extract row or column i.
 
 RowVector
-Matrix::row (int i) const
+Matrix::row (octave_idx_type i) const
 {
-  int nc = cols ();
+  octave_idx_type nc = cols ();
   if (i < 0 || i >= rows ())
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector ();
     }
 
   RowVector retval (nc);
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     retval.xelem (j) = elem (i, j);
 
   return retval;
 }
 
 RowVector
 Matrix::row (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return row (0);
+    return row ( static_cast<octave_idx_type>(0) );
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector ();
     }
 }
 
 ColumnVector
-Matrix::column (int i) const
+Matrix::column (octave_idx_type i) const
 {
-  int nr = rows ();
+  octave_idx_type nr = rows ();
   if (i < 0 || i >= cols ())
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector ();
     }
 
   ColumnVector retval (nr);
-  for (int j = 0; j < nr; j++)
+  for (octave_idx_type j = 0; j < nr; j++)
     retval.xelem (j) = elem (j, i);
 
   return retval;
 }
 
 ColumnVector
 Matrix::column (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return column (0);
+    return column (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector ();
     }
 }
 
 Matrix
 Matrix::inverse (void) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return inverse (info, rcond, 0, 0);
 }
 
 Matrix
-Matrix::inverse (int& info) const
+Matrix::inverse (octave_idx_type& info) const
 {
   double rcond;
   return inverse (info, rcond, 0, 0);
 }
 
 Matrix
-Matrix::inverse (int& info, double& rcond, int force, int calc_cond) const
+Matrix::inverse (octave_idx_type& info, double& rcond, int force, int calc_cond) const
 {
   Matrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
-      Array<int> ipvt (nr);
-      int *pipvt = ipvt.fortran_vec ();
+      Array<octave_idx_type> ipvt (nr);
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       retval = *this;
       double *tmp_data = retval.fortran_vec ();
 
       Array<double> z(1);
-      int lwork = -1;
+      octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt, 
 				 z.fortran_vec (), lwork, info));
 
       if (f77_exception_encountered) 
 	{
 	  (*current_liboctave_error_handler)
 	    ("unrecoverable error in dgetri");
 	  return retval;
 	}
 
-      lwork = static_cast<int> (z(0));
+      lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
-	anorm = retval.abs().sum().row(0).max();
+	anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
       else
 	{
 	  // Throw-away extra info LAPACK gives so as to not change output.
 	  rcond = 0.0;
 	  if (info != 0) 
 	    info = -1;
 	  else if (calc_cond) 
 	    {
-	      int dgecon_info = 0;
+	      octave_idx_type dgecon_info = 0;
 
 	      // Now calculate the condition number for non-singular matrix.
 	      char job = '1';
-	      Array<int> iz (nc);
-	      int *piz = iz.fortran_vec ();
+	      Array<octave_idx_type> iz (nc);
+	      octave_idx_type *piz = iz.fortran_vec ();
 	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					 nc, tmp_data, nr, anorm, 
 					 rcond, pz, piz, dgecon_info
 					 F77_CHAR_ARG_LEN (1)));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler) 
 		  ("unrecoverable error in dgecon");
@@ -706,17 +706,17 @@ Matrix::inverse (int& info, double& rcon
 	      if (dgecon_info != 0) 
 		info = -1;
 	    }
 
 	  if (info == -1 && ! force)
 	    retval = *this; // Restore matrix contents.
 	  else
 	    {
-	      int dgetri_info = 0;
+	      octave_idx_type dgetri_info = 0;
 
 	      F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
 					 pz, lwork, dgetri_info));
 
 	      if (f77_exception_encountered)
 		(*current_liboctave_error_handler)
 		  ("unrecoverable error in dgetri");
 
@@ -735,19 +735,19 @@ Matrix::pseudo_inverse (double tol) cons
   SVD result (*this, SVD::economy);
 
   DiagMatrix S = result.singular_values ();
   Matrix U = result.left_singular_matrix ();
   Matrix V = result.right_singular_matrix ();
 
   ColumnVector sigma = S.diag ();
 
-  int r = sigma.length () - 1;
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type r = sigma.length () - 1;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (tol <= 0.0)
     {
       if (nr > nc)
 	tol = nr * sigma.elem (0) * DBL_EPSILON;
       else
 	tol = nc * sigma.elem (0) * DBL_EPSILON;
     }
@@ -854,128 +854,128 @@ Matrix::ifourier2d (void) const
 
 #else
 
 ComplexMatrix
 Matrix::fourier (void) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
-
-  int npts, nsamples;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  int nn = 4*npts+15;
+  octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
-
-  int npts, nsamples;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  int nn = 4*npts+15;
+  octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
       F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
-  for (int j = 0; j < npts*nsamples; j++)
+  for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::fourier2d (void) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
-
-  int npts, nsamples;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  int nn = 4*npts+15;
+  octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
       F77_FUNC (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
     }
 
   npts = nc;
   nsamples = nr;
@@ -984,147 +984,147 @@ Matrix::fourier2d (void) const
   wsave.resize (nn);
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (npts);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
-      for (int i = 0; i < npts; i++)
+      for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-      for (int i = 0; i < npts; i++)
+      for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier2d (void) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
-
-  int npts, nsamples;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  int nn = 4*npts+15;
+  octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
       F77_FUNC (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
     }
 
-  for (int j = 0; j < npts*nsamples; j++)
+  for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn);
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (npts);
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int j = 0; j < nsamples; j++)
+  for (octave_idx_type j = 0; j < nsamples; j++)
     {
       OCTAVE_QUIT;
 
-      for (int i = 0; i < npts; i++)
+      for (octave_idx_type i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-      for (int i = 0; i < npts; i++)
+      for (octave_idx_type i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
 
   return retval;
 }
 
 #endif
 
 DET
 Matrix::determinant (void) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 DET
-Matrix::determinant (int& info) const
+Matrix::determinant (octave_idx_type& info) const
 {
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 DET
-Matrix::determinant (int& info, double& rcond, int calc_cond) const
+Matrix::determinant (octave_idx_type& info, double& rcond, int calc_cond) const
 {
   DET retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0)
     {
       double d[2];
       d[0] = 1.0;
       d[1] = 0.0;
       retval = DET (d);
     }
   else
     {
-      Array<int> ipvt (nr);
-      int *pipvt = ipvt.fortran_vec ();
+      Array<octave_idx_type> ipvt (nr);
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
-	anorm = atmp.abs().sum().row(0).max();
+	anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
       else
 	{
 	  // Throw-away extra info LAPACK gives so as to not change output.
@@ -1137,18 +1137,18 @@ Matrix::determinant (int& info, double& 
 	  else 
 	    {
 	      if (calc_cond) 
 		{
 		  // Now calc the condition number for non-singular matrix.
 		  char job = '1';
 		  Array<double> z (4 * nc);
 		  double *pz = z.fortran_vec ();
-		  Array<int> iz (nc);
-		  int *piz = iz.fortran_vec ();
+		  Array<octave_idx_type> iz (nc);
+		  octave_idx_type *piz = iz.fortran_vec ();
 
 		  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nc, tmp_data, nr, anorm, 
 					     rcond, pz, piz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (f77_exception_encountered)
 		    (*current_liboctave_error_handler) 
@@ -1158,17 +1158,17 @@ Matrix::determinant (int& info, double& 
 	      if (info != 0) 
 		{
 		  info = -1;
 		  retval = DET ();
 		} 
 	      else 
 		{
 		  double d[2] = { 1., 0.};
-		  for (int i=0; i<nc; i++) 
+		  for (octave_idx_type i=0; i<nc; i++) 
 		    {
 		      if (ipvt(i) != (i+1)) d[0] = -d[0];
 		      d[0] *= atmp(i,i);
 		      if (d[0] == 0.) break;
 		      while (fabs(d[0]) < 1.) 
 			{
 			  d[0] = 10. * d[0];
 			  d[1] = d[1] - 1.0;
@@ -1186,63 +1186,63 @@ Matrix::determinant (int& info, double& 
     }
 
   return retval;
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-Matrix::solve (const Matrix& b, int& info) const
+Matrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-Matrix::solve (const Matrix& b, int& info, double& rcond) const
+Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-Matrix::solve (const Matrix& b, int& info, double& rcond,
+Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   Matrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       info = 0;
 
-      Array<int> ipvt (nr);
-      int *pipvt = ipvt.fortran_vec ();
+      Array<octave_idx_type> ipvt (nr);
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       Array<double> z (4 * nc);
       double *pz = z.fortran_vec ();
-      Array<int> iz (nc);
-      int *piz = iz.fortran_vec ();
+      Array<octave_idx_type> iz (nc);
+      octave_idx_type *piz = iz.fortran_vec ();
 
       // Calculate the norm of the matrix, for later use.
-      double anorm = atmp.abs().sum().row(0).max();
+      double anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
       else
 	{
 	  // Throw-away extra info LAPACK gives so as to not change output.
@@ -1287,17 +1287,17 @@ Matrix::solve (const Matrix& b, int& inf
 		      ("matrix singular to machine precision, rcond = %g",
 		       rcond);
 		}
 	      else
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nc = b.cols ();
 
 		  job = 'N';
 		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, b_nc, tmp_data, nr,
 					     pipvt, result, b.rows(), info
 					     F77_CHAR_ARG_LEN (1)));
 		
 		  if (f77_exception_encountered)
@@ -1314,86 +1314,86 @@ Matrix::solve (const Matrix& b, int& inf
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
 
 ComplexMatrix
-Matrix::solve (const ComplexMatrix& b, int& info) const
+Matrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 ComplexMatrix
-Matrix::solve (const ComplexMatrix& b, int& info, double& rcond) const
+Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcond);
 }
 
 ComplexMatrix
-Matrix::solve (const ComplexMatrix& b, int& info, double& rcond,
+Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcond, sing_handler);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b) const
 {
-  int info; double rcond;
+  octave_idx_type info; double rcond;
   return solve (b, info, rcond);
 }
 
 ColumnVector
-Matrix::solve (const ColumnVector& b, int& info) const
+Matrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond);
 }
 
 ColumnVector
-Matrix::solve (const ColumnVector& b, int& info, double& rcond) const
+Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ColumnVector
-Matrix::solve (const ColumnVector& b, int& info, double& rcond,
+Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   ColumnVector retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.length ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       info = 0;
 
-      Array<int> ipvt (nr);
-      int *pipvt = ipvt.fortran_vec ();
+      Array<octave_idx_type> ipvt (nr);
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       Array<double> z (4 * nc);
       double *pz = z.fortran_vec ();
-      Array<int> iz (nc);
-      int *piz = iz.fortran_vec ();
+      Array<octave_idx_type> iz (nc);
+      octave_idx_type *piz = iz.fortran_vec ();
 
       // Calculate the norm of the matrix, for later use.
-      double anorm = atmp.abs().sum().row(0).max();
+      double anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
       else
 	{
 	  // Throw-away extra info LAPACK gives so as to not change output.
@@ -1463,245 +1463,245 @@ Matrix::solve (const ColumnVector& b, in
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
 
 ComplexColumnVector
-Matrix::solve (const ComplexColumnVector& b, int& info) const
+Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 ComplexColumnVector
-Matrix::solve (const ComplexColumnVector& b, int& info, double& rcond) const
+Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcond);
 }
 
 ComplexColumnVector
-Matrix::solve (const ComplexColumnVector& b, int& info, double& rcond,
+Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcond, sing_handler);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 Matrix
-Matrix::lssolve (const Matrix& b, int& info) const
+Matrix::lssolve (const Matrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 Matrix
-Matrix::lssolve (const Matrix& b, int& info, int& rank) const
+Matrix::lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   Matrix retval;
 
-  int nrhs = b.cols ();
-
-  int m = rows ();
-  int n = cols ();
+  octave_idx_type nrhs = b.cols ();
+
+  octave_idx_type m = rows ();
+  octave_idx_type n = cols ();
 
   if (m == 0 || n == 0 || m != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of least squares problem");
   else
     {
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
-      int nrr = m > n ? m : n;
+      octave_idx_type nrr = m > n ? m : n;
       Matrix result (nrr, nrhs, 0.0);
 
-      for (int j = 0; j < nrhs; j++)
-	for (int i = 0; i < m; i++)
+      for (octave_idx_type j = 0; j < nrhs; j++)
+	for (octave_idx_type i = 0; i < m; i++)
 	  result.elem (i, j) = b.elem (i, j);
 
       double *presult = result.fortran_vec ();
 
-      int len_s = m < n ? m : n;
+      octave_idx_type len_s = m < n ? m : n;
       Array<double> s (len_s);
       double *ps = s.fortran_vec ();
 
       double rcond = -1.0;
 
       // Ask DGELSS what the dimension of WORK should be.
 
-      int lwork = -1;
+      octave_idx_type lwork = -1;
 
       Array<double> work (1);
 
       F77_XFCN (dgelss, DGELSS, (m, n, nrhs, tmp_data, m, presult, nrr, ps,
 				 rcond, rank, work.fortran_vec (),
 				 lwork, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgelss");
       else
 	{
-	  lwork = static_cast<int> (work(0));
+	  lwork = static_cast<octave_idx_type> (work(0));
 	  work.resize (lwork);
 
 	  F77_XFCN (dgelss, DGELSS, (m, n, nrhs, tmp_data, m, presult,
 				     nrr, ps, rcond, rank,
 				     work.fortran_vec (), lwork, info));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dgelss");
 	  else
 	    {
 	      retval.resize (n, nrhs);
-	      for (int j = 0; j < nrhs; j++)
-		for (int i = 0; i < n; i++)
+	      for (octave_idx_type j = 0; j < nrhs; j++)
+		for (octave_idx_type i = 0; i < n; i++)
 		  retval.elem (i, j) = result.elem (i, j);
 	    }
 	}
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b) const
 {
   ComplexMatrix tmp (*this);
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return tmp.lssolve (b, info, rank);
 }
 
 ComplexMatrix
-Matrix::lssolve (const ComplexMatrix& b, int& info) const
+Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
-  int rank;
+  octave_idx_type rank;
   return tmp.lssolve (b, info, rank);
 }
 
 ComplexMatrix
-Matrix::lssolve (const ComplexMatrix& b, int& info, int& rank) const
+Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ColumnVector
-Matrix::lssolve (const ColumnVector& b, int& info) const
+Matrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ColumnVector
-Matrix::lssolve (const ColumnVector& b, int& info, int& rank) const
+Matrix::lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   ColumnVector retval;
 
-  int nrhs = 1;
-
-  int m = rows ();
-  int n = cols ();
+  octave_idx_type nrhs = 1;
+
+  octave_idx_type m = rows ();
+  octave_idx_type n = cols ();
 
   if (m == 0 || n == 0 || m != b.length ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of least squares problem");
   else
     {
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
-      int nrr = m > n ? m : n;
+      octave_idx_type nrr = m > n ? m : n;
       ColumnVector result (nrr);
 
-      for (int i = 0; i < m; i++)
+      for (octave_idx_type i = 0; i < m; i++)
 	result.elem (i) = b.elem (i);
 
       double *presult = result.fortran_vec ();
 
-      int len_s = m < n ? m : n;
+      octave_idx_type len_s = m < n ? m : n;
       Array<double> s (len_s);
       double *ps = s.fortran_vec ();
 
       double rcond = -1.0;
 
       // Ask DGELSS what the dimension of WORK should be.
 
-      int lwork = -1;
+      octave_idx_type lwork = -1;
 
       Array<double> work (1);
 
       F77_XFCN (dgelss, DGELSS, (m, n, nrhs, tmp_data, m, presult, nrr, ps,
 				 rcond, rank, work.fortran_vec (),
 				 lwork, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dgelss");
       else
 	{
-	  lwork = static_cast<int> (work(0));
+	  lwork = static_cast<octave_idx_type> (work(0));
 	  work.resize (lwork);
 
 	  F77_XFCN (dgelss, DGELSS, (m, n, nrhs, tmp_data, m, presult,
 				     nrr, ps, rcond, rank,
 				     work.fortran_vec (), lwork, info));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler)
 	      ("unrecoverable error in dgelss");
 	  else
 	    {
 	      retval.resize (n);
-	      for (int i = 0; i < n; i++)
+	      for (octave_idx_type i = 0; i < n; i++)
 		retval.elem (i) = result.elem (i);
 	    }
 	}
     }
 
   return retval;
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b);
 }
 
 ComplexColumnVector
-Matrix::lssolve (const ComplexColumnVector& b, int& info) const
+Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info);
 }
 
 ComplexColumnVector
-Matrix::lssolve (const ComplexColumnVector& b, int& info, int& rank) const
+Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank);
 }
 
 // Constants for matrix exponential calculation.
 
 static double padec [] =
@@ -1718,41 +1718,41 @@ static double padec [] =
 
 Matrix
 Matrix::expm (void) const
 {
   Matrix retval;
 
   Matrix m = *this;
 
-  int nc = columns ();
+  octave_idx_type nc = columns ();
 
   // Preconditioning step 1: trace normalization to reduce dynamic
   // range of poles, but avoid making stable eigenvalues unstable.
 
   // trace shift value
   volatile double trshift = 0.0;
 
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     trshift += m.elem (i, i);
 
   trshift /= nc;
 
   if (trshift > 0.0)
     {
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	m.elem (i, i) -= trshift;
     }
 
   // Preconditioning step 2: balancing; code follows development
   // in AEPBAL
 
   double *p_m = m.fortran_vec ();
 
-  int info, ilo, ihi, ilos, ihis;
+  octave_idx_type info, ilo, ihi, ilos, ihis;
   Array<double> dpermute (nc);
   Array<double> dscale (nc);
 
   // permutation first
   char job = 'P';
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nc, p_m, nc, ilo, ihi,
 			     dpermute.fortran_vec (), info
@@ -1782,53 +1782,53 @@ Matrix::expm (void) const
 			       F77_CHAR_ARG_LEN (1)));
   
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler) ("unrecoverable error in dlange");
       return retval;
     }
 
-  int sqpow = (int) (inf_norm > 0.0
+  octave_idx_type sqpow = static_cast<octave_idx_type> (inf_norm > 0.0
 		     ? (1.0 + log (inf_norm) / log (2.0))
 		     : 0.0);
   
   // Check whether we need to square at all.
   
   if (sqpow < 0)
     sqpow = 0;
   
   if (sqpow > 0)
     {
       double scale_factor = 1.0;
-      for (int i = 0; i < sqpow; i++)
+      for (octave_idx_type i = 0; i < sqpow; i++)
 	scale_factor *= 2.0;
   
       m = m / scale_factor;
     }
   
   // npp, dpp: pade' approx polynomial matrices.
   
   Matrix npp (nc, nc, 0.0);
   Matrix dpp = npp;
   
   // Now powers a^8 ... a^1.
   
-  int minus_one_j = -1;
-  for (int j = 7; j >= 0; j--)
+  octave_idx_type minus_one_j = -1;
+  for (octave_idx_type j = 7; j >= 0; j--)
     {
       npp = m * npp + padec[j] * m;
       dpp = m * dpp + (minus_one_j * padec[j]) * m;
       minus_one_j *= -1;
     }
   
   // Zero power.
   
   dpp = -dpp;
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
       npp.elem (j, j) += 1.0;
       dpp.elem (j, j) += 1.0;
     }
   
   // Compute pade approximation = inverse (dpp) * npp.
 
   retval = dpp.solve (npp, info);
@@ -1838,136 +1838,136 @@ Matrix::expm (void) const
   while (sqpow)
     {
       retval = retval * retval;
       sqpow--;
     }
   
   // Reverse preconditioning step 2: inverse balancing.
   // apply inverse scaling to computed exponential
-  for (int i = 0; i < nc; i++)
-    for (int j = 0; j < nc; j++)
+  for (octave_idx_type i = 0; i < nc; i++)
+    for (octave_idx_type j = 0; j < nc; j++)
        retval(i,j) *= dscale(i) / dscale(j);
 
   OCTAVE_QUIT;
 
   // construct balancing permutation vector
-  Array<int> iperm (nc);
-  for (int i = 0; i < nc; i++)
+  Array<octave_idx_type> iperm (nc);
+  for (octave_idx_type i = 0; i < nc; i++)
     iperm(i) = i;  // identity permutation
 
   // leading permutations in forward order
-  for (int i = 0; i < (ilo-1); i++)
+  for (octave_idx_type i = 0; i < (ilo-1); i++)
     {
-      int swapidx = static_cast<int> (dpermute(i)) - 1;
-      int tmp = iperm(i);
+      octave_idx_type swapidx = static_cast<octave_idx_type> (dpermute(i)) - 1;
+      octave_idx_type tmp = iperm(i);
       iperm(i) = iperm (swapidx);
       iperm(swapidx) = tmp;
     }
 
   // trailing permutations must be done in reverse order
-  for (int i = nc - 1; i >= ihi; i--)
+  for (octave_idx_type i = nc - 1; i >= ihi; i--)
     {
-      int swapidx = static_cast<int> (dpermute(i)) - 1;
-      int tmp = iperm(i);
+      octave_idx_type swapidx = static_cast<octave_idx_type> (dpermute(i)) - 1;
+      octave_idx_type tmp = iperm(i);
       iperm(i) = iperm(swapidx);
       iperm(swapidx) = tmp;
     }
 
   // construct inverse balancing permutation vector
-  Array<int> invpvec (nc);
-  for (int i = 0; i < nc; i++)
+  Array<octave_idx_type> invpvec (nc);
+  for (octave_idx_type i = 0; i < nc; i++)
     invpvec(iperm(i)) = i;     // Thanks to R. A. Lippert for this method
 
   OCTAVE_QUIT;
  
   Matrix tmpMat = retval;
-  for (int i = 0; i < nc; i++)
-    for (int j = 0; j < nc; j++)
+  for (octave_idx_type i = 0; i < nc; i++)
+    for (octave_idx_type j = 0; j < nc; j++)
       retval(i,j) = tmpMat(invpvec(i),invpvec(j));
 
   // Reverse preconditioning step 1: fix trace normalization.
   
   if (trshift > 0.0)
     retval = exp (trshift) * retval;
 
   return retval;
 }
 
 Matrix&
 Matrix::operator += (const DiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
       gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
 
 Matrix&
 Matrix::operator -= (const DiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
       gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
 // unary operations
 
 boolMatrix
 Matrix::operator ! (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   boolMatrix b (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       b.elem (i, j) = ! elem (i, j);
 
   return b;
 }
 
 // column vector by row vector -> matrix operations
 
 Matrix
 operator * (const ColumnVector& v, const RowVector& a)
 {
   Matrix retval;
 
-  int len = v.length ();
+  octave_idx_type len = v.length ();
 
   if (len != 0)
     {
-      int a_len = a.length ();
+      octave_idx_type a_len = a.length ();
 
       retval.resize (len, a_len);
       double *c = retval.fortran_vec ();
 	  
       F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
 			       F77_CONST_CHAR_ARG2 ("N", 1),
 			       len, a_len, 1, 1.0, v.data (), len,
 			       a.data (), 1, 0.0, c, len
@@ -1989,82 +1989,82 @@ Matrix::map (d_d_Mapper f) const
 {
   Matrix b (*this);
   return b.apply (f);
 }
 
 boolMatrix
 Matrix::map (b_d_Mapper f) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   boolMatrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (elem(i,j));
 
   return retval;
 }
 
 Matrix&
 Matrix::apply (d_d_Mapper f)
 {
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     d[i] = f (d[i]);
 
   return *this;
 }
 
 bool
 Matrix::any_element_is_negative (bool neg_zero) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
   if (neg_zero)
     {
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	if (lo_ieee_signbit (elem (i)))
 	  return true;
     }
   else
     {
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	if (elem (i) < 0)
 	  return true;
     }
 
   return false;
 }
 
 
 bool
 Matrix::any_element_is_inf_or_nan (void) const
 {
-  int nel = nelem ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nelem ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
 
   return false;
 }
 
 bool
 Matrix::all_elements_are_int_or_inf_or_nan (void) const
 {
-  int nel = nelem ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nelem ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisnan (val) || D_NINT (val) == val)
 	continue;
       else
 	return false;
     }
 
@@ -2072,27 +2072,27 @@ Matrix::all_elements_are_int_or_inf_or_n
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
 bool
 Matrix::all_integers (double& max_val, double& min_val) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
   if (nel > 0)
     {
       max_val = elem (0);
       min_val = elem (0);
     }
   else
     return false;
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (val > max_val)
 	max_val = val;
 
       if (val < min_val)
 	min_val = val;
@@ -2102,19 +2102,19 @@ Matrix::all_integers (double& max_val, d
     }
 
   return true;
 }
 
 bool
 Matrix::too_large_for_float (void) const
 {
-  int nel = nelem ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nelem ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (val > FLT_MAX || val < FLT_MIN)
 	return true;
     }
 
   return false;
@@ -2174,110 +2174,110 @@ Matrix::sumsq (int dim) const
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 Matrix
 Matrix::abs (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval (i, j) = fabs (elem (i, j));
 
   return retval;
 }
 
 ColumnVector
 Matrix::diag (void) const
 {
   return diag (0);
 }
 
 ColumnVector
-Matrix::diag (int k) const
+Matrix::diag (octave_idx_type k) const
 {
-  int nnr = rows ();
-  int nnc = cols ();
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ColumnVector d;
 
   if (nnr > 0 && nnc > 0)
     {
-      int ndiag = (nnr < nnc) ? nnr : nnc;
+      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
       d.resize (ndiag);
 
       if (k > 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i+k);
 	}
       else if (k < 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i-k, i);
 	}
       else
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i);
 	}
     }
   else
     (*current_liboctave_error_handler)
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
 ColumnVector
 Matrix::row_min (void) const
 {
-  Array<int> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
 
 ColumnVector
-Matrix::row_min (Array<int>& idx_arg) const
+Matrix::row_min (Array<octave_idx_type>& idx_arg) const
 {
   ColumnVector result;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-	  int idx_j;
+	  octave_idx_type idx_j;
 
 	  double tmp_min = octave_NaN;
 
 	  for (idx_j = 0; idx_j < nc; idx_j++)
 	    {
 	      tmp_min = elem (i, idx_j);
 
 	      if (! octave_is_NaN_or_NA (tmp_min))
 		break;
 	    }
 
-	  for (int j = idx_j+1; j < nc; j++)
+	  for (octave_idx_type j = idx_j+1; j < nc; j++)
 	    {
 	      double tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (tmp < tmp_min)
 		{
 		  idx_j = j;
@@ -2291,48 +2291,48 @@ Matrix::row_min (Array<int>& idx_arg) co
     }
 
   return result;
 }
 
 ColumnVector
 Matrix::row_max (void) const
 {
-  Array<int> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return row_max (dummy_idx);
 }
 
 ColumnVector
-Matrix::row_max (Array<int>& idx_arg) const
+Matrix::row_max (Array<octave_idx_type>& idx_arg) const
 {
   ColumnVector result;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       idx_arg.resize (nr);
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-	  int idx_j;
+	  octave_idx_type idx_j;
 
 	  double tmp_max = octave_NaN;
 
 	  for (idx_j = 0; idx_j < nc; idx_j++)
 	    {
 	      tmp_max = elem (i, idx_j);
 
 	      if (! octave_is_NaN_or_NA (tmp_max))
 		break;
 	    }
 
-	  for (int j = idx_j+1; j < nc; j++)
+	  for (octave_idx_type j = idx_j+1; j < nc; j++)
 	    {
 	      double tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (tmp > tmp_max)
 		{
 		  idx_j = j;
@@ -2346,48 +2346,48 @@ Matrix::row_max (Array<int>& idx_arg) co
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_min (void) const
 {
-  Array<int> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return column_min (dummy_idx);
 }
 
 RowVector
-Matrix::column_min (Array<int>& idx_arg) const
+Matrix::column_min (Array<octave_idx_type>& idx_arg) const
 {
   RowVector result;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
         {
-	  int idx_i;
+	  octave_idx_type idx_i;
 
 	  double tmp_min = octave_NaN;
 
 	  for (idx_i = 0; idx_i < nr; idx_i++)
 	    {
 	      tmp_min = elem (idx_i, j);
 
 	      if (! octave_is_NaN_or_NA (tmp_min))
 		break;
 	    }
 
-	  for (int i = idx_i+1; i < nr; i++)
+	  for (octave_idx_type i = idx_i+1; i < nr; i++)
 	    {
 	      double tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (tmp < tmp_min)
 		{
 		  idx_i = i;
@@ -2401,48 +2401,48 @@ Matrix::column_min (Array<int>& idx_arg)
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_max (void) const
 {
-  Array<int> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return column_max (dummy_idx);
 }
 
 RowVector
-Matrix::column_max (Array<int>& idx_arg) const
+Matrix::column_max (Array<octave_idx_type>& idx_arg) const
 {
   RowVector result;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       idx_arg.resize (nc);
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
         {
-	  int idx_i;
+	  octave_idx_type idx_i;
 
 	  double tmp_max = octave_NaN;
 
 	  for (idx_i = 0; idx_i < nr; idx_i++)
 	    {
 	      tmp_max = elem (idx_i, j);
 
 	      if (! octave_is_NaN_or_NA (tmp_max))
 		break;
 	    }
 
-	  for (int i = idx_i+1; i < nr; i++)
+	  for (octave_idx_type i = idx_i+1; i < nr; i++)
 	    {
 	      double tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (tmp > tmp_max)
 		{
 		  idx_i = i;
@@ -2456,41 +2456,41 @@ Matrix::column_max (Array<int>& idx_arg)
     }
 
   return result;
 }
 
 std::ostream&
 operator << (std::ostream& os, const Matrix& a)
 {
-  for (int i = 0; i < a.rows (); i++)
+  for (octave_idx_type i = 0; i < a.rows (); i++)
     {
-      for (int j = 0; j < a.cols (); j++)
+      for (octave_idx_type j = 0; j < a.cols (); j++)
 	{
 	  os << " ";
 	  octave_write_double (os, a.elem (i, j));
 	}
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, Matrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (nr < 1 || nc < 1)
     is.clear (std::ios::badbit);
   else
     {
       double tmp;
-      for (int i = 0; i < nr; i++)
-	for (int j = 0; j < nc; j++)
+      for (octave_idx_type i = 0; i < nr; i++)
+	for (octave_idx_type j = 0; j < nc; j++)
 	  {
 	    tmp = octave_read_double (is);
 	    if (is)
 	      a.elem (i, j) = tmp;
 	    else
 	      goto done;
 	  }
     }
@@ -2538,21 +2538,21 @@ Sylvester (const Matrix& a, const Matrix
   Matrix ub = bs.unitary_matrix ();
   Matrix sch_b = bs.schur_matrix ();
   
   Matrix cx = ua.transpose () * c * ub;
   
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
-  int a_nr = a.rows ();
-  int b_nr = b.rows ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type b_nr = b.rows ();
 
   double scale;
-  int info;
+  octave_idx_type info;
 
   double *pa = sch_a.fortran_vec ();
   double *pb = sch_b.fortran_vec ();
   double *px = cx.fortran_vec ();
 
   F77_XFCN (dtrsyl, DTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
 			     F77_CONST_CHAR_ARG2 ("N", 1),
 			     1, a_nr, b_nr, pa, a_nr, pb,
@@ -2575,32 +2575,32 @@ Sylvester (const Matrix& a, const Matrix
 
 // matrix by matrix -> matrix operations
 
 Matrix
 operator * (const Matrix& m, const Matrix& a)
 {
   Matrix retval;
 
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.cols ();
+
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (nc != a_nr)
     gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
   else
     {
       if (nr == 0 || nc == 0 || a_nc == 0)
 	retval.resize (nr, a_nc, 0.0);
       else
 	{
-	  int ld  = nr;
-	  int lda = a_nr;
+	  octave_idx_type ld  = nr;
+	  octave_idx_type lda = a_nr;
 
 	  retval.resize (nr, a_nc);
 	  double *c = retval.fortran_vec ();
 
 	  F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
 				   F77_CONST_CHAR_ARG2 ("N", 1),
 				   nr, a_nc, nc, 1.0, m.data (),
 				   ld, a.data (), lda, 0.0, c, nr
@@ -2621,139 +2621,139 @@ operator * (const Matrix& m, const Matri
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 Matrix
 min (double d, const Matrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmin (d, m (i, j));
       }
 
   return result;
 }
 
 Matrix
 min (const Matrix& m, double d)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmin (m (i, j), d);
       }
 
   return result;
 }
 
 Matrix
 min (const Matrix& a, const Matrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.columns ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
 	("two-arg min expecting args of same size");
       return Matrix ();
     }
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmin (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 Matrix
 max (double d, const Matrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmax (d, m (i, j));
       }
 
   return result;
 }
 
 Matrix
 max (const Matrix& m, double d)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmax (m (i, j), d);
       }
 
   return result;
 }
 
 Matrix
 max (const Matrix& a, const Matrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.columns ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
     {
       (*current_liboctave_error_handler)
 	("two-arg max expecting args of same size");
       return Matrix ();
     }
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -33,19 +33,19 @@ class
 Matrix : public MArray2<double>
 {
 public:
 
   typedef void (*solve_singularity_handler) (double rcond);
 
   Matrix (void) : MArray2<double> () { }
 
-  Matrix (int r, int c) : MArray2<double> (r, c) { }
+  Matrix (octave_idx_type r, octave_idx_type c) : MArray2<double> (r, c) { }
 
-  Matrix (int r, int c, double val) : MArray2<double> (r, c, val) { }
+  Matrix (octave_idx_type r, octave_idx_type c, double val) : MArray2<double> (r, c, val) { }
 
   Matrix (const Matrix& a) : MArray2<double> (a) { }
 
   Matrix (const MArray2<double>& a) : MArray2<double> (a) { }
 
   explicit Matrix (const RowVector& rv);
 
   explicit Matrix (const ColumnVector& cv);
@@ -64,23 +64,23 @@ public:
 
   bool operator == (const Matrix& a) const;
   bool operator != (const Matrix& a) const;
 
   bool is_symmetric (void) const;
 
   // destructive insert/delete/reorder operations
 
-  Matrix& insert (const Matrix& a, int r, int c);
-  Matrix& insert (const RowVector& a, int r, int c);
-  Matrix& insert (const ColumnVector& a, int r, int c);
-  Matrix& insert (const DiagMatrix& a, int r, int c);
+  Matrix& insert (const Matrix& a, octave_idx_type r, octave_idx_type c);
+  Matrix& insert (const RowVector& a, octave_idx_type r, octave_idx_type c);
+  Matrix& insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c);
+  Matrix& insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c);
 
   Matrix& fill (double val);
-  Matrix& fill (double val, int r1, int c1, int r2, int c2);
+  Matrix& fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
 
   Matrix append (const Matrix& a) const;
   Matrix append (const RowVector& a) const;
   Matrix append (const ColumnVector& a) const;
   Matrix append (const DiagMatrix& a) const;
 
   Matrix stack (const Matrix& a) const;
   Matrix stack (const RowVector& a) const;
@@ -89,88 +89,88 @@ public:
 
   friend Matrix real (const ComplexMatrix& a);
   friend Matrix imag (const ComplexMatrix& a);
 
   Matrix transpose (void) const { return MArray2<double>::transpose (); }
 
   // resize is the destructive equivalent for this one
 
-  Matrix extract (int r1, int c1, int r2, int c2) const;
+  Matrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
-  Matrix extract_n (int r1, int c1, int nr, int nc) const;
+  Matrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
-  RowVector row (int i) const;
+  RowVector row (octave_idx_type i) const;
   RowVector row (char *s) const;
 
-  ColumnVector column (int i) const;
+  ColumnVector column (octave_idx_type i) const;
   ColumnVector column (char *s) const;
 
   Matrix inverse (void) const;
-  Matrix inverse (int& info) const;
-  Matrix inverse (int& info, double& rcond, int force = 0, 
+  Matrix inverse (octave_idx_type& info) const;
+  Matrix inverse (octave_idx_type& info, double& rcond, int force = 0, 
 		  int calc_cond = 1) const;
 
   Matrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   DET determinant (void) const;
-  DET determinant (int& info) const;
-  DET determinant (int& info, double& rcond, int calc_cond = 1) const;
+  DET determinant (octave_idx_type& info) const;
+  DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
   Matrix solve (const Matrix& b) const;
-  Matrix solve (const Matrix& b, int& info) const;
-  Matrix solve (const Matrix& b, int& info, double& rcond) const;
-  Matrix solve (const Matrix& b, int& info, double& rcond,
+  Matrix solve (const Matrix& b, octave_idx_type& info) const;
+  Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
+  Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
 		       solve_singularity_handler sing_handler) const;
 
   ColumnVector solve (const ColumnVector& b) const;
-  ColumnVector solve (const ColumnVector& b, int& info) const;
-  ColumnVector solve (const ColumnVector& b, int& info, double& rcond) const;
-  ColumnVector solve (const ColumnVector& b, int& info, double& rcond,
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const;
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 		      solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   Matrix lssolve (const Matrix& b) const;
-  Matrix lssolve (const Matrix& b, int& info) const;
-  Matrix lssolve (const Matrix& b, int& info, int& rank) const;
+  Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
+  Matrix lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info,
-			 int& rank) const;
+  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
+  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
+			 octave_idx_type& rank) const;
 
   ColumnVector lssolve (const ColumnVector& b) const;
-  ColumnVector lssolve (const ColumnVector& b, int& info) const;
-  ColumnVector lssolve (const ColumnVector& b, int& info, int& rank) const;
+  ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
+  ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
-			       int& rank) const;
+  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info,
+			       octave_idx_type& rank) const;
 
   Matrix expm (void) const;
 
   Matrix& operator += (const DiagMatrix& a);
   Matrix& operator -= (const DiagMatrix& a);
 
   // unary operations
 
@@ -199,40 +199,40 @@ public:
   Matrix cumprod (int dim = -1) const;
   Matrix cumsum (int dim = -1) const;
   Matrix prod (int dim = -1) const;
   Matrix sum (int dim = -1) const;
   Matrix sumsq (int dim = -1) const;
   Matrix abs (void) const;
 
   ColumnVector diag (void) const;
-  ColumnVector diag (int k) const;
+  ColumnVector diag (octave_idx_type k) const;
 
   ColumnVector row_min (void) const;
   ColumnVector row_max (void) const;
 
-  ColumnVector row_min (Array<int>& index) const;
-  ColumnVector row_max (Array<int>& index) const;
+  ColumnVector row_min (Array<octave_idx_type>& index) const;
+  ColumnVector row_max (Array<octave_idx_type>& index) const;
 
   RowVector column_min (void) const;
   RowVector column_max (void) const;
 
-  RowVector column_min (Array<int>& index) const;
-  RowVector column_max (Array<int>& index) const;
+  RowVector column_min (Array<octave_idx_type>& index) const;
+  RowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 
   static double resize_fill_value (void) { return 0; }
 
 private:
 
-  Matrix (double *d, int r, int c) : MArray2<double> (d, r, c) { }
+  Matrix (double *d, octave_idx_type r, octave_idx_type c) : MArray2<double> (d, r, c) { }
 };
 
 extern Matrix Givens (double, double);
 
 extern Matrix Sylvester (const Matrix&, const Matrix&, const Matrix&);
 
 extern Matrix operator * (const Matrix& a, const Matrix& b);
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -43,63 +43,63 @@ Software Foundation, 59 Temple Place - S
 ComplexNDArray
 NDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
-  int stride = 1;
-  int n = dv(dim);
+  octave_idx_type stride = 1;
+  octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  int howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv (dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  int nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
-  int dist = (stride == 1 ? n : 1);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type dist = (stride == 1 ? n : 1);
 
   const double *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
-  for (int k = 0; k < nloop; k++)
+  for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
 		      n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
-  int stride = 1;
-  int n = dv(dim);
+  octave_idx_type stride = 1;
+  octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  int howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv (dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  int nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
-  int dist = (stride == 1 ? n : 1);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type dist = (stride == 1 ? n : 1);
 
   ComplexNDArray retval (*this);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
-  for (int k = 0; k < nloop; k++)
+  for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (out + k * stride * n, out + k * stride * n, 
 		      n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
@@ -107,39 +107,39 @@ NDArray::fourier2d (void) const
   dim_vector dv = dims();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const double *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  int howmany = numel() / dv(0) / dv(1);
-  int dist = dv(0) * dv(1);
+  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type dist = dv(0) * dv(1);
 
-  for (int i=0; i < howmany; i++)
+  for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
   dim_vector dv = dims();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   ComplexNDArray retval (*this);
   Complex *out = retval.fortran_vec ();
-  int howmany = numel() / dv(0) / dv(1);
-  int dist = dv(0) * dv(1);
+  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type dist = dv(0) * dv(1);
 
-  for (int i=0; i < howmany; i++)
+  for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (out + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourierNd (void) const
 {
@@ -176,158 +176,158 @@ NDArray::ifourierNd (void) const
 extern "C"
 {
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
   // implicit double precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
   F77_RET_T
-  F77_FUNC (cffti, CFFTI) (const int&, Complex*);
+  F77_FUNC (cffti, CFFTI) (const octave_idx_type&, Complex*);
 
   F77_RET_T
-  F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
+  F77_FUNC (cfftf, CFFTF) (const octave_idx_type&, Complex*, Complex*);
 
   F77_RET_T
-  F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
+  F77_FUNC (cfftb, CFFTB) (const octave_idx_type&, Complex*, Complex*);
 }
 
 ComplexNDArray
 NDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
-  int npts = dv(dim);
-  int nn = 4*npts+15;
+  octave_idx_type npts = dv(dim);
+  octave_idx_type nn = 4*npts+15;
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
 
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  int howmany = numel () / npts;
+  octave_idx_type howmany = numel () / npts;
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  int dist = (stride == 1 ? npts : 1);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+  octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int k = 0; k < nloop; k++)
+  for (octave_idx_type k = 0; k < nloop; k++)
     {
-      for (int j = 0; j < howmany; j++)
+      for (octave_idx_type j = 0; j < howmany; j++)
 	{
 	  OCTAVE_QUIT;
 
-	  for (int i = 0; i < npts; i++)
+	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
-	  for (int i = 0; i < npts; i++)
+	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i];
 	}
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
-  int npts = dv(dim);
-  int nn = 4*npts+15;
+  octave_idx_type npts = dv(dim);
+  octave_idx_type nn = 4*npts+15;
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
 
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  int howmany = numel () / npts;
+  octave_idx_type howmany = numel () / npts;
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  int dist = (stride == 1 ? npts : 1);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+  octave_idx_type dist = (stride == 1 ? npts : 1);
 
   F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-  for (int k = 0; k < nloop; k++)
+  for (octave_idx_type k = 0; k < nloop; k++)
     {
-      for (int j = 0; j < howmany; j++)
+      for (octave_idx_type j = 0; j < howmany; j++)
 	{
 	  OCTAVE_QUIT;
 
-	  for (int i = 0; i < npts; i++)
+	  for (octave_idx_type i = 0; i < npts; i++)
 	    tmp[i] = elem((i + k*npts)*stride + j*dist);
 
 	  F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
-	  for (int i = 0; i < npts; i++)
+	  for (octave_idx_type i = 0; i < npts; i++)
 	    retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
 	      static_cast<double> (npts);
 	}
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
   dim_vector dv = dims();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
-      int npts = dv2(i);
-      int nn = 4*npts+15;
+      octave_idx_type npts = dv2(i);
+      octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
-      int howmany = numel () / npts;
+      octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
 		 (howmany > stride ? stride : howmany));
-      int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      int dist = (stride == 1 ? npts : 1);
+      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+      octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-      for (int k = 0; k < nloop; k++)
+      for (octave_idx_type k = 0; k < nloop; k++)
 	{
-	  for (int j = 0; j < howmany; j++)
+	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
 	      OCTAVE_QUIT;
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
 	    }
 	}
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -335,47 +335,47 @@ NDArray::fourier2d (void) const
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
   dim_vector dv = dims();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
-      int npts = dv2(i);
-      int nn = 4*npts+15;
+      octave_idx_type npts = dv2(i);
+      octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
-      int howmany = numel () / npts;
+      octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
 		 (howmany > stride ? stride : howmany));
-      int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      int dist = (stride == 1 ? npts : 1);
+      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+      octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-      for (int k = 0; k < nloop; k++)
+      for (octave_idx_type k = 0; k < nloop; k++)
 	{
-	  for (int j = 0; j < howmany; j++)
+	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
 	      OCTAVE_QUIT;
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] / 
 		  static_cast<double> (npts);
 	    }
 	}
 
       stride *= dv2(i);
     }
 
@@ -383,94 +383,94 @@ NDArray::ifourier2d (void) const
 }
 
 ComplexNDArray
 NDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
   int rank = dv.length ();
   ComplexNDArray retval (*this);
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
-      int npts = dv(i);
-      int nn = 4*npts+15;
+      octave_idx_type npts = dv(i);
+      octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
-      int howmany = numel () / npts;
+      octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
 		 (howmany > stride ? stride : howmany));
-      int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      int dist = (stride == 1 ? npts : 1);
+      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+      octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-      for (int k = 0; k < nloop; k++)
+      for (octave_idx_type k = 0; k < nloop; k++)
 	{
-	  for (int j = 0; j < howmany; j++)
+	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
 	      OCTAVE_QUIT;
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l];
 	    }
 	}
 
       stride *= dv(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
   int rank = dv.length ();
   ComplexNDArray retval (*this);
-  int stride = 1;
+  octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
-      int npts = dv(i);
-      int nn = 4*npts+15;
+      octave_idx_type npts = dv(i);
+      octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
-      int howmany = numel () / npts;
+      octave_idx_type howmany = numel () / npts;
       howmany = (stride == 1 ? howmany : 
 		 (howmany > stride ? stride : howmany));
-      int nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      int dist = (stride == 1 ? npts : 1);
+      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
+      octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
-      for (int k = 0; k < nloop; k++)
+      for (octave_idx_type k = 0; k < nloop; k++)
 	{
-	  for (int j = 0; j < howmany; j++)
+	  for (octave_idx_type j = 0; j < howmany; j++)
 	    {
 	      OCTAVE_QUIT;
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		prow[l] = retval ((l + k*npts)*stride + j*dist);
 
 	      F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
-	      for (int l = 0; l < npts; l++)
+	      for (octave_idx_type l = 0; l < npts; l++)
 		retval ((l + k*npts)*stride + j*dist) = prow[l] /
 		  static_cast<double> (npts);
 	    }
 	}
 
       stride *= dv(i);
     }
 
@@ -481,65 +481,65 @@ NDArray::ifourierNd (void) const
 
 // unary operations
 
 boolNDArray
 NDArray::operator ! (void) const
 {
   boolNDArray b (dims ());
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     b.elem (i) = ! elem (i);
 
   return b;
 }
 
 bool
 NDArray::any_element_is_negative (bool neg_zero) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
   if (neg_zero)
     {
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	if (lo_ieee_signbit (elem (i)))
 	  return true;
     }
   else
     {
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	if (elem (i) < 0)
 	  return true;
     }
 
   return false;
 }
 
 
 bool
 NDArray::any_element_is_inf_or_nan (void) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
 
   return false;
 }
 
 bool
 NDArray::all_elements_are_int_or_inf_or_nan (void) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
       if (xisnan (val) || D_NINT (val) == val)
 	continue;
       else
 	return false;
     }
 
@@ -547,27 +547,27 @@ NDArray::all_elements_are_int_or_inf_or_
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
 bool
 NDArray::all_integers (double& max_val, double& min_val) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
   if (nel > 0)
     {
       max_val = elem (0);
       min_val = elem (0);
     }
   else
     return false;
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (val > max_val)
 	max_val = val;
 
       if (val < min_val)
 	min_val = val;
@@ -577,19 +577,19 @@ NDArray::all_integers (double& max_val, 
     }
 
   return true;
 }
 
 bool
 NDArray::too_large_for_float (void) const
 {
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = elem (i);
 
       if (val > FLT_MAX || val < FLT_MIN)
 	return true;
     }
 
   return false;
@@ -639,69 +639,69 @@ NDArray
 NDArray::sum (int dim) const
 {
   MX_ND_REAL_OP_REDUCTION (+= elem (iter_idx), 0);
 }
 
 NDArray
 NDArray::max (int dim) const
 {
-  ArrayN<int> dummy_idx;
+  ArrayN<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
 NDArray
-NDArray::max (ArrayN<int>& idx_arg, int dim) const
+NDArray::max (ArrayN<octave_idx_type>& idx_arg, int dim) const
 {
   dim_vector dv = dims ();
   dim_vector dr = dims ();
 
   if (dv.numel () == 0 || dim > dv.length () || dim < 0)
     return NDArray ();
   
   dr(dim) = 1;
 
   NDArray result (dr);
   idx_arg.resize (dr);
 
-  int x_stride = 1;
-  int x_len = dv(dim);
+  octave_idx_type x_stride = 1;
+  octave_idx_type x_len = dv(dim);
   for (int i = 0; i < dim; i++)
     x_stride *= dv(i);
 
-  for (int i = 0; i < dr.numel (); i++)
+  for (octave_idx_type i = 0; i < dr.numel (); i++)
     {
-      int x_offset;
+      octave_idx_type x_offset;
       if (x_stride == 1)
 	x_offset = i * x_len;
       else
 	{
-	  int x_offset2 = 0;
+	  octave_idx_type x_offset2 = 0;
 	  x_offset = i;
 	  while (x_offset >= x_stride)
 	    {
 	      x_offset -= x_stride;
 	      x_offset2++;
 	    }
 	  x_offset += x_offset2 * x_stride * x_len;
 	}
 
-      int idx_j;
+      octave_idx_type idx_j;
 
       double tmp_max = octave_NaN;
 
       for (idx_j = 0; idx_j < x_len; idx_j++)
 	{
 	  tmp_max = elem (idx_j * x_stride + x_offset);
 	  
 	  if (! octave_is_NaN_or_NA (tmp_max))
 	    break;
 	}
 
-      for (int j = idx_j+1; j < x_len; j++)
+      for (octave_idx_type j = idx_j+1; j < x_len; j++)
 	{
 	  double tmp = elem (j * x_stride + x_offset);
 
 	  if (octave_is_NaN_or_NA (tmp))
 	    continue;
 	  else if (tmp > tmp_max)
 	    {
 	      idx_j = j;
@@ -714,69 +714,69 @@ NDArray::max (ArrayN<int>& idx_arg, int 
     }
 
   return result;
 }
 
 NDArray
 NDArray::min (int dim) const
 {
-  ArrayN<int> dummy_idx;
+  ArrayN<octave_idx_type> dummy_idx;
   return min (dummy_idx, dim);
 }
 
 NDArray
-NDArray::min (ArrayN<int>& idx_arg, int dim) const
+NDArray::min (ArrayN<octave_idx_type>& idx_arg, int dim) const
 {
   dim_vector dv = dims ();
   dim_vector dr = dims ();
 
   if (dv.numel () == 0 || dim > dv.length () || dim < 0)
     return NDArray ();
   
   dr(dim) = 1;
 
   NDArray result (dr);
   idx_arg.resize (dr);
 
-  int x_stride = 1;
-  int x_len = dv(dim);
+  octave_idx_type x_stride = 1;
+  octave_idx_type x_len = dv(dim);
   for (int i = 0; i < dim; i++)
     x_stride *= dv(i);
 
-  for (int i = 0; i < dr.numel (); i++)
+  for (octave_idx_type i = 0; i < dr.numel (); i++)
     {
-      int x_offset;
+      octave_idx_type x_offset;
       if (x_stride == 1)
 	x_offset = i * x_len;
       else
 	{
-	  int x_offset2 = 0;
+	  octave_idx_type x_offset2 = 0;
 	  x_offset = i;
 	  while (x_offset >= x_stride)
 	    {
 	      x_offset -= x_stride;
 	      x_offset2++;
 	    }
 	  x_offset += x_offset2 * x_stride * x_len;
 	}
 
-      int idx_j;
+      octave_idx_type idx_j;
 
       double tmp_min = octave_NaN;
 
       for (idx_j = 0; idx_j < x_len; idx_j++)
 	{
 	  tmp_min = elem (idx_j * x_stride + x_offset);
 	  
 	  if (! octave_is_NaN_or_NA (tmp_min))
 	    break;
 	}
 
-      for (int j = idx_j+1; j < x_len; j++)
+      for (octave_idx_type j = idx_j+1; j < x_len; j++)
 	{
 	  double tmp = elem (j * x_stride + x_offset);
 
 	  if (octave_is_NaN_or_NA (tmp))
 	    continue;
 	  else if (tmp < tmp_min)
 	    {
 	      idx_j = j;
@@ -787,51 +787,51 @@ NDArray::min (ArrayN<int>& idx_arg, int 
       result.elem (i) = tmp_min;
       idx_arg.elem (i) = octave_is_NaN_or_NA (tmp_min) ? 0 : idx_j;
     }
 
   return result;
 }
 
 NDArray
-NDArray::concat (const NDArray& rb, const Array<int>& ra_idx)
+NDArray::concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 ComplexNDArray
-NDArray::concat (const ComplexNDArray& rb, const Array<int>& ra_idx)
+NDArray::concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   ComplexNDArray retval (*this);
   if (rb.numel () > 0)
     retval.insert (rb, ra_idx);
   return retval;
 }
 
 charNDArray
-NDArray::concat (const charNDArray& rb, const Array<int>& ra_idx)
+NDArray::concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   charNDArray retval (dims ());
-  int nel = numel ();
+  octave_idx_type nel = numel ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = elem (i);
 
       if (xisnan (d))
 	{
 	  (*current_liboctave_error_handler)
 	    ("invalid conversion from NaN to character");
 	  return retval;
 	}
       else
 	{
-	  int ival = NINT (d);
+	  octave_idx_type ival = NINTbig (d);
 
 	  if (ival < 0 || ival > UCHAR_MAX)
 	    // XXX FIXME XXX -- is there something
 	    // better we could do? Should we warn the user?
 	    ival = 0;
 
 	  retval.elem (i) = static_cast<char>(ival);
 	}
@@ -842,55 +842,55 @@ NDArray::concat (const charNDArray& rb, 
 
   retval.insert (rb, ra_idx);
   return retval;
 }
 
 NDArray
 real (const ComplexNDArray& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   NDArray retval;
   if (a_len > 0)
     retval = NDArray (mx_inline_real_dup (a.data (), a_len), a.dims ());
   return retval;
 }
 
 NDArray
 imag (const ComplexNDArray& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   NDArray retval;
   if (a_len > 0)
     retval = NDArray (mx_inline_imag_dup (a.data (), a_len), a.dims ());
   return retval;
 }
 
 NDArray&
-NDArray::insert (const NDArray& a, int r, int c)
+NDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   Array<double>::insert (a, r, c);
   return *this;
 }
 
 NDArray&
-NDArray::insert (const NDArray& a, const Array<int>& ra_idx)
+NDArray::insert (const NDArray& a, const Array<octave_idx_type>& ra_idx)
 {
   Array<double>::insert (a, ra_idx);
   return *this;
 }
 
 NDArray
 NDArray::abs (void) const
 {
   NDArray retval (dims ());
 
-  int nel = nelem ();
+  octave_idx_type nel = nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = fabs (elem (i));
 
   return retval;
 }
 
 Matrix
 NDArray::matrix_value (void) const
 {
@@ -913,56 +913,56 @@ NDArray::matrix_value (void) const
 	("invalid conversion of NDArray to Matrix");
       break;
     }
 
   return retval;
 }
 
 void
-NDArray::increment_index (Array<int>& ra_idx,
+NDArray::increment_index (Array<octave_idx_type>& ra_idx,
 			  const dim_vector& dimensions,
 			  int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
-int
-NDArray::compute_index (Array<int>& ra_idx,
+octave_idx_type
+NDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const NDArray& a)
 {
-  int nel = a.nelem ();
+  octave_idx_type nel = a.nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       os << " ";
       octave_write_double (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, NDArray& a)
 {
-  int nel = a.nelem ();
+  octave_idx_type nel = a.nelem ();
 
   if (nel < 1 )
     is.clear (std::ios::badbit);
   else
     {
       double tmp;
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	  {
 	    tmp = octave_read_double (is);
 	    if (is)
 	      a.elem (i) = tmp;
 	    else
 	      goto done;
 	  }
     }
@@ -978,132 +978,132 @@ operator >> (std::istream& is, NDArray& 
 #define EMPTY_RETURN_CHECK(T) \
   if (nel == 0)	\
     return T (dv);
 
 NDArray
 min (double d, const NDArray& m)
 {
   dim_vector dv = m.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
       result (i) = xmin (d, m (i));
     }
 
   return result;
 }
 
 NDArray
 min (const NDArray& m, double d)
 {
   dim_vector dv = m.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
       result (i) = xmin (d, m (i));
     }
 
   return result;
 }
 
 NDArray
 min (const NDArray& a, const NDArray& b)
 {
   dim_vector dv = a.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
 
   if (dv != b.dims ())
     {
       (*current_liboctave_error_handler)
 	("two-arg min expecting args of same size");
       return NDArray ();
     }
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
       result (i) = xmin (a (i), b (i));
     }
 
   return result;
 }
 
 NDArray
 max (double d, const NDArray& m)
 {
   dim_vector dv = m.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
       result (i) = xmax (d, m (i));
     }
 
   return result;
 }
 
 NDArray
 max (const NDArray& m, double d)
 {
   dim_vector dv = m.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
       result (i) = xmax (d, m (i));
     }
 
   return result;
 }
 
 NDArray
 max (const NDArray& a, const NDArray& b)
 {
   dim_vector dv = a.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
 
   if (dv != b.dims ())
     {
       (*current_liboctave_error_handler)
 	("two-arg max expecting args of same size");
       return NDArray ();
     }
 
   EMPTY_RETURN_CHECK (NDArray);
 
   NDArray result (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -72,27 +72,27 @@ public:
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   NDArray cumprod (int dim = -1) const;
   NDArray cumsum (int dim = -1) const;
   NDArray prod (int dim = -1) const;
   NDArray sum (int dim = -1) const;  
   NDArray sumsq (int dim = -1) const;
-  NDArray concat (const NDArray& rb, const Array<int>& ra_idx);
-  ComplexNDArray concat (const ComplexNDArray& rb, const Array<int>& ra_idx);
-  charNDArray concat (const charNDArray& rb, const Array<int>& ra_idx);
+  NDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
+  ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
+  charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   NDArray max (int dim = 0) const;
-  NDArray max (ArrayN<int>& index, int dim = 0) const;
+  NDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
   NDArray min (int dim = 0) const;
-  NDArray min (ArrayN<int>& index, int dim = 0) const;
+  NDArray min (ArrayN<octave_idx_type>& index, int dim = 0) const;
   
-  NDArray& insert (const NDArray& a, int r, int c);
-  NDArray& insert (const NDArray& a, const Array<int>& ra_idx);
+  NDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
+  NDArray& insert (const NDArray& a, const Array<octave_idx_type>& ra_idx);
 
   NDArray abs (void) const;
 
   ComplexNDArray fourier (int dim = 1) const;
   ComplexNDArray ifourier (int dim = 1) const;
 
   ComplexNDArray fourier2d (void) const;
   ComplexNDArray ifourier2d (void) const;
@@ -102,21 +102,21 @@ public:
 
   friend NDArray real (const ComplexNDArray& a);
   friend NDArray imag (const ComplexNDArray& a);
 
   Matrix matrix_value (void) const;
 
   NDArray squeeze (void) const { return MArrayN<double>::squeeze (); }
 
-  static void increment_index (Array<int>& ra_idx,
+  static void increment_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
-  static int compute_index (Array<int>& ra_idx,
+  static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions);
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const NDArray& a);
   friend std::istream& operator >> (std::istream& is, NDArray& a);
 
   static double resize_fill_value (void) { return 0; }
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -35,190 +35,190 @@ Software Foundation, 59 Temple Place - S
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
-			   const int&, const int&, const double&,
-			   const double*, const int&, const double*,
-			   const int&, const double&, double*, const int&
+			   const octave_idx_type&, const octave_idx_type&, const double&,
+			   const double*, const octave_idx_type&, const double*,
+			   const octave_idx_type&, const double&, double*, const octave_idx_type&
 			   F77_CHAR_ARG_LEN_DECL);
 
-  double F77_FUNC (ddot, DDOT) (const int&, const double*, const int&,
-				const double*, const int&);
+  double F77_FUNC (ddot, DDOT) (const octave_idx_type&, const double*, const octave_idx_type&,
+				const double*, const octave_idx_type&);
 }
 
 // Row Vector class.
 
 bool
 RowVector::operator == (const RowVector& a) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len != a.length ())
     return 0;
   return mx_inline_equal (data (), a.data (), len);
 }
 
 bool
 RowVector::operator != (const RowVector& a) const
 {
   return !(*this == a);
 }
 
 RowVector&
-RowVector::insert (const RowVector& a, int c)
+RowVector::insert (const RowVector& a, octave_idx_type c)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (c < 0 || c + a_len > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   if (a_len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 RowVector&
 RowVector::fill (double val)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (len > 0)
     {
       make_unique ();
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 RowVector&
-RowVector::fill (double val, int c1, int c2)
+RowVector::fill (double val, octave_idx_type c1, octave_idx_type c2)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   if (c2 >= c1)
     {
       make_unique ();
 
-      for (int i = c1; i <= c2; i++)
+      for (octave_idx_type i = c1; i <= c2; i++)
 	xelem (i) = val;
     }
 
   return *this;
 }
 
 RowVector
 RowVector::append (const RowVector& a) const
 {
-  int len = length ();
-  int nc_insert = len;
+  octave_idx_type len = length ();
+  octave_idx_type nc_insert = len;
   RowVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ColumnVector
 RowVector::transpose (void) const
 {
   return ColumnVector (*this);
 }
 
 RowVector
 real (const ComplexRowVector& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   RowVector retval;
   if (a_len > 0)
     retval = RowVector (mx_inline_real_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 RowVector
 imag (const ComplexRowVector& a)
 {
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
   RowVector retval;
   if (a_len > 0)
     retval = RowVector (mx_inline_imag_dup (a.data (), a_len), a_len);
   return retval;
 }
 
 RowVector
-RowVector::extract (int c1, int c2) const
+RowVector::extract (octave_idx_type c1, octave_idx_type c2) const
 {
-  if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
+  if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
-  int new_c = c2 - c1 + 1;
+  octave_idx_type new_c = c2 - c1 + 1;
 
   RowVector result (new_c);
 
-  for (int i = 0; i < new_c; i++)
+  for (octave_idx_type i = 0; i < new_c; i++)
     result.xelem (i) = elem (c1+i);
 
   return result;
 }
 
 RowVector
-RowVector::extract_n (int r1, int n) const
+RowVector::extract_n (octave_idx_type r1, octave_idx_type n) const
 {
   RowVector result (n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     result.xelem (i) = elem (r1+i);
 
   return result;
 }
 
 // row vector by matrix -> row vector
 
 RowVector
 operator * (const RowVector& v, const Matrix& a)
 {
   RowVector retval;
 
-  int len = v.length ();
+  octave_idx_type len = v.length ();
 
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
     gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
 	retval.resize (a_nc, 0.0);
       else
 	{
 	  // Transpose A to form A'*x == (x'*A)'
 
-	  int ld = a_nr;
+	  octave_idx_type ld = a_nr;
 
 	  retval.resize (a_nc);
 	  double *y = retval.fortran_vec ();
 
 	  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
 				   a_nr, a_nc, 1.0, a.data (),
 				   ld, v.data (), 1, 0.0, y, 1
 				   F77_CHAR_ARG_LEN (1)));
@@ -241,99 +241,99 @@ RowVector::map (d_d_Mapper f) const
   return b.apply (f);
 }
 
 RowVector&
 RowVector::apply (d_d_Mapper f)
 {
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
-  for (int i = 0; i < length (); i++)
+  for (octave_idx_type i = 0; i < length (); i++)
     d[i] = f (d[i]);
 
   return *this;
 }
 
 double
 RowVector::min (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len == 0)
     return 0;
 
   double res = elem (0);
 
-  for (int i = 1; i < len; i++)
+  for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) < res)
       res = elem (i);
 
   return res;
 }
 
 double
 RowVector::max (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
   if (len == 0)
     return 0;
 
   double res = elem (0);
 
-  for (int i = 1; i < len; i++)
+  for (octave_idx_type i = 1; i < len; i++)
     if (elem (i) > res)
       res = elem (i);
 
   return res;
 }
 
 std::ostream&
 operator << (std::ostream& os, const RowVector& a)
 {
 //  int field_width = os.precision () + 7;
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, RowVector& a)
 {
-  int len = a.length();
+  octave_idx_type len = a.length();
 
   if (len < 1)
     is.clear (std::ios::badbit);
   else
     {
       double tmp;
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
             a.elem (i) = tmp;
           else
             break;
         }
     }
   return is;
 }
 
 // other operations
 
 RowVector
-linspace (double x1, double x2, int n)
+linspace (double x1, double x2, octave_idx_type n)
 {
   RowVector retval;
 
   if (n > 1)
     {
       retval.resize (n);
       double delta = (x2 - x1) / (n - 1);
       retval.elem (0) = x1;
-      for (int i = 1; i < n-1; i++)
+      for (octave_idx_type i = 1; i < n-1; i++)
 	retval.elem (i) = x1 + i * delta;
       retval.elem (n-1) = x2;
     }
   else if (n == 1)
     {
       if (x1 == x2)
 	{
 	  retval.resize (1);
@@ -352,19 +352,19 @@ linspace (double x1, double x2, int n)
 
 // row vector by column vector -> scalar
 
 double
 operator * (const RowVector& v, const ColumnVector& a)
 {
   double retval = 0.0;
 
-  int len = v.length ();
+  octave_idx_type len = v.length ();
 
-  int a_len = a.length ();
+  octave_idx_type a_len = a.length ();
 
   if (len != a_len)
     gripe_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     retval = F77_FUNC (ddot, DDOT) (len, v.data (), 1, a.data (), 1);
 
   return retval;
 }
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -29,52 +29,52 @@ Software Foundation, 59 Temple Place - S
 
 class
 RowVector : public MArray<double>
 {
 public:
 
   RowVector (void) : MArray<double> () { }
 
-  explicit RowVector (int n) : MArray<double> (n) { }
+  explicit RowVector (octave_idx_type n) : MArray<double> (n) { }
 
-  RowVector (int n, double val) : MArray<double> (n, val) { }
+  RowVector (octave_idx_type n, double val) : MArray<double> (n, val) { }
 
   RowVector (const RowVector& a) : MArray<double> (a) { }
 
   RowVector (const MArray<double>& a) : MArray<double> (a) { }
 
   RowVector& operator = (const RowVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const RowVector& a) const;
   bool operator != (const RowVector& a) const;
 
   // destructive insert/delete/reorder operations
 
-  RowVector& insert (const RowVector& a, int c);
+  RowVector& insert (const RowVector& a, octave_idx_type c);
 
   RowVector& fill (double val);
-  RowVector& fill (double val, int c1, int c2);
+  RowVector& fill (double val, octave_idx_type c1, octave_idx_type c2);
 
   RowVector append (const RowVector& a) const;
 
   ColumnVector transpose (void) const;
 
   friend RowVector real (const ComplexRowVector& a);
   friend RowVector imag (const ComplexRowVector& a);
 
   // resize is the destructive equivalent for this one
 
-  RowVector extract (int c1, int c2) const;
+  RowVector extract (octave_idx_type c1, octave_idx_type c2) const;
 
-  RowVector extract_n (int c1, int n) const;
+  RowVector extract_n (octave_idx_type c1, octave_idx_type n) const;
 
   // row vector by matrix -> row vector
 
   friend RowVector operator * (const RowVector& a, const Matrix& b);
 
   // other operations
 
   RowVector map (d_d_Mapper f) const;
@@ -86,28 +86,28 @@ public:
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const RowVector& a);
   friend std::istream& operator >> (std::istream& is, RowVector& a);
 
 private:
 
-  RowVector (double *d, int l) : MArray<double> (d, l) { }
+  RowVector (double *d, octave_idx_type l) : MArray<double> (d, l) { }
 };
 
 // row vector by column vector -> scalar
 
 double operator * (const RowVector& a, const ColumnVector& b);
 
 Complex operator * (const RowVector& a, const ComplexColumnVector& b);
 
 // other operations
 
-RowVector linspace (double x1, double x2, int n);
+RowVector linspace (double x1, double x2, octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, RowVector, double)
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -47,112 +47,112 @@ extern "C" {
 #include <umfpack/umfpack.h>
 }
 #endif
 
 // Fortran functions we call.
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dgbtrf, DGBTRF) (const int&, const int&, const int&, 
-			     const int&, double*, const int&, int*, int&);
+  F77_FUNC (dgbtrf, DGBTRF) (const octave_idx_type&, const int&, const octave_idx_type&, 
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (dgbtrs, DGBTRS) (F77_CONST_CHAR_ARG_DECL, const int&,
-			     const int&, const int&, const int&, 
-			     const double*, const int&,
-			     const int*, double*, const int&, int&
+  F77_FUNC (dgbtrs, DGBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, 
+			     const double*, const octave_idx_type&,
+			     const octave_idx_type*, double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dgbcon, DGBCON) (F77_CONST_CHAR_ARG_DECL, const int&, 
-			     const int&, const int&, double*, 
-			     const int&, const int*, const double&, 
-			     double&, double*, int*, int&
+  F77_FUNC (dgbcon, DGBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, const octave_idx_type&, double*, 
+			     const octave_idx_type&, const octave_idx_type*, const double&, 
+			     double&, double*, octave_idx_type*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dpbtrf, DPBTRF) (F77_CONST_CHAR_ARG_DECL, const int&, 
-			     const int&, double*, const int&, int&
+  F77_FUNC (dpbtrf, DPBTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dpbtrs, DPBTRS) (F77_CONST_CHAR_ARG_DECL, const int&, 
-			     const int&, const int&, double*, const int&, 
-			     double*, const int&, int&
+  F77_FUNC (dpbtrs, DPBTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, const octave_idx_type&, double*, const octave_idx_type&, 
+			     double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dpbcon, DPBCON) (F77_CONST_CHAR_ARG_DECL, const int&, 
-			     const int&, double*, const int&, 
-			     const double&, double&, double*, int*, int&
+  F77_FUNC (dpbcon, DPBCON) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&, 
+			     const octave_idx_type&, double*, const octave_idx_type&, 
+			     const double&, double&, double*, octave_idx_type*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
-  F77_FUNC (dptsv, DPTSV) (const int&, const int&, double*, double*,
-			   double*, const int&, int&);
+  F77_FUNC (dptsv, DPTSV) (const octave_idx_type&, const octave_idx_type&, double*, double*,
+			   double*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (dgtsv, DGTSV) (const int&, const int&, double*, double*,
-			   double*, double*, const int&, int&);
+  F77_FUNC (dgtsv, DGTSV) (const octave_idx_type&, const octave_idx_type&, double*, double*,
+			   double*, double*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (dgttrf, DGTTRF) (const int&, double*, double*, double*, double*,
-			     int*, int&);
+  F77_FUNC (dgttrf, DGTTRF) (const octave_idx_type&, double*, double*, double*, double*,
+			     octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (dgttrs, DGTTRS) (F77_CONST_CHAR_ARG_DECL, const int&,
-			     const int&, const double*, const double*,
-			     const double*, const double*, const int*,
-			     double *, const int&, int&
+  F77_FUNC (dgttrs, DGTTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
+			     const octave_idx_type&, const double*, const double*,
+			     const double*, const double*, const octave_idx_type*,
+			     double *, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zptsv, ZPTSV) (const int&, const int&, Complex*, Complex*,
-			   Complex*, const int&, int&);
+  F77_FUNC (zptsv, ZPTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
+			   Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (zgtsv, ZGTSV) (const int&, const int&, Complex*, Complex*,
-			   Complex*, Complex*, const int&, int&);
+  F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
+			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 
 }
 
 SparseMatrix::SparseMatrix (const SparseBoolMatrix &a)
   : MSparse<double> (a.rows (), a.cols (), a.nnz ())
 {
-  int nc = cols ();
-  int nz = nnz ();
-
-  for (int i = 0; i < nc + 1; i++)
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
+
+  for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     {
       data (i) = a.data (i);
       ridx (i) = a.ridx (i);
     }
 }
 
 bool
 SparseMatrix::operator == (const SparseMatrix& a) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
-  int nr_a = a.rows ();
-  int nc_a = a.cols ();
-  int nz_a = a.nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
+  octave_idx_type nr_a = a.rows ();
+  octave_idx_type nc_a = a.cols ();
+  octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
-  for (int i = 0; i < nc + 1; i++)
+  for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
 	return false;
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
       return false;
 
   return true;
 }
 
 bool
 SparseMatrix::operator != (const SparseMatrix& a) const
@@ -160,73 +160,73 @@ SparseMatrix::operator != (const SparseM
   return !(*this == a);
 }
 
 bool
 SparseMatrix::is_symmetric (void) const
 {
   if (is_square () && rows () > 0)
     {
-      for (int i = 0; i < rows (); i++)
-	for (int j = i+1; j < cols (); j++)
+      for (octave_idx_type i = 0; i < rows (); i++)
+	for (octave_idx_type j = i+1; j < cols (); j++)
 	  if (elem (i, j) != elem (j, i))
 	    return false;
 
       return true;
     }
 
   return false;
 }
 
 SparseMatrix&
-SparseMatrix::insert (const SparseMatrix& a, int r, int c)
+SparseMatrix::insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   MSparse<double>::insert (a, r, c);
   return *this;
 }
 
 SparseMatrix
 SparseMatrix::max (int dim) const
 {
-  Array2<int> dummy_idx;
+  Array2<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
 SparseMatrix
-SparseMatrix::max (Array2<int>& idx_arg, int dim) const
+SparseMatrix::max (Array2<octave_idx_type>& idx_arg, int dim) const
 {
   SparseMatrix result;
   dim_vector dv = dims ();
 
   if (dv.numel () == 0 || dim > dv.length () || dim < 0)
     return result;
  
-  int nr = dv(0);
-  int nc = dv(1);
+  octave_idx_type nr = dv(0);
+  octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
       idx_arg.resize (1, nc);
-      int nel = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  double tmp_max = octave_NaN;
-	  int idx_j = 0;
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  octave_idx_type idx_j = 0;
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      if (ridx(i) != idx_j)
 		break;
 	      else
 		idx_j++;
 	    }
 
 	  if (idx_j != nr)
 	    tmp_max = 0.;
 
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      double tmp = data (i);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (octave_is_NaN_or_NA (tmp_max) || tmp > tmp_max)
 		{
 		  idx_j = ridx (i);
@@ -237,81 +237,81 @@ SparseMatrix::max (Array2<int>& idx_arg,
 
  	  idx_arg.elem (j) = octave_is_NaN_or_NA (tmp_max) ? 0 : idx_j;
 	  if (tmp_max != 0.)
 	    nel++;
 	}
 
       result = SparseMatrix (1, nc, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx (0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  double tmp = elem (idx_arg(j), j);
 	  if (tmp != 0.)
 	    {
 	      result.xdata (ii) = tmp;
 	      result.xridx (ii++) = 0;
 	    }
 	  result.xcidx (j+1) = ii;
 
 	}
     }
   else
     {
       idx_arg.resize (nr, 1, 0);
 
-      for (int i = cidx(0); i < cidx(1); i++)
+      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
 	idx_arg.elem(ridx(i)) = -1;
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    if (idx_arg.elem(i) != -1)
 	      continue;
 	    bool found = false;
-	    for (int k = cidx(j); k < cidx(j+1); k++)
+	    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
 	      if (ridx(k) == i)
 		{
 		  found = true;
 		  break;
 		}
 	    
 	    if (!found)
 	      idx_arg.elem(i) = j;
 
 	  }
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
-	      int ir = ridx (i);
-	      int ix = idx_arg.elem (ir);
+	      octave_idx_type ir = ridx (i);
+	      octave_idx_type ix = idx_arg.elem (ir);
 	      double tmp = data (i);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (ix == -1 || tmp > elem (ir, ix))
 		idx_arg.elem (ir) = j;
 	    }
 	}
 
-      int nel = 0;
-      for (int j = 0; j < nr; j++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nr; j++)
 	if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
 	  nel++;
 
       result = SparseMatrix (nr, 1, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
-      for (int j = 0; j < nr; j++)
+      for (octave_idx_type j = 0; j < nr; j++)
 	{
 	  if (idx_arg(j) == -1)
 	    {
 	      idx_arg(j) = 0;
 	      result.xdata (ii) = octave_NaN;
 	      result.xridx (ii++) = j;
 	    }
 	  else
@@ -327,52 +327,52 @@ SparseMatrix::max (Array2<int>& idx_arg,
     }
 
   return result;
 }
 
 SparseMatrix
 SparseMatrix::min (int dim) const
 {
-  Array2<int> dummy_idx;
+  Array2<octave_idx_type> dummy_idx;
   return min (dummy_idx, dim);
 }
 
 SparseMatrix
-SparseMatrix::min (Array2<int>& idx_arg, int dim) const
+SparseMatrix::min (Array2<octave_idx_type>& idx_arg, int dim) const
 {
   SparseMatrix result;
   dim_vector dv = dims ();
 
   if (dv.numel () == 0 || dim > dv.length () || dim < 0)
     return result;
  
-  int nr = dv(0);
-  int nc = dv(1);
+  octave_idx_type nr = dv(0);
+  octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
       idx_arg.resize (1, nc);
-      int nel = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  double tmp_min = octave_NaN;
-	  int idx_j = 0;
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  octave_idx_type idx_j = 0;
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      if (ridx(i) != idx_j)
 		break;
 	      else
 		idx_j++;
 	    }
 
 	  if (idx_j != nr)
 	    tmp_min = 0.;
 
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      double tmp = data (i);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (octave_is_NaN_or_NA (tmp_min) || tmp < tmp_min)
 		{
 		  idx_j = ridx (i);
@@ -383,81 +383,81 @@ SparseMatrix::min (Array2<int>& idx_arg,
 
  	  idx_arg.elem (j) = octave_is_NaN_or_NA (tmp_min) ? 0 : idx_j;
 	  if (tmp_min != 0.)
 	    nel++;
 	}
 
       result = SparseMatrix (1, nc, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx (0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  double tmp = elem (idx_arg(j), j);
 	  if (tmp != 0.)
 	    {
 	      result.xdata (ii) = tmp;
 	      result.xridx (ii++) = 0;
 	    }
 	  result.xcidx (j+1) = ii;
 
 	}
     }
   else
     {
       idx_arg.resize (nr, 1, 0);
 
-      for (int i = cidx(0); i < cidx(1); i++)
+      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
 	idx_arg.elem(ridx(i)) = -1;
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    if (idx_arg.elem(i) != -1)
 	      continue;
 	    bool found = false;
-	    for (int k = cidx(j); k < cidx(j+1); k++)
+	    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
 	      if (ridx(k) == i)
 		{
 		  found = true;
 		  break;
 		}
 	    
 	    if (!found)
 	      idx_arg.elem(i) = j;
 
 	  }
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
-	      int ir = ridx (i);
-	      int ix = idx_arg.elem (ir);
+	      octave_idx_type ir = ridx (i);
+	      octave_idx_type ix = idx_arg.elem (ir);
 	      double tmp = data (i);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 	      else if (ix == -1 || tmp < elem (ir, ix))
 		idx_arg.elem (ir) = j;
 	    }
 	}
 
-      int nel = 0;
-      for (int j = 0; j < nr; j++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nr; j++)
 	if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
 	  nel++;
 
       result = SparseMatrix (nr, 1, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
-      for (int j = 0; j < nr; j++)
+      for (octave_idx_type j = 0; j < nr; j++)
 	{
 	  if (idx_arg(j) == -1)
 	    {
 	      idx_arg(j) = 0;
 	      result.xdata (ii) = octave_NaN;
 	      result.xridx (ii++) = j;
 	    }
 	  else
@@ -471,126 +471,126 @@ SparseMatrix::min (Array2<int>& idx_arg,
 	    }
 	}
     }
 
   return result;
 }
 
 SparseMatrix
-SparseMatrix::concat (const SparseMatrix& rb, const Array<int>& ra_idx)
+SparseMatrix::concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx)
 {
   // Don't use numel to avoid all possiblity of an overflow
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (rb, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 SparseComplexMatrix
-SparseMatrix::concat (const SparseComplexMatrix& rb, const Array<int>& ra_idx)
+SparseMatrix::concat (const SparseComplexMatrix& rb, const Array<octave_idx_type>& ra_idx)
 {
   SparseComplexMatrix retval (*this);
   if (rb.rows () > 0 && rb.cols () > 0)
     retval.insert (rb, ra_idx(0), ra_idx(1));
   return retval;
 }
 
 SparseMatrix
 real (const SparseComplexMatrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
-  int nz = a.nnz ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
-  for (int i = 0; i < nc +1; i++)
+  for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx(i) = a.cidx(i);
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     {
       r.data(i) = std::real (a.data(i));
       r.ridx(i) = a.ridx(i);
     }
 
   return r;
 }
 
 SparseMatrix
 imag (const SparseComplexMatrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
-  int nz = a.nnz ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
-  for (int i = 0; i < nc +1; i++)
+  for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx(i) = a.cidx(i);
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     {
       r.data(i) = std::imag (a.data(i));
       r.ridx(i) = a.ridx(i);
     }
 
   return r;
 }
 
 SparseMatrix 
 atan2 (const double& x, const SparseMatrix& y)
 {
-  int nr = y.rows ();
-  int nc = y.cols ();
+  octave_idx_type nr = y.rows ();
+  octave_idx_type nc = y.cols ();
 
   if (x == 0.)
     return SparseMatrix (nr, nc);
   else
     {
       // Its going to be basically full, so this is probably the
       // best way to handle it.
       Matrix tmp (nr, nc, atan2 (x, 0.));
 
-      for (int j = 0; j < nc; j++)
-	for (int i = y.cidx (j); i < y.cidx (j+1); i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
 	  tmp.elem (y.ridx(i), j) = atan2 (x, y.data(i));
 
       return SparseMatrix (tmp);
     }
 }
 
 SparseMatrix 
 atan2 (const SparseMatrix& x, const double& y)
 {
-  int nr = x.rows ();
-  int nc = x.cols ();
-  int nz = x.nnz ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.cols ();
+  octave_idx_type nz = x.nnz ();
 
   SparseMatrix retval (nr, nc, nz);
 
-  int ii = 0;
+  octave_idx_type ii = 0;
   retval.xcidx(0) = 0;
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     {
-      for (int j = x.cidx(i); j < x.cidx(i+1); j++)
+      for (octave_idx_type j = x.cidx(i); j < x.cidx(i+1); j++)
 	{
 	  double tmp = atan2 (x.data(j), y);
 	  if (tmp != 0.)
 	    {
 	      retval.xdata (ii) = tmp;
 	      retval.xridx (ii++) = x.ridx (j);
 	    }
 	}
       retval.xcidx (i+1) = ii;
     }
 
   if (ii != nz)
     {
       SparseMatrix retval2 (nr, nc, ii);
-      for (int i = 0; i < nc+1; i++)
+      for (octave_idx_type i = 0; i < nc+1; i++)
 	retval2.xcidx (i) = retval.cidx (i);
-      for (int i = 0; i < ii; i++)
+      for (octave_idx_type i = 0; i < ii; i++)
 	{
 	  retval2.xdata (i) = retval.data (i);
 	  retval2.xridx (i) = retval.ridx (i);
 	}
       return retval2;
     }
   else
     return retval;
@@ -598,38 +598,38 @@ atan2 (const SparseMatrix& x, const doub
 
 SparseMatrix 
 atan2 (const SparseMatrix& x, const SparseMatrix& y)
 {
   SparseMatrix r;
 
   if ((x.rows() == y.rows()) && (x.cols() == y.cols())) 
     {
-      int x_nr = x.rows ();
-      int x_nc = x.cols ();
-
-      int y_nr = y.rows ();
-      int y_nc = y.cols ();
+      octave_idx_type x_nr = x.rows ();
+      octave_idx_type x_nc = x.cols ();
+
+      octave_idx_type y_nr = y.rows ();
+      octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
 	gripe_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
       else
 	{
 	  r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
        
-	  int jx = 0;
+	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
-	  for (int i = 0 ; i < x_nc ; i++)
+	  for (octave_idx_type i = 0 ; i < x_nc ; i++)
 	    {
-	      int  ja = x.cidx(i);
-	      int  ja_max = x.cidx(i+1);
+	      octave_idx_type  ja = x.cidx(i);
+	      octave_idx_type  ja_max = x.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
            
-	      int  jb = y.cidx(i);
-	      int  jb_max = y.cidx(i+1);
+	      octave_idx_type  jb = y.cidx(i);
+	      octave_idx_type  jb_max = y.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
 		  OCTAVE_QUIT;
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (x.ridx(ja) < y.ridx(jb))))
 		    {
@@ -670,60 +670,60 @@ atan2 (const SparseMatrix& x, const Spar
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
 SparseMatrix
 SparseMatrix::inverse (void) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return inverse (info, rcond, 0, 0);
 }
 
 SparseMatrix
-SparseMatrix::inverse (int& info) const
+SparseMatrix::inverse (octave_idx_type& info) const
 {
   double rcond;
   return inverse (info, rcond, 0, 0);
 }
 
 SparseMatrix
-SparseMatrix::inverse (int& info, double& rcond, int force, int calc_cond) const
+SparseMatrix::inverse (octave_idx_type& info, double& rcond, int force, int calc_cond) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseMatrix::inverse not implemented yet");
   return SparseMatrix ();
 }
 
 DET
 SparseMatrix::determinant (void) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 DET
-SparseMatrix::determinant (int& info) const
+SparseMatrix::determinant (octave_idx_type& info) const
 {
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 DET
-SparseMatrix::determinant (int& err, double& rcond, int) const
+SparseMatrix::determinant (octave_idx_type& err, double& rcond, int) const
 {
   DET retval;
 
 #ifdef HAVE_UMFPACK
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       double d[2];
       d[0] = 1.0;
       d[1] = 0.0;
       retval = DET (d);
     }
@@ -752,18 +752,18 @@ SparseMatrix::determinant (int& err, dou
       if (!xisnan (tmp))
 	Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU 
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       umfpack_di_report_control (control);
 
-      const int *Ap = cidx ();
-      const int *Ai = ridx ();
+      const octave_idx_type *Ap = cidx ();
+      const octave_idx_type *Ai = ridx ();
       const double *Ax = data ();
 
       umfpack_di_report_matrix (nr, nc, Ap, Ai, Ax, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = umfpack_di_qsymbolic (nr, nc, Ap, Ai, Ax, NULL,
@@ -827,49 +827,49 @@ SparseMatrix::determinant (int& err, dou
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 Matrix
-SparseMatrix::dsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseMatrix::dsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		      double& rcond, solve_singularity_handler) const
 {
   Matrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  retval.resize (b.rows (), b.cols());
 	  if (typ == SparseType::Diagonal)
-	    for (int j = 0; j < b.cols(); j++)
-	      for (int i = 0; i < nr; i++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
-	    for (int j = 0; j < b.cols(); j++)
-	      for (int i = 0; i < nr; i++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		retval(i,j) = b(ridx(i),j) / data (i);
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = fabs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -877,78 +877,78 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::dsolve (SparseType &mattype, const SparseMatrix& b, int& err, 
+SparseMatrix::dsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler) const
 {
   SparseMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (b_nr, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
+	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
-	    for (int j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
-	    for (int j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (int i = 0; i < nr; i++)
+		for (octave_idx_type i = 0; i < nr; i++)
 		  {
 		    bool found = false;
-		    int k;
+		    octave_idx_type k;
 		    for (k = b.cidx(j); k < b.cidx(j+1); k++)
 		      if (ridx(i) == b.ridx(k))
 			{
 			  found = true;
 			  break;
 			}
 		    if (found)
 		      {
 			retval.xridx (ii) = i;
 			retval.xdata (ii++) = b.data(k) / data (i);
 		      }
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = fabs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -956,49 +956,49 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b, int& err, 
+SparseMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  retval.resize (b.rows (), b.cols());
 	  if (typ == SparseType::Diagonal)
-	    for (int j = 0; j < b.cols(); j++)
-	      for (int i = 0; i < nr; i++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
-	    for (int j = 0; j < b.cols(); j++)
-	      for (int i = 0; i < nr; i++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		retval(i,j) = b(ridx(i),j) / data (i);
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = fabs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1007,78 +1007,78 @@ SparseMatrix::dsolve (SparseType &mattyp
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::dsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
+	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
-	    for (int j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
-	    for (int j = 0; j < b.cols(); j++)
+	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (int i = 0; i < nr; i++)
+		for (octave_idx_type i = 0; i < nr; i++)
 		  {
 		    bool found = false;
-		    int k;
+		    octave_idx_type k;
 		    for (k = b.cidx(j); k < b.cidx(j+1); k++)
 		      if (ridx(i) == b.ridx(k))
 			{
 			  found = true;
 			  break;
 			}
 		    if (found)
 		      {
 			retval.xridx (ii) = i;
 			retval.xdata (ii++) = b.data(k) / data (i);
 		      }
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = fabs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1086,182 +1086,182 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::utsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseMatrix::utsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		       double& rcond,
 		       solve_singularity_handler sing_handler) const
 {
   Matrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  int b_cols = b.cols ();
+	  octave_idx_type b_cols = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 		(*current_liboctave_warning_handler)
 		  ("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx+1)-1) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    retval (i, j) = work[p_perm[i]];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = b;
 	      double *x_vec = retval.fortran_vec ();
 
-	      for (int j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
-		  int offset = j * nr;
-		  for (int k = nr-1; k >= 0; k--)
+		  octave_idx_type offset = j * nr;
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (x_vec[k+offset] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = x_vec[k+offset] / 
 			    data(cidx(k+1)-1);
 			  x_vec[k+offset] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      x_vec[iidx+offset] = 
 				x_vec[iidx+offset] - tmp * data(i);
 			    }
 			}
 		    }
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -1296,23 +1296,23 @@ SparseMatrix::utsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::utsolve (SparseType &mattype, const SparseMatrix& b, int& err, 
+SparseMatrix::utsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler) const
 {
   SparseMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -1322,210 +1322,210 @@ SparseMatrix::utsolve (SparseType &matty
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
-	  int x_nz = b_nz;
+	  octave_idx_type ii = 0;
+	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx+1)-1) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[p_perm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[p_perm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -1559,183 +1559,183 @@ SparseMatrix::utsolve (SparseType &matty
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b, int& err, 
+SparseMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  int b_nc = b.cols ();
+	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx+1)-1) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    retval (i, j) = work[p_perm[i]];
 
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work2[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work2[q_perm[j]] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work2[iidx] != 0.)
 			{
 			  double tmp = work2[iidx] / data(cidx(iidx+1)-1);
 			  work2[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work2[idx2] = work2[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work2[i]);
 		      work2[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = b;
 	      Complex *x_vec = retval.fortran_vec ();
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  int offset = j * nr;
-		  for (int k = nr-1; k >= 0; k--)
+		  octave_idx_type offset = j * nr;
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (x_vec[k+offset] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = x_vec[k+offset] / 
 			    data(cidx(k+1)-1);
 			  x_vec[k+offset] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      x_vec[iidx+offset] = 
 				x_vec[iidx+offset] - tmp * data(i);
 			    }
 			}
 		    }
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -1771,23 +1771,23 @@ SparseMatrix::utsolve (SparseType &matty
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::utsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -1797,212 +1797,212 @@ SparseMatrix::utsolve (SparseType &matty
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
-	  int x_nz = b_nz;
+	  octave_idx_type ii = 0;
+	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx+1)-1) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[p_perm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[p_perm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work2[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work2[q_perm[j]] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work2[iidx] != 0.)
 			{
 			  double tmp = work2[iidx] / data(cidx(iidx+1)-1);
 			  work2[iidx] = tmp;
-			  for (int i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work2[idx2] = work2[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work2[i]);
 		      work2[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k+1)-1);
 			  work[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work2[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work2[j] = 1.;
 
-		  for (int k = j; k >= 0; k--)
+		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
 		      if (work2[k] != 0.)
 			{
 			  double tmp = work2[k] / data(cidx(k+1)-1);
 			  work2[k] = tmp;
-			  for (int i = cidx(k); i < cidx(k+1)-1; i++)
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work2[iidx] = work2[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work2[i]);
 		      work2[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2037,184 +2037,184 @@ SparseMatrix::utsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::ltsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseMatrix::ltsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		       double& rcond,
 		       solve_singularity_handler sing_handler) const
 {
   Matrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  int b_cols = b.cols ();
+	  octave_idx_type b_cols = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 		(*current_liboctave_warning_handler)
 		  ("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx)) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    retval (i, j) = work[p_perm[i]];
 
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = b;
 	      double *x_vec = retval.fortran_vec ();
 
-	      for (int j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
-		  int offset = j * nr;
-		  for (int k = 0; k < nr; k++)
+		  octave_idx_type offset = j * nr;
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
 		      if (x_vec[k+offset] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = x_vec[k+offset] / 
 			    data(cidx(k));
 			  x_vec[k+offset] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      x_vec[iidx+offset] = 
 				x_vec[iidx+offset] - tmp * data(i);
 			    }
 			}
 		    }
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nr; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2250,23 +2250,23 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, int& err, 
+SparseMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler) const
 {
   SparseMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -2276,211 +2276,211 @@ SparseMatrix::ltsolve (SparseType &matty
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
-	  int x_nz = b_nz;
+	  octave_idx_type ii = 0;
+	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 		(*current_liboctave_warning_handler)
 		  ("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx)) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[p_perm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[p_perm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[q_perm[j]] = 1.;
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work[iidx] != 0.)
 			{
 			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nr; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2516,184 +2516,184 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b, int& err, 
+SparseMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  int b_nc = b.cols ();
+	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx)) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    retval (i, j) = work[p_perm[i]];
 
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work2[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work2[q_perm[j]] = 1.;
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work2[iidx] != 0.)
 			{
 			  double tmp = work2[iidx] / data(cidx(iidx+1)-1);
 			  work2[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work2[idx2] = work2[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work2[i]);
 		      work2[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = b;
 	      Complex *x_vec = retval.fortran_vec ();
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  int offset = j * nr;
-		  for (int k = 0; k < nr; k++)
+		  octave_idx_type offset = j * nr;
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
 		      if (x_vec[k+offset] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = x_vec[k+offset] / 
 			    data(cidx(k));
 			  x_vec[k+offset] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      x_vec[iidx+offset] = 
 				x_vec[iidx+offset] - tmp * data(i);
 			    }
 			}
 		    }
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (int k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nr; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2730,23 +2730,23 @@ SparseMatrix::ltsolve (SparseType &matty
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::ltsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -2756,213 +2756,213 @@ SparseMatrix::ltsolve (SparseType &matty
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (int j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nr; j++)
 	    {
 	      double atmp = 0.;
-	      for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols ();
-	  int b_nz = b.nnz ();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols ();
+	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
-	  int ii = 0;
-	  int x_nz = b_nz;
+	  octave_idx_type ii = 0;
+	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      int *p_perm = mattype.triangular_row_perm ();
-	      int *q_perm = mattype.triangular_col_perm ();
+	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
+	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
 
 	      (*current_liboctave_warning_handler)
 		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 		      if (work[iidx] != 0.)
 			{
 			  if (ridx(cidx(iidx)) != iidx)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
 			  work[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work[idx2] = 
 				work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[p_perm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[p_perm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work2[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work2[q_perm[j]] = 1.;
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      int iidx = q_perm[k];
+		      octave_idx_type iidx = q_perm[k];
 
 		      if (work2[iidx] != 0.)
 			{
 			  double tmp = work2[iidx] / data(cidx(iidx+1)-1);
 			  work2[iidx] = tmp;
-			  for (int i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
 			    {
-			      int idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = q_perm[ridx(i)];
 			      work2[idx2] = work2[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = 0; i < j+1; i++)
+		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work2[i]);
 		      work2[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
-		  for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (int k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
-		  int new_nnz = 0;
-		  for (int i = 0; i < nr; i++)
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
-		      int sz = new_nnz * (b_nc - j) + x_nz;
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (int i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nr; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		work2[i] = 0.;
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work2[j] = 1.;
 
-		  for (int k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nr; k++)
 		    {
 
 		      if (work2[k] != 0.)
 			{
 			  double tmp = work2[k] / data(cidx(k));
 			  work2[k] = tmp;
-			  for (int i = cidx(k)+1; i < cidx(k+1); i++)
+			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
-			      int iidx = ridx(i);
+			      octave_idx_type iidx = ridx(i);
 			      work2[iidx] = work2[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (int i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += fabs(work2[i]);
 		      work2[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2998,24 +2998,24 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::trisolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseMatrix::trisolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		       double& rcond,
 		       solve_singularity_handler sing_handler) const
 {
   Matrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -3024,46 +3024,46 @@ SparseMatrix::trisolve (SparseType &matt
       
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii);
 		  ii += 2;
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		  }
 	    }
 	      
-	  int b_nc = b.cols();
+	  octave_idx_type b_nc = b.cols();
 	  retval = b;
 	  double *result = retval.fortran_vec ();
 
 	  F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result, 
 				   b.rows(), err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
@@ -3081,49 +3081,49 @@ SparseMatrix::trisolve (SparseType &matt
       if (typ == SparseType::Tridiagonal)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii++);
 		  DU[j] = data(ii++);
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		  DU[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j] = data(i);
 		  }
 	    }
 
-	  int b_nc = b.cols();
+	  octave_idx_type b_nc = b.cols();
 	  retval = b;
 	  double *result = retval.fortran_vec ();
 
 	  F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result, 
 				   b.rows(), err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
@@ -3146,23 +3146,23 @@ SparseMatrix::trisolve (SparseType &matt
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	       (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::trisolve (SparseType &mattype, const SparseMatrix& b, int& err, 
+SparseMatrix::trisolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler) const
 {
   SparseMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -3172,43 +3172,43 @@ SparseMatrix::trisolve (SparseType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal ||
 	  typ == SparseType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
 	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii++);
 		  DU[j] = data(ii++);
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		  DU[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j] = data(i);
 		  }
@@ -3231,29 +3231,29 @@ SparseMatrix::trisolve (SparseType &matt
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile int x_nz = b.nnz ();
-		  int b_nc = b.cols ();
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
-		  volatile int ii = 0;
+		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (double, work, nr);
 
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			work[i] = 0.;
-		      for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 			work[b.ridx(i)] = b.data(i);
 
 		      F77_XFCN (dgttrs, DGTTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, 1, DL, D, DU, DU2, pipvt, 
 				 work, b.rows (), err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -3261,30 +3261,30 @@ SparseMatrix::trisolve (SparseType &matt
 			{
 			  (*current_liboctave_error_handler)
 			    ("unrecoverable error in dgttrs");
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (work[i] != 0.)
 			  new_nnz++;
 
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (work[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = work[i];
 			  }
 		      retval.xcidx(j+1) = ii;
 		    }
 
@@ -3295,23 +3295,23 @@ SparseMatrix::trisolve (SparseType &matt
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::trisolve (SparseType &mattype, const ComplexMatrix& b, int& err, 
+SparseMatrix::trisolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -3321,47 +3321,47 @@ SparseMatrix::trisolve (SparseType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii);
 		  ii += 2;
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		  }
 	    }
 
-	  int b_nr = b.rows ();
-	  int b_nc = b.cols();
+	  octave_idx_type b_nr = b.rows ();
+	  octave_idx_type b_nc = b.cols();
 	  rcond = 1.;
 
 	  retval = b;
 	  Complex *result = retval.fortran_vec ();
 		  
 	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
 				   b_nr, err));
 
@@ -3382,50 +3382,50 @@ SparseMatrix::trisolve (SparseType &matt
       if (typ == SparseType::Tridiagonal)
 	{
 	  OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii++);
 		  DU[j] = data(ii++);
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		  DU[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j] = data(i);
 		  }
 	    }
 
-	  int b_nr = b.rows();
-	  int b_nc = b.cols();
+	  octave_idx_type b_nr = b.rows();
+	  octave_idx_type b_nc = b.cols();
 	  rcond = 1.;
 
 	  retval = b;
 	  Complex *result = retval.fortran_vec ();
 	      
 	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
 				   b_nr, err));
 
@@ -3451,23 +3451,23 @@ SparseMatrix::trisolve (SparseType &matt
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::trisolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -3477,43 +3477,43 @@ SparseMatrix::trisolve (SparseType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal ||
 	  typ == SparseType::Tridiagonal_Hermitian)
 	{
 	  OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
 	  OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
 	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  if (mattype.is_dense ())
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < nc-1; j++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
 		  D[j] = data(ii++);
 		  DL[j] = data(ii++);
 		  DU[j] = data(ii++);
 		}
 	      D[nc-1] = data(ii);
 	    }
 	  else
 	    {
 	      D[0] = 0.;
-	      for (int i = 0; i < nr - 1; i++)
+	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		  DU[i] = 0.;
 		}
 
-	      for (int j = 0; j < nc; j++)
-		for (int i = cidx(j); i < cidx(j+1); i++)
+	      for (octave_idx_type j = 0; j < nc; j++)
+		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j] = data(i);
 		  }
@@ -3536,32 +3536,32 @@ SparseMatrix::trisolve (SparseType &matt
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 		} 
 	      else 
 		{	
 		  rcond = 1.;
 		  char job = 'N';
-		  int b_nr = b.rows ();
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile int x_nz = b.nnz ();
-		  volatile int ii = 0;
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			{
 			  Complex c = b (i,j);
 			  Bx[i] = std::real (c);
 			  Bz[i] = std::imag (c);
 			}
 
 
 		      F77_XFCN (dgttrs, DGTTRS, 
@@ -3605,30 +3605,30 @@ SparseMatrix::trisolve (SparseType &matt
 			    ("SparseMatrix::solve solve failed");
 
 			  err = -1;
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0. || Bz[i] != 0.)
 			  new_nnz++;
 		      
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 			  
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0. || Bz[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = 
 			      Complex (Bx[i], Bz[i]);
 			  }
 
 		      retval.xcidx(j+1) = ii;
@@ -3641,55 +3641,55 @@ SparseMatrix::trisolve (SparseType &matt
       else if (typ != SparseType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::bsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseMatrix::bsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		       double& rcond,
 		       solve_singularity_handler sing_handler) const
 {
   Matrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Banded_Hermitian)
 	{
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_lower + 1;
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_lower + 1;
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
-		int ri = ridx (i);
+		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  // Calculate the norm of the matrix, for later use.
 	  // double anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
@@ -3753,17 +3753,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  //  }
 		  //else
 		  //    REST OF CODE, EXCEPT rcond=1
 
 		  rcond = 1.;
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nc = b.cols ();
 
 		  F77_XFCN (dpbtrs, DPBTRS, 
 			    (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nr, n_lower, b_nc, tmp_data,
 			     ldm, result, b.rows(), err
 			     F77_CHAR_ARG_LEN (1)));
 		    
 		  if (f77_exception_encountered)
@@ -3787,29 +3787,29 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_upper + 2 * n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgbtrf");
 	  else
@@ -3866,17 +3866,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  //  }
 		  //else
 		  //  REST OF CODE, EXCEPT rcond=1
 
 		  rcond = 1.;
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nc = b.cols ();
 
 		  job = 'N';
 		  F77_XFCN (dgbtrs, DGBTRS, 
 			    (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nr, n_lower, n_upper, b_nc, tmp_data,
 			     ldm, pipvt, result, b.rows(), err
 			     F77_CHAR_ARG_LEN (1)));
 		    
@@ -3889,23 +3889,23 @@ SparseMatrix::bsolve (SparseType &mattyp
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::bsolve (SparseType &mattype, const SparseMatrix& b, int& err, 
+SparseMatrix::bsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler) const
 {
   SparseMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -3917,27 +3917,27 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
-		int ri = ridx (i);
+		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
@@ -3952,30 +3952,30 @@ SparseMatrix::bsolve (SparseType &mattyp
 		{
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
 		  rcond = 1.;
-		  int b_nr = b.rows ();
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile int x_nz = b.nnz ();
-		  volatile int ii = 0;
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
 		  retval = SparseMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			Bx[i] = b.elem (i, j);
 
 		      F77_XFCN (dpbtrs, DPBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, n_lower, 1, tmp_data,
 				 ldm, Bx, b_nr, err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -3990,25 +3990,25 @@ SparseMatrix::bsolve (SparseType &mattyp
 		      if (err != 0)
 			{
 			  (*current_liboctave_error_handler) 
 			    ("SparseMatrix::solve solve failed");
 			  err = -1;
 			  break;
 			}
 
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			{
 			  double tmp = Bx[i];
 			  if (tmp != 0.0)
 			    {
 			      if (ii == x_nz)
 				{
 				  // Resize the sparse matrix
-				  int sz = x_nz * (b_nc - j) / b_nc;
+				  octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
 				  sz = (sz > 10 ? sz : 10) + x_nz;
 				  retval.change_capacity (sz);
 				  x_nz = sz;
 				}
 			      retval.xdata(ii) = tmp;
 			      retval.xridx(ii++) = i;
 			    }
 			}
@@ -4018,38 +4018,38 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
-	  int n_upper = mattype.nupper ();
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_upper + 2 * n_lower + 1;
+	  octave_idx_type n_upper = mattype.nupper ();
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgbtrf");
 	  else
@@ -4064,29 +4064,29 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile int x_nz = b.nnz ();
-		  int b_nc = b.cols ();
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
-		  volatile int ii = 0;
+		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (double, work, nr);
 
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			work[i] = 0.;
-		      for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 			work[b.ridx(i)] = b.data(i);
 
 		      F77_XFCN (dgbtrs, DGBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, n_lower, n_upper, 1, tmp_data,
 				 ldm, pipvt, work, b.rows (), err
 				 F77_CHAR_ARG_LEN (1)));
 		    
@@ -4094,30 +4094,30 @@ SparseMatrix::bsolve (SparseType &mattyp
 			{
 			  (*current_liboctave_error_handler)
 			    ("unrecoverable error in dgbtrs");
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (work[i] != 0.)
 			  new_nnz++;
 
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (work[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = work[i];
 			  }
 		      retval.xcidx(j+1) = ii;
 		    }
 
@@ -4128,55 +4128,55 @@ SparseMatrix::bsolve (SparseType &mattyp
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::bsolve (SparseType &mattype, const ComplexMatrix& b, int& err, 
+SparseMatrix::bsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
 		     double& rcond, solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Banded_Hermitian)
 	{
-	  int n_lower = mattype.nlower ();
-	  int ldm = n_lower + 1;
+	  octave_idx_type n_lower = mattype.nlower ();
+	  octave_idx_type ldm = n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
-		int ri = ridx (i);
+		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
@@ -4193,27 +4193,27 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  // unsymmetric banded solver.
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 		  err = 0;
 		} 
 	      else 
 		{
 		  rcond = 1.;
-		  int b_nr = b.rows ();
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
 
 		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 		  retval.resize (b_nr, b_nc);
 	      
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			{
 			  Complex c = b (i,j);
 			  Bx[i] = std::real (c);
 			  Bz[i] = std::imag (c);
 			}
 			  
 		      F77_XFCN (dpbtrs, DPBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
@@ -4254,17 +4254,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 		      if (err != 0)
 			{
 			  (*current_liboctave_error_handler) 
 			    ("SparseMatrix::solve solve failed");
 			  err = -1;
 			  break;
 			}
 
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			retval (i, j) = Complex (Bx[i], Bz[i]);
 		    }
 		}
 	    }
 	}
 
       if (typ == SparseType::Banded)
 	{
@@ -4273,29 +4273,29 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_upper + 2 * n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgbtrf");
 	  else
@@ -4310,25 +4310,25 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval.resize (nr,b_nc);
 
 		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
 
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			{
 			  Complex c = b (i, j);
 			  Bx[i] = std::real (c);
 			  Bz[i] = std::imag  (c);
 			}
 
 		      F77_XFCN (dgbtrs, DGBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
@@ -4351,38 +4351,38 @@ SparseMatrix::bsolve (SparseType &mattyp
 		    
 		      if (f77_exception_encountered)
 			{
 			  (*current_liboctave_error_handler)
 			    ("unrecoverable error in dgbtrs");
 			  break;
 			}
 
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			retval (i, j) = Complex (Bx[i], Bz[i]);
 		    }
 		}
 	    }
 	}
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::bsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -4394,27 +4394,27 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      {
-		int ri = ridx (i);
+		octave_idx_type ri = ridx (i);
 		if (ri >= j)
 		  m_band(ri - j, j) = data(i);
 	      }
 
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
@@ -4432,32 +4432,32 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  mattype.mark_as_unsymmetric ();
 		  typ = SparseType::Banded;
 
 		  err = 0;
 		} 
 	      else 
 		{
 		  rcond = 1.;
-		  int b_nr = b.rows ();
-		  int b_nc = b.cols ();
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile int x_nz = b.nnz ();
-		  volatile int ii = 0;
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
-		      for (int i = 0; i < b_nr; i++)
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			{
 			  Complex c = b (i,j);
 			  Bx[i] = std::real (c);
 			  Bz[i] = std::imag (c);
 			}
 
 		      F77_XFCN (dpbtrs, DPBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
@@ -4501,30 +4501,30 @@ SparseMatrix::bsolve (SparseType &mattyp
 			    ("SparseMatrix::solve solve failed");
 
 			  err = -1;
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0. || Bz[i] != 0.)
 			  new_nnz++;
 			  
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 			  
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0. || Bz[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = 
 			      Complex (Bx[i], Bz[i]);
 			  }
 
 		      retval.xcidx(j+1) = ii;
@@ -4542,29 +4542,29 @@ SparseMatrix::bsolve (SparseType &mattyp
 	  int n_lower = mattype.nlower ();
 	  int ldm = n_upper + 2 * n_lower + 1;
 
 	  Matrix m_band (ldm, nc);
 	  double *tmp_data = m_band.fortran_vec ();
 	      
 	  if (! mattype.is_dense ()) 
 	    {
-	      int ii = 0;
-
-	      for (int j = 0; j < ldm; j++)
-		for (int i = 0; i < nc; i++)
+	      octave_idx_type ii = 0;
+
+	      for (octave_idx_type j = 0; j < ldm; j++)
+		for (octave_idx_type i = 0; i < nc; i++)
 		  tmp_data[ii++] = 0.;
 	    }
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
-	  Array<int> ipvt (nr);
-	  int *pipvt = ipvt.fortran_vec ();
+	  Array<octave_idx_type> ipvt (nr);
+	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgbtrf");
 	  else
@@ -4579,33 +4579,33 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile int x_nz = b.nnz ();
-		  int b_nc = b.cols ();
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
-		  volatile int ii = 0;
+		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
 
-		  for (volatile int j = 0; j < b_nc; j++)
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			{
 			  Bx[i] = 0.;
 			  Bz[i] = 0.;
 			}
-		      for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 			{
 			  Complex c = b.data(i);
 			  Bx[b.ridx(i)] = std::real (c);
 			  Bz[b.ridx(i)] = std::imag (c);
 			}
 
 		      F77_XFCN (dgbtrs, DGBTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
@@ -4630,30 +4630,30 @@ SparseMatrix::bsolve (SparseType &mattyp
 			{
 			  (*current_liboctave_error_handler)
 			    ("unrecoverable error in dgbtrs");
 			  break;
 			}
 
 		      // Count non-zeros in work vector and adjust 
 		      // space in retval if needed
-		      int new_nnz = 0;
-		      for (int i = 0; i < nr; i++)
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0. || Bz[i] != 0.)
 			  new_nnz++;
 
 		      if (ii + new_nnz > x_nz)
 			{
 			  // Resize the sparse matrix
-			  int sz = new_nnz * (b_nc - j) + x_nz;
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 			  retval.change_capacity (sz);
 			  x_nz = sz;
 			}
 
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			if (Bx[i] != 0. || Bz[i] != 0.)
 			  {
 			    retval.xridx(ii) = i;
 			    retval.xdata(ii++) = 
 			      Complex (Bx[i], Bz[i]);
 			  }
 		      retval.xcidx(j+1) = ii;
 		    }
@@ -4665,17 +4665,17 @@ SparseMatrix::bsolve (SparseType &mattyp
       else if (typ != SparseType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 void *
-SparseMatrix::factorize (int& err, double &rcond, Matrix &Control, Matrix &Info,
+SparseMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control, Matrix &Info,
 			 solve_singularity_handler sing_handler) const
 {
   // The return values
   void *Numeric;
   err = 0;
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
@@ -4695,21 +4695,21 @@ SparseMatrix::factorize (int& err, doubl
 
   // Set whether we are allowed to modify Q or not
   tmp = Voctave_sparse_controls.get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   umfpack_di_report_control (control);
 
-  const int *Ap = cidx ();
-  const int *Ai = ridx ();
+  const octave_idx_type *Ap = cidx ();
+  const octave_idx_type *Ai = ridx ();
   const double *Ax = data ();
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   umfpack_di_report_matrix (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = umfpack_di_qsymbolic (nr, nc, Ap, Ai, Ax, NULL,
 				     &Symbolic, control, info);
@@ -4776,24 +4776,24 @@ SparseMatrix::factorize (int& err, doubl
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 Matrix
-SparseMatrix::fsolve (SparseType &mattype, const Matrix& b, int& err, 
+SparseMatrix::fsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		     double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   Matrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -4819,26 +4819,26 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  void *Numeric = 
 	    factorize (err, rcond, Control, Info, sing_handler);
 
 	  if (err == 0)
 	    {
 	      const double *Bx = b.fortran_vec ();
 	      retval.resize (b.rows (), b.cols());
 	      double *result = retval.fortran_vec ();
-	      int b_nr = b.rows ();
-	      int b_nc = b.cols ();
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
-	      const int *Ap = cidx ();
-	      const int *Ai = ridx ();
+	      const octave_idx_type *Ap = cidx ();
+	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
-	      for (int j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
+	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 		  status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, 
 					     &result[iidx], &Bx[iidx],
 					     Numeric, control, info);
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseMatrix::solve solve failed");
@@ -4881,23 +4881,23 @@ SparseMatrix::fsolve (SparseType &mattyp
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::fsolve (SparseType &mattype, const SparseMatrix& b, int& err, double& rcond,
+SparseMatrix::fsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
   SparseMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -4920,39 +4920,39 @@ SparseMatrix::fsolve (SparseType &mattyp
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler);
 
 	  if (err == 0)
 	    {
-	      int b_nr = b.rows ();
-	      int b_nc = b.cols ();
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
-	      const int *Ap = cidx ();
-	      const int *Ai = ridx ();
+	      const octave_idx_type *Ap = cidx ();
+	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      int x_nz = b.nnz ();
-	      int ii = 0;
+	      octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type ii = 0;
 	      retval = SparseMatrix (b_nr, b_nc, x_nz);
 
 	      retval.xcidx(0) = 0;
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b.elem (i, j);
 
 		  status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, Xx,
 					     Bx, Numeric, control, 
 					     info);
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
@@ -4960,25 +4960,25 @@ SparseMatrix::fsolve (SparseType &mattyp
 
 		      umfpack_di_report_status (control, status);
 		  
 		      err = -1;
 
 		      break;
 		    }
 	      
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
 		      double tmp = Xx[i];
 		      if (tmp != 0.0)
 			{
 			  if (ii == x_nz)
 			    {
 			      // Resize the sparse matrix
-			      int sz = x_nz * (b_nc - j) / b_nc;
+			      octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
 			      sz = (sz > 10 ? sz : 10) + x_nz;
 			      retval.change_capacity (sz);
 			      x_nz = sz;
 			    }
 			  retval.xdata(ii) = tmp;
 			  retval.xridx(ii++) = i;
 			}
 		    }
@@ -5017,23 +5017,23 @@ SparseMatrix::fsolve (SparseType &mattyp
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::fsolve (SparseType &mattype, const ComplexMatrix& b, int& err, double& rcond,
+SparseMatrix::fsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -5056,36 +5056,36 @@ SparseMatrix::fsolve (SparseType &mattyp
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler);
 
 	  if (err == 0)
 	    {
-	      int b_nr = b.rows ();
-	      int b_nc = b.cols ();
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
-	      const int *Ap = cidx ();
-	      const int *Ai = ridx ();
+	      const octave_idx_type *Ap = cidx ();
+	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 	      retval.resize (b_nr, b_nc);
 
 	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 	      
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
 		      Complex c = b (i,j);
 		      Bx[i] = std::real (c);
 		      Bz[i] = std::imag (c);
 		    }
 
 		  status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, 
 					     Xx, Bx, Numeric, control, 
@@ -5101,17 +5101,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 
 		      umfpack_di_report_status (control, status);
 		      
 		      err = -1;
 
 		      break;
 		    }
 
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    retval (i, j) = Complex (Xx[i], Xz[i]);
 		}
 
 #ifndef HAVE_LSSOLVE
 	      rcond = Info (UMFPACK_RCOND);
 	      volatile double rcond_plus_one = rcond + 1.0;
 
 	      if (status == UMFPACK_WARNING_singular_matrix || 
@@ -5141,23 +5141,23 @@ SparseMatrix::fsolve (SparseType &mattyp
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::fsolve (SparseType &mattype, const SparseComplexMatrix& b, 
-		      int& err, double& rcond,
+		      octave_idx_type& err, double& rcond,
 		      solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
   err = 0;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
@@ -5180,41 +5180,41 @@ SparseMatrix::fsolve (SparseType &mattyp
 	{
 #ifdef HAVE_UMFPACK
 	  Matrix Control, Info;
 	  void *Numeric = factorize (err, rcond, Control, Info, 
 				     sing_handler);
 
 	  if (err == 0)
 	    {
-	      int b_nr = b.rows ();
-	      int b_nc = b.cols ();
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
 	      int status = 0;
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
-	      const int *Ap = cidx ();
-	      const int *Ai = ridx ();
+	      const octave_idx_type *Ap = cidx ();
+	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      int x_nz = b.nnz ();
-	      int ii = 0;
+	      octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 	      
 	      retval.xcidx(0) = 0;
-	      for (int j = 0; j < b_nc; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
 		      Complex c = b (i,j);
 		      Bx[i] = std::real (c);
 		      Bz[i] = std::imag (c);
 		    }
 
 		  status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, Xx,
 					     Bx, Numeric, control, 
@@ -5230,25 +5230,25 @@ SparseMatrix::fsolve (SparseType &mattyp
 
 		      umfpack_di_report_status (control, status);
 		      
 		      err = -1;
 
 		      break;
 		    }
 
-		  for (int i = 0; i < b_nr; i++)
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
 		      Complex tmp = Complex (Xx[i], Xz[i]);
 		      if (tmp != 0.0)
 			{
 			  if (ii == x_nz)
 			    {
 			      // Resize the sparse matrix
-			      int sz = x_nz * (b_nc - j) / b_nc;
+			      octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
 			      sz = (sz > 10 ? sz : 10) + x_nz;
 			      retval.change_capacity (sz);
 			      x_nz = sz;
 			    }
 			  retval.xdata(ii) = tmp;
 			  retval.xridx(ii++) = i;
 			}
 		    }
@@ -5289,37 +5289,37 @@ SparseMatrix::fsolve (SparseType &mattyp
     }
   
   return retval;
 }
 
 Matrix
 SparseMatrix::solve (SparseType &mattype, const Matrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (SparseType &mattype, const Matrix& b, int& info) const
+SparseMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (SparseType &mattype, const Matrix& b, int& info, 
+SparseMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& info, 
 		     double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (SparseType &mattype, const Matrix& b, int& err, 
+SparseMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		     double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   int typ = mattype.type ();
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
@@ -5342,39 +5342,39 @@ SparseMatrix::solve (SparseType &mattype
 	("matrix dimension mismatch solution of linear equations");
       return Matrix ();
     }
 }
 
 SparseMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
-		     int& info) const
+		     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b,
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
-		     int& err, double& rcond,
+		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
   int typ = mattype.type ();
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
@@ -5396,39 +5396,39 @@ SparseMatrix::solve (SparseType &mattype
 	("matrix dimension mismatch solution of linear equations");
       return SparseMatrix ();
     }
 }
 
 ComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
-			    int& info) const
+			    octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   int typ = mattype.type ();
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
@@ -5450,39 +5450,39 @@ SparseMatrix::solve (SparseType &mattype
 	("matrix dimension mismatch solution of linear equations");
       return ComplexMatrix ();
     }
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
-		     int& info) const
+		     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b,
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
-		     int& err, double& rcond,
+		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
   int typ = mattype.type ();
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
@@ -5504,481 +5504,481 @@ SparseMatrix::solve (SparseType &mattype
 	("matrix dimension mismatch solution of linear equations");
       return SparseComplexMatrix ();
     }
 }
 
 ColumnVector
 SparseMatrix::solve (SparseType &mattype, const ColumnVector& b) const
 {
-  int info; double rcond;
+  octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, int& info) const
+SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, int& info, double& rcond) const
+SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ColumnVector
-SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, int& info, double& rcond,
+SparseMatrix::solve (SparseType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (mattype, tmp, info, rcond, sing_handler).column (0);
+  return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, int& info) const
+SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, int& info, 
+SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, octave_idx_type& info, 
 		     double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, int& info, double& rcond,
+SparseMatrix::solve (SparseType &mattype, const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (mattype, tmp, info, rcond, sing_handler).column (0);
+  return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (const Matrix& b, int& info) const
+SparseMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (const Matrix& b, int& info, 
+SparseMatrix::solve (const Matrix& b, octave_idx_type& info, 
 		     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (const Matrix& b, int& err, 
+SparseMatrix::solve (const Matrix& b, octave_idx_type& err, 
 		     double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b, 
-		     int& info) const
+		     octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b,
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b, 
-		     int& err, double& rcond,
+		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
   SparseType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, 
-			    int& info) const
+			    octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, 
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, 
-		     int& err, double& rcond, 
+		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
   SparseType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b, 
-		     int& info) const
+		     octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b,
-		     int& info, double& rcond) const
+		     octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b, 
-		     int& err, double& rcond,
+		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
   SparseType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ColumnVector
 SparseMatrix::solve (const ColumnVector& b) const
 {
-  int info; double rcond;
+  octave_idx_type info; double rcond;
   return solve (b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (const ColumnVector& b, int& info) const
+SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (const ColumnVector& b, int& info, double& rcond) const
+SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ColumnVector
-SparseMatrix::solve (const ColumnVector& b, int& info, double& rcond,
+SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler).column (0);
+  return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b) const
 {
-  int info;
+  octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (const ComplexColumnVector& b, int& info) const
+SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (const ComplexColumnVector& b, int& info, 
+SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
 		     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (const ComplexColumnVector& b, int& info, double& rcond,
+SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler).column (0);
+  return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 Matrix
 SparseMatrix::lssolve (const Matrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 Matrix
-SparseMatrix::lssolve (const Matrix& b, int& info) const
+SparseMatrix::lssolve (const Matrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 Matrix
-SparseMatrix::lssolve (const Matrix& b, int& info, int& rank) const
+SparseMatrix::lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseMatrix::lssolve not implemented yet");
   return Matrix ();
 }
 
 SparseMatrix
 SparseMatrix::lssolve (const SparseMatrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 SparseMatrix
-SparseMatrix::lssolve (const SparseMatrix& b, int& info) const
+SparseMatrix::lssolve (const SparseMatrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 SparseMatrix
-SparseMatrix::lssolve (const SparseMatrix& b, int& info, int& rank) const
+SparseMatrix::lssolve (const SparseMatrix& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseMatrix::lssolve not implemented yet");
   return SparseMatrix ();
 }
 
 ComplexMatrix
 SparseMatrix::lssolve (const ComplexMatrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
-SparseMatrix::lssolve (const ComplexMatrix& b, int& info) const
+SparseMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
-SparseMatrix::lssolve (const ComplexMatrix& b, int& info, int& rank) const
+SparseMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseMatrix::lssolve not implemented yet");
   return ComplexMatrix ();
 }
 
 SparseComplexMatrix
 SparseMatrix::lssolve (const SparseComplexMatrix& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 SparseComplexMatrix
-SparseMatrix::lssolve (const SparseComplexMatrix& b, int& info) const
+SparseMatrix::lssolve (const SparseComplexMatrix& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 SparseComplexMatrix
-SparseMatrix::lssolve (const SparseComplexMatrix& b, int& info, 
-		       int& rank) const
+SparseMatrix::lssolve (const SparseComplexMatrix& b, octave_idx_type& info, 
+		       octave_idx_type& rank) const
 {
   info = -1;
   (*current_liboctave_error_handler) 
     ("SparseMatrix::lssolve not implemented yet");
   return SparseComplexMatrix ();
 }
 
 ColumnVector
 SparseMatrix::lssolve (const ColumnVector& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ColumnVector
-SparseMatrix::lssolve (const ColumnVector& b, int& info) const
+SparseMatrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ColumnVector
-SparseMatrix::lssolve (const ColumnVector& b, int& info, int& rank) const
+SparseMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const
 {
   Matrix tmp (b);
-  return lssolve (tmp, info, rank).column (0);
+  return lssolve (tmp, info, rank).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::lssolve (const ComplexColumnVector& b) const
 {
-  int info;
-  int rank;
+  octave_idx_type info;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
-SparseMatrix::lssolve (const ComplexColumnVector& b, int& info) const
+SparseMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
-  int rank;
+  octave_idx_type rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
-SparseMatrix::lssolve (const ComplexColumnVector& b, int& info, 
-		       int& rank) const
+SparseMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, 
+		       octave_idx_type& rank) const
 {
   ComplexMatrix tmp (b);
-  return lssolve (tmp, info, rank).column (0);
+  return lssolve (tmp, info, rank).column (static_cast<octave_idx_type> (0));
 }
 
 // other operations.
 
 SparseMatrix
 SparseMatrix::map (d_d_Mapper f) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
-  int nel = (f_zero ? 0 : nr*nc - nz);
-  for (int i = 0; i < nz; i++)
+  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
+  for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
   SparseMatrix retval (nr, nc, nel);
 
   if (f_zero)
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = f (elem (i, j));
 	      if (tmp != 0.0)
 		{
 		  retval.data(ii) = tmp;
 		  retval.ridx(ii++) = i;
 		}
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
   else
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      retval.data(ii) = f (elem(i));
 	      retval.ridx(ii++) = ridx(i);
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
 
   return retval;
 }
 
 SparseBoolMatrix
 SparseMatrix::map (b_d_Mapper f) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  int nz = nnz ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz = nnz ();
   bool f_zero = f(0.0);
 
   // Count number of non-zero elements
-  int nel = (f_zero ? 0 : nr*nc - nz);
-  for (int i = 0; i < nz; i++)
+  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
+  for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
   SparseBoolMatrix retval (nr, nc, nel);
 
   if (f_zero)
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      bool tmp = f (elem (i, j));
 	      if (tmp)
 		{
 		  retval.data(ii) = tmp;
 		  retval.ridx(ii++) = i;
 		}
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
   else
     {
-      int ii = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type ii = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = cidx(j); i < cidx(j+1); i++)
+	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      retval.data(ii) = f (elem(i));
 	      retval.ridx(ii++) = ridx(i);
 	    }
 	  retval.cidx(j+1) = ii;
 	}
     }
 
@@ -5990,55 +5990,55 @@ SparseMatrix::apply (d_d_Mapper f)
 {
   *this = map (f);
   return *this;
 }
 
 bool
 SparseMatrix::any_element_is_negative (bool neg_zero) const
 {
-  int nel = nnz ();
+  octave_idx_type nel = nnz ();
 
   if (neg_zero)
     {
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	if (lo_ieee_signbit (data (i)))
 	  return true;
     }
   else
     {
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	if (data (i) < 0)
 	  return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::any_element_is_inf_or_nan (void) const
 {
-  int nel = nnz ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nnz ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::all_elements_are_int_or_inf_or_nan (void) const
 {
-  int nel = nnz ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nnz ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisnan (val) || D_NINT (val) == val)
 	continue;
       else
 	return false;
     }
 
@@ -6046,25 +6046,25 @@ SparseMatrix::all_elements_are_int_or_in
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
 bool
 SparseMatrix::all_integers (double& max_val, double& min_val) const
 {
-  int nel = nnz ();
+  octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
 
   max_val = data (0);
   min_val = data (0);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
 
       if (val > max_val)
 	max_val = val;
 
       if (val < min_val)
 	min_val = val;
@@ -6074,45 +6074,45 @@ SparseMatrix::all_integers (double& max_
     }
 
   return true;
 }
 
 bool
 SparseMatrix::too_large_for_float (void) const
 {
-  int nel = nnz ();
-
-  for (int i = 0; i < nel; i++)
+  octave_idx_type nel = nnz ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
 
       if (val > FLT_MAX || val < FLT_MIN)
 	return true;
     }
 
   return false;
 }
 
 SparseBoolMatrix 
 SparseMatrix::operator ! (void) const 
 { 
-  int nr = rows ();
-  int nc = cols ();
-  int nz1 = nnz ();
-  int nz2 = nr*nc - nz1;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type nz1 = nnz ();
+  octave_idx_type nz2 = nr*nc - nz1;
    
   SparseBoolMatrix r (nr, nc, nz2);
    
-  int ii = 0;
-  int jj = 0;
+  octave_idx_type ii = 0;
+  octave_idx_type jj = 0;
   r.cidx (0) = 0;
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     {
-      for (int j = 0; j < nr; j++)
+      for (octave_idx_type j = 0; j < nr; j++)
 	{
 	  if (jj < cidx(i+1) && ridx(jj) == j)
 	    jj++;
 	  else
 	    {
 	      r.data(ii) = true;
 	      r.ridx(ii++) = j;
 	    }
@@ -6178,96 +6178,96 @@ SparseMatrix::sumsq (int dim) const
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix
 SparseMatrix::abs (void) const
 {
-  int nz = nnz ();
+  octave_idx_type nz = nnz ();
 
   SparseMatrix retval (*this);
 
-  for (int i = 0; i < nz; i++)
+  for (octave_idx_type i = 0; i < nz; i++)
     retval.data(i) = fabs(retval.data(i));
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::diag (int k) const
+SparseMatrix::diag (octave_idx_type k) const
 {
-  int nnr = rows ();
-  int nnc = cols ();
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
 
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   SparseMatrix d;
 
   if (nnr > 0 && nnc > 0)
     {
-      int ndiag = (nnr < nnc) ? nnr : nnc;
+      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
       // Count the number of non-zero elements
-      int nel = 0;
+      octave_idx_type nel = 0;
       if (k > 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    if (elem (i, i+k) != 0.)
 	      nel++;
 	}
       else if ( k < 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    if (elem (i-k, i) != 0.)
 	      nel++;
 	}
       else
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    if (elem (i, i) != 0.)
 	      nel++;
 	}
       
       d = SparseMatrix (ndiag, 1, nel);
       d.xcidx (0) = 0;
       d.xcidx (1) = nel;
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       if (k > 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    {
 	      double tmp = elem (i, i+k);
 	      if (tmp != 0.)
 		{
 		  d.xdata (ii) = tmp;
 		  d.xridx (ii++) = i;
 		}
 	    }
 	}
       else if ( k < 0)
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    {
 	      double tmp = elem (i-k, i);
 	      if (tmp != 0.)
 		{
 		  d.xdata (ii) = tmp;
 		  d.xridx (ii++) = i;
 		}
 	    }
 	}
       else
 	{
-	  for (int i = 0; i < ndiag; i++)
+	  for (octave_idx_type i = 0; i < ndiag; i++)
 	    {
 	      double tmp = elem (i, i);
 	      if (tmp != 0.)
 		{
 		  d.xdata (ii) = tmp;
 		  d.xridx (ii++) = i;
 		}
 	    }
@@ -6278,87 +6278,87 @@ SparseMatrix::diag (int k) const
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
 Matrix
 SparseMatrix::matrix_value (void) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
 
   Matrix retval (nr, nc, 0.0);
-  for (int j = 0; j < nc; j++)
-    for (int i = cidx(j); i < cidx(j+1); i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
       retval.elem (ridx(i), j) = data (i);
 
   return retval;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SparseMatrix& a)
 {
-  int nc = a.cols ();
+  octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
-   for (int j = 0; j < nc; j++)  {
+   for (octave_idx_type j = 0; j < nc; j++)  {
       OCTAVE_QUIT;
-      for (int i = a.cidx(j); i < a.cidx(j+1); i++) {
+      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++) {
 	os << a.ridx(i) + 1 << " "  << j + 1 << " ";
 	octave_write_double (os, a.data(i));
 	os << "\n";
       }
    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseMatrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
-  int nz = a.nnz ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type nz = a.nnz ();
 
   if (nr < 1 || nc < 1)
     is.clear (std::ios::badbit);
   else
     {
-      int itmp, jtmp, jold = 0;
+      octave_idx_type itmp, jtmp, jold = 0;
       double tmp;
-      int ii = 0;
+      octave_idx_type ii = 0;
        
       a.cidx (0) = 0;
-      for (int i = 0; i < nz; i++)
+      for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  is >> itmp;
 	  itmp--;
 	  is >> jtmp;
 	  jtmp--;
 	  tmp = octave_read_double (is);
 	  
 	  if (is)
 	    {
 	      if (jold != jtmp)
 		{
-		  for (int j = jold; j < jtmp; j++)
+		  for (octave_idx_type j = jold; j < jtmp; j++)
 		    a.cidx(j+1) = ii;
 		  
 		  jold = jtmp;
 		}
 	      a.data (ii) = tmp;
 	      a.ridx (ii++) = itmp;
 	    }
 	  else
 	    goto done;
 	}
 
-      for (int j = jold; j < nc; j++)
+      for (octave_idx_type j = jold; j < nc; j++)
 	a.cidx(j+1) = ii;
     }
   
  done:
 
   return is;
 }
 
@@ -6388,23 +6388,23 @@ SparseMatrix::index (Array<idx_vector>& 
 
 SparseMatrix
 SparseMatrix::reshape (const dim_vector& new_dims) const
 {
   return MSparse<double>::reshape (new_dims);
 }
 
 SparseMatrix
-SparseMatrix::permute (const Array<int>& vec, bool inv) const
+SparseMatrix::permute (const Array<octave_idx_type>& vec, bool inv) const
 {
   return MSparse<double>::permute (vec, inv);
 }
 
 SparseMatrix
-SparseMatrix::ipermute (const Array<int>& vec) const
+SparseMatrix::ipermute (const Array<octave_idx_type>& vec) const
 {
   return MSparse<double>::ipermute (vec);
 }
 
 // matrix by matrix -> matrix operations
 
 SparseMatrix
 operator * (const SparseMatrix& m, const SparseMatrix& a)
@@ -6424,52 +6424,52 @@ operator * (const SparseMatrix& m, const
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 SparseMatrix
 min (double d, const SparseMatrix& m)
 {
   SparseMatrix result;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
   // Count the number of non-zero elements
   if (d < 0.)
     {
       result = SparseMatrix (nr, nc, d);
-      for (int j = 0; j < nc; j++)
-	for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 	  {
 	    double tmp = xmin (d, m.data (i));
 	    if (tmp != 0.)
 	      {
-		int idx = m.ridx(i) + j * nr;
+		octave_idx_type idx = m.ridx(i) + j * nr;
 		result.xdata(idx) = tmp;
 		result.xridx(idx) = m.ridx(i);
 	      }
 	  }
     }
   else
     {
-      int nel = 0;
-      for (int j = 0; j < nc; j++)
-	for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 	  if (xmin (d, m.data (i)) != 0.)
 	    nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx(0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+	  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 	    {
 	      double tmp = xmin (d, m.data (i));
 
 	      if (tmp != 0.)
 		{
 		  result.xdata(ii) = tmp;
 		  result.xridx(ii++) = m.ridx(i);
 		}
@@ -6489,38 +6489,38 @@ min (const SparseMatrix& m, double d)
 
 SparseMatrix
 min (const SparseMatrix& a, const SparseMatrix& b)
 {
   SparseMatrix r;
 
   if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
     {
-      int a_nr = a.rows ();
-      int a_nc = a.cols ();
-
-      int b_nr = b.rows ();
-      int b_nc = b.cols ();
+      octave_idx_type a_nr = a.rows ();
+      octave_idx_type a_nc = a.cols ();
+
+      octave_idx_type b_nr = b.rows ();
+      octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
 	  r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-	  int jx = 0;
+	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
-	  for (int i = 0 ; i < a_nc ; i++)
+	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
-	      int  ja = a.cidx(i);
-	      int  ja_max = a.cidx(i+1);
+	      octave_idx_type  ja = a.cidx(i);
+	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
            
-	      int  jb = b.cidx(i);
-	      int  jb_max = b.cidx(i+1);
+	      octave_idx_type  jb = b.cidx(i);
+	      octave_idx_type  jb_max = b.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
 		  OCTAVE_QUIT;
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
 		    {
@@ -6574,53 +6574,53 @@ min (const SparseMatrix& a, const Sparse
   return r;
 }
 
 SparseMatrix
 max (double d, const SparseMatrix& m)
 {
   SparseMatrix result;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
   // Count the number of non-zero elements
   if (d > 0.)
     {
       result = SparseMatrix (nr, nc, d);
-      for (int j = 0; j < nc; j++)
-	for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 	  {
 	    double tmp = xmax (d, m.data (i));
 
 	    if (tmp != 0.)
 	      {
-		int idx = m.ridx(i) + j * nr;
+		octave_idx_type idx = m.ridx(i) + j * nr;
 		result.xdata(idx) = tmp;
 		result.xridx(idx) = m.ridx(i);
 	      }
 	  }
     }
   else
     {
-      int nel = 0;
-      for (int j = 0; j < nc; j++)
-	for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+      octave_idx_type nel = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 	  if (xmax (d, m.data (i)) != 0.)
 	    nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       result.xcidx(0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+	  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 	    {
 	      double tmp = xmax (d, m.data (i));
 	      if (tmp != 0.)
 		{
 		  result.xdata(ii) = tmp;
 		  result.xridx(ii++) = m.ridx(i);
 		}
 	    }
@@ -6639,38 +6639,38 @@ max (const SparseMatrix& m, double d)
 
 SparseMatrix
 max (const SparseMatrix& a, const SparseMatrix& b)
 {
   SparseMatrix r;
 
   if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
     {
-      int a_nr = a.rows ();
-      int a_nc = a.cols ();
-
-      int b_nr = b.rows ();
-      int b_nc = b.cols ();
+      octave_idx_type a_nr = a.rows ();
+      octave_idx_type a_nc = a.cols ();
+
+      octave_idx_type b_nr = b.rows ();
+      octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
 	  r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
        
-	  int jx = 0;
+	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
-	  for (int i = 0 ; i < a_nc ; i++)
+	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
-	      int  ja = a.cidx(i);
-	      int  ja_max = a.cidx(i+1);
+	      octave_idx_type  ja = a.cidx(i);
+	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
            
-	      int  jb = b.cidx(i);
-	      int  jb_max = b.cidx(i+1);
+	      octave_idx_type  jb = b.cidx(i);
+	      octave_idx_type  jb_max = b.cidx(i+1);
 	      bool jb_lt_max = jb < jb_max;
            
 	      while (ja_lt_max || jb_lt_max )
 		{
 		  OCTAVE_QUIT;
 		  if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
 		    {
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -41,302 +41,302 @@ class
 SparseMatrix : public MSparse<double>
 {
  public:
 
   typedef void (*solve_singularity_handler) (double rcond);
 
   SparseMatrix (void) : MSparse<double> () { }
 
-  SparseMatrix (int r, int c) : MSparse<double> (r, c) { }
+  SparseMatrix (octave_idx_type r, octave_idx_type c) : MSparse<double> (r, c) { }
 
-  explicit SparseMatrix (int r, int c, double val) 
+  explicit SparseMatrix (octave_idx_type r, octave_idx_type c, double val) 
     : MSparse<double> (r, c, val) { }
 
   SparseMatrix (const SparseMatrix& a) : MSparse<double> (a) { }
 
   SparseMatrix (const SparseMatrix& a, const dim_vector& dv) 
     : MSparse<double> (a, dv) { }
 
   SparseMatrix (const MSparse<double>& a) : MSparse<double> (a) { }
 
   explicit SparseMatrix (const SparseBoolMatrix& a);
 
   explicit SparseMatrix (const Matrix& a) : MSparse<double> (a) { }
 
   explicit SparseMatrix (const NDArray& a) : MSparse<double> (a) { }
 
-  explicit SparseMatrix (const Array<double> a, const Array<int>& r, 
-			 const Array<int>& c, int nr = -1, 
-			 int nc = -1, bool sum_terms = true)
+  explicit SparseMatrix (const Array<double> a, const Array<octave_idx_type>& r, 
+			 const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
+			 octave_idx_type nc = -1, bool sum_terms = true)
     : MSparse<double> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseMatrix (const Array<double> a, const Array<double>& r, 
-			 const Array<double>& c, int nr = -1, 
-			 int nc = -1, bool sum_terms = true)
+			 const Array<double>& c, octave_idx_type nr = -1, 
+			 octave_idx_type nc = -1, bool sum_terms = true)
     : MSparse<double> (a, r, c, nr, nc, sum_terms) { }
 
-  SparseMatrix (int r, int c, int num_nz) : MSparse<double> (r, c, num_nz) { }
+  SparseMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : MSparse<double> (r, c, num_nz) { }
 
   SparseMatrix& operator = (const SparseMatrix& a)
     {
       MSparse<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const SparseMatrix& a) const;
   bool operator != (const SparseMatrix& a) const;
 
   bool is_symmetric (void) const;
 
   SparseMatrix max (int dim = 0) const;
-  SparseMatrix max (Array2<int>& index, int dim = 0) const;
+  SparseMatrix max (Array2<octave_idx_type>& index, int dim = 0) const;
   SparseMatrix min (int dim = 0) const;
-  SparseMatrix min (Array2<int>& index, int dim = 0) const;
+  SparseMatrix min (Array2<octave_idx_type>& index, int dim = 0) const;
   
   // destructive insert/delete/reorder operations
 
-  SparseMatrix& insert (const SparseMatrix& a, int r, int c);
+  SparseMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
 
-  SparseMatrix concat (const SparseMatrix& rb, const Array<int>& ra_idx);
+  SparseMatrix concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx);
   SparseComplexMatrix concat (const SparseComplexMatrix& rb,
-			      const Array<int>& ra_idx);
+			      const Array<octave_idx_type>& ra_idx);
 
   friend SparseMatrix real (const SparseComplexMatrix& a);
   friend SparseMatrix imag (const SparseComplexMatrix& a);
 
   friend SparseMatrix atan2 (const double& x, const SparseMatrix& y);
   friend SparseMatrix atan2 (const SparseMatrix& x, const double& y);
   friend SparseMatrix atan2 (const SparseMatrix& x, const SparseMatrix& y);
 
   SparseMatrix transpose (void) const 
     { 
       return MSparse<double>::transpose (); 
     }
 
   SparseMatrix inverse (void) const;
-  SparseMatrix inverse (int& info) const;
-  SparseMatrix inverse (int& info, double& rcond, int force = 0, 
+  SparseMatrix inverse (octave_idx_type& info) const;
+  SparseMatrix inverse (octave_idx_type& info, double& rcond, int force = 0, 
 		        int calc_cond = 1) const;
 
   DET determinant (void) const;
-  DET determinant (int& info) const;
-  DET determinant (int& info, double& rcond, int calc_cond = 1) const;
+  DET determinant (octave_idx_type& info) const;
+  DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
-  Matrix dsolve (SparseType &typ, const Matrix& b, int& info, double& rcond,
+  Matrix dsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix dsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseMatrix dsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseMatrix dsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix dsolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Upper triangular matrix solvers
-  Matrix utsolve (SparseType &typ, const Matrix& b, int& info, double& rcond,
+  Matrix utsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix utsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseMatrix utsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseMatrix utsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix utsolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Lower triangular matrix solvers
-  Matrix ltsolve (SparseType &typ, const Matrix& b, int& info, double& rcond,
+  Matrix ltsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix ltsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseMatrix ltsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseMatrix ltsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix ltsolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Tridiagonal matrix solvers
-  Matrix trisolve (SparseType &typ, const Matrix& b, int& info, double& rcond,
+  Matrix trisolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix trisolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseMatrix trisolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseMatrix trisolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix trisolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Banded matrix solvers (umfpack/cholesky)
-  Matrix bsolve (SparseType &typ, const Matrix& b, int& info, double& rcond,
+  Matrix bsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix bsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseMatrix bsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseMatrix bsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix bsolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond, 
+		octave_idx_type& info, double& rcond, 
 		solve_singularity_handler sing_handler) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  void * factorize (int& err, double &rcond, Matrix &Control, Matrix &Info,
+  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control, Matrix &Info,
 		    solve_singularity_handler sing_handler) const;
 
-  Matrix fsolve (SparseType &typ, const Matrix& b, int& info, double& rcond,
+  Matrix fsolve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
-  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix fsolve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
-  SparseMatrix fsolve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseMatrix fsolve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix fsolve (SparseType &typ, const SparseComplexMatrix& b,
-		int& info, double& rcond,
+		octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (SparseType &typ, const Matrix& b) const;
-  Matrix solve (SparseType &typ, const Matrix& b, int& info) const;
-  Matrix solve (SparseType &typ, const Matrix& b, int& info, 
+  Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info) const;
+  Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcond) const;
-  Matrix solve (SparseType &typ, const Matrix& b, int& info, double& rcond,
+  Matrix solve (SparseType &typ, const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, 
-		       int& info) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, int& info, 
+		       octave_idx_type& info) const;
+  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		       double& rcond) const;
-  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, int& info, 
+  ComplexMatrix solve (SparseType &typ, const ComplexMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseMatrix solve (SparseType &typ, const SparseMatrix& b) const;
   SparseMatrix solve (SparseType &typ, const SparseMatrix& b, 
-		      int& info) const;
-  SparseMatrix solve (SparseType &typ, const SparseMatrix& b, int& info, 
+		      octave_idx_type& info) const;
+  SparseMatrix solve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		      double& rcond) const;
-  SparseMatrix solve (SparseType &typ, const SparseMatrix& b, int& info, 
+  SparseMatrix solve (SparseType &typ, const SparseMatrix& b, octave_idx_type& info, 
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (SparseType &typ, 
 			     const SparseComplexMatrix& b) const;
   SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, 
-			     int& info) const;
+			     octave_idx_type& info) const;
   SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, 
-			     int& info, double& rcond) const;
-  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, int& info, 
+			     octave_idx_type& info, double& rcond) const;
+  SparseComplexMatrix solve (SparseType &typ, const SparseComplexMatrix& b, octave_idx_type& info, 
 	       double& rcond, solve_singularity_handler sing_handler) const;
 
   ColumnVector solve (SparseType &typ, const ColumnVector& b) const;
   ColumnVector solve (SparseType &typ, const ColumnVector& b, 
-		      int& info) const;
+		      octave_idx_type& info) const;
   ColumnVector solve (SparseType &typ, const ColumnVector& b, 
-		      int& info, double& rcond) const;
-  ColumnVector solve (SparseType &typ, const ColumnVector& b, int& info,
+		      octave_idx_type& info, double& rcond) const;
+  ColumnVector solve (SparseType &typ, const ColumnVector& b, octave_idx_type& info,
 		double& rcond, solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (SparseType &typ, 
 			     const ComplexColumnVector& b) const;
   ComplexColumnVector solve (SparseType &typ, 
-			     const ComplexColumnVector& b, int& info) const;
+			     const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b,
-			     int& info, double& rcond) const;
+			     octave_idx_type& info, double& rcond) const;
   ComplexColumnVector solve (SparseType &typ, const ComplexColumnVector& b,
-			     int& info, double& rcond,
+			     octave_idx_type& info, double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
-  Matrix solve (const Matrix& b, int& info) const;
-  Matrix solve (const Matrix& b, int& info, double& rcond) const;
-  Matrix solve (const Matrix& b, int& info, double& rcond,
+  Matrix solve (const Matrix& b, octave_idx_type& info) const;
+  Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
+  Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, 
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, 
 		       double& rcond) const;
-  ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
 		       solve_singularity_handler sing_handler) const;
 
   SparseMatrix solve (const SparseMatrix& b) const;
-  SparseMatrix solve (const SparseMatrix& b, int& info) const;
-  SparseMatrix solve (const SparseMatrix& b, int& info, 
+  SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info) const;
+  SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
 		      double& rcond) const;
-  SparseMatrix solve (const SparseMatrix& b, int& info, double& rcond,
+  SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info, double& rcond,
 		solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, int& info) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, int& info, 
+  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info) const;
+  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info, 
 			     double& rcond) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, int& info, 
+  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info, 
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   ColumnVector solve (const ColumnVector& b) const;
-  ColumnVector solve (const ColumnVector& b, int& info) const;
-  ColumnVector solve (const ColumnVector& b, int& info, double& rcond) const;
-  ColumnVector solve (const ColumnVector& b, int& info, double& rcond,
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const;
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
 		      solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   // Minimum-norm solvers
   Matrix lssolve (const Matrix& b) const;
-  Matrix lssolve (const Matrix& b, int& info) const;
-  Matrix lssolve (const Matrix& b, int& info, int& rank) const;
+  Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
+  Matrix lssolve (const Matrix& b, octave_idx_type& info, octave_idx_type& rank) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info) const;
-  ComplexMatrix lssolve (const ComplexMatrix& b, int& info,
-			 int& rank) const;
+  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
+  ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
+			 octave_idx_type& rank) const;
 
   SparseMatrix lssolve (const SparseMatrix& b) const;
-  SparseMatrix lssolve (const SparseMatrix& b, int& info) const;
-  SparseMatrix lssolve (const SparseMatrix& b, int& info, int& rank) const;
+  SparseMatrix lssolve (const SparseMatrix& b, octave_idx_type& info) const;
+  SparseMatrix lssolve (const SparseMatrix& b, octave_idx_type& info, octave_idx_type& rank) const;
 
   SparseComplexMatrix lssolve (const SparseComplexMatrix& b) const;
   SparseComplexMatrix lssolve (const SparseComplexMatrix& b, 
-			       int& info) const;
-  SparseComplexMatrix lssolve (const SparseComplexMatrix& b, int& info,
-			       int& rank) const;
+			       octave_idx_type& info) const;
+  SparseComplexMatrix lssolve (const SparseComplexMatrix& b, octave_idx_type& info,
+			       octave_idx_type& rank) const;
 
   ColumnVector lssolve (const ColumnVector& b) const;
-  ColumnVector lssolve (const ColumnVector& b, int& info) const;
-  ColumnVector lssolve (const ColumnVector& b, int& info, int& rank) const;
+  ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
+  ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info, octave_idx_type& rank) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
-			       int& rank) const;
+  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector lssolve (const ComplexColumnVector& b, octave_idx_type& info,
+			       octave_idx_type& rank) const;
 
   // other operations
   SparseMatrix map (d_d_Mapper f) const;
   SparseBoolMatrix map (b_d_Mapper f) const;
 
   SparseMatrix& apply (d_d_Mapper f);
 
   bool any_element_is_negative (bool = false) const;
@@ -352,33 +352,33 @@ public:
 
   SparseMatrix cumprod (int dim = -1) const;
   SparseMatrix cumsum (int dim = -1) const;
   SparseMatrix prod (int dim = -1) const;
   SparseMatrix sum (int dim = -1) const;
   SparseMatrix sumsq (int dim = -1) const;
   SparseMatrix abs (void) const;
 
-  SparseMatrix diag (int k = 0) const;
+  SparseMatrix diag (octave_idx_type k = 0) const;
 
   Matrix matrix_value (void) const;
 
   SparseMatrix squeeze (void) const;
 
   SparseMatrix index (idx_vector& i, int resize_ok) const;
 
   SparseMatrix index (idx_vector& i, idx_vector& j, int resize_ok) const;
   
   SparseMatrix index (Array<idx_vector>& ra_idx, int resize_ok) const;
 
   SparseMatrix reshape (const dim_vector& new_dims) const;
 
-  SparseMatrix permute (const Array<int>& vec, bool inv = false) const;
+  SparseMatrix permute (const Array<octave_idx_type>& vec, bool inv = false) const;
 
-  SparseMatrix ipermute (const Array<int>& vec) const;
+  SparseMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const SparseMatrix& a);
   friend std::istream& operator >> (std::istream& is, SparseMatrix& a);
 };
 
 extern SparseMatrix operator * (const SparseMatrix& a, 
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -28,43 +28,43 @@ Software Foundation, 59 Temple Place - S
 
 #include "dbleAEPBAL.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, double*, const int&, int&,
-			     int&, double*, int&
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
+			     octave_idx_type&, double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, const int&, double*,
-			     const int&, double*, const int&, int&
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
-int
+octave_idx_type
 AEPBALANCE::init (const Matrix& a, const std::string& balance_job)
 {
-  int n = a.cols ();
+  octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
       return -1;
     }
 
-  int info;
-  int ilo;
-  int ihi;
+  octave_idx_type info;
+  octave_idx_type ilo;
+  octave_idx_type ihi;
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   double *p_balanced_mat = balanced_mat.fortran_vec ();
 
   char job = balance_job[0];
@@ -73,17 +73,17 @@ AEPBALANCE::init (const Matrix& a, const
 			     n, p_balanced_mat, n, ilo, ihi, pscale, info
 			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgebal");
   else
     {
       balancing_mat = Matrix (n, n, 0.0);
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	balancing_mat.elem (i ,i) = 1.0;
 
       double *p_balancing_mat = balancing_mat.fortran_vec ();
 
       char side = 'R';
 
       F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
 				 F77_CONST_CHAR_ARG2 (&side, 1),
diff --git a/liboctave/dbleAEPBAL.h b/liboctave/dbleAEPBAL.h
--- a/liboctave/dbleAEPBAL.h
+++ b/liboctave/dbleAEPBAL.h
@@ -61,17 +61,17 @@ public:
 
   friend std::ostream& operator << (std::ostream& os, const AEPBALANCE& a);
 
 private:
 
   Matrix balanced_mat;
   Matrix balancing_mat;
 
-  int init (const Matrix& a, const std::string& balance_job);
+  octave_idx_type init (const Matrix& a, const std::string& balance_job);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -26,53 +26,53 @@ Software Foundation, 59 Temple Place - S
 
 #include "dbleCHOL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL, const int&,
-			     double*, const int&, int&
+  F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
+			     double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
-int
+octave_idx_type
 CHOL::init (const Matrix& a)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("CHOL requires square matrix");
       return -1;
     }
 
-  int n = a_nc;
-  int info;
+  octave_idx_type n = a_nc;
+  octave_idx_type info;
 
   chol_mat = a;
   double *h = chol_mat.fortran_vec ();
 
   F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1),
 			     n, h, n, info
 			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dpotrf");
   else
     {
       // If someone thinks of a more graceful way of doing this (or
       // faster for that matter :-)), please let me know!
 
       if (n > 1)
-	for (int j = 0; j < a_nc; j++)
-	  for (int i = j+1; i < a_nr; i++)
+	for (octave_idx_type j = 0; j < a_nc; j++)
+	  for (octave_idx_type i = j+1; i < a_nr; i++)
 	    chol_mat.elem (i, j) = 0.0;
     }
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/dbleCHOL.h b/liboctave/dbleCHOL.h
--- a/liboctave/dbleCHOL.h
+++ b/liboctave/dbleCHOL.h
@@ -31,17 +31,17 @@ class
 CHOL
 {
 public:
 
   CHOL (void) : chol_mat () { }
 
   CHOL (const Matrix& a) { init (a); }
 
-  CHOL (const Matrix& a, int& info) { info = init (a); }
+  CHOL (const Matrix& a, octave_idx_type& info) { info = init (a); }
 
   CHOL (const CHOL& a) : chol_mat (a.chol_mat) { }
 
   CHOL& operator = (const CHOL& a)
     {
       if (this != &a)
 	chol_mat = a.chol_mat;
 
@@ -51,17 +51,17 @@ public:
   Matrix chol_matrix (void) const { return chol_mat; }
 
   friend std::ostream& operator << (std::ostream& os, const CHOL& a);
 
 private:
 
   Matrix chol_mat;
 
-  int init (const Matrix& a);
+  octave_idx_type init (const Matrix& a);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -27,59 +27,59 @@ Software Foundation, 59 Temple Place - S
 #include "dbleHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgebal, DGEBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const int&, double*, const int&, int&,
-			     int&, double*, int&
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
+			     octave_idx_type&, double*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dgehrd, DGEHRD) (const int&, const int&, const int&,
-			     double*, const int&, double*, double*,
-			     const int&, int&);
+  F77_FUNC (dgehrd, DGEHRD) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     double*, const octave_idx_type&, double*, double*,
+			     const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (dorghr, DORGHR) (const int&, const int&, const int&,
-			     double*, const int&, double*, double*,
-			     const int&, int&);
+  F77_FUNC (dorghr, DORGHR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     double*, const octave_idx_type&, double*, double*,
+			     const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgebak, DGEBAK) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, const int&, double*,
-			     const int&, double*, const int&, int&
+			     const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
-int
+octave_idx_type
 HESS::init (const Matrix& a)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("HESS requires square matrix");
       return -1;
     }
 
   char job = 'N';
   char side = 'R';
 
-  int n = a_nc;
-  int lwork = 32 * n;
-  int info;
-  int ilo;
-  int ihi;
+  octave_idx_type n = a_nc;
+  octave_idx_type lwork = 32 * n;
+  octave_idx_type info;
+  octave_idx_type ilo;
+  octave_idx_type ihi;
 
   hess_mat = a;
   double *h = hess_mat.fortran_vec ();
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
@@ -126,18 +126,18 @@ HESS::init (const Matrix& a)
 		  ("unrecoverable error in dgebak");
 	      else
 		{
 		  // If someone thinks of a more graceful way of doing
 		  // this (or faster for that matter :-)), please let
 		  // me know!
 
 		  if (n > 2)
-		    for (int j = 0; j < a_nc; j++)
-		      for (int i = j+2; i < a_nr; i++)
+		    for (octave_idx_type j = 0; j < a_nc; j++)
+		      for (octave_idx_type i = j+2; i < a_nr; i++)
 			hess_mat.elem (i, j) = 0;
 		}
 	    }
 	}
     }
 
   return info;
 }
diff --git a/liboctave/dbleHESS.h b/liboctave/dbleHESS.h
--- a/liboctave/dbleHESS.h
+++ b/liboctave/dbleHESS.h
@@ -31,17 +31,17 @@ class
 HESS
 {
 public:
 
   HESS (void) : hess_mat (), unitary_hess_mat () { }
 
   HESS (const Matrix& a) { init (a); }
 
-  HESS (const Matrix& a, int& info) { info = init (a); }
+  HESS (const Matrix& a, octave_idx_type& info) { info = init (a); }
 
   HESS (const HESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   HESS& operator = (const HESS& a)
     {
       if (this != &a)
 	{
@@ -59,17 +59,17 @@ public:
 
   friend std::ostream& operator << (std::ostream& os, const HESS& a);
 
 private:
 
   Matrix hess_mat;
   Matrix unitary_hess_mat;
 
-  int init (const Matrix& a);
+  octave_idx_type init (const Matrix& a);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -35,39 +35,39 @@ Software Foundation, 59 Temple Place - S
 
 template class base_lu <Matrix, double, Matrix, double>;
 
 // Define the constructor for this particular derivation.
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dgetrf, DGETRF) (const int&, const int&, double*,
-			     const int&, int*, int&);
+  F77_FUNC (dgetrf, DGETRF) (const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, octave_idx_type*, octave_idx_type&);
 }
 
 LU::LU (const Matrix& a)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-  int mn = (a_nr < a_nc ? a_nr : a_nc);
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
+  octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
 
   ipvt.resize (mn);
-  int *pipvt = ipvt.fortran_vec ();
+  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   double *tmp_data = a_fact.fortran_vec ();
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   F77_XFCN (dgetrf, DGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
   else
-    ipvt -= 1;
+    ipvt -= static_cast<octave_idx_type> (1);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -26,91 +26,91 @@ Software Foundation, 59 Temple Place - S
 
 #include "dbleQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dgeqrf, DGEQRF) (const int&, const int&, double*, const int&,
-			     double*, double*, const int&, int&); 
+  F77_FUNC (dgeqrf, DGEQRF) (const octave_idx_type&, const octave_idx_type&, double*, const octave_idx_type&,
+			     double*, double*, const octave_idx_type&, octave_idx_type&); 
 
   F77_RET_T
-  F77_FUNC (dorgqr, DORGQR) (const int&, const int&, const int&, double*,
-			     const int&, double*, double*, const int&, int&);
+  F77_FUNC (dorgqr, DORGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, double*, double*, const octave_idx_type&, octave_idx_type&);
 }
 
 QR::QR (const Matrix& a, QR::type qr_type)
   : q (), r ()
 {
   init (a, qr_type);
 }
 
 void
 QR::init (const Matrix& a, QR::type qr_type)
 {
-  int m = a.rows ();
-  int n = a.cols ();
+  octave_idx_type m = a.rows ();
+  octave_idx_type n = a.cols ();
 
   if (m == 0 || n == 0)
     {
       (*current_liboctave_error_handler) ("QR must have non-empty matrix");
       return;
     }
 
-  int min_mn = m < n ? m : n;
+  octave_idx_type min_mn = m < n ? m : n;
   Array<double> tau (min_mn);
   double *ptau = tau.fortran_vec ();
 
-  int lwork = 32*n;
+  octave_idx_type lwork = 32*n;
   Array<double> work (lwork);
   double *pwork = work.fortran_vec ();
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   Matrix A_fact = a;
   if (m > n && qr_type != QR::economy)
       A_fact.resize (m, m, 0.0);
 
   double *tmp_data = A_fact.fortran_vec ();
 
   F77_XFCN (dgeqrf, DGEQRF, (m, n, tmp_data, m, ptau, pwork, lwork, info));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgeqrf");
   else
     {
       if (qr_type == QR::raw)
 	{
-	  for (int j = 0; j < min_mn; j++)
+	  for (octave_idx_type j = 0; j < min_mn; j++)
 	    {
-	      int limit = j < min_mn - 1 ? j : min_mn - 1;
-	      for (int i = limit + 1; i < m; i++)
+	      octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
+	      for (octave_idx_type i = limit + 1; i < m; i++)
 		A_fact.elem (i, j) *= tau.elem (j);
 	    }
 
 	  r = A_fact;
 
 	  if (m > n)
 	    r.resize (m, n);
 	}
       else
 	{
-	  int n2 = (qr_type == QR::economy) ? min_mn : m;
+	  octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
 
 	  if (qr_type == QR::economy && m > n)
 	    r.resize (n, n, 0.0);
 	  else
 	    r.resize (m, n, 0.0);
 
-	  for (int j = 0; j < n; j++)
+	  for (octave_idx_type j = 0; j < n; j++)
 	    {
-	      int limit = j < min_mn-1 ? j : min_mn-1;
-	      for (int i = 0; i <= limit; i++)
+	      octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
+	      for (octave_idx_type i = 0; i <= limit; i++)
 		r.elem (i, j) = tmp_data[m*j+i];
 	    }
 
 	  lwork = 32 * n2;
 	  work.resize (lwork);
 	  double *pwork2 = work.fortran_vec ();
 
 	  F77_XFCN (dorgqr, DORGQR, (m, n2, min_mn, tmp_data, m, ptau,
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -28,101 +28,101 @@ Software Foundation, 59 Temple Place - S
 
 #include "dbleQRP.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dgeqpf, DGEQPF) (const int&, const int&, double*,
-			     const int&, int*, double*, double*, int&);
+  F77_FUNC (dgeqpf, DGEQPF) (const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, octave_idx_type*, double*, double*, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (dorgqr, DORGQR) (const int&, const int&, const int&,
-			     double*, const int&, double*, double*,
-			     const int&, int&);
+  F77_FUNC (dorgqr, DORGQR) (const octave_idx_type&, const octave_idx_type&, const octave_idx_type&,
+			     double*, const octave_idx_type&, double*, double*,
+			     const octave_idx_type&, octave_idx_type&);
 }
 
 // It would be best to share some of this code with QR class...
 
 QRP::QRP (const Matrix& a, QR::type qr_type)
   : QR (), p ()
 {
   init (a, qr_type);
 }
 
 void
 QRP::init (const Matrix& a, QR::type qr_type)
 {
   assert (qr_type != QR::raw);
 
-  int m = a.rows ();
-  int n = a.cols ();
+  octave_idx_type m = a.rows ();
+  octave_idx_type n = a.cols ();
 
   if (m == 0 || n == 0)
     {
       (*current_liboctave_error_handler) ("QR must have non-empty matrix");
       return;
     }
 
-  int min_mn = m < n ? m : n;
+  octave_idx_type min_mn = m < n ? m : n;
   Array<double> tau (min_mn);
   double *ptau = tau.fortran_vec ();
 
-  int lwork = 3*n > 32*m ? 3*n : 32*m;
+  octave_idx_type lwork = 3*n > 32*m ? 3*n : 32*m;
   Array<double> work (lwork);
   double *pwork = work.fortran_vec ();
 
-  int info = 0;
+  octave_idx_type info = 0;
 
   Matrix A_fact = a;
   if (m > n && qr_type != QR::economy)
     A_fact.resize (m, m, 0.0);
 
   double *tmp_data = A_fact.fortran_vec ();
 
-  Array<int> jpvt (n, 0);
-  int *pjpvt = jpvt.fortran_vec ();
+  Array<octave_idx_type> jpvt (n, 0);
+  octave_idx_type *pjpvt = jpvt.fortran_vec ();
 
   // Code to enforce a certain permutation could go here...
 
   F77_XFCN (dgeqpf, DGEQPF, (m, n, tmp_data, m, pjpvt, ptau, pwork, info));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgeqpf");
   else
     {
       // Form Permutation matrix (if economy is requested, return the
       // indices only!)
 
       if (qr_type == QR::economy)
 	{
 	  p.resize (1, n, 0.0);
-	  for (int j = 0; j < n; j++)
+	  for (octave_idx_type j = 0; j < n; j++)
 	    p.elem (0, j) = jpvt.elem (j);
 	}
       else
 	{
 	  p.resize (n, n, 0.0);
-	  for (int j = 0; j < n; j++)
+	  for (octave_idx_type j = 0; j < n; j++)
 	    p.elem (jpvt.elem (j) - 1, j) = 1.0;
 	}
 
-      int n2 = (qr_type == QR::economy) ? min_mn : m;
+      octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
 
       if (qr_type == QR::economy && m > n)
 	r.resize (n, n, 0.0);
       else
 	r.resize (m, n, 0.0);
 
-      for (int j = 0; j < n; j++)
+      for (octave_idx_type j = 0; j < n; j++)
 	{
-	  int limit = j < min_mn-1 ? j : min_mn-1;
-	  for (int i = 0; i <= limit; i++)
+	  octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
+	  for (octave_idx_type i = 0; i <= limit; i++)
 	    r.elem (i, j) = A_fact.elem (i, j);
 	}
 
       F77_XFCN (dorgqr, DORGQR, (m, n2, min_mn, tmp_data, m, ptau,
 				 pwork, lwork, info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in dorgqr");
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -32,42 +32,42 @@ Software Foundation, 59 Temple Place - S
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeesx, DGEESX) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
 			     SCHUR::select_function,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, double*, const int&, int&,
-			     double*, double*, double*, const int&,
-			     double&, double&, double*, const int&,
-			     int*, const int&, int*, int&
+			     const octave_idx_type&, double*, const octave_idx_type&, octave_idx_type&,
+			     double*, double*, double*, const octave_idx_type&,
+			     double&, double&, double*, const octave_idx_type&,
+			     octave_idx_type*, const octave_idx_type&, octave_idx_type*, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
-static int
+static octave_idx_type
 select_ana (const double& a, const double&)
 {
    return (a < 0.0);
 }
 
-static int
+static octave_idx_type
 select_dig (const double& a, const double& b)
 {
   return (hypot (a, b) < 1.0);
 }
 
-int
+octave_idx_type
 SCHUR::init (const Matrix& a, const std::string& ord, bool calc_unitary)
 {
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("SCHUR requires square matrix");
       return -1;
     }
 
   // Workspace requirements may need to be fixed if any of the
@@ -89,21 +89,21 @@ SCHUR::init (const Matrix& a, const std:
 
   if (ord_char == 'A' || ord_char == 'a')
     selector = select_ana;
   else if (ord_char == 'D' || ord_char == 'd')
     selector = select_dig;
   else
     selector = 0;
 
-  int n = a_nc;
-  int lwork = 8 * n;
-  int liwork = 1;
-  int info;
-  int sdim;
+  octave_idx_type n = a_nc;
+  octave_idx_type lwork = 8 * n;
+  octave_idx_type liwork = 1;
+  octave_idx_type info;
+  octave_idx_type sdim;
   double rconde;
   double rcondv;
 
   schur_mat = a;
 
   if (calc_unitary)
     unitary_mat.resize (n, n);
 
@@ -115,21 +115,21 @@ SCHUR::init (const Matrix& a, const std:
 
   Array<double> wi (n);
   double *pwi = wi.fortran_vec ();
 
   Array<double> work (lwork);
   double *pwork = work.fortran_vec ();
 
   // BWORK is not referenced for the non-ordered Schur routine.
-  Array<int> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
-  int *pbwork = bwork.fortran_vec ();
+  Array<octave_idx_type> bwork ((ord_char == 'N' || ord_char == 'n') ? 0 : n);
+  octave_idx_type *pbwork = bwork.fortran_vec ();
 
-  Array<int> iwork (liwork);
-  int *piwork = iwork.fortran_vec ();
+  Array<octave_idx_type> iwork (liwork);
+  octave_idx_type *piwork = iwork.fortran_vec ();
 
   F77_XFCN (dgeesx, DGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
 			     F77_CONST_CHAR_ARG2 (&sort, 1),
 			     selector,
 			     F77_CONST_CHAR_ARG2 (&sense, 1),
 			     n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
 			     pwork, lwork, piwork, liwork, pbwork, info
 			     F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/dbleSCHUR.h b/liboctave/dbleSCHUR.h
--- a/liboctave/dbleSCHUR.h
+++ b/liboctave/dbleSCHUR.h
@@ -59,26 +59,26 @@ public:
   ~SCHUR (void) { }
 
   Matrix schur_matrix (void) const { return schur_mat; }
 
   Matrix unitary_matrix (void) const { return unitary_mat; }
 
   friend std::ostream& operator << (std::ostream& os, const SCHUR& a);
 
-  typedef int (*select_function) (const double&, const double&);
+  typedef octave_idx_type (*select_function) (const double&, const double&);
 
 private:
 
   Matrix schur_mat;
   Matrix unitary_mat;
 
   select_function selector;
 
-  int init (const Matrix& a, const std::string& ord, bool calc_unitary);
+  octave_idx_type init (const Matrix& a, const std::string& ord, bool calc_unitary);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -29,20 +29,20 @@ Software Foundation, 59 Temple Place - S
 #include "dbleSVD.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgesvd, DGESVD) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int&, const int&, double*,
-			     const int&, double*, double*,
-			     const int&, double*, const int&,
-			     double*, const int&, int&
+			     const octave_idx_type&, const octave_idx_type&, double*,
+			     const octave_idx_type&, double*, double*,
+			     const octave_idx_type&, double*, const octave_idx_type&,
+			     double*, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
 Matrix
 SVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
@@ -63,36 +63,36 @@ SVD::right_singular_matrix (void) const
       (*current_liboctave_error_handler)
 	("ComplexSVD: V not computed because type == SVD::sigma_only");
       return Matrix ();
     }
   else
     return right_sm;
 }
 
-int
+octave_idx_type
 SVD::init (const Matrix& a, SVD::type svd_type)
 {
-  int info;
+  octave_idx_type info;
 
-  int m = a.rows ();
-  int n = a.cols ();
+  octave_idx_type m = a.rows ();
+  octave_idx_type n = a.cols ();
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
-  int min_mn = m < n ? m : n;
+  octave_idx_type min_mn = m < n ? m : n;
 
   char jobu = 'A';
   char jobv = 'A';
 
-  int ncol_u = m;
-  int nrow_vt = n;
-  int nrow_s = m;
-  int ncol_s = n;
+  octave_idx_type ncol_u = m;
+  octave_idx_type nrow_vt = n;
+  octave_idx_type nrow_s = m;
+  octave_idx_type ncol_s = n;
 
   switch (svd_type)
     {
     case SVD::economy:
       jobu = jobv = 'S';
       ncol_u = nrow_vt = nrow_s = ncol_s = min_mn;
       break;
 
@@ -127,32 +127,32 @@ SVD::init (const Matrix& a, SVD::type sv
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   double *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
-  int lwork = -1;
+  octave_idx_type lwork = -1;
 
   Array<double> work (1);
 
   F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
 			     F77_CONST_CHAR_ARG2 (&jobv, 1),
 			     m, n, tmp_data, m, s_vec, u, m, vt,
 			     nrow_vt, work.fortran_vec (), lwork, info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgesvd");
   else
     {
-      lwork = static_cast<int> (work(0));
+      lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
 				 F77_CONST_CHAR_ARG2 (&jobv, 1),
 				 m, n, tmp_data, m, s_vec, u, m, vt,
 				 nrow_vt, work.fortran_vec (), lwork, info
 				 F77_CHAR_ARG_LEN (1)
 				 F77_CHAR_ARG_LEN (1)));
diff --git a/liboctave/dbleSVD.h b/liboctave/dbleSVD.h
--- a/liboctave/dbleSVD.h
+++ b/liboctave/dbleSVD.h
@@ -39,17 +39,17 @@ public:
       economy,
       sigma_only
     };
 
   SVD (void) : sigma (), left_sm (), right_sm () { }
 
   SVD (const Matrix& a, type svd_type = SVD::std) { init (a, svd_type); }
 
-  SVD (const Matrix& a, int& info, type svd_type = SVD::std)
+  SVD (const Matrix& a, octave_idx_type& info, type svd_type = SVD::std)
     {
       info = init (a, svd_type);
     }
 
   SVD (const SVD& a)
     : type_computed (a.type_computed),
       sigma (a.sigma), left_sm (a.left_sm), right_sm (a.right_sm) { }
 
@@ -79,17 +79,17 @@ public:
 private:
 
   SVD::type type_computed;
 
   DiagMatrix sigma;
   Matrix left_sm;
   Matrix right_sm;
 
-  int init (const Matrix& a, type svd_type = std);
+  octave_idx_type init (const Matrix& a, type svd_type = std);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -22,64 +22,65 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_dim_vector_h)
 #define octave_dim_vector_h 1
 
 #include <cassert>
 #include <string>
 
 #include "lo-sstream.h"
+#include "oct-types.h"
 
 class
 dim_vector
 {
 protected:
 
   class dim_vector_rep
   {
   public:
 
-    int *dims;
+    octave_idx_type *dims;
     int ndims;
     int count;
 
     dim_vector_rep (void) : dims (0), ndims (0), count (1) { }
 
-    dim_vector_rep (int n) : dims (new int [1]), ndims (1), count (1)
+    dim_vector_rep (octave_idx_type n) : dims (new octave_idx_type [1]), ndims (1), count (1)
     {
       dims[0] = n;
     }
 
-    dim_vector_rep (int r, int c) : dims (new int [2]), ndims (2), count (1)
+    dim_vector_rep (octave_idx_type r, octave_idx_type c) : dims (new octave_idx_type [2]), ndims (2), count (1)
     {
       dims[0] = r;
       dims[1] = c;
     }
 
-    dim_vector_rep (int r, int c, int p)
-      : dims (new int [3]), ndims (3), count (1)
+    dim_vector_rep (octave_idx_type r, octave_idx_type c, octave_idx_type p)
+      : dims (new octave_idx_type [3]), ndims (3), count (1)
     {
       dims[0] = r;
       dims[1] = c;
       dims[2] = p;
     }
 
     dim_vector_rep (const dim_vector_rep& dv)
-      : dims (dv.ndims > 0 ? new int [dv.ndims] : 0),
+      : dims (dv.ndims > 0 ? new octave_idx_type [dv.ndims] : 0),
 	ndims (dv.ndims > 0 ? dv.ndims : 0), count (1)
     {
       if (dims)
 	{
 	  for (int i = 0; i < ndims; i++)
 	    dims[i] = dv.dims[i];
 	}
     }
 
-    dim_vector_rep (int n, const dim_vector_rep *dv, int fill_value = 0)
-      : dims ((dv && n > 0) ? new int [n] : 0),
+    dim_vector_rep (octave_idx_type n, const dim_vector_rep *dv, int fill_value = 0)
+      : dims ((dv && n > 0) ? new octave_idx_type [n] : 0),
 	ndims (n > 0 ? n : 0), count (1)
     {
       if (dims)
 	{
 	  int dv_ndims = dv ? dv->ndims : 0;
 
 	  int min_len = n < dv_ndims ? n : dv_ndims;
 
@@ -90,23 +91,23 @@ protected:
 	    dims[i] = fill_value;
 	}
     }
 
     ~dim_vector_rep (void) { delete [] dims; }
 
     int length (void) const { return ndims; }
 
-    int& elem (int i)
+    octave_idx_type& elem (int i)
     {
       assert (i >= 0 && i < ndims);
       return dims[i];
     }
 
-    int elem (int i) const
+    octave_idx_type elem (int i) const
     {
       assert (i >= 0 && i < ndims);
       return dims[i];
     }
 
     void chop_trailing_singletons (void)
     {
       for (int i = ndims - 1; i > 1; i--)
@@ -145,23 +146,23 @@ private:
     return nr;
   }
 
 public:
 
   explicit dim_vector (void)
     : rep (nil_rep ()) { rep->count++; }
 
-  explicit dim_vector (int n)
+  explicit dim_vector (octave_idx_type n)
     : rep (new dim_vector_rep (n)) { }
 
-  explicit dim_vector (int r, int c)
+  explicit dim_vector (octave_idx_type r, octave_idx_type c)
     : rep (new dim_vector_rep (r, c)) { }
 
-  explicit dim_vector (int r, int c, int p)
+  explicit dim_vector (octave_idx_type r, octave_idx_type c, octave_idx_type p)
     : rep (new dim_vector_rep (r, c, p)) { }
 
   dim_vector (const dim_vector& dv)
     : rep (dv.rep) { rep->count++; }
 
   dim_vector& operator = (const dim_vector& dv)
   {
     if (&dv != this)
@@ -179,23 +180,23 @@ public:
   ~dim_vector (void)
   {
     if (--rep->count <= 0)
       delete rep;
   }
 
   int length (void) const { return rep->length (); }
 
-  int& elem (int i) { make_unique (); return rep->elem (i); }
+  octave_idx_type& elem (int i) { make_unique (); return rep->elem (i); }
 
-  int elem (int i) const { return rep->elem (i); }
+  octave_idx_type elem (int i) const { return rep->elem (i); }
 
-  int& operator () (int i) { return elem (i); }
+  octave_idx_type& operator () (int i) { return elem (i); }
 
-  int operator () (int i) const { return elem (i); }
+  octave_idx_type operator () (int i) const { return elem (i); }
 
   void resize (int n, int fill_value = 0)
   {
     int len = length ();
 
     if (n != len)
       {
 	dim_vector_rep *old_rep = rep;
@@ -277,21 +278,21 @@ public:
   {
     return (num_ones () == length ());
   }
 
   // This is the number of elements that a matrix with this dimension
   // vector would have, NOT the number of dimensions (elements in the
   // dimension vector).
 
-  int numel (void) const
+  octave_idx_type numel (void) const
   {
     int n_dims = length ();
 
-    int retval = n_dims > 0 ? elem (0) : 0;
+    octave_idx_type retval = n_dims > 0 ? elem (0) : 0;
 
     for (int i = 1; i < n_dims; i++)
       retval *= elem (i);
 
     return retval;
   }
 
   void chop_trailing_singletons (void)
@@ -325,17 +326,17 @@ public:
 	    // There is one non-singleton dimension, so we need
 	    // to decide the correct orientation.
 
 	    if (elem (0) == 1)
 	      {
 		// The original dimension vector had a leading
 		// singleton dimension.
 
-		int tmp = new_dims(0);
+		octave_idx_type tmp = new_dims(0);
 	
 		new_dims.resize (2);
 
  		new_dims(0) = 1;
 		new_dims(1) = tmp;
 	      }
 	    else
 	      {
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -44,38 +44,38 @@ IDX_VEC_REP::idx_vector_rep (const IDX_V
     max_val (a.max_val), min_val (a.min_val),
     frozen_at_z_len (a.frozen_at_z_len), frozen_len (a.frozen_len),
     colon (a.colon), one_zero (a.one_zero), initialized (a.initialized),
     frozen (a.frozen), colon_equiv_checked (a.colon_equiv_checked),
     colon_equiv (a.colon_equiv), orig_dims (a.orig_dims)
 {
   if (len > 0)
     {
-      data = new int [len];
-      for (int i = 0; i < len; i++)
+      data = new octave_idx_type [len];
+      for (octave_idx_type i = 0; i < len; i++)
 	data[i] = a.data[i];
     }
 }
 
-int
+octave_idx_type
 IDX_VEC_REP::tree_to_mat_idx (double x, bool& conversion_error)
 {
-  int retval = -1;
+  octave_idx_type retval = -1;
 
   conversion_error = false;
 
   if (D_NINT (x) != x)
     {
       (*current_liboctave_error_handler)
 	("expecting integer index, found %f", x);
 
       conversion_error = true;
     }
   else
-    retval = static_cast<int> (x - 1);
+    retval = static_cast<octave_idx_type> (x - 1);
 
   return retval;
 }
 
 static inline bool
 idx_is_inf_or_nan (double x)
 {
   bool retval = false;
@@ -102,21 +102,21 @@ IDX_VEC_REP::idx_vector_rep (const Colum
 {
   if (len == 0)
     {
       initialized = 1;
       return;
     }
   else
     {
-      data = new int [len];
+      data = new octave_idx_type [len];
 
       bool conversion_error = false;
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	{
 	  double d = v.elem (i);
 
 	  if (idx_is_inf_or_nan (d))
 	    return;
 	  else
 	    data[i] = tree_to_mat_idx (d, conversion_error);
 
@@ -137,22 +137,22 @@ IDX_VEC_REP::idx_vector_rep (const NDArr
 {
   if (len == 0)
     {
       initialized = 1;
       return;
     }
   else
     {
-      int k = 0;
-      data = new int [len];
+      octave_idx_type k = 0;
+      data = new octave_idx_type [len];
 
       bool conversion_error = false;
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	{
 	  double d = nda.elem (i);
 
 	  if (idx_is_inf_or_nan (d))
 	    return;
 	  else
 	    data[k++] = tree_to_mat_idx (d, conversion_error);
 
@@ -180,21 +180,21 @@ IDX_VEC_REP::idx_vector_rep (const Range
     {
       initialized = 1;
       return;
     }
 
   double b = r.base ();
   double step = r.inc ();
 
-  data = new int [len];
+  data = new octave_idx_type [len];
 
   bool conversion_error = false;
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     {
       double val = b + i * step;
 
       if (idx_is_inf_or_nan (val))
 	return;
       else
 	data[i] = tree_to_mat_idx (val, conversion_error);
 
@@ -211,37 +211,37 @@ IDX_VEC_REP::idx_vector_rep (double d)
     frozen_len (0), colon (0), one_zero (0), initialized (0),
     frozen (0), colon_equiv_checked (0), colon_equiv (0),
     orig_dims (1, 1)
 {
   if (idx_is_inf_or_nan (d))
     return;
   else
     {
-      data = new int [len];
+      data = new octave_idx_type [len];
 
       bool conversion_error = false;
 
       data[0] = tree_to_mat_idx (d, conversion_error);
 
       if (conversion_error)
 	return;
     }
 
   init_state ();
 }
 
-IDX_VEC_REP::idx_vector_rep (int i)
+IDX_VEC_REP::idx_vector_rep (octave_idx_type i)
   : data (0), len (1), num_zeros (0), num_ones (0),
     max_val (0), min_val (0), count (1), frozen_at_z_len (0),
     frozen_len (0), colon (0), one_zero (0), initialized (0),
     frozen (0), colon_equiv_checked (0), colon_equiv (0),
     orig_dims (1, 1)
 {
-  data = new int [len];
+  data = new octave_idx_type [len];
 
   data[0] = tree_to_mat_idx (i);
 
   init_state ();
 }
 
 IDX_VEC_REP::idx_vector_rep (char c)
   : data (0), len (0), num_zeros (0), num_ones (0),
@@ -257,17 +257,17 @@ IDX_VEC_REP::idx_vector_rep (char c)
 
 IDX_VEC_REP::idx_vector_rep (bool b)
   : data (0), len (1), num_zeros (0), num_ones (0),
     max_val (0), min_val (0), count (1), frozen_at_z_len (0),
     frozen_len (0), colon (0), one_zero (1), initialized (0),
     frozen (0), colon_equiv_checked (0), colon_equiv (0),
     orig_dims (1, 1)
 {
-  data = new int [len];
+  data = new octave_idx_type [len];
 
   data[0] = tree_to_mat_idx (b);
 
   init_state ();
 }
 
 IDX_VEC_REP::idx_vector_rep (const boolNDArray& bnda)
   : data (0), len (bnda.length ()), num_zeros (0), num_ones (0),
@@ -278,35 +278,35 @@ IDX_VEC_REP::idx_vector_rep (const boolN
 {
   if (len == 0)
     {
       initialized = 1;
       return;
     }
   else
     {
-      int k = 0;
-      data = new int [len];
+      octave_idx_type k = 0;
+      data = new octave_idx_type [len];
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	data[k++] = tree_to_mat_idx (bnda.elem (i));
     }
 
   init_state ();
 }
 
 IDX_VEC_REP&
 IDX_VEC_REP::operator = (const IDX_VEC_REP& a)
 {
   if (this != &a)
     {
       delete [] data;
       len = a.len;
-      data = new int [len];
-      for (int i = 0; i < len; i++)
+      data = new octave_idx_type [len];
+      for (octave_idx_type i = 0; i < len; i++)
 	data[i] = a.data[i];
 
       num_zeros = a.num_zeros;
       num_ones = a.num_ones;
       max_val = a.max_val;
       min_val = a.min_val;
       frozen_at_z_len = a.frozen_at_z_len;
       frozen_len = a.frozen_len;
@@ -332,17 +332,17 @@ IDX_VEC_REP::init_state (void)
     {
       min_val = 0;
       max_val = 0;
     }
   else
     {
       min_val = max_val = data[0];
 
-      int i = 0;
+      octave_idx_type i = 0;
       do
 	{
 	  if (data[i] == -1)
 	    num_zeros++;
 	  else if (data[i] == 0)
 	    num_ones++;
 
 	  if (data[i] > max_val)
@@ -353,147 +353,147 @@ IDX_VEC_REP::init_state (void)
 	}
       while (++i < len);
     }
 
   initialized = 1;
 }
 
 void
-IDX_VEC_REP::maybe_convert_one_zero_to_idx (int z_len)
+IDX_VEC_REP::maybe_convert_one_zero_to_idx (octave_idx_type z_len)
 {
   if (one_zero && (z_len == len || z_len == 0))
     {
       if (num_ones == 0)
 	{
 	  len = 0;
 	  max_val = 0;
 	  min_val = 0;
 	  delete [] data;
 	  data = 0;
 	}
       else
 	{
 	  assert (num_ones + num_zeros == len);
 
-	  int *new_data = new int [num_ones];
-	  int k = 0;
-	  for (int i = 0; i < len; i++)
+	  octave_idx_type *new_data = new octave_idx_type [num_ones];
+	  octave_idx_type k = 0;
+	  for (octave_idx_type i = 0; i < len; i++)
 	    if (data[i] == 0)
 	      new_data[k++] = i;
 
 	  delete [] data;
 	  len = num_ones;
 	  data = new_data;
 
 	  min_val = max_val = data[0];
 
-	  int i = 0;
+	  octave_idx_type i = 0;
 	  do
 	    {
 	      if (data[i] > max_val)
 		max_val = data[i];
 
 	      if (data[i] < min_val)
 		min_val = data[i];
 	    }
 	  while (++i < len);
 	}
     }
 }
 
-int
-IDX_VEC_REP::checkelem (int n) const
+octave_idx_type
+IDX_VEC_REP::checkelem (octave_idx_type n) const
 {
   if (n < 0 || n >= len)
     {
       (*current_liboctave_error_handler) ("idx-vector: index out of range");
       return 0;
     }
 
   return elem (n);
 }
 
 static inline int
 intcmp (const void *ii, const void *jj)
 {
-  return (*(static_cast<const int *> (ii)) - *(static_cast<const int *> (jj)));
+  return (*(static_cast<const octave_idx_type *> (ii)) - *(static_cast<const octave_idx_type *> (jj)));
 }
 
 static inline void
-sort_data (int *d, int l)
+sort_data (octave_idx_type *d, octave_idx_type l)
 {
-  qsort (d, l, sizeof (int), intcmp);
+  qsort (d, l, sizeof (octave_idx_type), intcmp);
 }
 
-static inline int
-make_uniq (int *d, int l)
+static inline octave_idx_type
+make_uniq (octave_idx_type *d, octave_idx_type l)
 {
   if (l < 2)
     return l;
 
-  int k = 0;
-  for (int ii = 1; ii < l; ii++)
+  octave_idx_type k = 0;
+  for (octave_idx_type ii = 1; ii < l; ii++)
     {
       if (d[ii] != d[k])
 	{
 	  k++;
 	  d[k] = d[ii];
 	}
     }
   return k+1;
 }
 
-static inline int *
-copy_data (const int *d, int l)
+static inline octave_idx_type *
+copy_data (const octave_idx_type *d, octave_idx_type l)
 {
-  int *new_data = new int [l];
+  octave_idx_type *new_data = new octave_idx_type [l];
 
-  for (int ii = 0; ii < l; ii++)
+  for (octave_idx_type ii = 0; ii < l; ii++)
     new_data[ii] = d[ii];
 
   return new_data;
 }
 
 int
-IDX_VEC_REP::is_colon_equiv (int n, int sort_uniq)
+IDX_VEC_REP::is_colon_equiv (octave_idx_type n, int sort_uniq)
 {
   if (! colon_equiv_checked)
     {
       if (colon)
 	{
 	  colon_equiv = 1;
 	}
-      else if (len > 1)
+      else if (static_cast<octave_idx_type> (len) > 1)
 	{
 	  if (one_zero)
 	    {
 	      colon_equiv = (len == n && ones_count () == n);
 	    }
 	  else if (sort_uniq)
 	    {
-	      int *tmp_data = copy_data (data, len);
+	      octave_idx_type *tmp_data = copy_data (data, len);
 
 	      sort_data (tmp_data, len);
 
-	      int tmp_len = make_uniq (tmp_data, len);
+	      octave_idx_type tmp_len = make_uniq (tmp_data, len);
 
 	      colon_equiv = (tmp_len == n
 			     && tmp_data[0] == 0
 			     && tmp_data[tmp_len-1] == tmp_len - 1);
 
 	      delete [] tmp_data;
 	    }
 	  else
 	    {
 	      if (len == n)
 		{
 		  colon_equiv = 1;
 
-		  for (int ii = 0; ii < n; ii++)
+		  for (octave_idx_type ii = 0; ii < n; ii++)
 		    if (data[ii] != ii)
 		      {
 			colon_equiv = 0;
 			break;
 		      }
 		}
 	    }
 	}
@@ -514,35 +514,35 @@ IDX_VEC_REP::sort (bool uniq)
       sort_data (data, len);
 
       if (uniq)
 	len = make_uniq (data, len);
     }
 }
 
 void
-IDX_VEC_REP::shorten (int n)
+IDX_VEC_REP::shorten (octave_idx_type n)
 {
   if (n > 0 && n <= len)
     len = n;
   else
     (*current_liboctave_error_handler)
       ("idx_vector::shorten: internal error!");
 }
 
 std::ostream&
 IDX_VEC_REP::print (std::ostream& os) const
 {
-  for (int ii = 0; ii < len; ii++)
+  for (octave_idx_type ii = 0; ii < len; ii++)
     os << data[ii] << "\n";
   return os;
 }
 
-int
-IDX_VEC_REP::freeze (int z_len, const char *tag, bool resize_ok,
+octave_idx_type
+IDX_VEC_REP::freeze (octave_idx_type z_len, const char *tag, bool resize_ok,
 		     bool warn_resize)
 {
   if (frozen)
     return frozen_len;
 
   frozen_len = -1;
 
   if (colon)
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -64,129 +64,130 @@ private:
     {
       if (len == 0)
 	{
 	  initialized = 1;
 	  return;
 	}
       else
 	{
-	  data = new int [len];
+	  data = new octave_idx_type [len];
 
 	  bool conversion_error = false;
 
-	  for (int i = 0; i < len; i++)
+	  for (octave_idx_type i = 0; i < len; i++)
 	    data[i] = tree_to_mat_idx (inda.elem (i), conversion_error);
 
 	  if (conversion_error)
 	    return;
 	}
 
       init_state ();
     }
 
     idx_vector_rep (const Range& r);
 
     idx_vector_rep (double d);
 
-    idx_vector_rep (int i);
+    idx_vector_rep (octave_idx_type i);
 
     idx_vector_rep (char c);
 
     idx_vector_rep (bool b);
 
     template <class U>
     idx_vector_rep (const octave_int<U>& i)
       : data (0), len (1), num_zeros (0), num_ones (0),
 	max_val (0), min_val (0), count (1), frozen_at_z_len (0),
 	frozen_len (0), colon (0), one_zero (0), initialized (0),
 	frozen (0), colon_equiv_checked (0), colon_equiv (0),
 	orig_dims (1, 1)
     {
-      data = new int [len];
+      data = new octave_idx_type [len];
 
       data[0] = tree_to_mat_idx (i);
 
       init_state ();
     }
 
     idx_vector_rep (const boolNDArray& bnda);
 
     idx_vector_rep (const idx_vector_rep& a);
 
     ~idx_vector_rep (void) { delete [] data; }
 
     idx_vector_rep& operator = (const idx_vector_rep& a);
 
     int ok (void) { return initialized; }
 
-    int capacity (void) const { return len; }
-    int length (int colon_len) const { return colon ? colon_len : len; }
+    octave_idx_type capacity (void) const { return len; }
+    octave_idx_type length (octave_idx_type colon_len) const { return colon ? colon_len : len; }
 
-    int elem (int n) const { return colon ? n : data[n]; }
+    octave_idx_type elem (octave_idx_type n) const { return colon ? n : data[n]; }
 
-    int checkelem (int n) const;
-    int operator () (int n) const { return checkelem (n); }
+    octave_idx_type checkelem (octave_idx_type n) const;
+    octave_idx_type operator () (octave_idx_type n) const { return checkelem (n); }
 
-    int max (void) const { return max_val; }
-    int min (void) const { return min_val; }
+    octave_idx_type max (void) const { return max_val; }
+    octave_idx_type min (void) const { return min_val; }
 
     int one_zero_only (void) const { return one_zero; }
-    int zeros_count (void) const { return num_zeros; }
-    int ones_count (void) const { return num_ones; }
+    octave_idx_type zeros_count (void) const { return num_zeros; }
+    octave_idx_type ones_count (void) const { return num_ones; }
 
     int is_colon (void) const { return colon; }
-    int is_colon_equiv (int n, int sort_uniq);
+    int is_colon_equiv (octave_idx_type n, int sort_uniq);
 
     void sort (bool uniq);
 
-    int orig_rows (void) const { return orig_dims(0); }
-    int orig_columns (void) const { return orig_dims(1); }
+    octave_idx_type orig_rows (void) const { return orig_dims(0); }
+    octave_idx_type orig_columns (void) const { return orig_dims(1); }
 
     dim_vector orig_dimensions (void) const { return orig_dims; }
 
     // other stuff
 
-    void shorten (int n); // Unsafe.  Avoid at all cost.
+    void shorten (octave_idx_type n); // Unsafe.  Avoid at all cost.
 
-    int freeze (int z_len, const char *tag, bool resize_ok, bool warn_resize);
+    octave_idx_type freeze (octave_idx_type z_len, const char *tag, bool resize_ok, bool warn_resize);
 
     // i/o
 
     std::ostream& print (std::ostream& os) const;
 
-    int *data;
-    int len;
-    int num_zeros;
-    int num_ones;
-    int max_val;
-    int min_val;
+    octave_idx_type *data;
+    octave_idx_type len;
+    octave_idx_type num_zeros;
+    octave_idx_type num_ones;
+    octave_idx_type max_val;
+    octave_idx_type min_val;
 
     int count;
-    int frozen_at_z_len;
-    int frozen_len;
+
+    octave_idx_type frozen_at_z_len;
+    octave_idx_type frozen_len;
 
     unsigned int colon : 1;
     unsigned int one_zero : 1;
     unsigned int initialized : 1;
     unsigned int frozen : 1;
     unsigned int colon_equiv_checked : 1;
     unsigned int colon_equiv : 1;
 
     dim_vector orig_dims;
  
     void init_state (void);
 
-    void maybe_convert_one_zero_to_idx (int z_len);
+    void maybe_convert_one_zero_to_idx (octave_idx_type z_len);
 
-    int tree_to_mat_idx (double x, bool& conversion_error);
+    octave_idx_type tree_to_mat_idx (double x, bool& conversion_error);
 
-    int tree_to_mat_idx (int i) { return i - 1; }
+    octave_idx_type tree_to_mat_idx (octave_idx_type i) { return i - 1; }
 
-    template <class U> int tree_to_mat_idx (const octave_int<U>& i)
+    template <class U> octave_idx_type tree_to_mat_idx (const octave_int<U>& i)
       { return i.value () - 1; }
   };
 
 public:
 
   idx_vector (void) : rep (new idx_vector_rep ()) { }
 
   idx_vector (const ColumnVector& v) : rep (new idx_vector_rep (v)) { }
@@ -195,17 +196,17 @@ public:
 
   template <class U>
   idx_vector (const intNDArray<U>& inda) : rep (new idx_vector_rep (inda)) { }
 
   idx_vector (const Range& r) : rep (new idx_vector_rep (r)) { }
 
   idx_vector (double d) : rep (new idx_vector_rep (d)) { }
 
-  idx_vector (int i) : rep (new idx_vector_rep (i)) { }
+  idx_vector (octave_idx_type i) : rep (new idx_vector_rep (i)) { }
 
   idx_vector (char c) : rep (new idx_vector_rep (c)) { }
 
   idx_vector (bool b) : rep (new idx_vector_rep (b)) { }
 
   template <class U>
   idx_vector (const octave_int<U>& i) : rep (new idx_vector_rep (i)) { }
 
@@ -229,59 +230,59 @@ public:
 	  rep = a.rep;
 	  rep->count++;
 	}
       return *this;
     }
 
   operator bool () const { return rep->ok (); }
 
-  int capacity (void) const { return rep->capacity (); }
-  int length (int cl) const { return rep->length (cl); }
+  octave_idx_type capacity (void) const { return rep->capacity (); }
+  octave_idx_type length (octave_idx_type cl) const { return rep->length (cl); }
 
-  int elem (int n) const { return rep->elem (n); }
-  int checkelem (int n) const { return rep->checkelem (n); }
-  int operator () (int n) const { return rep->operator () (n); }
+  octave_idx_type elem (octave_idx_type n) const { return rep->elem (n); }
+  octave_idx_type checkelem (octave_idx_type n) const { return rep->checkelem (n); }
+  octave_idx_type operator () (octave_idx_type n) const { return rep->operator () (n); }
 
-  int max (void) const { return rep->max (); }
-  int min (void) const { return rep->min (); }
+  octave_idx_type max (void) const { return rep->max (); }
+  octave_idx_type min (void) const { return rep->min (); }
 
   int one_zero_only (void) const { return rep->one_zero_only (); }
-  int zeros_count (void) const { return rep->zeros_count (); }
-  int ones_count (void) const { return rep->ones_count (); }
+  octave_idx_type zeros_count (void) const { return rep->zeros_count (); }
+  octave_idx_type ones_count (void) const { return rep->ones_count (); }
 
   int is_colon (void) const { return rep->is_colon (); }
-  int is_colon_equiv (int n, int sort_uniq = 0) const
+  int is_colon_equiv (octave_idx_type n, int sort_uniq = 0) const
     { return rep->is_colon_equiv (n, sort_uniq); }
 
   void sort (bool uniq = false) { rep->sort (uniq); }
 
-  int orig_rows (void) const { return rep->orig_rows (); }
-  int orig_columns (void) const { return rep->orig_columns (); }
+  octave_idx_type orig_rows (void) const { return rep->orig_rows (); }
+  octave_idx_type orig_columns (void) const { return rep->orig_columns (); }
 
   dim_vector orig_dimensions (void) const { return rep->orig_dimensions (); }
 
   int orig_empty (void) const
     { return (! is_colon () && orig_dimensions().any_zero ()); }
 
   // Unsafe.  Avoid at all cost.
-  void shorten (int n) { rep->shorten (n); }
+  void shorten (octave_idx_type n) { rep->shorten (n); }
 
   // i/o
 
-  int freeze (int z_len, const char *tag, bool resize_ok = false,
+  octave_idx_type freeze (octave_idx_type z_len, const char *tag, bool resize_ok = false,
 	      bool warn_resize = false)
     { return rep->freeze (z_len, tag, resize_ok, warn_resize); }
 
   std::ostream& print (std::ostream& os) const { return rep->print (os); }
 
   friend std::ostream& operator << (std::ostream& os, const idx_vector& a)
     { return a.print (os); }
 
-  void maybe_convert_one_zero_to_idx (int z_len)
+  void maybe_convert_one_zero_to_idx (octave_idx_type z_len)
     { rep->maybe_convert_one_zero_to_idx (z_len); }
 
 private:
 
   idx_vector_rep *rep;
 
   void init_state (void) { rep->init_state (); }
 };
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -32,17 +32,17 @@ Software Foundation, 59 Temple Place - S
 // unary operations
 
 template <class T>
 boolNDArray
 intNDArray<T>::operator ! (void) const
 {
   boolNDArray b (this->dims ());
 
-  for (int i = 0; i < this->length (); i++)
+  for (octave_idx_type i = 0; i < this->length (); i++)
     b.elem (i) = ! this->elem (i);
 
   return b;
 }
 
 // XXX FIXME XXX -- this is not quite the right thing.
 
 template <class T>
@@ -56,83 +56,83 @@ template <class T>
 boolNDArray
 intNDArray<T>::any (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (this->elem (iter_idx) == T (0)), false);
 }
 
 template <class T>
 void
-intNDArray<T>::increment_index (Array<int>& ra_idx,
+intNDArray<T>::increment_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 template <class T>
-int 
-intNDArray<T>::compute_index (Array<int>& ra_idx,
+octave_idx_type 
+intNDArray<T>::compute_index (Array<octave_idx_type>& ra_idx,
 			      const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 template <class T>
 intNDArray<T>
-intNDArray<T>::concat (const intNDArray<T>& rb, const Array<int>& ra_idx)
+intNDArray<T>::concat (const intNDArray<T>& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0);
     insert (rb, ra_idx);
   return *this;
 }
 
 template <class T>
 intNDArray<T>&
-intNDArray<T>::insert (const intNDArray<T>& a, int r, int c)
+intNDArray<T>::insert (const intNDArray<T>& a, octave_idx_type r, octave_idx_type c)
 {
   Array<T>::insert (a, r, c);
   return *this;
 }
 
 template <class T>
 intNDArray<T>&
-intNDArray<T>::insert (const intNDArray<T>& a, const Array<int>& ra_idx)
+intNDArray<T>::insert (const intNDArray<T>& a, const Array<octave_idx_type>& ra_idx)
 {
   Array<T>::insert (a, ra_idx);
   return *this;
 }
 
 // This contains no information on the array structure !!!
 
 template <class T>
 std::ostream&
 operator << (std::ostream& os, const intNDArray<T>& a)
 {
-  int nel = a.nelem ();
+  octave_idx_type nel = a.nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     os << " " << a.elem (i) << "\n";
 
   return os;
 }
 
 template <class T>
 std::istream&
 operator >> (std::istream& is, intNDArray<T>& a)
 {
-  int nel = a.nelem ();
+  octave_idx_type nel = a.nelem ();
 
   if (nel < 1 )
     is.clear (std::ios::badbit);
   else
     {
       T tmp;
 
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	{
 	  is >> tmp;
 
 	  if (is)
 	    a.elem (i) = tmp;
 	  else
 	    goto done;
 	}
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -67,26 +67,26 @@ public:
   boolNDArray any (int dim = -1) const;
 
   intNDArray squeeze (void) const
     { return intNDArray<T> (MArrayN<T>::squeeze ()); }
 
   intNDArray transpose (void) const
     { return intNDArray<T> (MArrayN<T>::transpose ()); }
 
-  intNDArray concat (const intNDArray<T>& rb, const Array<int>& ra_idx);
+  intNDArray concat (const intNDArray<T>& rb, const Array<octave_idx_type>& ra_idx);
 
-  intNDArray& insert (const intNDArray<T>& a, int r, int c);
-  intNDArray& insert (const intNDArray<T>& a, const Array<int>& ra_idx);
+  intNDArray& insert (const intNDArray<T>& a, octave_idx_type r, octave_idx_type c);
+  intNDArray& insert (const intNDArray<T>& a, const Array<octave_idx_type>& ra_idx);
 
-  static void increment_index (Array<int>& ra_idx,
+  static void increment_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
-  static int compute_index (Array<int>& ra_idx,
+  static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions);
 
   static T resize_fill_value (void) { return 0; }
 
 protected:
 
   intNDArray (T *d, dim_vector& dv) : MArrayN<T> (d, dv) { }
 };
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -40,46 +40,46 @@ Software Foundation, 59 Temple Place - S
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
 #endif
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zbesj, ZBESJ) (const double&, const double&, const double&,
-			   const int&, const int&, double*, double*,
-			   int&, int&);
+			   const octave_idx_type&, const octave_idx_type&, double*, double*,
+			   octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbesy, ZBESY) (const double&, const double&, const double&,
-			   const int&, const int&, double*, double*,
-			   int&, double*, double*, int&);
+			   const octave_idx_type&, const octave_idx_type&, double*, double*,
+			   octave_idx_type&, double*, double*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbesi, ZBESI) (const double&, const double&, const double&,
-			   const int&, const int&, double*, double*,
-			   int&, int&);
+			   const octave_idx_type&, const octave_idx_type&, double*, double*,
+			   octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbesk, ZBESK) (const double&, const double&, const double&,
-			   const int&, const int&, double*, double*,
-			   int&, int&);
+			   const octave_idx_type&, const octave_idx_type&, double*, double*,
+			   octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zbesh, ZBESH) (const double&, const double&, const double&,
-			   const int&, const int&, const int&, double*,
-			   double*, int&, int&);
+			   const octave_idx_type&, const octave_idx_type&, const octave_idx_type&, double*,
+			   double*, octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (zairy, ZAIRY) (const double&, const double&, const int&,
-			   const int&, double&, double&, int&, int&);
+  F77_FUNC (zairy, ZAIRY) (const double&, const double&, const octave_idx_type&,
+			   const octave_idx_type&, double&, double&, octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (zbiry, ZBIRY) (const double&, const double&, const int&,
-			   const int&, double&, double&, int&);
+  F77_FUNC (zbiry, ZBIRY) (const double&, const double&, const octave_idx_type&,
+			   const octave_idx_type&, double&, double&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (xdacosh, XDACOSH) (const double&, double&);
 
   F77_RET_T
   F77_FUNC (xdasinh, XDASINH) (const double&, double&);
 
   F77_RET_T
@@ -174,35 +174,35 @@ xlgamma (double x)
       ("xlgamma: argument must be nonnegative");
 
   F77_FUNC (dlgams, DLGAMS) (x, result, sgngam);
 
   return result;
 }
 
 static inline Complex
-zbesj (const Complex& z, double alpha, int kode, int& ierr);
+zbesj (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
-zbesy (const Complex& z, double alpha, int kode, int& ierr);
+zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
-zbesi (const Complex& z, double alpha, int kode, int& ierr);
+zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
-zbesk (const Complex& z, double alpha, int kode, int& ierr);
+zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
-zbesh1 (const Complex& z, double alpha, int kode, int& ierr);
+zbesh1 (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
-zbesh2 (const Complex& z, double alpha, int kode, int& ierr);
+zbesh2 (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
-bessel_return_value (const Complex& val, int ierr)
+bessel_return_value (const Complex& val, octave_idx_type ierr)
 {
   static const Complex inf_val = Complex (octave_Inf, octave_Inf);
   static const Complex nan_val = Complex (octave_NaN, octave_NaN);
 
   Complex retval;
 
   switch (ierr)
     {
@@ -225,26 +225,26 @@ bessel_return_value (const Complex& val,
 
 static inline bool
 is_integer_value (double x)
 {
   return x == static_cast<double> (static_cast<long> (x));
 }
 
 static inline Complex
-zbesj (const Complex& z, double alpha, int kode, int& ierr)
+zbesj (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
   Complex retval;
 
   if (alpha >= 0.0)
     {
       double yr = 0.0;
       double yi = 0.0;
 
-      int nz;
+      octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesj, ZBESJ) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
 	{
@@ -282,26 +282,26 @@ zbesj (const Complex& z, double alpha, i
       else
 	retval = Complex (octave_NaN, octave_NaN);
     }
 
   return retval;
 }
 
 static inline Complex
-zbesy (const Complex& z, double alpha, int kode, int& ierr)
+zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
   Complex retval;
 
   if (alpha >= 0.0)
     {
       double yr = 0.0;
       double yi = 0.0;
 
-      int nz;
+      octave_idx_type nz;
 
       double wr, wi;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       ierr = 0;
 
@@ -352,26 +352,26 @@ zbesy (const Complex& z, double alpha, i
       else
 	retval = Complex (octave_NaN, octave_NaN);
     }
 
   return retval;
 }
 
 static inline Complex
-zbesi (const Complex& z, double alpha, int kode, int& ierr)
+zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
   Complex retval;
 
   if (alpha >= 0.0)
     {
       double yr = 0.0;
       double yi = 0.0;
 
-      int nz;
+      octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesi, ZBESI) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
 	{
@@ -402,26 +402,26 @@ zbesi (const Complex& z, double alpha, i
       else
 	retval = Complex (octave_NaN, octave_NaN);
     }
 
   return retval;
 }
 
 static inline Complex
-zbesk (const Complex& z, double alpha, int kode, int& ierr)
+zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
   Complex retval;
 
   if (alpha >= 0.0)
     {
       double yr = 0.0;
       double yi = 0.0;
 
-      int nz;
+      octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       ierr = 0;
 
       if (zr == 0.0 && zi == 0.0)
 	{
@@ -457,26 +457,26 @@ zbesk (const Complex& z, double alpha, i
 
       retval = bessel_return_value (tmp, ierr);
     }
 
   return retval;
 }
 
 static inline Complex
-zbesh1 (const Complex& z, double alpha, int kode, int& ierr)
+zbesh1 (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
   Complex retval;
 
   if (alpha >= 0.0)
     {
       double yr = 0.0;
       double yi = 0.0;
 
-      int nz;
+      octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 1, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
 	{
@@ -503,26 +503,26 @@ zbesh1 (const Complex& z, double alpha, 
 
       retval = bessel_return_value (tmp, ierr);
     }
 
   return retval;
 }
 
 static inline Complex
-zbesh2 (const Complex& z, double alpha, int kode, int& ierr)
+zbesh2 (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
   Complex retval;
 
   if (alpha >= 0.0)
     {
       double yr = 0.0;
       double yi = 0.0;
 
-      int nz;
+      octave_idx_type nz;
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 2, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
 	{
@@ -548,230 +548,230 @@ zbesh2 (const Complex& z, double alpha, 
       Complex tmp = exp (-M_PI * alpha * eye) * zbesh2 (z, alpha, kode, ierr);
 
       retval = bessel_return_value (tmp, ierr);
     }
 
   return retval;
 }
 
-typedef Complex (*fptr) (const Complex&, double, int, int&);
+typedef Complex (*fptr) (const Complex&, double, int, octave_idx_type&);
 
 static inline Complex
 do_bessel (fptr f, const char *, double alpha, const Complex& x,
-	   bool scaled, int& ierr)
+	   bool scaled, octave_idx_type& ierr)
 {
   Complex retval;
 
   retval = f (x, alpha, (scaled ? 2 : 1), ierr);
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (fptr f, const char *, double alpha, const ComplexMatrix& x,
-	   bool scaled, Array2<int>& ierr)
+	   bool scaled, Array2<octave_idx_type>& ierr)
 {
-  int nr = x.rows ();
-  int nc = x.cols ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (fptr f, const char *, const Matrix& alpha, const Complex& x,
-	   bool scaled, Array2<int>& ierr)
+	   bool scaled, Array2<octave_idx_type>& ierr)
 {
-  int nr = alpha.rows ();
-  int nc = alpha.cols ();
+  octave_idx_type nr = alpha.rows ();
+  octave_idx_type nc = alpha.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (fptr f, const char *fn, const Matrix& alpha,
-	   const ComplexMatrix& x, bool scaled, Array2<int>& ierr)
+	   const ComplexMatrix& x, bool scaled, Array2<octave_idx_type>& ierr)
 {
   ComplexMatrix retval;
 
-  int x_nr = x.rows ();
-  int x_nc = x.cols ();
+  octave_idx_type x_nr = x.rows ();
+  octave_idx_type x_nc = x.cols ();
 
-  int alpha_nr = alpha.rows ();
-  int alpha_nc = alpha.cols ();
+  octave_idx_type alpha_nr = alpha.rows ();
+  octave_idx_type alpha_nc = alpha.cols ();
 
   if (x_nr == alpha_nr && x_nc == alpha_nc)
     {
-      int nr = x_nr;
-      int nc = x_nc;
+      octave_idx_type nr = x_nr;
+      octave_idx_type nc = x_nc;
 
       retval.resize (nr, nc);
 
       ierr.resize (nr, nc);
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
     }
   else
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (fptr f, const char *, double alpha, const ComplexNDArray& x,
-	   bool scaled, ArrayN<int>& ierr)
+	   bool scaled, ArrayN<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
       retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (fptr f, const char *, const NDArray& alpha, const Complex& x,
-	   bool scaled, ArrayN<int>& ierr)
+	   bool scaled, ArrayN<octave_idx_type>& ierr)
 {
   dim_vector dv = alpha.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (fptr f, const char *fn, const NDArray& alpha,
-	   const ComplexNDArray& x, bool scaled, ArrayN<int>& ierr)
+	   const ComplexNDArray& x, bool scaled, ArrayN<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   ComplexNDArray retval;
 
   if (dv == alpha.dims ())
     {
-      int nel = dv.numel ();
+      octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
       ierr.resize (dv);
 
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
     }
   else
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (fptr f, const char *, const RowVector& alpha,
-	   const ComplexColumnVector& x, bool scaled, Array2<int>& ierr)
+	   const ComplexColumnVector& x, bool scaled, Array2<octave_idx_type>& ierr)
 {
-  int nr = x.length ();
-  int nc = alpha.length ();
+  octave_idx_type nr = x.length ();
+  octave_idx_type nc = alpha.length ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 #define SS_BESSEL(name, fcn) \
   Complex \
-  name (double alpha, const Complex& x, bool scaled, int& ierr) \
+  name (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SM_BESSEL(name, fcn) \
   ComplexMatrix \
   name (double alpha, const ComplexMatrix& x, bool scaled, \
-	Array2<int>& ierr) \
+	Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MS_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const Matrix& alpha, const Complex& x, bool scaled, \
-	Array2<int>& ierr) \
+	Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MM_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const Matrix& alpha, const ComplexMatrix& x, bool scaled, \
-	Array2<int>& ierr) \
+	Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SN_BESSEL(name, fcn) \
   ComplexNDArray \
   name (double alpha, const ComplexNDArray& x, bool scaled, \
-	ArrayN<int>& ierr) \
+	ArrayN<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NS_BESSEL(name, fcn) \
   ComplexNDArray \
   name (const NDArray& alpha, const Complex& x, bool scaled, \
-	ArrayN<int>& ierr) \
+	ArrayN<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NN_BESSEL(name, fcn) \
   ComplexNDArray \
   name (const NDArray& alpha, const ComplexNDArray& x, bool scaled, \
-	ArrayN<int>& ierr) \
+	ArrayN<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define RC_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, \
-        Array2<int>& ierr) \
+        Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define ALL_BESSEL(name, fcn) \
   SS_BESSEL (name, fcn) \
   SM_BESSEL (name, fcn) \
   MS_BESSEL (name, fcn) \
@@ -784,27 +784,27 @@ do_bessel (fptr f, const char *, const R
 ALL_BESSEL (besselj, zbesj)
 ALL_BESSEL (bessely, zbesy)
 ALL_BESSEL (besseli, zbesi)
 ALL_BESSEL (besselk, zbesk)
 ALL_BESSEL (besselh1, zbesh1)
 ALL_BESSEL (besselh2, zbesh2)
 
 Complex
-airy (const Complex& z, bool deriv, bool scaled, int& ierr)
+airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr)
 {
   double ar = 0.0;
   double ai = 0.0;
 
-  int nz;
+  octave_idx_type nz;
 
   double zr = z.real ();
   double zi = z.imag ();
 
-  int id = deriv ? 1 : 0;
+  octave_idx_type id = deriv ? 1 : 0;
 
   F77_FUNC (zairy, ZAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
 
   if (! scaled)
     {
       Complex expz = exp (- 2.0 / 3.0 * z * sqrt(z));
 
       double rexpz = real (expz);
@@ -818,25 +818,25 @@ airy (const Complex& z, bool deriv, bool
 
   if (zi == 0.0 && (! scaled || zr >= 0.0))
     ai = 0.0;
 
   return bessel_return_value (Complex (ar, ai), ierr);
 }
 
 Complex
-biry (const Complex& z, bool deriv, bool scaled, int& ierr)
+biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr)
 {
   double ar = 0.0;
   double ai = 0.0;
 
   double zr = z.real ();
   double zi = z.imag ();
 
-  int id = deriv ? 1 : 0;
+  octave_idx_type id = deriv ? 1 : 0;
 
   F77_FUNC (zbiry, ZBIRY) (zr, zi, id, 2, ar, ai, ierr);
 
   if (! scaled)
     {
       Complex expz = exp (std::abs (real (2.0 / 3.0 * z * sqrt (z))));
 
       double rexpz = real (expz);
@@ -850,82 +850,82 @@ biry (const Complex& z, bool deriv, bool
 
   if (zi == 0.0 && (! scaled || zr >= 0.0))
     ai = 0.0;
 
   return bessel_return_value (Complex (ar, ai), ierr);
 }
 
 ComplexMatrix
-airy (const ComplexMatrix& z, bool deriv, bool scaled, Array2<int>& ierr)
+airy (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr)
 {
-  int nr = z.rows ();
-  int nc = z.cols ();
+  octave_idx_type nr = z.rows ();
+  octave_idx_type nc = z.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 ComplexMatrix
-biry (const ComplexMatrix& z, bool deriv, bool scaled, Array2<int>& ierr)
+biry (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr)
 {
-  int nr = z.rows ();
-  int nc = z.cols ();
+  octave_idx_type nr = z.rows ();
+  octave_idx_type nc = z.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 ComplexNDArray
-airy (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<int>& ierr)
+airy (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     retval (i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 ComplexNDArray
-biry (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<int>& ierr)
+biry (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     retval (i) = biry (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 static void
-gripe_betainc_nonconformant (int r1, int c1, int r2, int c2, int r3,
-			     int c3)
+gripe_betainc_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2, octave_idx_type r3,
+			     octave_idx_type c3)
 {
   (*current_liboctave_error_handler)
    ("betainc: nonconformant arguments (x is %dx%d, a is %dx%d, b is %dx%d)",
      r1, c1, r2, c2, r3, c3);
 }
 
 static dim_vector null_dims (0);
 
@@ -948,60 +948,60 @@ betainc (double x, double a, double b)
   double retval;
   F77_FUNC (xdbetai, XDBETAI) (x, a, b, retval);
   return retval;
 }
 
 Matrix
 betainc (double x, double a, const Matrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = betainc (x, a, b(i,j));
 
   return retval;
 }
 
 Matrix
 betainc (double x, const Matrix& a, double b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = betainc (x, a(i,j), b);
 
   return retval;
 }
 
 Matrix
 betainc (double x, const Matrix& a, const Matrix& b)
 {
   Matrix retval;
 
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (a_nr == b_nr && a_nc == b_nc)
     {
       retval.resize (a_nr, a_nc);
 
-      for (int j = 0; j < a_nc; j++)
-	for (int i = 0; i < a_nr; i++)
+      for (octave_idx_type j = 0; j < a_nc; j++)
+	for (octave_idx_type i = 0; i < a_nr; i++)
 	  retval(i,j) = betainc (x, a(i,j), b(i,j));
     }
   else
     gripe_betainc_nonconformant (1, 1, a_nr, a_nc, b_nr, b_nc);
 
   return retval;
 }
 
@@ -1053,98 +1053,98 @@ betainc (double x, const NDArray& a, con
   
   return retval;
 }
 
 
 Matrix
 betainc (const Matrix& x, double a, double b)
 {
-  int nr = x.rows ();
-  int nc = x.cols ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.cols ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = betainc (x(i,j), a, b);
 
   return retval;
 }
 
 Matrix
 betainc (const Matrix& x, double a, const Matrix& b)
 {
   Matrix retval;
 
-  int nr = x.rows ();
-  int nc = x.cols ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr == b_nr && nc == b_nc)
     {
       retval.resize (nr, nc);
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  retval(i,j) = betainc (x(i,j), a, b(i,j));
     }
   else
     gripe_betainc_nonconformant (nr, nc, 1, 1, b_nr, b_nc);
 
   return retval;
 }
 
 Matrix
 betainc (const Matrix& x, const Matrix& a, double b)
 {
   Matrix retval;
 
-  int nr = x.rows ();
-  int nc = x.cols ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.cols ();
 
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (nr == a_nr && nc == a_nc)
     {
       retval.resize (nr, nc);
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  retval(i,j) = betainc (x(i,j), a(i,j), b);
     }
   else
     gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, 1, 1);
 
   return retval;
 }
 
 Matrix
 betainc (const Matrix& x, const Matrix& a, const Matrix& b)
 {
   Matrix retval;
 
-  int nr = x.rows ();
-  int nc = x.cols ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.cols ();
 
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr == a_nr && nr == b_nr && nc == a_nc && nc == b_nc)
     {
       retval.resize (nr, nc);
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  retval(i,j) = betainc (x(i,j), a(i,j), b(i,j));
     }
   else
     gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, b_nr, b_nc);
 
   return retval;
 }
 
@@ -1245,26 +1245,26 @@ gammainc (double x, double a, bool& err)
     F77_FUNC (xgammainc, XGAMMAINC) (a, x, retval);
 
   return retval;
 }
 
 Matrix
 gammainc (double x, const Matrix& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   Matrix result (nr, nc);
   Matrix retval;
 
   bool err;
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	result(i,j) = gammainc (x, a(i,j), err);
 
 	if (err)
 	  goto done;
       }
 
   retval = result;
@@ -1272,26 +1272,26 @@ gammainc (double x, const Matrix& a)
  done:
 
   return retval;
 }
 
 Matrix
 gammainc (const Matrix& x, double a)
 {
-  int nr = x.rows ();
-  int nc = x.cols ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.cols ();
 
   Matrix result (nr, nc);
   Matrix retval;
 
   bool err;
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	result(i,j) = gammainc (x(i,j), a, err);
 
 	if (err)
 	  goto done;
       }
 
   retval = result;
@@ -1302,30 +1302,30 @@ gammainc (const Matrix& x, double a)
 }
 
 Matrix
 gammainc (const Matrix& x, const Matrix& a)
 {
   Matrix result;
   Matrix retval;
 
-  int nr = x.rows ();
-  int nc = x.cols ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.cols ();
 
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
   if (nr == a_nr && nc == a_nc)
     {
       result.resize (nr, nc);
 
       bool err;
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    result(i,j) = gammainc (x(i,j), a(i,j), err);
 
 	    if (err)
 	      goto done;
 	  }
 
       retval = result;
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -19,16 +19,17 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_liboctave_specfun_h)
 #define octave_liboctave_specfun_h 1
 
 #include "oct-cmplx.h"
+#include "oct-types.h"
 #include "ArrayN.h"
 
 template <class T> class Array2;
 class Matrix;
 class ComplexMatrix;
 class NDArray;
 class ComplexNDArray;
 class RowVector;
@@ -54,215 +55,215 @@ extern double erf (double);
 #if !defined (HAVE_ERFC)
 extern double erfc (double);
 #endif
 
 extern double xgamma (double x);
 extern double xlgamma (double x);
 
 extern Complex
-besselj (double alpha, const Complex& x, bool scaled, int& ierr);
+besselj (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern Complex
-bessely (double alpha, const Complex& x, bool scaled, int& ierr);
+bessely (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern Complex
-besseli (double alpha, const Complex& x, bool scaled, int& ierr);
+besseli (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern Complex
-besselk (double alpha, const Complex& x, bool scaled, int& ierr);
+besselk (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern Complex
-besselh1 (double alpha, const Complex& x, bool scaled, int& ierr);
+besselh1 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern Complex
-besselh2 (double alpha, const Complex& x, bool scaled, int& ierr);
+besselh2 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern ComplexMatrix
 besselj (double alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 bessely (double alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besseli (double alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselk (double alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselh1 (double alpha, const ComplexMatrix& x, bool scaled,
-	  Array2<int>& ierr);
+	  Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselh2 (double alpha, const ComplexMatrix& x, bool scaled,
-	  Array2<int>& ierr);
+	  Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselj (const Matrix& alpha, const Complex& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 bessely (const Matrix& alpha, const Complex& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besseli (const Matrix& alpha, const Complex& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselk (const Matrix& alpha, const Complex& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselh1 (const Matrix& alpha, const Complex& x, bool scaled,
-	  Array2<int>& ierr);
+	  Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselh2 (const Matrix& alpha, const Complex& x, bool scaled,
-	  Array2<int>& ierr);
+	  Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselj (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 bessely (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besseli (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselk (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselh1 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	  Array2<int>& ierr);
+	  Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	  Array2<int>& ierr);
+	  Array2<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselj (double alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 bessely (double alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besseli (double alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselk (double alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselh1 (double alpha, const ComplexNDArray& x, bool scaled,
-	  ArrayN<int>& ierr);
+	  ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselh2 (double alpha, const ComplexNDArray& x, bool scaled,
-	  ArrayN<int>& ierr);
+	  ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselj (const NDArray& alpha, const Complex& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 bessely (const NDArray& alpha, const Complex& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besseli (const NDArray& alpha, const Complex& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselk (const NDArray& alpha, const Complex& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselh1 (const NDArray& alpha, const Complex& x, bool scaled,
-	  ArrayN<int>& ierr);
+	  ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselh2 (const NDArray& alpha, const Complex& x, bool scaled,
-	  ArrayN<int>& ierr);
+	  ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselj (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 bessely (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besseli (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselk (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<int>& ierr);
+	 ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselh1 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	  ArrayN<int>& ierr);
+	  ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
 besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	  ArrayN<int>& ierr);
+	  ArrayN<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besseli (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselk (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	 Array2<int>& ierr);
+	 Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	  Array2<int>& ierr);
+	  Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
 besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	  Array2<int>& ierr);
+	  Array2<octave_idx_type>& ierr);
 
-extern Complex airy (const Complex& z, bool deriv, bool scaled, int& ierr);
-extern Complex biry (const Complex& z, bool deriv, bool scaled, int& ierr);
+extern Complex airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+extern Complex biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
 extern ComplexMatrix
-airy (const ComplexMatrix& z, bool deriv, bool scaled, Array2<int>& ierr);
+airy (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
 
 extern ComplexMatrix
-biry (const ComplexMatrix& z, bool deriv, bool scaled, Array2<int>& ierr);
+biry (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
 
 extern ComplexNDArray
-airy (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<int>& ierr);
+airy (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr);
 
 extern ComplexNDArray
-biry (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<int>& ierr);
+biry (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr);
 
 extern double betainc (double x, double a, double b);
 extern Matrix betainc (double x, double a, const Matrix& b);
 extern Matrix betainc (double x, const Matrix& a, double b);
 extern Matrix betainc (double x, const Matrix& a, const Matrix& b);
 
 extern NDArray betainc (double x, double a, const NDArray& b);
 extern NDArray betainc (double x, const NDArray& a, double b);
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -41,16 +41,30 @@ Software Foundation, 59 Temple Place - S
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 
 // Convert X to the nearest integer value.  Should not pass NaN to
 // this function.
 
+// Sometimes you need a large integer, but not always.
+// XXX FIXME-64 XXX -- INT_MAX and INT_MIN are probably not right here.
+
+octave_idx_type
+NINTbig (double x)
+{
+  if (x > INT_MAX)
+    return INT_MAX;
+  else if (x < INT_MIN)
+    return INT_MIN;
+  else
+    return static_cast<octave_idx_type> ((x > 0) ? (x + 0.5) : (x - 0.5));
+}
+
 int
 NINT (double x)
 {
   if (x > INT_MAX)
     return INT_MAX;
   else if (x < INT_MIN)
     return INT_MIN;
   else
diff --git a/liboctave/lo-utils.h b/liboctave/lo-utils.h
--- a/liboctave/lo-utils.h
+++ b/liboctave/lo-utils.h
@@ -24,17 +24,19 @@ Software Foundation, 59 Temple Place - S
 #define octave_liboctave_utils_h 1
 
 #include <cstdio>
 
 #include <iostream>
 #include <string>
 
 #include "oct-cmplx.h"
+#include "oct-types.h"
 
+extern octave_idx_type NINTbig (double x);
 extern int NINT (double x);
 extern double D_NINT (double x);
 
 extern char *strsave (const char *);
 
 extern void octave_putenv (const std::string&, const std::string&);
 
 extern std::string octave_fgets (std::FILE *);
diff --git a/liboctave/mach-info.cc b/liboctave/mach-info.cc
--- a/liboctave/mach-info.cc
+++ b/liboctave/mach-info.cc
@@ -22,20 +22,21 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "mach-info.h"
+#include "oct-types.h"
 
 extern "C"
 {
-  double F77_FUNC (d1mach, D1MACH) (const int&);
+  double F77_FUNC (d1mach, D1MACH) (const octave_idx_type&);
 }
 
 oct_mach_info *oct_mach_info::instance = 0;
 
 union equiv
 {
   double d;
   int i[2];
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -226,82 +226,82 @@ OP_DUP_FCN (-, mx_inline_change_sign, Co
 OP_DUP_FCN (real, mx_inline_real_dup, double,  Complex)
 OP_DUP_FCN (imag, mx_inline_imag_dup, double,  Complex)
 OP_DUP_FCN (conj, mx_inline_conj_dup, Complex, Complex)
 
 // Avoid some code duplication.  Maybe we should use templates.
 
 #define MX_CUMULATIVE_OP(RET_TYPE, ELT_TYPE, OP) \
  \
-  int nr = rows (); \
-  int nc = cols (); \
+  octave_idx_type nr = rows (); \
+  octave_idx_type nc = cols (); \
  \
   RET_TYPE retval (nr, nc); \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
 	{ \
-	  for (int i = 0; i < nr; i++) \
+	  for (octave_idx_type i = 0; i < nr; i++) \
 	    { \
 	      ELT_TYPE t = elem (i, 0); \
-	      for (int j = 0; j < nc; j++) \
+	      for (octave_idx_type j = 0; j < nc; j++) \
 		{ \
 		  retval.elem (i, j) = t; \
 		  if (j < nc - 1) \
 		    t OP elem (i, j+1); \
 		} \
 	    } \
 	} \
       else \
 	{ \
-	  for (int j = 0; j < nc; j++) \
+	  for (octave_idx_type j = 0; j < nc; j++) \
 	    { \
 	      ELT_TYPE t = elem (0, j); \
-	      for (int i = 0; i < nr; i++) \
+	      for (octave_idx_type i = 0; i < nr; i++) \
 		{ \
 		  retval.elem (i, j) = t; \
 		  if (i < nr - 1) \
 		    t OP elem (i+1, j); \
 		} \
 	    } \
 	} \
     } \
  \
   return retval
 
 #define MX_BASE_REDUCTION_OP(RET_TYPE, ROW_EXPR, COL_EXPR, INIT_VAL, \
 			     MT_RESULT) \
  \
-  int nr = rows (); \
-  int nc = cols (); \
+  octave_idx_type nr = rows (); \
+  octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
 	{ \
 	  retval.resize (nr, 1); \
-	  for (int i = 0; i < nr; i++) \
+	  for (octave_idx_type i = 0; i < nr; i++) \
 	    { \
 	      retval.elem (i, 0) = INIT_VAL; \
-	      for (int j = 0; j < nc; j++) \
+	      for (octave_idx_type j = 0; j < nc; j++) \
 		{ \
 		  ROW_EXPR; \
 		} \
 	    } \
 	} \
       else \
 	{ \
 	  retval.resize (1, nc); \
-	  for (int j = 0; j < nc; j++) \
+	  for (octave_idx_type j = 0; j < nc; j++) \
 	    { \
 	      retval.elem (0, j) = INIT_VAL; \
-	      for (int i = 0; i < nr; i++) \
+	      for (octave_idx_type i = 0; i < nr; i++) \
 		{ \
 		  COL_EXPR; \
 		} \
 	    } \
 	} \
     } \
   else if (nc == 0 && (nr == 0 || (nr == 1 && dim == -1))) \
     retval.resize (1, 1, MT_RESULT); \
@@ -434,45 +434,45 @@ OP_DUP_FCN (conj, mx_inline_conj_dup, Co
       dv(dim) = 1; \
  \
       retval.resize (dv, VAL); \
  \
       return retval; \
     } \
  \
   /*  Length of Dimension */ \
-  int dim_length = 1; \
+  octave_idx_type dim_length = 1; \
  \
   /* dim = -1 means from here that the user specified a */ \
   /* dimension which is larger that the number of dimensions */ \
   /* of the array */ \
  \
   if (dim >= dv.length ()) \
     dim = -1; \
   else \
     dim_length = dv(dim); \
  \
   if (dim > -1) \
     dv(dim) = 1; \
  \
   /* This finds the number of elements in retval */ \
-  int num_iter = (this->numel () / dim_length); \
+  octave_idx_type num_iter = (this->numel () / dim_length); \
  \
   /* Make sure retval has correct dimensions */ \
   retval.resize (dv, VAL); \
  \
-  Array<int> iter_idx (dv.length (), 0); \
+  Array<octave_idx_type> iter_idx (dv.length (), 0); \
  \
   /* Filling in values.         */ \
   /* First loop finds new index */ \
  \
-  for (int j = 0; j < num_iter; j++) \
+  for (octave_idx_type j = 0; j < num_iter; j++) \
     { \
       ACC_DECL;\
-      for (int i = 0; i < dim_length; i++) \
+      for (octave_idx_type i = 0; i < dim_length; i++) \
 	{ \
 	  if (dim > -1) \
 	    iter_idx(dim) = i; \
  \
 	  EVAL_EXPR; \
 	} \
  \
       if (dim > -1) \
@@ -562,33 +562,33 @@ OP_DUP_FCN (conj, mx_inline_conj_dup, Co
       retval.resize (dv); \
       return retval; \
     } \
  \
   /* Make sure retval has correct dimensions */ \
   retval.resize (dv, VAL); \
  \
   /*  Length of Dimension */ \
-  int dim_length = 1; \
+  octave_idx_type dim_length = 1; \
  \
   dim_length = dv (dim); \
  \
   dv (dim) = 1; \
  \
   /* This finds the number of elements in retval */ \
-  int num_iter = (this->numel () / dim_length); \
+  octave_idx_type num_iter = (this->numel () / dim_length); \
  \
-  Array<int> iter_idx (dv.length (), 0); \
+  Array<octave_idx_type> iter_idx (dv.length (), 0); \
  \
   /* Filling in values.         */ \
   /* First loop finds new index */ \
  \
-  for (int j = 0; j < num_iter; j++) \
+  for (octave_idx_type j = 0; j < num_iter; j++) \
     { \
-      for (int i = 0; i < dim_length; i++) \
+      for (octave_idx_type i = 0; i < dim_length; i++) \
 	{ \
 	  if (i > 0) \
 	    { \
 	      iter_idx (dim) = i - 1; \
  \
 	      ACC_TYPE prev_sum = retval (iter_idx); \
  \
 	      iter_idx (dim) = i; \
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -52,64 +52,64 @@ Software Foundation, 59 Temple Place - S
 class
 octave_fftw_planner
 {
 public:
 
   octave_fftw_planner (void);
 
   fftw_plan create_plan (int dir, const int rank, const dim_vector dims, 
-			 int howmany, int stride, int dist, 
+			 octave_idx_type howmany, octave_idx_type stride, octave_idx_type dist, 
 			 const Complex *in, Complex *out);
 
   fftw_plan create_plan (const int rank, const dim_vector dims, 
-			 int howmany, int stride, int dist, 
+			 octave_idx_type howmany, octave_idx_type stride, octave_idx_type dist, 
 			 const double *in, Complex *out);
 
 private:
 
   int plan_flags;
 
   // XXX FIXME XXX -- perhaps this should be split into two classes?
 
   // Plan for fft and ifft of complex values
   fftw_plan plan[2];
 
   // dist
-  int d[2];
+  octave_idx_type d[2];
 
   // stride
-  int s[2];
+  octave_idx_type s[2];
 
   // rank
   int r[2];
 
   // howmany
-  int h[2];
+  octave_idx_type h[2];
 
   // dims
   dim_vector n[2];
 
   bool simd_align[2];
   bool inplace[2];
 
   // Plan for fft of real values
   fftw_plan rplan;
 
   // dist
-  int rd;
+  octave_idx_type rd;
 
   // stride
-  int rs;
+  octave_idx_type rs;
 
   // rank
   int rr;
 
   // howmany
-  int rh;
+  octave_idx_type rh;
 
   // dims
   dim_vector rn;
 
   bool rsimd_align;
 };
 
 octave_fftw_planner::octave_fftw_planner (void)
@@ -131,18 +131,18 @@ octave_fftw_planner::octave_fftw_planner
   fftw_import_system_wisdom ();
 }
 
 #define CHECK_SIMD_ALIGNMENT(x) \
   ((reinterpret_cast<ptrdiff_t> (x)) & 0xF == 0)
 
 fftw_plan
 octave_fftw_planner::create_plan (int dir, const int rank,
-				  const dim_vector dims, int howmany,
-				  int stride, int dist, 
+				  const dim_vector dims, octave_idx_type howmany,
+				  octave_idx_type stride, octave_idx_type dist, 
 				  const Complex *in, Complex *out)
 {
   int which = (dir == FFTW_FORWARD) ? 0 : 1;
   fftw_plan *cur_plan_p = &plan[which];
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
   bool ioinplace = (in == out);
 
@@ -202,17 +202,17 @@ octave_fftw_planner::create_plan (int di
 	(*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
  
 fftw_plan
 octave_fftw_planner::create_plan (const int rank, const dim_vector dims, 
-				  int howmany, int stride, int dist, 
+				  octave_idx_type howmany, octave_idx_type stride, octave_idx_type dist, 
 				  const double *in, Complex *out)
 {
   fftw_plan *cur_plan_p = &rplan;
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
@@ -269,17 +269,17 @@ octave_fftw_planner::create_plan (const 
 
   return *cur_plan_p;
 }
 
 static octave_fftw_planner fftw_planner;
 
 static inline void
 convert_packcomplex_1d (Complex *out, size_t nr, size_t nc,
-			int stride, int dist)
+			octave_idx_type stride, octave_idx_type dist)
 {
   OCTAVE_QUIT;
 
   // Fill in the missing data.
 
   for (size_t i = 0; i < nr; i++)
     for (size_t j = nc/2+1; j < nc; j++)
       out[j*stride + i*dist] = conj(out[(nc - j)*stride + i*dist]);
@@ -346,17 +346,17 @@ convert_packcomplex_Nd (Complex *out, co
       jstart = jmax;
     }
 
   OCTAVE_QUIT;
 }
 
 int
 octave_fftw::fft (const double *in, Complex *out, size_t npts, 
-		  size_t nsamples, int stride, int dist)
+		  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftw_plan plan = fftw_planner.create_plan (1, dv, nsamples, stride, dist,
 					     in, out);
 
   fftw_execute_dft_r2c (plan, (const_cast<double *>(in)),
@@ -366,34 +366,34 @@ octave_fftw::fft (const double *in, Comp
 
   convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
   return 0;
 }
 
 int
 octave_fftw::fft (const Complex *in, Complex *out, size_t npts, 
-		  size_t nsamples, int stride, int dist)
+		  size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftw_plan plan = fftw_planner.create_plan (FFTW_FORWARD, 1, dv, nsamples,
 					     stride, dist, in, out);
 
   fftw_execute_dft (plan, 
 	reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
 	reinterpret_cast<fftw_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifft (const Complex *in, Complex *out, size_t npts, 
-		   size_t nsamples, int stride, int dist)
+		   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts);
   fftw_plan plan = fftw_planner.create_plan (FFTW_BACKWARD, 1, dv, nsamples,
 					     stride, dist, in, out);
 
   fftw_execute_dft (plan, 
@@ -407,24 +407,24 @@ octave_fftw::ifft (const Complex *in, Co
 
   return 0;
 }
 
 int
 octave_fftw::fftNd (const double *in, Complex *out, const int rank, 
 		    const dim_vector &dv)
 {
-  int dist = 1;
+  octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   // Fool with the position of the start of the output matrix, so that
   // creating other half of the matrix won't cause cache problems.
 
-  int offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2); 
+  octave_idx_type offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2); 
   
   fftw_plan plan = fftw_planner.create_plan (rank, dv, 1, 1, dist,
 					     in, out + offset);
 
   fftw_execute_dft_r2c (plan, (const_cast<double *>(in)),
 			reinterpret_cast<fftw_complex *> (out+ offset));
 
   // Need to create other half of the transform.
@@ -433,17 +433,17 @@ octave_fftw::fftNd (const double *in, Co
 
   return 0;
 }
 
 int
 octave_fftw::fftNd (const Complex *in, Complex *out, const int rank, 
 		    const dim_vector &dv)
 {
-  int dist = 1;
+  octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftw_plan plan = fftw_planner.create_plan (FFTW_FORWARD, rank, dv, 1, 1,
 					     dist, in, out);
 
   fftw_execute_dft (plan, 
 	reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
@@ -451,17 +451,17 @@ octave_fftw::fftNd (const Complex *in, C
 
   return 0;
 }
 
 int
 octave_fftw::ifftNd (const Complex *in, Complex *out, const int rank, 
 		     const dim_vector &dv)
 {
-  int dist = 1;
+  octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftw_plan plan = fftw_planner.create_plan (FFTW_BACKWARD, rank, dv, 1, 1,
 					     dist, in, out);
 
   fftw_execute_dft (plan, 
 	reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
diff --git a/liboctave/oct-fftw.h b/liboctave/oct-fftw.h
--- a/liboctave/oct-fftw.h
+++ b/liboctave/oct-fftw.h
@@ -27,21 +27,21 @@ Software Foundation, 59 Temple Place - S
 #include "oct-cmplx.h"
 #include "dim-vector.h"
 
 class
 octave_fftw
 {
 public:
   static int fft (const double *in, Complex *out, size_t npts, 
-		  size_t nsamples = 1, int stride = 1, int dist = -1);
+		  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
   static int fft (const Complex *in, Complex *out, size_t npts, 
-		  size_t nsamples = 1, int stride = 1, int dist = -1);
+		  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
   static int ifft (const Complex *in, Complex *out, size_t npts,
-		   size_t nsamples = 1, int stride = 1, int dist = -1);
+		   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
 
   static int fftNd (const double*, Complex*, const int, const dim_vector &);
   static int fftNd (const Complex*, Complex*, const int, 
 		    const dim_vector &);
   static int ifftNd (const Complex*, Complex*, const int, 
 		     const dim_vector &);
 
 private:
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -44,30 +44,30 @@ extern "C"
 {
   F77_RET_T
   F77_FUNC (dgennor, DGENNOR) (const double&, const double&, double&);
 
   F77_RET_T
   F77_FUNC (dgenunf, DGENUNF) (const double&, const double&, double&);
 
   F77_RET_T
-  F77_FUNC (setall, SETALL) (const int&, const int&);
+  F77_FUNC (setall, SETALL) (const octave_idx_type&, const octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (getsd, GETSD) (int&, int&);
+  F77_FUNC (getsd, GETSD) (octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (setsd, SETSD) (const int&, const int&);
+  F77_FUNC (setsd, SETSD) (const octave_idx_type&, const octave_idx_type&);
 
   F77_RET_T
-  F77_FUNC (setcgn, SETCGN) (const int&);
+  F77_FUNC (setcgn, SETCGN) (const octave_idx_type&);
 }
 
-static int
-force_to_fit_range (int i, int lo, int hi)
+static octave_idx_type
+force_to_fit_range (octave_idx_type i, octave_idx_type lo, octave_idx_type hi)
 {
   assert (hi > lo && lo >= 0 && hi > lo);
 
   i = i > 0 ? i : -i;
 
   if (i < lo)
     i = lo;
   else if (i > hi)
@@ -85,18 +85,18 @@ static void
 do_initialization (void)
 {
   octave_localtime tm;
  
   int hour = tm.hour() + 1;
   int minute = tm.min() + 1;
   int second = tm.sec() + 1;
 
-  int s0 = tm.mday() * hour * minute * second;
-  int s1 = hour * minute * second;
+  octave_idx_type s0 = tm.mday() * hour * minute * second;
+  octave_idx_type s1 = hour * minute * second;
 
   s0 = force_to_fit_range (s0, 1, 2147483563);
   s1 = force_to_fit_range (s1, 1, 2147483399);
 
   F77_FUNC (setall, SETALL) (s0, s1);
 
   initialized = true;
 }
@@ -108,28 +108,28 @@ maybe_initialize (void)
     do_initialization ();
 }
 
 double
 octave_rand::seed (void)
 {
   maybe_initialize ();
 
-  union d2i { double d; int i[2]; };
+  union d2i { double d; octave_idx_type i[2]; };
   union d2i u;
   F77_FUNC (getsd, GETSD) (u.i[0], u.i[1]);
   return u.d;
 }
 
 void
 octave_rand::seed (double s)
 {
   maybe_initialize ();
 
-  union d2i { double d; int i[2]; };
+  union d2i { double d; octave_idx_type i[2]; };
   union d2i u;
   u.d = s;
   int i0 = force_to_fit_range (u.i[0], 1, 2147483563);
   int i1 = force_to_fit_range (u.i[1], 1, 2147483399);
   F77_FUNC (setsd, SETSD) (i0, i1);
 }
 
 std::string
@@ -203,28 +203,28 @@ octave_rand::scalar (void)
 
   return retval;
 }
 
 #define MAKE_RAND_MAT(mat, nr, nc, f, F) \
   do \
     { \
       double val; \
-      for (volatile int j = 0; j < nc; j++) \
-	for (volatile int i = 0; i < nr; i++) \
+      for (volatile octave_idx_type j = 0; j < nc; j++) \
+	for (volatile octave_idx_type i = 0; i < nr; i++) \
 	  { \
 	    OCTAVE_QUIT; \
 	    F77_FUNC (f, F) (0.0, 1.0, val); \
 	    mat(i,j) = val; \
 	  } \
     } \
   while (0)
 
 Matrix
-octave_rand::matrix (int n, int m)
+octave_rand::matrix (octave_idx_type n, octave_idx_type m)
 {
   maybe_initialize ();
 
   Matrix retval;
 
   if (n >= 0 && m >= 0)
     {
       retval.resize (n, m);
@@ -252,17 +252,17 @@ octave_rand::matrix (int n, int m)
 
   return retval;
 }
 
 #define MAKE_RAND_ND_ARRAY(mat, len, f, F) \
   do \
     { \
       double val; \
-      for (volatile int i = 0; i < len; i++) \
+      for (volatile octave_idx_type i = 0; i < len; i++) \
 	{ \
 	  OCTAVE_QUIT; \
 	  F77_FUNC (f, F) (0.0, 1.0, val); \
 	  mat(i) = val; \
 	} \
     } \
   while (0)
 
@@ -272,17 +272,17 @@ octave_rand::nd_array (const dim_vector&
   maybe_initialize ();
 
   NDArray retval;
 
   if (! dims.all_zero ())
     {
       retval.resize (dims);
 
-      int len = retval.length ();
+      octave_idx_type len = retval.length ();
 
       switch (current_distribution)
 	{
 	case uniform_dist:
 	  MAKE_RAND_ND_ARRAY (retval, len, dgenunf, DGENUNF);
 	  break;
 
 	case normal_dist:
@@ -297,27 +297,27 @@ octave_rand::nd_array (const dim_vector&
 
   return retval;
 }
 
 #define MAKE_RAND_ARRAY(array, n, f, F) \
   do \
     { \
       double val; \
-      for (volatile int i = 0; i < n; i++) \
+      for (volatile octave_idx_type i = 0; i < n; i++) \
 	{ \
 	  OCTAVE_QUIT; \
 	  F77_FUNC (f, F) (0.0, 1.0, val); \
 	  array(i) = val; \
 	} \
     } \
   while (0)
 
 Array<double>
-octave_rand::vector (int n)
+octave_rand::vector (octave_idx_type n)
 {
   maybe_initialize ();
 
   Array<double> retval;
 
   if (n > 0)
     {
       retval.resize (n);
diff --git a/liboctave/oct-rand.h b/liboctave/oct-rand.h
--- a/liboctave/oct-rand.h
+++ b/liboctave/oct-rand.h
@@ -48,24 +48,24 @@ octave_rand
 
   static void normal_distribution (void);
 
   // Return the next number from the sequence.
   static double scalar (void);
 
   // Return a matrix of numbers from the sequence, filled in column
   // major order.
-  static Matrix matrix (int r, int c);
+  static Matrix matrix (octave_idx_type r, octave_idx_type c);
 
   // Return an N-dimensional array of numbers from the sequence,
   // filled in column major order.
   static NDArray nd_array (const dim_vector& dims);
 
   // Return an array of numbers from the sequence.
-  static Array<double> vector (int n);
+  static Array<double> vector (octave_idx_type n);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/oct-types.h.in b/liboctave/oct-types.h.in
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-types.h.in
@@ -0,0 +1,34 @@
+/*
+
+Copyright (C) 2005 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_oct_types_h)
+#define octave_oct_types_h 1
+
+typedef @OCTAVE_IDX_TYPE@ octave_idx_type;
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/so-array.cc b/liboctave/so-array.cc
--- a/liboctave/so-array.cc
+++ b/liboctave/so-array.cc
@@ -63,44 +63,44 @@ operator -= (streamoff_array& a, const s
 {
   DO_VS_OP2 (std::streamoff, a, -=, s);
   return a;
 }
 
 streamoff_array&
 operator += (streamoff_array& a, const streamoff_array& b)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
   if (l > 0)
     {
-      int bl = b.length ();
+      octave_idx_type bl = b.length ();
       if (l != bl)
 	gripe_nonconformant ("operator +=", l, bl);
       else
 	DO_VV_OP2 (std::streamoff, a, +=, b);
     }
   return a;
 }
 
 streamoff_array&
 operator -= (streamoff_array& a, const streamoff_array& b)
 {
-  int l = a.length ();
+  octave_idx_type l = a.length ();
   if (l > 0)
     {
-      int bl = b.length ();
+      octave_idx_type bl = b.length ();
       if (l != bl)
 	gripe_nonconformant ("operator -=", l, bl);
       else
 	DO_VV_OP2 (std::streamoff, a, -=, b);
     }
   return a;
 }
 
-int
+octave_idx_type
 streamoff_array::compute_index (Array<int>& ra_idx,
 				const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 SND_CMP_OP (mx_el_eq, ==, std::streamoff, , streamoff_array, )
 SND_CMP_OP (mx_el_ne, !=, std::streamoff, , streamoff_array, )
diff --git a/liboctave/so-array.h b/liboctave/so-array.h
--- a/liboctave/so-array.h
+++ b/liboctave/so-array.h
@@ -59,17 +59,17 @@ public:
     }
 
   streamoff_array squeeze (void) const
     { return ArrayN<std::streamoff>::squeeze (); }
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
-  static int compute_index (Array<int>& ra_idx,
+  static octave_idx_type compute_index (Array<int>& ra_idx,
 			    const dim_vector& dimensions);
 
   static std::streamoff resize_fill_value (void) { return 0; }
 };
 
 streamoff_array& operator += (streamoff_array& l, const std::streamoff& r);
 streamoff_array& operator -= (streamoff_array& l, const std::streamoff& r);
 
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -24,40 +24,40 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "sparse-base-lu.h"
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 p_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pr (void) const
 {
-  int nr = Lfact.rows ();
+  octave_idx_type nr = Lfact.rows ();
 
   p_type Pout (nr, nr, nr);
 
-  for (int i = 0; i < nr; i++)
+  for (octave_idx_type i = 0; i < nr; i++)
     {
       Pout.cidx (i) = i;
       Pout.ridx (P (i)) = i;
       Pout.data (i) = 1;
     }
   Pout.cidx (nr) = nr;
 
   return Pout;
 }
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 p_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pc (void) const
 {
-  int nc = Ufact.cols ();
+  octave_idx_type nc = Ufact.cols ();
 
   p_type Pout (nc, nc, nc);
 
-  for (int i = 0; i < nc; i++)
+  for (octave_idx_type i = 0; i < nc; i++)
     {
       Pout.cidx (i) = i;
       Pout.ridx (i) = Q (i);
       Pout.data (i) = 1;
     }
   Pout.cidx (nc) = nc;
 
   return Pout;
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -39,106 +39,106 @@ 90, 91, 95, 1996 Free Software Foundatio
 #include "lo-utils.h"
 #include "str-vec.h"
 
 // Create a string vector from a NULL terminated list of C strings.
 
 string_vector::string_vector (const char * const *s)
   : Array<std::string> ()
 {
-  int n = 0;
+  octave_idx_type n = 0;
 
   const char * const *t = s;
 
   while (*t++)
     n++;
 
   resize (n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 // Create a string vector from up to N C strings.  Assumes that N is
 // nonnegative.
 
-string_vector::string_vector (const char * const *s, int n)
+string_vector::string_vector (const char * const *s, octave_idx_type n)
   : Array<std::string> (n)
 {
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 int
 string_vector::compare (const void *a_arg, const void *b_arg)
 {
   const std::string *a = (const std::string *) a_arg;
   const std::string *b = (const std::string *) b_arg;
 
   return a->compare (*b);
 }
 
 string_vector&
 string_vector::uniq (void)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (len > 0)
     {
-      int k = 0;
+      octave_idx_type k = 0;
 
-      for (int i = 1; i < len; i++)
+      for (octave_idx_type i = 1; i < len; i++)
 	if (elem(i) != elem(k))
 	  if (++k != i)
 	    elem(k) = elem(i);
 
       if (len != ++k)
 	resize (k);
     }
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const std::string& s)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   resize (len + 1);
 
   elem(len) = s;
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const string_vector& sv)
 {
-  int len = length ();
-  int sv_len = sv.length ();
-  int new_len = len + sv_len;
+  octave_idx_type len = length ();
+  octave_idx_type sv_len = sv.length ();
+  octave_idx_type new_len = len + sv_len;
 
   resize (new_len);
 
-  for (int i = 0; i < sv_len; i++)
+  for (octave_idx_type i = 0; i < sv_len; i++)
     elem(len + i) = sv[i];
 
   return *this;
 }
 
 char **
 string_vector::c_str_vec (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   char **retval = new char * [len + 1];
 
   retval [len] = 0;
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     retval[i] = strsave (elem(i).c_str ());
 
   return retval;
 }
 
 void
 string_vector::delete_c_str_vec (const char * const *v)
 {
@@ -150,67 +150,67 @@ string_vector::delete_c_str_vec (const c
 
 // Format a list in neat columns.
 
 std::ostream&
 string_vector::list_in_columns (std::ostream& os) const
 {
   // Compute the maximum name length.
 
-  int max_name_length = 0;
-  int total_names = length ();
+  octave_idx_type max_name_length = 0;
+  octave_idx_type total_names = length ();
 
-  for (int i = 0; i < total_names; i++)
+  for (octave_idx_type i = 0; i < total_names; i++)
     {
-      int name_length = elem (i).length ();
+      octave_idx_type name_length = elem (i).length ();
       if (name_length > max_name_length)
 	max_name_length = name_length;
     }
 
   // Allow at least two spaces between names.
 
   max_name_length += 2;
 
   // Calculate the maximum number of columns that will fit.
 
-  int line_length = command_editor::terminal_cols ();
-  int nc = line_length / max_name_length;
+  octave_idx_type line_length = command_editor::terminal_cols ();
+  octave_idx_type nc = line_length / max_name_length;
   if (nc == 0)
     nc = 1;
 
   // Calculate the number of rows that will be in each column except
   // possibly  for a short column on the right.
 
-  int nr = total_names / nc + (total_names % nc != 0);
+  octave_idx_type nr = total_names / nc + (total_names % nc != 0);
 
   // Recalculate columns based on rows.
 
   nc = total_names / nr + (total_names % nr != 0);
 
-  int count;
-  for (int row = 0; row < nr; row++)
+  octave_idx_type count;
+  for (octave_idx_type row = 0; row < nr; row++)
     {
       count = row;
-      int pos = 0;
+      octave_idx_type pos = 0;
 
       // Print the next row.
 
       while (1)
 	{
 	  std::string nm = elem (count);
 
 	  os << nm;
-	  int name_length = nm.length ();
+	  octave_idx_type name_length = nm.length ();
 
 	  count += nr;
 	  if (count >= total_names)
 	    break;
 
-	  int spaces_to_pad = max_name_length - name_length;
-	  for (int i = 0; i < spaces_to_pad; i++)
+	  octave_idx_type spaces_to_pad = max_name_length - name_length;
+	  for (octave_idx_type i = 0; i < spaces_to_pad; i++)
 	    os << " ";
 	  pos += max_name_length;
 	}
       os << "\n";
     }
 
   return os;
 }
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -30,59 +30,59 @@ Software Foundation, 59 Temple Place - S
 
 class
 string_vector : public Array<std::string>
 {
 public:
 
   string_vector (void) : Array<std::string> () { }
 
-  explicit string_vector (int n) : Array<std::string> (n) { }
+  explicit string_vector (octave_idx_type n) : Array<std::string> (n) { }
 
   string_vector (const char *s) : Array<std::string> (1, s) { }
 
   string_vector (const std::string& s) : Array<std::string> (1, s) { }
 
   string_vector (const string_vector& s) : Array<std::string> (s) { }
 
   string_vector (const char * const *s);
 
-  string_vector (const char * const *s, int n);
+  string_vector (const char * const *s, octave_idx_type n);
 
   string_vector& operator = (const string_vector& s)
   {
     if (this != &s)
       Array<std::string>::operator = (s);
 
     return *this;
   }
 
   ~string_vector (void) { }
 
   int empty (void) const { return length () == 0; }
 
-  int max_length (void) const
+  octave_idx_type max_length (void) const
   {
-    int n = length ();
-    int longest = 0;
+    octave_idx_type n = length ();
+    octave_idx_type longest = 0;
 
-    for (int i = 0; i < n; i++)
+    for (octave_idx_type i = 0; i < n; i++)
       {
-	int tmp = elem(i).length ();
+	octave_idx_type tmp = elem(i).length ();
 
 	if (tmp > longest)
 	  longest = tmp;
       }
 
     return longest;
   }
 
-  std::string& operator[] (int i) { return Array<std::string>::elem (i); }
+  std::string& operator[] (octave_idx_type i) { return Array<std::string>::elem (i); }
 
-  std::string operator[] (int i) const { return Array<std::string>::elem (i); }
+  std::string operator[] (octave_idx_type i) const { return Array<std::string>::elem (i); }
 
   static int compare (const void *a_arg, const void *b_arg);
 
   string_vector& qsort (bool make_uniq = false)
   {
     Array<std::string>::qsort (compare);
 
     if (make_uniq)
diff --git a/mk-opts.pl b/mk-opts.pl
--- a/mk-opts.pl
+++ b/mk-opts.pl
@@ -614,38 +614,46 @@ print_${class_name} (std::ostream& os)
        << std::resetiosflags (std::ios::left)
        << \"  \";\n\n";
 
       if ($type[$i] eq "double")
         {
           print "    double val = $static_object_name.$opt[$i] ();\n\n";
           print "    os << val << \"\\n\";\n";
         }
-      elsif ($type[$i] eq "int")
+      elsif ($type[$i] eq "int" || $type[$i] eq "octave_idx_type")
         {
           print "    int val = $static_object_name.$opt[$i] ();\n\n";
           print "    os << val << \"\\n\";\n";
         }
       elsif ($type[$i] eq "std::string")
         {
           print "    os << $static_object_name.$opt[$i] () << \"\\n\";\n";
         }
-      elsif ($type[$i] eq "Array<int>")
+      elsif ($type[$i] eq "Array<int>" || $type[$i] eq "Array<octave_idx_type>")
         {
-          print "    Array<int> val = $static_object_name.$opt[$i] ();\n\n";
+	  if ($type[$i] eq "Array<int>")
+            {
+              $elt_type = "int";
+            }
+          else
+            {
+              $elt_type = "octave_idx_type";
+            }
+          print "    Array<$elt_type> val = $static_object_name.$opt[$i] ();\n\n";
           print "    if (val.length () == 1)
       {
         os << val(0) << \"\\n\";
       }
     else
       {
         os << \"\\n\\n\";
-	int len = val.length ();
+	octave_idx_type len = val.length ();
 	Matrix tmp (len, 1);
-	for (int i = 0; i < len; i++)
+	for (octave_idx_type i = 0; i < len; i++)
 	  tmp(i,0) = val(i);
         octave_print_internal (os, tmp, false, 2);
         os << \"\\n\\n\";
       }\n";
         }
       elsif ($type[$i] eq "Array<double>")
         {
           print "    Array<double> val = $static_object_name.$opt[$i] ();\n\n";
@@ -690,29 +698,29 @@ set_${class_name} (const std::string& ke
     {\n";
 
       if ($type[$i] eq "double")
         {
           print "      double tmp = val.double_value ();\n\n";
           print "      if (! error_state)
         $static_object_name.set_$opt[$i] (tmp);\n";
         }
-      elsif ($type[$i] eq "int")
+      elsif ($type[$i] eq "int" || $type[$i] eq "octave_idx_type")
         {
           print "      int tmp = val.int_value ();\n\n";
           print "      if (! error_state)
         $static_object_name.set_$opt[$i] (tmp);\n";
         }
       elsif ($type[$i] eq "std::string")
         {
           print "      std::string tmp = val.string_value ();\n\n";
           print "      if (! error_state)
         $static_object_name.set_$opt[$i] (tmp);\n";
         }
-      elsif ($type[$i] eq "Array<int>")
+      elsif ($type[$i] eq "Array<int>" || $type[$i] eq "Array<octave_idx_type>")
         {
           print "      Array<int> tmp = val.int_vector_value ();\n\n";
           print "      if (! error_state)
         $static_object_name.set_$opt[$i] (tmp);\n";
         }
       elsif ($type[$i] eq "Array<double>")
         {
           print "      Array<double> tmp = val.vector_value ();\n\n";
@@ -755,37 +763,45 @@ show_${class_name} (const std::string& k
            keyword, list[$i].min_toks_to_match, MAX_TOKENS))
     {\n";
 
       if ($type[$i] eq "double")
         {
           print "      double val = $static_object_name.$opt[$i] ();\n\n";
           print "      retval = val;\n";
         }
-      elsif ($type[$i] eq "int")
+      elsif ($type[$i] eq "int" || $type[$i] eq "octave_idx_type")
         {
           print "      int val = $static_object_name.$opt[$i] ();\n\n";
           print "      retval = static_cast<double> (val);\n";
         }
       elsif ($type[$i] eq "std::string")
         {
           print "      retval = $static_object_name.$opt[$i] ();\n";
         }
-      elsif ($type[$i] eq "Array<int>")
+      elsif ($type[$i] eq "Array<int>" || $type[$i] eq "Array<octave_idx_type>")
         {
-          print "      Array<int> val = $static_object_name.$opt[$i] ();\n\n";
+	  if ($type[$i] eq "Array<int>")
+            {
+              $elt_type = "int";
+            }
+          else
+            {
+              $elt_type = "octave_idx_type";
+            }
+          print "      Array<$elt_type> val = $static_object_name.$opt[$i] ();\n\n";
           print "      if (val.length () == 1)
         {
           retval = static_cast<double> (val(0));
         }
       else
         {
-	  int len = val.length ();
+	  octave_idx_type len = val.length ();
 	  ColumnVector tmp (len);
-	  for (int i = 0; i < len; i++)
+	  for (octave_idx_type i = 0; i < len; i++)
 	    tmp(i) = val(i);
           retval = tmp;
         }\n";
         }
       elsif ($type[$i] eq "Array<double>")
         {
           print "      Array<double> val = $static_object_name.$opt[$i] ();\n\n";
           print "      if (val.length () == 1)
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -27,33 +27,33 @@ Software Foundation, 59 Temple Place - S
 #include "idx-vector.h"
 
 #include "Cell.h"
 #include "error.h"
 
 Cell::Cell (const string_vector& sv)
   : ArrayN<octave_value> ()
 {
-  int n = sv.length ();
+  octave_idx_type n = sv.length ();
 
   if (n > 0)
     {
       resize (dim_vector (n, 1));
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	elem(i,0) = sv[i];
     }
 }
 
 Cell
 Cell::index (const octave_value_list& idx_arg, bool resize_ok) const
 {
   Cell retval;
 
-  int n = idx_arg.length ();
+  octave_idx_type n = idx_arg.length ();
 
   switch (n)
     {
     case 1:
       {
 	idx_vector i = idx_arg(0).index_vector ();
 
 	if (! error_state)
@@ -74,17 +74,17 @@ Cell::index (const octave_value_list& id
 	  }
       }
       break;
 
     default:
       {
 	Array<idx_vector> iv (n);
 
-	for (int i = 0; i < n; i++)
+	for (octave_idx_type i = 0; i < n; i++)
 	  {
 	    iv(i) = idx_arg(i).index_vector ();
 
 	    if (error_state)
 	      break;
 	  }
 
 	if (!error_state)
@@ -96,39 +96,39 @@ Cell::index (const octave_value_list& id
   return retval;
 }
 
 Cell&
 Cell::assign (const octave_value_list& idx_arg, const Cell& rhs,
 	      const octave_value& fill_val)
 
 {
-  for (int i = 0; i < idx_arg.length (); i++)
+  for (octave_idx_type i = 0; i < idx_arg.length (); i++)
     set_index (idx_arg(i).index_vector ());
 
   ::assign (*this, rhs, fill_val);
 
   return *this;
 }
 
 Cell
-Cell::concat (const Cell& rb, const Array<int>& ra_idx)
+Cell::concat (const Cell& rb, const Array<octave_idx_type>& ra_idx)
 {
   return insert (rb, ra_idx);
 }
 
 Cell&
-Cell::insert (const Cell& a, int r, int c)
+Cell::insert (const Cell& a, octave_idx_type r, octave_idx_type c)
 {
   Array<octave_value>::insert (a, r, c);
   return *this;
 }
 
 Cell&
-Cell::insert (const Cell& a, const Array<int>& ra_idx)
+Cell::insert (const Cell& a, const Array<octave_idx_type>& ra_idx)
 {
   Array<octave_value>::insert (a, ra_idx);
   return *this;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -40,33 +40,33 @@ public:
     : ArrayN<octave_value> (dim_vector (0, 0)) { }
 
   Cell (const octave_value& val)
     : ArrayN<octave_value> (dim_vector (1, 1), val) { }
 
   Cell (const octave_value_list& ovl)
     : ArrayN<octave_value> (dim_vector (ovl.length (), 1))
     {
-      for (int i = 0; i < ovl.length (); i++)
+      for (octave_idx_type i = 0; i < ovl.length (); i++)
 	elem (i) = ovl (i);
     }
 
-  Cell (int n, int m, const octave_value& val = resize_fill_value ())
+  Cell (octave_idx_type n, octave_idx_type m, const octave_value& val = resize_fill_value ())
     : ArrayN<octave_value> (dim_vector (n, m), val) { }
 
   Cell (const dim_vector& dv, const octave_value& val = resize_fill_value ())
     : ArrayN<octave_value> (dv, val) { }
 
   Cell (const ArrayN<octave_value>& c)
     : ArrayN<octave_value> (c) { }
 
   Cell (const Array<octave_value>& c)
     : ArrayN<octave_value> (c) { }
 
-  Cell (const Array<octave_value>& c, int nr, int nc)
+  Cell (const Array<octave_value>& c, octave_idx_type nr, octave_idx_type nc)
     : ArrayN<octave_value> (c, dim_vector (nr, nc)) { }
 
   Cell (const string_vector& sv);
 
   Cell (const Cell& c)
     : ArrayN<octave_value> (c) { }
 
   Cell index (const octave_value_list& idx, bool resize_ok = false) const;
@@ -90,20 +90,20 @@ public:
     { return ArrayN<octave_value>::reshape (new_dims); }
 
   // XXX FIXME XXX
   boolMatrix all (int /* dim */ = 0) const { return boolMatrix (); }
 
   // XXX FIXME XXX
   boolMatrix any (int /* dim */ = 0) const { return boolMatrix (); }
 
-  Cell concat (const Cell& rb, const Array<int>& ra_idx);
+  Cell concat (const Cell& rb, const Array<octave_idx_type>& ra_idx);
 
-  Cell& insert (const Cell& a, int r, int c);
-  Cell& insert (const Cell& a, const Array<int>& ra_idx);
+  Cell& insert (const Cell& a, octave_idx_type r, octave_idx_type c);
+  Cell& insert (const Cell& a, const Array<octave_idx_type>& ra_idx);
 
   // XXX FIXME XXX
   bool is_true (void) const { return false; }
 
   static octave_value resize_fill_value (void) { return Matrix (); }
 };
 
 #endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,70 @@
+2005-04-08  John W. Eaton  <jwe@octave.org>
+
+	* Initial merge of 64-bit changes from Clinton Chee:
+
+	2005-04-07  John W. Eaton  <jwe@octave.org>
+
+	* ls-oct-ascii.h, ls-oct-ascii.cc (extract_keyword): Now template
+	functions defined in the header file.
+
+	* ls-mat5.cc, ov-base-sparse.h, ov-base.h, ov-bool-sparse.cc
+	ov-cx-sparse.cc, ov-re-sparse.cc, ov.cc, pt-loop.cc,
+	sparse-xdiv.cc, sparse-xpow.cc, DLD-FUNCTIONS/sparse.cc,
+	DLD-FUNCTIONS/spdet.cc:
+	Use octave_idx_type instead of int where needed.
+
+	2005-03-31  Clinton Chee  <chee@parallel.hpc.unsw.edu.au>
+
+	* Cell.cc, Cell.h, data.cc, defaults.cc, dirfns.cc, file-io.cc,
+	gripes.cc, gripes.h, ls-mat-ascii.cc, ls-mat4.cc, ls-oct-ascii.cc,
+	oct-map.cc, oct-map.h, oct-obj.cc, oct-obj.h, oct-stream.cc,
+	oct-stream.h, octave.cc, ops.h, ov-base-mat.cc, ov-base.h,
+	ov-bool-mat.cc, ov-cell.cc, ov-cs-list.cc, ov-cx-mat.cc,
+	ov-intx.h, ov-list.cc, ov-mapper.cc, ov-range.cc, ov-range.h,
+	ov-re-mat.cc, ov-scalar.h, ov-str-mat.cc, ov-struct.cc, ov.cc,
+	ov.h, pr-output.cc, pt-arg-list.cc, pt-cell.cc, pt-loop.cc,
+	pt-mat.cc, pt-select.cc, symtab.h, utils.cc, utils.h, xdiv.cc,
+	xpow.cc:
+	Use octave_idx_type instead of int where needed.
+
+	2005-04-01  John W. Eaton  <jwe@octave.org>
+
+	* toplev.cc (octave_config_info): Add USE_64_BIT_IDX_T to the list.
+	* oct-conf.h.in (OCTAVE_CONF_USE_64_BIT_IDX_T): Substitute here.
+
+	2005-03-31  John W. Eaton  <jwe@octave.org>
+
+	* DLD-FUNCTIONS/sort.cc: Don't use unsigned int for index into
+	dim_vector, or cast dim to unsigned int.
+	(Fsort): No need to cast arg before asking for dims.
+
+	* DLD-FUNCTIONS/gcd.cc (Fgcd): Use OCTAVE_LOCAL_BUFFER to allocate
+	local array of NDArray objects.
+
+	2005-03-31  Clinton Chee  <chee@parallel.hpc.unsw.edu.au>
+
+	* DLD-FUNCTIONS/balance.cc, DLD-FUNCTIONS/besselj.cc,
+	DLD-FUNCTIONS/chol.cc, DLD-FUNCTIONS/colloc.cc,
+	DLD-FUNCTIONS/daspk.cc, DLD-FUNCTIONS/dasrt.cc,
+	DLD-FUNCTIONS/dassl.cc, DLD-FUNCTIONS/det.cc,
+	DLD-FUNCTIONS/eig.cc, DLD-FUNCTIONS/expm.cc, DLD-FUNCTIONS/fft.cc,
+	DLD-FUNCTIONS/fft2.cc, DLD-FUNCTIONS/fftn.cc,
+	DLD-FUNCTIONS/fftw_wisdom.cc, DLD-FUNCTIONS/filter.cc,
+	DLD-FUNCTIONS/find.cc, DLD-FUNCTIONS/fsolve.cc,
+	DLD-FUNCTIONS/gcd.cc, DLD-FUNCTIONS/hess.cc, DLD-FUNCTIONS/inv.cc,
+	DLD-FUNCTIONS/kron.cc, DLD-FUNCTIONS/lu.cc,
+	DLD-FUNCTIONS/minmax.cc, DLD-FUNCTIONS/quad.cc,
+	DLD-FUNCTIONS/qz.cc, DLD-FUNCTIONS/rand.cc,
+	DLD-FUNCTIONS/schur.cc, DLD-FUNCTIONS/sort.cc,
+	DLD-FUNCTIONS/sqrtm.cc, DLD-FUNCTIONS/svd.cc,
+	DLD-FUNCTIONS/syl.cc:
+	Use octave_idx_type instead of int where needed.
+
 2005-04-06  David Bateman  <dbateman@free.fr>
 
 	* Makefile.in: Link to UMFPACK_LIBS. Add zfstream.{cc,h} to build and 
 	dist files.
 
 	* zfstream.cc: New file for C++ binding for fstream like class for 
 	zlib.
 
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -39,39 +39,39 @@ Software Foundation, 59 Temple Place - S
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL, const int& N,
-			     double* A, const int& LDA, double* B,
-			     const int& LDB, int& ILO, int& IHI,
+  F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type& N,
+			     double* A, const octave_idx_type& LDA, double* B,
+			     const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
 			     double* LSCALE, double* RSCALE,
-			     double* WORK, int& INFO
+			     double* WORK, octave_idx_type& INFO
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int& N, const int& ILO,
-			     const int& IHI, const double* LSCALE,
-			     const double* RSCALE, int& M, double* V,
-			     const int& LDV, int& INFO
+			     const octave_idx_type& N, const octave_idx_type& ILO,
+			     const octave_idx_type& IHI, const double* LSCALE,
+			     const double* RSCALE, octave_idx_type& M, double* V,
+			     const octave_idx_type& LDV, octave_idx_type& INFO
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zggbal, ZGGBAL) (F77_CONST_CHAR_ARG_DECL, const int& N,
-			     Complex* A, const int& LDA, Complex* B,
-			     const int& LDB, int& ILO, int& IHI,
+  F77_FUNC (zggbal, ZGGBAL) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type& N,
+			     Complex* A, const octave_idx_type& LDA, Complex* B,
+			     const octave_idx_type& LDB, octave_idx_type& ILO, octave_idx_type& IHI,
 			     double* LSCALE, double* RSCALE,
-			     double* WORK, int& INFO
+			     double* WORK, octave_idx_type& INFO
 			     F77_CHAR_ARG_LEN_DECL);
 }
 
 DEFUN_DLD (balance, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{aa} =} balance (@var{a}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{dd}, @var{aa}] =} balance (@var{a}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{cc}, @var{dd}, @var{aa}, @var{bb}] =} balance (@var{a}, @var{b}, @var{opt})\n\
@@ -123,19 +123,19 @@ Generalized eigenvalue problem balancing
       return retval;
     }
 
   // determine if it's AEP or GEP
   int AEPcase = nargin == 1 ? 1 : args(1).is_string ();
   std::string bal_job;
 
   // problem dimension
-  int nn = args(0).rows ();
+  octave_idx_type nn = args(0).rows ();
 
-  int arg_is_empty = empty_arg ("balance", nn, args(0).columns());
+  octave_idx_type arg_is_empty = empty_arg ("balance", nn, args(0).columns());
 
   if (arg_is_empty < 0)
     return retval;
 
   if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
   if (nn != args(0).columns())
@@ -225,21 +225,21 @@ Generalized eigenvalue problem balancing
 	bb = args(1).matrix_value ();
 
       if (error_state)
 	return retval;
 
       // Both matrices loaded, now let's check what kind of arithmetic:
       // first, declare variables used in both the real and complex case
 
-      int ilo, ihi, info;
+      octave_idx_type ilo, ihi, info;
       RowVector lscale(nn), rscale(nn), work(6*nn);
       char job = bal_job[0];
 
-      static int complex_case
+      static octave_idx_type complex_case
 	= (args(0).is_complex_type () || args(1).is_complex_type ());
 
       // now balance
       if (complex_case)
 	{
 	  if (args(0).is_real_type ())
 	    caa = ComplexMatrix (aa);
 
@@ -277,18 +277,18 @@ Generalized eigenvalue problem balancing
 	    }
 	}
       
       // Since we just want the balancing matrices, we can use dggbal
       // for both the real and complex cases.
 
       Matrix Pl(nn,nn), Pr(nn,nn);
 
-      for (int ii = 0; ii < nn; ii++)
-	for (int jj = 0; jj < nn; jj++)
+      for (octave_idx_type ii = 0; ii < nn; ii++)
+	for (octave_idx_type jj = 0; jj < nn; jj++)
 	  {
 	    OCTAVE_QUIT;
 
 	    Pl(ii,jj) = Pr(ii,jj) = (ii == jj ? 1.0 : 0.0);
 	  }
   
       // left first
       F77_XFCN (dggbak, DGGBAK,
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -74,25 +74,25 @@ enum bessel_type
  \
 	  default: \
 	    break; \
         } \
     } \
   while (0)
 
 static inline Matrix
-int_array2_to_matrix (const Array2<int>& a)
+int_array2_to_matrix (const Array2<octave_idx_type>& a)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 
 	retval(i,j) = (double) (a(i,j));
       }
 
   return retval;
 }
@@ -143,17 +143,17 @@ do_bessel (enum bessel_type type, const 
 	  if (! error_state)
 	    {
 	      if (x_arg.is_scalar_type ())
 		{
 		  Complex x = x_arg.complex_value ();
 
 		  if (! error_state)
 		    {
-		      int ierr;
+		      octave_idx_type ierr;
 		      octave_value result;
 
 		      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
 		      if (nargout > 1)
 			retval(1) = (double) ierr;
 
 		      retval(0) = result;
@@ -162,17 +162,17 @@ do_bessel (enum bessel_type type, const 
 		    gripe_bessel_arg (fn, "second");
 		}
 	      else
 		{
 		  ComplexNDArray x = x_arg.complex_array_value ();
 
 		  if (! error_state)
 		    {
-		      ArrayN<int> ierr;
+		      ArrayN<octave_idx_type> ierr;
 		      octave_value result;
 
 		      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
 		      if (nargout > 1)
 			retval(1) = int_arrayN_to_array (ierr);
 
 		      retval(0) = result;
@@ -198,17 +198,17 @@ do_bessel (enum bessel_type type, const 
 
 	      if (! error_state)
 		{
 		  ComplexColumnVector cx = 
 		    x_arg.complex_column_vector_value ();
 
 		  if (! error_state)
 		    {
-		      Array2<int> ierr;
+		      Array2<octave_idx_type> ierr;
 		      octave_value result;
 
 		      DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 		      
 		      if (nargout > 1)
 			retval(1) = int_array2_to_matrix (ierr);
 
 		      retval(0) = result;
@@ -226,17 +226,17 @@ do_bessel (enum bessel_type type, const 
 	      if (! error_state)
 		{
 		  if (x_arg.is_scalar_type ())
 		    {
 		      Complex x = x_arg.complex_value ();
 
 		      if (! error_state)
 			{
-			  ArrayN<int> ierr;
+			  ArrayN<octave_idx_type> ierr;
 			  octave_value result;
 
 			  DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
 			  if (nargout > 1)
 			    retval(1) = int_arrayN_to_array (ierr);
 
 			  retval(0) = result;
@@ -245,17 +245,17 @@ do_bessel (enum bessel_type type, const 
 			gripe_bessel_arg (fn, "second");
 		    }
 		  else
 		    {
 		      ComplexNDArray x = x_arg.complex_array_value ();
 
 		      if (! error_state)
 			{
-			  ArrayN<int> ierr;
+			  ArrayN<octave_idx_type> ierr;
 			  octave_value result;
 			  
 			  DO_BESSEL (type, alpha, x, scaled, ierr, result);
 			  
 			  if (nargout > 1)
 			    retval(1) = int_arrayN_to_array (ierr);
 			  
 			  retval(0) = result;
@@ -374,17 +374,17 @@ See besselj.\n\
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       retval = do_bessel (BESSEL_H1, "besselh", args, nargout);
     }
   else if (nargin == 3 || nargin == 4)
     {
-      int kind = args(1).int_value ();
+      octave_idx_type kind = args(1).int_value ();
 
       if (! error_state)
 	{
 	  octave_value_list tmp_args;
 
 	  if (nargin == 4)
 	    tmp_args(2) = args(3);
 
@@ -476,17 +476,17 @@ return @code{NaN}\n\
 	}
 
       if (! error_state)
 	{
 	  z = args(nargin == 1 ? 0 : 1).complex_array_value ();
 
 	  if (! error_state)
 	    {
-	      ArrayN<int> ierr;
+	      ArrayN<octave_idx_type> ierr;
 	      octave_value result;
 
 	      if (kind > 1)
 		result = biry (z, kind == 3, scale, ierr);
 	      else
 		result = airy (z, kind == 1, scale, ierr);
 
 	      if (nargout > 1)
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -59,50 +59,50 @@ r' * r = a.\n\
   if (nargin != 1 || nargout > 2)
     {
       print_usage ("chol");
       return retval;
     }
 
   octave_value arg = args(0);
     
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("chol", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
-	  int info;
+	  octave_idx_type info;
 	  CHOL fact (m, info);
 	  if (nargout == 2 || info == 0)
 	    {
 	      retval(1) = static_cast<double> (info);
 	      retval(0) = fact.chol_matrix ();
 	    }
 	  else
 	    error ("chol: matrix not positive definite");
 	}
     }
   else if (arg.is_complex_type ())
     {
       ComplexMatrix m = arg.complex_matrix_value ();
 
       if (! error_state)
 	{
-	  int info;
+	  octave_idx_type info;
 	  ComplexCHOL fact (m, info);
 	  if (nargout == 2 || info == 0)
 	    {
 	      retval(1) = static_cast<double> (info);
 	      retval(0) = fact.chol_matrix ();
 	    }
 	  else
 	    error ("chol: matrix not positive definite");
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/DLD-FUNCTIONS/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/DLD-FUNCTIONS/colloc.cc
@@ -65,26 +65,26 @@ Polynomial Approximation}.\n\
     return retval;
 
   if (xisnan (tmp))
     {
       error ("colloc: NaN is invalid as NCOL");
       return retval;
     }
 
-  int ncol = NINT (tmp);
+  octave_idx_type ncol = NINTbig (tmp);
   if (ncol < 0)
     {
       error ("colloc: first argument must be non-negative");
       return retval;
     }
 
-  int ntot = ncol;
-  int left = 0;
-  int right = 0;
+  octave_idx_type ntot = ncol;
+  octave_idx_type left = 0;
+  octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
     {
       if (args(i).is_defined ())
 	{
 	  if (! args(i).is_string ())
 	    {
 	      error ("colloc: expecting string argument");
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -53,17 +53,17 @@ static octave_function *daspk_jac;
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 ColumnVector
 daspk_user_function (const ColumnVector& x, const ColumnVector& xdot,
-		     double t, int& ires)
+		     double t, octave_idx_type& ires)
 {
   ColumnVector retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(2) = t;
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -53,17 +53,17 @@ static bool warned_fcn_imaginary = false
 static bool warned_jac_imaginary = false;
 static bool warned_cf_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 static ColumnVector
 dasrt_user_f (const ColumnVector& x, const ColumnVector& xdot,
-	      double t, int&)
+	      double t, octave_idx_type&)
 {
   ColumnVector retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(2) = t;
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -53,17 +53,17 @@ static octave_function *dassl_jac;
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 ColumnVector
 dassl_user_function (const ColumnVector& x, const ColumnVector& xdot,
-		     double t, int& ires)
+		     double t, octave_idx_type& ires)
 {
   ColumnVector retval;
 
   assert (x.capacity () == xdot.capacity ());
 
   octave_value_list args;
 
   args(2) = t;
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -77,17 +77,17 @@ of the reciprocal condition number if re
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  // Always compute rcond, so we can detect numerically
 	  // singular matrices.
 
-	  int info;
+	  octave_idx_type info;
 	  double rcond = 0.0;
 	  DET det = m.determinant (info, rcond);
 	  retval(1) = rcond;
 	  volatile double xrcond = rcond;
 	  xrcond += 1.0;
 	  retval(0) = ((info == -1 || xrcond == 1.0) ? 0.0 : det.value ());
 	}
     }
@@ -95,17 +95,17 @@ of the reciprocal condition number if re
     {
       ComplexMatrix m = arg.complex_matrix_value ();
 
       if (! error_state)
 	{
 	  // Always compute rcond, so we can detect numerically
 	  // singular matrices.
 
-	  int info;
+	  octave_idx_type info;
 	  double rcond = 0.0;
 	  ComplexDET det = m.determinant (info, rcond);
 	  retval(1) = rcond;
 	  volatile double xrcond = rcond;
 	  xrcond += 1.0;
 	  retval(0) = ((info == -1 || xrcond == 1.0)
 		       ? Complex (0.0) : det.value ());
 	}
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -50,18 +50,18 @@ Schur decomposition.\n\
   if (nargin != 1 || nargout > 2)
     {
       print_usage ("eig");
       return retval;
     }
 
   octave_value arg = args(0);
 
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("eig", nr, nc);
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
   if (nr != nc)
diff --git a/src/DLD-FUNCTIONS/expm.cc b/src/DLD-FUNCTIONS/expm.cc
--- a/src/DLD-FUNCTIONS/expm.cc
+++ b/src/DLD-FUNCTIONS/expm.cc
@@ -125,18 +125,18 @@ is ill-conditioned.\n\
   if (nargin != 1)
     {
       print_usage ("expm");
       return retval;
     }
 
   octave_value arg = args(0);
 
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("expm", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -49,29 +49,29 @@ do_fft (const octave_value_list &args, c
   if (nargin < 1 || nargin > 3)
     {
       print_usage (fcn);
       return retval;
     }
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
-  int n_points = -1;
+  octave_idx_type n_points = -1;
   int dim = -1;
   
   if (nargin > 1)
     {
       if (! args(1).is_empty ())
 	{
 	  double dval = args(1).double_value ();
 	  if (xisnan (dval))
 	    error ("%s: NaN is invalid as the N_POINTS", fcn);
 	  else
 	    {
-	      n_points = NINT (dval);
+	      n_points = NINTbig (dval);
 	      if (n_points < 0)
 		error ("%s: number of points must be greater than zero", fcn);
 	    }
 	}
     }
 
   if (error_state)
     return retval;
@@ -79,29 +79,30 @@ do_fft (const octave_value_list &args, c
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
 	error ("%s: NaN is invalid as the N_POINTS", fcn);
       else if (dval < 1 || dval > dims.length ())
 	error ("%s: invalid dimension along which to perform fft", fcn);
       else
+	// to be safe, cast it back to int since dim is an int
 	dim = NINT (dval) - 1;
     }
 
   if (error_state)
     return retval;
 
-  for (int i = 0; i < dims.length (); i++)
+  for (octave_idx_type i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (dim < 0)
     {
-      for (int i = 0; i < dims.length (); i++)
+      for (octave_idx_type i = 0; i < dims.length (); i++)
 	if ( dims(i) > 1)
 	  {
 	    dim = i;
 	    break;
 	  }
 
       // And if the first argument is scalar?
       if (dim < 0)
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -51,43 +51,43 @@ do_fft2 (const octave_value_list &args, 
   if (nargin < 1 || nargin > 3)
     {
       print_usage (fcn);
       return retval;
     }
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
-  int n_rows = -1;
+  octave_idx_type n_rows = -1;
   
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
       if (xisnan (dval))
 	error ("%s: NaN is invalid as the N_ROWS", fcn);
       else
 	{
-	  n_rows = NINT (dval);
+	  n_rows = NINTbig (dval);
 	  if (n_rows < 0)
 	    error ("%s: number of rows must be greater than zero", fcn);
 	}
     }
 
   if (error_state)
     return retval;
 
-  int n_cols = -1;
+  octave_idx_type n_cols = -1;
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
 	error ("%s: NaN is invalid as the N_COLS", fcn);
       else
 	{
-	  n_cols = NINT (dval);
+	  n_cols = NINTbig (dval);
 	  if (n_cols < 0)
 	    error ("%s: number of columns must be greater than zero", fcn);
 	}
     }
 
   if (error_state)
     return retval;
 
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -69,21 +69,21 @@ do_fftn (const octave_value_list &args, 
       if (error_state || val.columns () != dims.length () || val.rows () != 1)
 	error ("%s: second argument must be a vector of length dim", fcn);
       else
 	{
 	  for (int i = 0; i < dims.length (); i++)
 	    {
 	      if (xisnan (val(i,0)))
 		error ("%s: NaN is invalid as a dimension", fcn);
-	      else if (NINT (val(i,0)) < 0)
+	      else if (NINTbig (val(i,0)) < 0)
 		error ("%s: all dimension must be greater than zero", fcn);
 	      else
 		{
-		  dims(i) = NINT(val(i,0));
+		  dims(i) = NINTbig(val(i,0));
 		}
 	    }
 	}
     }
 
   if (error_state)
     return retval;
 
diff --git a/src/DLD-FUNCTIONS/fftw_wisdom.cc b/src/DLD-FUNCTIONS/fftw_wisdom.cc
--- a/src/DLD-FUNCTIONS/fftw_wisdom.cc
+++ b/src/DLD-FUNCTIONS/fftw_wisdom.cc
@@ -98,17 +98,17 @@ Octave.\n\
 
   if (args(0).is_string ())
     {
       bool overwrite = false;
 
       if (nargin != 1)
 	{
 	  double dval = args (1).double_value ();
-	  if (NINT (dval) != 0)
+	  if (NINTbig (dval) != 0)
 	    overwrite = true;
 	}
 
       std::string wisdom = octave_env::make_absolute
 	(Vload_path_dir_path.find_first_of (args(0).string_value ()),
 	 octave_env::getcwd ());
 
       // XXX FIXME XXX -- should probably protect FILE* resources with
@@ -145,31 +145,31 @@ Octave.\n\
 	{
 	  error ("fftw_wisdom: can not open temporary file");
 	  return retval;
 	}
 
       OSSTREAM cmd_buf; 
       cmd_buf << Vfftw_wisdom_prog << " -n -o \"" << name << "\"";
 
-      for (int k = 0; k < m.rows (); k++)
+      for (octave_idx_type k = 0; k < m.rows (); k++)
 	{
 	  bool first = true;
 
 	  cmd_buf << " ";
 
 	  // Note reversal of dimensions for column major storage in FFTW
-	  for (int j = m.columns()-1; j >= 0; j--)
-	    if (NINT(m(k,j)) > 0)
+	  for (octave_idx_type j = m.columns()-1; j >= 0; j--)
+	    if (NINTbig(m(k,j)) > 0)
 	      {
 		if (first)
 		  first = false;
 		else
 		  cmd_buf << "x";
-		cmd_buf << NINT(m(k,j)) ;
+		cmd_buf << NINTbig(m(k,j)) ;
 	      }
 	} 
 
       cmd_buf << OSSTREAM_ENDS;
 
       volatile octave_interrupt_handler old_interrupt_handler
 	= octave_ignore_interrupts ();
 
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -48,20 +48,20 @@ filter (MArray<Complex>&, MArray<Complex
 
 template <class T>
 MArrayN<T>
 filter (MArray<T>& b, MArray<T>& a, MArrayN<T>& x, MArrayN<T>& si, 
 	int dim = 0)
 {
   MArrayN<T> y;
 
-  int a_len  = a.length ();
-  int b_len  = b.length ();
+  octave_idx_type a_len  = a.length ();
+  octave_idx_type b_len  = b.length ();
 
-  int ab_len = a_len > b_len ? a_len : b_len;
+  octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
 
   b.resize (ab_len, 0.0);
   if (a_len > 1)
     a.resize (ab_len, 0.0);
 
   T norm = a (0);
 
   if (norm == 0.0)
@@ -72,35 +72,35 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 
   dim_vector x_dims = x.dims ();
   if (dim < 0 || dim > x_dims.length ())
     {
       error ("filter: filtering over invalid dimension");
       return y;
     }
 
-  int x_len = x_dims(dim);
+  octave_idx_type x_len = x_dims(dim);
 
   dim_vector si_dims = si.dims ();
-  int si_len = si_dims(0);
+  octave_idx_type si_len = si_dims(0);
 
   if (si_len != ab_len - 1)
     {
       error ("filter: first dimension of si must be of length max (length (a), length (b)) - 1");
       return y;
     }
 
   if (si_dims.length () != x_dims.length ())
     {
       error ("filter: dimensionality of si and x must agree");
       return y;
     }
 
-  int si_dim = 0;
-  for (int i = 0; i < x_dims.length (); i++)
+  octave_idx_type si_dim = 0;
+  for (octave_idx_type i = 0; i < x_dims.length (); i++)
     {
       if (i == dim)
 	continue;
      
       if (x_dims(i) == 1)
 	continue;
  
       if (si_dims(++si_dim) != x_dims(i))
@@ -120,53 +120,53 @@ filter (MArray<T>& b, MArray<T>& a, MArr
     return b(0) * x;
 
   y.resize (x_dims, 0.0);
 
   int x_stride = 1;
   for (int i = 0; i < dim; i++)
     x_stride *= x_dims(i);
 
-  int x_num = x_dims.numel () / x_len;
-  for (int num = 0; num < x_num; num++)
+  octave_idx_type x_num = x_dims.numel () / x_len;
+  for (octave_idx_type num = 0; num < x_num; num++)
     {
-      int x_offset;
+      octave_idx_type x_offset;
       if (x_stride == 1)
 	x_offset = num * x_len;
       else
 	{
-	  int x_offset2 = 0;
+	  octave_idx_type x_offset2 = 0;
 	  x_offset = num;
 	  while (x_offset >= x_stride)
 	    {
 	      x_offset -= x_stride;
 	      x_offset2++;
 	    }
 	  x_offset += x_offset2 * x_stride * x_len;
 	}
-      int si_offset = num * si_len;
+      octave_idx_type si_offset = num * si_len;
 
       if (a_len > 1)
 	{
 	  T *py = y.fortran_vec ();
 	  T *psi = si.fortran_vec ();
 
 	  const T *pa = a.data ();
 	  const T *pb = b.data ();
 	  const T *px = x.data ();
 
 	  psi += si_offset;
 
-	  for (int i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
+	  for (octave_idx_type i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
 	    {
 	      py[idx] = psi[0] + pb[0] * px[idx];
 
 	      if (si_len > 0)
 		{
-		  for (int j = 0; j < si_len - 1; j++)
+		  for (octave_idx_type j = 0; j < si_len - 1; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      psi[j] = psi[j+1] - pa[j+1] * py[idx] + pb[j+1] * px[idx];
 		    }
 
 		  psi[si_len-1] = pb[si_len] * px[idx] - pa[si_len] * py[idx];
 		}
@@ -183,23 +183,23 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 	  T *py = y.fortran_vec ();
 	  T *psi = si.fortran_vec ();
 
 	  const T *pb = b.data ();
 	  const T *px = x.data ();
 
 	  psi += si_offset;
 
-	  for (int i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
+	  for (octave_idx_type i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
 	    {
 	      py[idx] = psi[0] + pb[0] * px[idx];
 
 	      if (si_len > 1)
 		{
-		  for (int j = 0; j < si_len - 1; j++)
+		  for (octave_idx_type j = 0; j < si_len - 1; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      psi[j] = psi[j+1] + pb[j+1] * px[idx];
 		    }
 
 		  psi[si_len-1] = pb[si_len] * px[idx];
 		}
@@ -244,20 +244,20 @@ filter (MArray<T>& b, MArray<T>& a, MArr
     }
   else
     if (dim < 0 || dim > x_dims.length ())
       {
 	error ("filter: filtering over invalid dimension");
 	return MArrayN<T> ();
       }
 
-  int a_len = a.length ();
-  int b_len = b.length ();
+  octave_idx_type a_len = a.length ();
+  octave_idx_type b_len = b.length ();
 
-  int si_len = (a_len > b_len ? a_len : b_len) - 1;
+  octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
   for (int i = dim; i > 0; i--)
     si_dims(i) = si_dims(i-1);
   si_dims(0) = si_len;
   
   MArrayN<T> si (si_dims, T (0.0));
 
   return filter (b, a, x, si, dim);
@@ -407,20 +407,20 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
       ComplexNDArray x (args(2).complex_array_value ());
 
       if (! error_state)
 	{
 	  ComplexNDArray si;
 
 	  if (nargin == 3 || args(3).is_empty ())
 	    {
-	      int a_len = a.length ();
-	      int b_len = b.length ();
+	      octave_idx_type a_len = a.length ();
+	      octave_idx_type b_len = b.length ();
 
-	      int si_len = (a_len > b_len ? a_len : b_len) - 1;
+	      octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
 	      dim_vector si_dims = x.dims ();
 	      for (int i = dim; i > 0; i--)
 		si_dims(i) = si_dims(i-1);
 	      si_dims(0) = si_len;
 
 	      si.resize (si_dims, 0.0);
 	    }
@@ -464,20 +464,20 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
       NDArray x (args(2).array_value ());
 
       if (! error_state)
 	{
 	  NDArray si;
 
 	  if (nargin == 3 || args(3).is_empty ())
 	    {
-	      int a_len = a.length ();
-	      int b_len = b.length ();
+	      octave_idx_type a_len = a.length ();
+	      octave_idx_type b_len = b.length ();
 
-	      int si_len = (a_len > b_len ? a_len : b_len) - 1;
+	      octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
 	      dim_vector si_dims = x.dims ();
 	      for (int i = dim; i > 0; i--)
 		si_dims(i) = si_dims(i-1);
 	      si_dims(0) = si_len;
 
 	      si.resize (si_dims, 0.0);
 	    }
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -34,34 +34,34 @@ Software Foundation, 59 Temple Place - S
 inline double real (double x) { return x; }
 
 template <typename T>
 octave_value_list
 find_nonzero_elem_idx (const T& nda, int nargout)
 {
   octave_value_list retval (((nargout == 0) ? 1 : nargout), Matrix ());
 
-  int count = 0;
+  octave_idx_type count = 0;
 
-  int nel = nda.nelem ();
+  octave_idx_type nel = nda.nelem ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
 
       if (nda(i) != 0.0)
 	count++;
     }
 
   // If the original argument was a row vector, force a row vector of
   // the overall indices to be returned.  But see below for scalar
   // case...
 
-  int result_nr = count;
-  int result_nc = 1;
+  octave_idx_type result_nr = count;
+  octave_idx_type result_nc = 1;
 
   bool scalar_arg = false;
 
   if (nda.ndims () == 2 && nda.rows () == 1)
     {
       result_nr = 1;
       result_nc = count;
 
@@ -74,22 +74,22 @@ find_nonzero_elem_idx (const T& nda, int
   Matrix j_idx (result_nr, result_nc);
 
   T val (dim_vector (result_nr, result_nc));
 
   if (count > 0)
     {
       count = 0;
 
-      int nr = nda.rows ();
+      octave_idx_type nr = nda.rows ();
 
-      int i = 0;
-      int j = 0;
+      octave_idx_type i = 0;
+      octave_idx_type j = 0;
 
-      for (int k = 0; k < nel; k++)
+      for (octave_idx_type k = 0; k < nel; k++)
 	{
 	  OCTAVE_QUIT;
 
 	  if (nda(k) != 0.0)
 	    {
 	      idx(count) = k + 1;
 
 	      i_idx(count) = i + 1;
diff --git a/src/DLD-FUNCTIONS/fsolve.cc b/src/DLD-FUNCTIONS/fsolve.cc
--- a/src/DLD-FUNCTIONS/fsolve.cc
+++ b/src/DLD-FUNCTIONS/fsolve.cc
@@ -51,18 +51,18 @@ static octave_function *fsolve_jac;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_fcn_imaginary = false;
 static bool warned_jac_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
-int
-hybrd_info_to_fsolve_info (int info)
+octave_idx_type
+hybrd_info_to_fsolve_info (octave_idx_type info)
 {
   switch (info)
     {
     case -1:
       info = -2;
       break;
 
     case 0:
@@ -90,25 +90,25 @@ hybrd_info_to_fsolve_info (int info)
   return info;
 }
 
 ColumnVector
 fsolve_user_function (const ColumnVector& x)
 {
   ColumnVector retval;
 
-  int n = x.length ();
+  octave_idx_type n = x.length ();
 
   octave_value_list args;
   args.resize (1);
 
   if (n > 1)
     {
       Matrix m (n, 1);
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	m (i, 0) = x (i);
       octave_value vars (m);
       args(0) = vars;
     }
   else
     {
       double d = x (0);
       octave_value vars (d);
@@ -139,25 +139,25 @@ fsolve_user_function (const ColumnVector
   return retval;
 }
 
 Matrix
 fsolve_user_jacobian (const ColumnVector& x)
 {
   Matrix retval;
 
-  int n = x.length ();
+  octave_idx_type n = x.length ();
 
   octave_value_list args;
   args.resize (1);
 
   if (n > 1)
     {
       Matrix m (n, 1);
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	m(i,0) = x(i);
       octave_value vars (m);
       args(0) = vars;
     }
   else
     {
       double d = x(0);
       octave_value vars (d);
@@ -311,17 +311,17 @@ parameters for @code{fsolve}.\n\
 
       NLFunc nleqn_fcn (fsolve_user_function);
       if (fsolve_jac)
 	nleqn_fcn.set_jacobian_function (fsolve_user_jacobian);
 
       NLEqn nleqn (x, nleqn_fcn);
       nleqn.set_options (fsolve_opts);
 
-      int info;
+      octave_idx_type info;
       ColumnVector soln = nleqn.solve (info);
 
       if (! error_state)
 	{
 	  std::string msg = nleqn.error_message ();
 
 	  retval(2) = msg;
 	  retval(1) = static_cast<double> (hybrd_info_to_fsolve_info (info));
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -236,17 +236,18 @@ all of the values of @var{v1}, @var{...}
 	}
 
       retval (1) = v;
       retval (0) = g;
     }
   else
     {
       NDArray g = args(0).array_value ();
-      NDArray v[nargin];
+
+      OCTAVE_LOCAL_BUFFER (NDArray, v, nargin);
 
       int nel = dv.numel ();
 
       v[0].resize(dv);
 
       for (int i = 0; i < nel; i++)
 	{
 	  v[0](i) = signum (g(i));
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -67,18 +67,18 @@ is upper Hessenberg (@code{i >= j+1 => h
   if (nargin != 1 || nargout > 2)
     {
       print_usage ("hess");
       return retval;
     }
 
   octave_value arg = args(0);
 
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("hess", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -46,18 +46,18 @@ ill-conditioned matrix if the reciprocal
   if (nargin != 1)
     {
       print_usage ("inv");
       return retval;
     }
 
   octave_value arg = args(0);
 
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
@@ -68,17 +68,17 @@ ill-conditioned matrix if the reciprocal
     }
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
-	  int info;
+	  octave_idx_type info;
 	  double rcond = 0.0;
 
 	  Matrix result = m.inverse (info, rcond, 1);
 
 	  if (nargout > 1)
 	    retval(1) = rcond;
 
 	  retval(0) = result;
@@ -91,17 +91,17 @@ ill-conditioned matrix if the reciprocal
 	}
     }
   else if (arg.is_complex_type ())
     {
       ComplexMatrix m = arg.complex_matrix_value ();
 
       if (! error_state)
 	{
-	  int info;
+	  octave_idx_type info;
 	  double rcond = 0.0;
 
 	  ComplexMatrix result = m.inverse (info, rcond, 1);
 
 	  if (nargout > 1)
 	    retval(1) = rcond;
 
 	  retval(0) = result;
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -43,24 +43,24 @@ kron (const Array2<Complex>&, const Arra
 #endif
 
 template <class T>
 void
 kron (const Array2<T>& A, const Array2<T>& B, Array2<T>& C)
 {
   C.resize (A.rows () * B.rows (), A.columns () * B.columns ());
 
-  int Ac, Ar, Cc, Cr;
+  octave_idx_type Ac, Ar, Cc, Cr;
 
   for (Ac = Cc = 0; Ac < A.columns (); Ac++, Cc += B.columns ())
     for (Ar = Cr = 0; Ar < A.rows (); Ar++, Cr += B.rows ())
       {
 	const T v = A (Ar, Ac);
-	for (int Bc = 0; Bc < B.columns (); Bc++)
-	  for (int Br = 0; Br < B.rows (); Br++)
+	for (octave_idx_type Bc = 0; Bc < B.columns (); Bc++)
+	  for (octave_idx_type Br = 0; Br < B.rows (); Br++)
 	    {
 	      OCTAVE_QUIT;
 	      C.xelem (Cr+Br, Cc+Bc) = v * B.elem (Br, Bc);
 	    }
       }
 }
 
 template void
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -76,18 +76,18 @@ The matrix is not required to be square.
   if (nargin != 1 || nargout > 3)
     {
       print_usage ("lu");
       return retval;
     }
 
   octave_value arg = args(0);
 
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("lu", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value_list (3, Matrix ());
 
diff --git a/src/DLD-FUNCTIONS/minmax.cc b/src/DLD-FUNCTIONS/minmax.cc
--- a/src/DLD-FUNCTIONS/minmax.cc
+++ b/src/DLD-FUNCTIONS/minmax.cc
@@ -122,17 +122,17 @@ Software Foundation, 59 Temple Place - S
 	      retval(0) = n; \
 	    } \
 	} \
       else \
 	gripe_wrong_type_arg (#FCN, arg1); \
     } \
   else if (single_arg && nargout == 2) \
     { \
-      ArrayN<int> index; \
+      ArrayN<octave_idx_type> index; \
  \
       if (arg1.is_real_type ()) \
 	{ \
 	  NDArray m = arg1.array_value (); \
  \
 	  if (! error_state) \
 	    { \
 	      NDArray n = m. FCN (index, dim);	\
@@ -147,25 +147,25 @@ Software Foundation, 59 Temple Place - S
 	    { \
 	      ComplexNDArray n = m. FCN (index, dim);	\
 	      retval(0) = n; \
 	    } \
 	} \
       else \
 	gripe_wrong_type_arg (#FCN, arg1); \
  \
-      int len = index.numel (); \
+      octave_idx_type len = index.numel (); \
  \
       if (len > 0) \
 	{ \
 	  double nan_val = lo_ieee_nan_value (); \
  \
 	  NDArray idx (index.dims ()); \
  \
-	  for (int i = 0; i < len; i++) \
+	  for (octave_idx_type i = 0; i < len; i++) \
 	    { \
 	      OCTAVE_QUIT; \
 	      int tmp = index.elem (i) + 1; \
 	      idx.elem (i) = (tmp <= 0) \
 		? nan_val : static_cast<double> (tmp); \
 	    } \
  \
 	  retval(1) = idx; \
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -225,18 +225,18 @@ parameters for @code{quad}.\n\
 	}
       else if (xisinf (b))
 	{
 	  indefinite = 1;
 	  bound = a;
 	  indef_type = IndefQuad::bound_to_inf;
 	}
 
-      int ier = 0;
-      int nfun = 0;
+      octave_idx_type ier = 0;
+      octave_idx_type nfun = 0;
       double abserr = 0.0;
       double val = 0.0;
       bool have_sing = false;
       ColumnVector sing;
       ColumnVector tol;
 
       switch (nargin)
 	{
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -50,156 +50,156 @@ Software Foundation, 59 Temple Place - S
 #include "pager.h"
 #if defined (DEBUG) || defined (DEBUG_SORT)
 #include "pr-output.h"
 #endif
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
-typedef int (*sort_function) (const int& LSIZE, const double& ALPHA,
+typedef octave_idx_type (*sort_function) (const octave_idx_type& LSIZE, const double& ALPHA,
 			      const double& BETA, const double& S,
 			      const double& P);
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL,
-			     const int& N, double* A, const int& LDA,
-			     double* B, const int& LDB, int& ILO,
-			     int& IHI, double* LSCALE, double* RSCALE,
-			     double* WORK, int& INFO
+			     const octave_idx_type& N, double* A, const octave_idx_type& LDA,
+			     double* B, const octave_idx_type& LDB, octave_idx_type& ILO,
+			     octave_idx_type& IHI, double* LSCALE, double* RSCALE,
+			     double* WORK, octave_idx_type& INFO
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int& N, const int& ILO,
-			     const int& IHI, const double* LSCALE,
-			     const double* RSCALE, int& M, double* V,
-			     const int& LDV, int& INFO
+			     const octave_idx_type& N, const octave_idx_type& ILO,
+			     const octave_idx_type& IHI, const double* LSCALE,
+			     const double* RSCALE, octave_idx_type& M, double* V,
+			     const octave_idx_type& LDV, octave_idx_type& INFO
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgghrd, DGGHRD) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int& N, const int& ILO,
-			     const int& IHI, double* A,
-			     const int& LDA, double* B,
-			     const int& LDB, double* Q,
-			     const int& LDQ, double* Z,
-			     const int& LDZ, int& INFO
+			     const octave_idx_type& N, const octave_idx_type& ILO,
+			     const octave_idx_type& IHI, double* A,
+			     const octave_idx_type& LDA, double* B,
+			     const octave_idx_type& LDB, double* Q,
+			     const octave_idx_type& LDQ, double* Z,
+			     const octave_idx_type& LDZ, octave_idx_type& INFO
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dhgeqz, DHGEQZ) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     const int& N, const int& ILO, const int& IHI,
-			     double* A, const int& LDA, double* B,
-			     const int& LDB, double* ALPHAR,
+			     const octave_idx_type& N, const octave_idx_type& ILO, const octave_idx_type& IHI,
+			     double* A, const octave_idx_type& LDA, double* B,
+			     const octave_idx_type& LDB, double* ALPHAR,
 			     double* ALPHAI, double* BETA, double* Q,
-			     const int& LDQ, double* Z,
-			     const int& LDZ, double* WORK,
-			     const int& LWORK, int& INFO
+			     const octave_idx_type& LDQ, double* Z,
+			     const octave_idx_type& LDZ, double* WORK,
+			     const octave_idx_type& LWORK, octave_idx_type& INFO
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dlag2, DLAG2) (const double* A, const int& LDA, const double* B,
-			   const int& LDB, const double& SAFMIN,
+  F77_FUNC (dlag2, DLAG2) (const double* A, const octave_idx_type& LDA, const double* B,
+			   const octave_idx_type& LDB, const double& SAFMIN,
 			   double& SCALE1, double& SCALE2,
 			   double& WR1, double& WR2, double& WI);
 
   // Van Dooren's code (netlib.org: toms/590) for reordering
   // GEP.  Only processes Z, not Q.
   F77_RET_T
-  F77_FUNC (dsubsp, DSUBSP) (const int& NMAX, const int& N, double* A,
+  F77_FUNC (dsubsp, DSUBSP) (const octave_idx_type& NMAX, const octave_idx_type& N, double* A,
 			     double* B, double* Z, sort_function,
-			     const double& EPS, int& NDIM, int& FAIL,
-			     int* IND);
+			     const double& EPS, octave_idx_type& NDIM, octave_idx_type& FAIL,
+			     octave_idx_type* IND);
 
   // documentation for DTGEVC incorrectly states that VR, VL are
   // complex*16; they are declared in DTGEVC as double precision
   // (probably a cut and paste problem fro ZTGEVC)
   F77_RET_T
   F77_FUNC (dtgevc, DTGEVC) (F77_CONST_CHAR_ARG_DECL,
 			     F77_CONST_CHAR_ARG_DECL,
-			     int* SELECT, const int& N, double* A,
-			     const int& LDA, double* B,
-			     const int& LDB, double* VL,
-			     const int& LDVL, double* VR,
-			     const int& LDVR, const int& MM,
-			     int& M, double* WORK, int& INFO
+			     octave_idx_type* SELECT, const octave_idx_type& N, double* A,
+			     const octave_idx_type& LDA, double* B,
+			     const octave_idx_type& LDB, double* VL,
+			     const octave_idx_type& LDVL, double* VR,
+			     const octave_idx_type& LDVR, const octave_idx_type& MM,
+			     octave_idx_type& M, double* WORK, octave_idx_type& INFO
 			     F77_CHAR_ARG_LEN_DECL
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG_DECL,
 			       double& retval
 			       F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL,
-			       const int&, const int&, const double*,
-			       const int&, double*, double&
+			       const octave_idx_type&, const octave_idx_type&, const double*,
+			       const octave_idx_type&, double*, double&
 			       F77_CHAR_ARG_LEN_DECL);
 }
 
 // fcrhp, fin, fout, folhp:
 // routines for ordering of generalized eigenvalues
 // return 1 if  test is passed, 0 otherwise
 //    fin: |lambda| < 1
 //    fout: |lambda| >= 1
 //    fcrhp: real(lambda) >= 0
 //    folhp: real(lambda) < 0
 
-static int
-fcrhp (const int& lsize, const double& alpha,
+static octave_idx_type
+fcrhp (const octave_idx_type& lsize, const double& alpha,
        const double& beta, const double& s, const double&)
 {
   if (lsize == 1)
     return (alpha*beta >= 0 ? 1 : -1);
   else
     return (s >= 0 ? 1 : -1);
 }
 
-static int
-fin (const int& lsize, const double& alpha,
+static octave_idx_type
+fin (const octave_idx_type& lsize, const double& alpha,
      const double& beta, const double&, const double& p)
 {
-  int retval;
+  octave_idx_type retval;
 
   if (lsize == 1)
     retval = (fabs (alpha) < fabs (beta) ? 1 : -1);
   else
     retval = (fabs (p) < 1 ? 1 : -1);
 
 #ifdef DEBUG
   std::cout << "qz: fin: retval=" << retval << std::endl;
 #endif
 
   return retval;
 }
 
-static int
-folhp (const int& lsize, const double& alpha,
+static octave_idx_type
+folhp (const octave_idx_type& lsize, const double& alpha,
        const double& beta, const double& s, const double&)
 {
   if (lsize == 1)
     return (alpha*beta < 0 ? 1 : -1);
   else
     return (s < 0 ? 1 : -1);
 }
 
-static int
-fout (const int& lsize, const double& alpha,
+static octave_idx_type
+fout (const octave_idx_type& lsize, const double& alpha,
       const double& beta, const double&, const double& p)
 {
   if (lsize == 1)
     return (fabs (alpha) >= fabs (beta) ? 1 : -1);
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
@@ -356,17 +356,17 @@ See also: balance, dare, eig, schur\n\
 	}
     }
 
 #ifdef DEBUG
   std::cout << "qz: check argument 1" << std::endl;
 #endif
 
   // Argument 1: check if it's o.k. dimensioned
-  int nn = args(0).rows ();
+  octave_idx_type nn = args(0).rows ();
 
 #ifdef DEBUG
   std::cout << "argument 1 dimensions: (" << nn << "," << args(0).columns () << ")"
        << std::endl;
 #endif
 
   int arg_is_empty = empty_arg ("qz", nn, args(0).columns ());
 
@@ -432,24 +432,24 @@ See also: balance, dare, eig, schur\n\
       return retval;
     }
 
   // first, declare variables used in both the real and complex case
   Matrix QQ(nn,nn), ZZ(nn,nn), VR(nn,nn), VL(nn,nn);
   RowVector alphar(nn), alphai(nn), betar(nn);
 
   ComplexMatrix CQ(nn,nn), CZ(nn,nn), CVR(nn,nn), CVL(nn,nn);
-  int ilo, ihi, info;
+  octave_idx_type ilo, ihi, info;
   char compq = (nargout >= 3 ? 'V' : 'N');
   char compz = (nargout >= 4 ? 'V' : 'N');
 
   // initialize Q, Z to identity if we need either of them
   if (compq == 'V' || compz == 'V')
-    for (int ii = 0; ii < nn; ii++)
-      for (int jj = 0; jj < nn; jj++)
+    for (octave_idx_type ii = 0; ii < nn; ii++)
+      for (octave_idx_type jj = 0; jj < nn; jj++)
 	{
 	  OCTAVE_QUIT;
 	  QQ(ii,jj) = ZZ(ii,jj) = (ii == jj ? 1.0 : 0.0);
 	}
 
   // always perform permutation balancing
   const char bal_job = 'P';
   RowVector lscale(nn), rscale(nn), work(6*nn);
@@ -668,17 +668,17 @@ See also: balance, dare, eig, schur\n\
 
 	    default:
 	      // invalid order option (should never happen, since we
 	      // checked the options at the top).
 	      panic_impossible ();
 	      break;
 	    }
 
-	  int ndim, fail;
+	  octave_idx_type ndim, fail;
 	  double inf_norm;
 
 	  F77_XFCN (xdlange, XDLANGE,
 		    (F77_CONST_CHAR_ARG2 ("I", 1),
 		     nn, nn, aa.data (), nn, work.fortran_vec (), inf_norm
 		     F77_CHAR_ARG_LEN (1)));
 
 	  double eps = DBL_EPSILON*inf_norm*nn;
@@ -698,17 +698,17 @@ See also: balance, dare, eig, schur\n\
 	  octave_print_internal (std::cout, (Matrix) alphar, 0);
 	  std::cout << std::endl << "alphai = " << std::endl;
 	  octave_print_internal (std::cout, (Matrix) alphai, 0);
 	  std::cout << std::endl << "beta = " << std::endl;
 	  octave_print_internal (std::cout, (Matrix) betar, 0);
 	  std::cout << std::endl;
 #endif
 
-	  Array<int> ind (nn);
+	  Array<octave_idx_type> ind (nn);
 
 	  F77_XFCN (dsubsp, DSUBSP,
 		    (nn, nn, aa.fortran_vec (), bb.fortran_vec (),
 		     ZZ.fortran_vec (), sort_test, eps, ndim, fail,
 		     ind.fortran_vec ()));
 
 #ifdef DEBUG
 	  std::cout << "qz: back from dsubsp: aa=" << std::endl;
@@ -870,18 +870,18 @@ See also: balance, dare, eig, schur\n\
 	}
     }
 
   // right, left eigenvector matrices
   if (nargout >= 5)
     {
       char side = (nargout == 5 ? 'R' : 'B');	// which side to compute?
       char howmny = 'B';  // compute all of them and backtransform
-      int *select = NULL; // dummy pointer; select is not used.
-      int m;
+      octave_idx_type *select = NULL; // dummy pointer; select is not used.
+      octave_idx_type m;
 
       if (complex_case)
 	{
 	  error ("complex type not yet implemented");
 	  return retval;
 	}
       else
 	{
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -94,42 +94,42 @@ do_rand (const octave_value_list& args, 
 	    if (xisnan (dval))
 	      {
 		error ("%s: NaN is invalid a matrix dimension", fcn);
 	      }
 	    else
 	      {
 		dims.resize (2);
 
-		dims(0) = NINT (tmp.double_value ());
-		dims(1) = NINT (tmp.double_value ());
+		dims(0) = NINTbig (tmp.double_value ());
+		dims(1) = NINTbig (tmp.double_value ());
 
 		if (! error_state)
 		  goto gen_matrix;
 	      }
 	  }
 	else if (tmp.is_range ())
 	  {
 	    Range r = tmp.range_value ();
 
 	    if (r.all_elements_are_ints ())
 	      {
-		int n = r.nelem ();
+		octave_idx_type n = r.nelem ();
 
 		dims.resize (n);
 
-		int base = NINT (r.base ());
-		int incr = NINT (r.inc ());
-		int lim = NINT (r.limit ());
+		octave_idx_type base = NINTbig (r.base ());
+		octave_idx_type incr = NINTbig (r.inc ());
+		octave_idx_type lim = NINTbig (r.limit ());
 
 		if (base < 0 || lim < 0)
 		  error ("%s: all dimensions must be nonnegative", fcn);
 		else
 		  {
-		    for (int i = 0; i < n; i++)
+		    for (octave_idx_type i = 0; i < n; i++)
 		      {
 			dims(i) = base;
 			base += incr;
 		      }
 
 		    goto gen_matrix;
 		  }
 	      }
@@ -138,23 +138,23 @@ do_rand (const octave_value_list& args, 
 		     fcn);
 	  }
 	else if (tmp.is_matrix_type ())
 	  {
 	    Array<int> iv = tmp.int_vector_value (true);
 
 	    if (! error_state)
 	      {
-		int len = iv.length ();
+		octave_idx_type len = iv.length ();
 
 		dims.resize (len);
 
-		for (int i = 0; i < len; i++)
+		for (octave_idx_type i = 0; i < len; i++)
 		  {
-		    int elt = iv(i);
+		    octave_idx_type elt = iv(i);
 
 		    if (elt < 0)
 		      {
 			error ("%s: all dimensions must be nonnegative", fcn);
 			goto done;
 		      }
 
 		    dims(i) = iv(i);
@@ -192,17 +192,17 @@ do_rand (const octave_value_list& args, 
 	      error ("%s: unrecognized string argument", fcn);
 	  }
 	else
 	  {
 	    dims.resize (nargin);
 
 	    for (int i = 0; i < nargin; i++)
 	      {
-		dims(i) = args(i).int_value ();
+		dims(i) = (octave_idx_type)args(i).int_value ();
 
 		if (error_state)
 		  {
 		    error ("%s: expecting integer arguments", fcn);
 		    goto done;
 		  }
 	      }
 
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -273,18 +273,18 @@ leading eigenvalues of\n\
   if (ord_char != 'U' && ord_char != 'A' && ord_char != 'D'
       && ord_char != 'u' && ord_char != 'a' && ord_char != 'd')
     {
       warning ("schur: incorrect ordered schur argument `%c'",
 	       ord.c_str ());
       return retval;
     }
 
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("schur", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
diff --git a/src/DLD-FUNCTIONS/sort.cc b/src/DLD-FUNCTIONS/sort.cc
--- a/src/DLD-FUNCTIONS/sort.cc
+++ b/src/DLD-FUNCTIONS/sort.cc
@@ -43,17 +43,17 @@ Software Foundation, 59 Temple Place - S
 enum sortmode { UNDEFINED, ASCENDING, DESCENDING };
 
 template <class T>
 class
 vec_index
 {
 public:
   T vec;
-  int indx;
+  octave_idx_type indx;
 };
 
 template <class T>
 bool 
 ascending_compare (T a, T b)
 {
   return (a < b);
 }
@@ -84,58 +84,58 @@ static octave_value
 mx_sort (ArrayN<T> &m, int dim, sortmode mode = UNDEFINED)
 {
   octave_value retval;
 
   if (m.length () < 1)
     return retval;
 
   dim_vector dv = m.dims ();
-  unsigned int ns = dv(dim);
-  unsigned int iter = dv.numel () / ns;
-  unsigned int stride = 1;
-  for (unsigned int i = 0; i < static_cast<unsigned int> (dim); i++)
+  octave_idx_type ns = dv(dim);
+  octave_idx_type iter = dv.numel () / ns;
+  octave_idx_type stride = 1;
+  for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
   T *v = m.fortran_vec ();
   octave_sort<T> sort;
 
   if (mode == ASCENDING) 
     sort.set_compare (ascending_compare);
   else if (mode == DESCENDING)
     sort.set_compare (descending_compare);
 
   if (stride == 1)
     {
-      for (unsigned int j = 0; j < iter; j++)
+      for (octave_idx_type j = 0; j < iter; j++)
 	{
 	  sort.sort (v, ns);
 	  v += ns;
 	}
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, vi, ns);
-      for (unsigned int j = 0; j < iter; j++) 
+      for (octave_idx_type j = 0; j < iter; j++) 
 	{
-	  unsigned int offset = j;
-	  unsigned int offset2 = 0;
+	   octave_idx_type offset = j;
+	   octave_idx_type offset2 = 0;
 	  while (offset >= stride)
 	    {
 	      offset -= stride;
 	      offset2++;
 	    }
 	  offset += offset2 * stride * ns;
 	  
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    vi[i] = v[i*stride + offset];
 
 	  sort.sort (vi, ns);
 	      
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    v[i*stride + offset] = vi[i];
 	}
     }
 
   retval = m;
 
   return retval;
 }
@@ -145,82 +145,82 @@ static octave_value_list
 mx_sort_indexed (ArrayN<T> &m, int dim, sortmode mode = UNDEFINED)
 {
   octave_value_list retval;
 
   if (m.length () < 1)
     return retval;
 
   dim_vector dv = m.dims ();
-  unsigned int ns = dv(dim);
-  unsigned int iter = dv.numel () / ns;
-  unsigned int stride = 1;
-  for (unsigned int i = 0; i < static_cast<unsigned int> (dim); i++)
+  octave_idx_type ns = dv(dim);
+  octave_idx_type iter = dv.numel () / ns;
+  octave_idx_type stride = 1;
+  for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
   T *v = m.fortran_vec ();
   octave_sort<vec_index<T> *> indexed_sort;
 
   if (mode == ASCENDING) 
     indexed_sort.set_compare (ascending_compare);
   else if (mode == DESCENDING)
     indexed_sort.set_compare (descending_compare);
 
   OCTAVE_LOCAL_BUFFER (vec_index<T> *, vi, ns);
   OCTAVE_LOCAL_BUFFER (vec_index<T>, vix, ns);
 
-  for (unsigned int i = 0; i < ns; i++)
+  for (octave_idx_type i = 0; i < ns; i++)
     vi[i] = &vix[i];
 
   NDArray idx (dv);
       
   if (stride == 1)
     {
-      for (unsigned int j = 0; j < iter; j++)
+      for (octave_idx_type j = 0; j < iter; j++)
 	{
-	  unsigned int offset = j * ns;
+	   octave_idx_type offset = j * ns;
 
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    {
 	      vi[i]->vec = v[i];
 	      vi[i]->indx = i + 1;
 	    }
 
 	  indexed_sort.sort (vi, ns);
 
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    {
 	      v[i] = vi[i]->vec;
 	      idx(i + offset) = vi[i]->indx;
 	    }
 	  v += ns;
 	}
     }
   else
     {
-      for (unsigned int j = 0; j < iter; j++)
+      for (octave_idx_type j = 0; j < iter; j++)
 	{
-	  unsigned int offset = j;
-	  unsigned int offset2 = 0;
+	  octave_idx_type offset = j;
+	  octave_idx_type offset2 = 0;
 	  while (offset >= stride)
 	    {
 	      offset -= stride;
 	      offset2++;
 	    }
 	  offset += offset2 * stride * ns;
 	      
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    {
 	      vi[i]->vec = v[i*stride + offset];
 	      vi[i]->indx = i + 1;
 	    }
 
 	  indexed_sort.sort (vi, ns);
 	      
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    {
 	      v[i*stride+offset] = vi[i]->vec;
 	      idx(i*stride+offset) = vi[i]->indx;
 	    }
 	}
     }
 
   retval(1) = idx;
@@ -284,253 +284,254 @@ descending_compare (vec_index<unsigned E
   return (a->vec > b->vec);
 }
 
 template class octave_sort<unsigned EIGHT_BYTE_INT>;
 template class vec_index<unsigned EIGHT_BYTE_INT>;
 template class octave_sort<vec_index<unsigned EIGHT_BYTE_INT> *>;
 
 template <>
-static octave_value
+octave_value
 mx_sort (ArrayN<double> &m, int dim, sortmode mode)
 {
   octave_value retval;
 
   if (m.length () < 1)
     return retval;
 
   dim_vector dv = m.dims ();
-  unsigned int ns = dv(dim);
-  unsigned int iter = dv.numel () / ns;
-  unsigned int stride = 1;
-  for (unsigned int i = 0; i < static_cast<unsigned int> (dim); i++)
+  octave_idx_type ns = dv(dim);
+  octave_idx_type iter = dv.numel () / ns;
+  octave_idx_type stride = 1;
+  for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
   double *v = m.fortran_vec ();
 
   unsigned EIGHT_BYTE_INT *p = reinterpret_cast<unsigned EIGHT_BYTE_INT *> (v);
 
   octave_sort<unsigned EIGHT_BYTE_INT> sort;
 
   if (mode == ASCENDING)
     sort.set_compare (ascending_compare);
   else if (mode == DESCENDING)
     sort.set_compare (descending_compare);
 
   if (stride == 1)
     {
-      for (unsigned int j = 0; j < iter; j++)
+      for (octave_idx_type j = 0; j < iter; j++)
 	{
 	  // Flip the data in the vector so that int compares on
 	  // IEEE754 give the correct ordering.
 
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    p[i] = FloatFlip (p[i]);
 	      
 	  sort.sort (p, ns);
 
 	  // Flip the data out of the vector so that int compares
 	  // on IEEE754 give the correct ordering.
 
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    p[i] = IFloatFlip (p[i]);
 
 	  // There are two representations of NaN.  One will be
 	  // sorted to the beginning of the vector and the other
 	  // to the end.  If it will be sorted incorrectly, fix
 	  // things up.
 
 	  if (lo_ieee_signbit (octave_NaN))
 	    if (mode == UNDEFINED || mode == ASCENDING)
 	      {
-		unsigned int i = 0;
+		octave_idx_type i = 0;
 		double *vtmp = (double *)p;
 		while (xisnan (vtmp[i++]) && i < ns);
-		for (unsigned int l = 0; l < ns - i + 1; l++)
+		for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		  vtmp[l] = vtmp[l+i-1];
-		for (unsigned int l = ns - i + 1; l < ns; l++)
+		for (octave_idx_type l = ns - i + 1; l < ns; l++)
 		  vtmp[l] = octave_NaN;
 	      }
 	    else
 	      {
-		unsigned int i = ns;
+		octave_idx_type i = ns;
 		double *vtmp = (double *)p;
 		while (xisnan (vtmp[--i]) && i > 0);
-		for (int l = i; l >= 0; l--)
+		for (octave_idx_type l = i; l >= 0; l--)
 		  vtmp[l-i+ns-1] = vtmp[l];
-		for (unsigned int l = 0; l < ns - i - 1; l++)
+		for (octave_idx_type l = 0; l < ns - i - 1; l++)
 		  vtmp[l] = octave_NaN;
 	      }
 
 	  p += ns;
 	}
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (unsigned EIGHT_BYTE_INT, vi, ns);
 
-      for (unsigned int j = 0; j < iter; j++)
+      for (octave_idx_type j = 0; j < iter; j++)
 	{
-	  unsigned int offset = j;
-	  unsigned int offset2 = 0;
+	  octave_idx_type offset = j;
+	  octave_idx_type offset2 = 0;
 	  while (offset >= stride)
 	    {
 	      offset -= stride;
 	      offset2++;
 	    }
 	  offset += offset2 * stride * ns;
 
 	  // Flip the data in the vector so that int compares on
 	  // IEEE754 give the correct ordering.
 
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    vi[i] = FloatFlip (p[i*stride + offset]);
 
 	  sort.sort (vi, ns);
 
 	  // Flip the data out of the vector so that int compares
 	  // on IEEE754 give the correct ordering.
 
-	  for (unsigned int i = 0; i < ns; i++)
+	  for (octave_idx_type i = 0; i < ns; i++)
 	    p[i*stride + offset] = IFloatFlip (vi[i]);
 	      
 	  // There are two representations of NaN. One will be
 	  // sorted to the beginning of the vector and the other
 	  // to the end. If it will be sorted to the beginning,
 	  // fix things up.
 
 	  if (lo_ieee_signbit (octave_NaN))
 	    if (mode == UNDEFINED || mode == ASCENDING)
 	      {
-		unsigned int i = 0;
+		 octave_idx_type i = 0;
 		while (xisnan (v[i++*stride + offset]) && i < ns);
-		for (unsigned int l = 0; l < ns - i + 1; l++)
+		for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		  v[l*stride + offset] = v[(l+i-1)*stride + offset];
-		for (unsigned int l = ns - i + 1; l < ns; l++)
+		for (octave_idx_type l = ns - i + 1; l < ns; l++)
 		  v[l*stride + offset] = octave_NaN;
 	      }
 	    else
 	      {
-		unsigned int i = ns;
+		 octave_idx_type i = ns;
 		while (xisnan (v[--i*stride + offset]) && i > 0);
-		for (int l = i; l >= 0; l--)
+		for (octave_idx_type l = i; l >= 0; l--)
 		  v[(l-i+ns-1)*stride + offset] = v[l*stride + offset];
-		for (unsigned int l = 0; l < ns - i - 1; l++)
+		for (octave_idx_type l = 0; l < ns - i - 1; l++)
 		  v[l*stride + offset] = octave_NaN;
 	      }
 	}
     }
 
   retval = m;
 
   return retval;
 }
 
+// Should other overloaded functions have their static keywords removed?
 template <>
-static octave_value_list
+octave_value_list
 mx_sort_indexed (ArrayN<double> &m, int dim, sortmode mode)
 {
   octave_value_list retval;
 
   if (m.length () < 1)
     return retval;
 
   dim_vector dv = m.dims ();
-  unsigned int ns = dv(dim);
-  unsigned int iter = dv.numel () / ns;
-  unsigned int stride = 1;
-  for (unsigned int i = 0; i < static_cast<unsigned int> (dim); i++)
+  octave_idx_type ns = dv(dim);
+  octave_idx_type iter = dv.numel () / ns;
+  octave_idx_type stride = 1;
+  for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
   double *v = m.fortran_vec ();
 
   unsigned EIGHT_BYTE_INT *p = reinterpret_cast<unsigned EIGHT_BYTE_INT *> (v);
 
   octave_sort<vec_index<unsigned EIGHT_BYTE_INT> *> indexed_sort;
 
   if (mode == ASCENDING)
     indexed_sort.set_compare (ascending_compare);
   else if (mode == DESCENDING)
     indexed_sort.set_compare (descending_compare);
 
   OCTAVE_LOCAL_BUFFER (vec_index<unsigned EIGHT_BYTE_INT> *, vi, ns);
   OCTAVE_LOCAL_BUFFER (vec_index<unsigned EIGHT_BYTE_INT>, vix, ns);
   
-  for (unsigned int i = 0; i < ns; i++)
+  for (octave_idx_type i = 0; i < ns; i++)
     vi[i] = &vix[i];
 
   NDArray idx (dv);
       
-  for (unsigned int j = 0; j < iter; j++)
+  for (octave_idx_type j = 0; j < iter; j++)
     {
-      unsigned int offset = j;
-      unsigned int offset2 = 0;
+      octave_idx_type offset = j;
+      octave_idx_type offset2 = 0;
       while (offset >= stride)
 	{
 	  offset -= stride;
 	  offset2++;
 	}
       offset += offset2 * stride * ns;
 
       // Flip the data in the vector so that int compares on
       // IEEE754 give the correct ordering.
 
-      for (unsigned int i = 0; i < ns; i++)
+      for (octave_idx_type i = 0; i < ns; i++)
 	{
 	  vi[i]->vec = FloatFlip (p[i*stride + offset]);
 	  vi[i]->indx = i + 1;
 	}
 
       indexed_sort.sort (vi, ns);
 
       // Flip the data out of the vector so that int compares on
       // IEEE754 give the correct ordering
 
-      for (unsigned int i = 0; i < ns; i++)
+      for (octave_idx_type i = 0; i < ns; i++)
 	{
 	  p[i*stride + offset] = IFloatFlip (vi[i]->vec);
 	  idx(i*stride + offset) = vi[i]->indx;
 	}
 
       // There are two representations of NaN.  One will be sorted
       // to the beginning of the vector and the other to the end.
       // If it will be sorted to the beginning, fix things up.
 
       if (lo_ieee_signbit (octave_NaN))
 	if (mode == UNDEFINED || mode == ASCENDING)
 	  {
-	    unsigned int i = 0;
+	    octave_idx_type i = 0;
 	    while (xisnan (v[i++*stride+offset]) && i < ns);
 	    OCTAVE_LOCAL_BUFFER (double, itmp, i - 1);
-	    for (unsigned int l = 0; l < i -1; l++)
+	    for (octave_idx_type l = 0; l < i -1; l++)
 	      itmp[l] = idx(l*stride + offset);
-	    for (unsigned int l = 0; l < ns - i + 1; l++)
+	    for (octave_idx_type l = 0; l < ns - i + 1; l++)
 	      {
 		v[l*stride + offset] = v[(l+i-1)*stride + offset];
 		idx(l*stride + offset) = idx((l+i-1)*stride + offset);
 	      }
-	    for (unsigned int k = 0, l = ns - i + 1; l < ns; l++, k++)
+	    for (octave_idx_type k = 0, l = ns - i + 1; l < ns; l++, k++)
 	      {
 		v[l*stride + offset] = octave_NaN;
 		idx(l*stride + offset) = itmp[k];
 	      }
 	  }
 	else 
 	  {
-	    unsigned int i = ns;
+	     octave_idx_type i = ns;
 	    while (xisnan (v[--i*stride+offset]) && i > 0);
 	    OCTAVE_LOCAL_BUFFER (double, itmp, ns - i - 1);
-	    for (unsigned int l = 0; l < ns - i -1; l++)
+	    for (octave_idx_type l = 0; l < ns - i -1; l++)
 	      itmp[l] = idx((l+i+1)*stride + offset);
-	    for (int l = i; l >= 0; l--)
+	    for (octave_idx_type l = i; l >= 0; l--)
 	      {
 		v[(l-i+ns-1)*stride + offset] = v[l*stride + offset];
 		idx((l-i+ns-1)*stride + offset) = idx(l*stride + offset);
 	      }
-	    for (unsigned int k = 0, l = 0; l < ns - i - 1; l++, k++)
+	    for (octave_idx_type k = 0, l = 0; l < ns - i - 1; l++, k++)
 	      {
 		v[l*stride + offset] = octave_NaN;
 		idx(l*stride + offset) = itmp[k];
 	      }
 	  }
     }
 
   retval(1) = idx;
@@ -770,17 +771,17 @@ ordered lists.\n\
 	smode = DESCENDING;
       else
 	{
 	  error ("sort: mode must be either \"ascend\" or \"descend\"");
 	  return retval;
 	}
     }
 
-  dim_vector dv = ((const octave_complex_matrix&) arg) .dims ();
+  dim_vector dv = arg.dims ();
   if (error_state)
     {
       gripe_wrong_type_arg ("sort", arg);
       return retval;
     }
   if (nargin == 1 || args(1).is_string ())
     {
       // Find first non singleton dimension
@@ -851,17 +852,17 @@ ordered lists.\n\
 	  retval(0) = retval(0).convert_to_str (false, true);
 	}
     }
   else if (arg.is_cell ())
     {
       Cell cellm = arg.cell_value ();
 
       // Need to check that all elements are strings
-      for (int i = 0; i < cellm.numel (); i++)
+      for (octave_idx_type i = 0; i < cellm.numel (); i++)
 	if (! cellm(i).is_string ())
 	  {
 	    gripe_wrong_type_arg ("sort", arg);
 	    break;
 	  }
 
       // Don't have unindexed version as ">" operator doesn't return bool
       if (!error_state)
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -189,17 +189,17 @@ which case they are expanded to all have
 	       if (error_state) 
 		 return retval;
 	       retval = new octave_sparse_matrix (sm);
 	     }
 	 }
      }
    else 
      {
-       int m = 1, n = 1;
+       octave_idx_type m = 1, n = 1;
        if (nargin == 2) 
 	 {
 	   m = args(0).int_value();
 	   n = args(1).int_value();
 	   if (error_state) return retval;
 
 	   if (use_complex) 
 	     retval = new octave_sparse_complex_matrix 
@@ -266,39 +266,39 @@ which case they are expanded to all have
 		   coefA = ColumnVector (0);
 		 else
 		   coefA = ColumnVector (args(2).vector_value (false, true));
 
 	       if (error_state)
 		 return retval;
 
 	       // Confirm that i,j,s all have the same number of elements
-	       int ns;
+	       octave_idx_type ns;
 	       if (use_complex) 
 		 ns = coefAC.length();
 	       else if (use_bool) 
 		 ns = coefAB.length();
 	       else 
 		 ns = coefA.length();
 
-	       int ni = ridxA.length();
-	       int nj = cidxA.length();
-	       int nnz = (ni > nj ? ni : nj);
+	       octave_idx_type ni = ridxA.length();
+	       octave_idx_type nj = cidxA.length();
+	       octave_idx_type nnz = (ni > nj ? ni : nj);
 	       if ((ns != 1 && ns != nnz) ||
 		   (ni != 1 && ni != nnz) ||
 		   (nj != 1 && nj != nnz)) 
 		 {
 		   error ("sparse i, j and s must have the same length");
 		   return retval;
 		 }
 
 	       if (nargin == 3 || nargin == 4) 
 		 {
-		   m = static_cast<int> (ridxA.max());
-		   n = static_cast<int> (cidxA.max());
+		   m = static_cast<octave_idx_type> (ridxA.max());
+		   n = static_cast<octave_idx_type> (cidxA.max());
 
 		   // if args(3) is not string, then ignore the value
 		   // otherwise check for summation or unique
 		   if (nargin == 4 && args(3).is_string())
 		     {
 		       std::string vv= args(3).string_value();
 		       if (error_state) return retval;
 		       
@@ -428,39 +428,39 @@ returns number of non zero elements in S
       else if (args(0).type_name () == "sparse complex matrix")
 	retval = (double) ((const octave_sparse_complex_matrix&) rep) .nonzero ();
       else if (args(0).type_name () == "sparse bool matrix")
 	retval = (double) ((const octave_sparse_bool_matrix&) rep) .nonzero ();
     } 
   else if (args(0).type_name () == "complex matrix") 
     {
       const ComplexMatrix M = args(0).complex_matrix_value();
-      int nnz = 0;
-      for( int j = 0; j < M.cols(); j++)
-	for( int i = 0; i < M.rows(); i++)
+      octave_idx_type nnz = 0;
+      for( octave_idx_type j = 0; j < M.cols(); j++)
+	for( octave_idx_type i = 0; i < M.rows(); i++)
 	  if (M (i, j) != 0.) 
 	    nnz++;
       retval = (double) nnz;
     } 
   else if (args(0).type_name () == "matrix") 
     {
       const Matrix M = args(0).matrix_value();
-      int nnz = 0;
-      for( int j = 0; j < M.cols(); j++)
-	for( int i = 0; i < M.rows(); i++)
+      octave_idx_type nnz = 0;
+      for( octave_idx_type j = 0; j < M.cols(); j++)
+	for( octave_idx_type i = 0; i < M.rows(); i++)
 	  if (M (i, j) != 0.) 
 	    nnz++;
       retval = (double) nnz;
     } 
   else if (args(0).type_name () == "string") 
     {
       const charMatrix M = args(0).char_matrix_value();
-      int nnz = 0;
-      for( int j = 0; j < M.cols(); j++)
-	for( int i = 0; i < M.rows(); i++)
+      octave_idx_type nnz = 0;
+      for( octave_idx_type j = 0; j < M.cols(); j++)
+	for( octave_idx_type i = 0; i < M.rows(); i++)
 	  if (M (i, j) != 0) 
 	    nnz++;
       retval = (double) nnz;
     } 
   else if (args(0).type_name () == "scalar") 
       retval = args(0).scalar_value() != 0.0 ? 1.0 : 0.0;
   else if (args(0).type_name () == "complex scalar")
     retval = args(0).complex_value() != 0.0 ? 1.0 : 0.0;
@@ -507,28 +507,28 @@ but in general they will give the same r
 
   return retval;
 }
 
 static octave_value_list
 sparse_find (const SparseMatrix& v)
 {
   octave_value_list retval;
-  int nnz = v.nnz ();
+  octave_idx_type nnz = v.nnz ();
   dim_vector dv = v.dims ();
-  int nr = dv(0);
-  int nc = dv (1);
+  octave_idx_type nr = dv(0);
+  octave_idx_type nc = dv (1);
 
   ColumnVector I (nnz), J (nnz);
   ColumnVector S (nnz);
 
-  for (int i = 0, cx = 0; i < nc; i++) 
+  for (octave_idx_type i = 0, cx = 0; i < nc; i++) 
     {
       OCTAVE_QUIT;
-      for (int j = v.cidx(i); j < v.cidx(i+1); j++ ) 
+      for (octave_idx_type j = v.cidx(i); j < v.cidx(i+1); j++ ) 
 	{
 	  I (cx) = static_cast<double> (v.ridx(j) + 1);
 	  J (cx) = static_cast<double> (i + 1);
 	  S (cx) = v.data(j);
 	  cx++;
 	}
     }
 
@@ -548,28 +548,28 @@ sparse_find (const SparseMatrix& v)
   retval(4)= (double) nc;
   return retval;
 }
 
 static octave_value_list
 sparse_find (const SparseComplexMatrix& v)
 {
   octave_value_list retval;
-  int nnz = v.nnz ();
+  octave_idx_type nnz = v.nnz ();
   dim_vector dv = v.dims ();
-  int nr = dv(0);
-  int nc = dv (1);
+  octave_idx_type nr = dv(0);
+  octave_idx_type nc = dv (1);
 
   ColumnVector I (nnz), J (nnz);
   ComplexColumnVector S (nnz);
 
-  for (int i = 0, cx = 0; i < nc; i++) 
+  for (octave_idx_type i = 0, cx = 0; i < nc; i++) 
     {
       OCTAVE_QUIT;
-      for (int j = v.cidx(i); j < v.cidx(i+1); j++ ) 
+      for (octave_idx_type j = v.cidx(i); j < v.cidx(i+1); j++ ) 
 	{
 	  I (cx) = static_cast<double> (v.ridx(j) + 1);
 	  J (cx) = static_cast<double> (i + 1);
 	  S (cx) = v.data(j);
 	  cx++;
 	}
     }
 
@@ -589,28 +589,28 @@ sparse_find (const SparseComplexMatrix& 
   retval(4)= (double) nc;
   return retval;
 }
 
 static octave_value_list
 sparse_find (const SparseBoolMatrix& v)
 {
   octave_value_list retval;
-  int nnz = v.nnz ();
+  octave_idx_type nnz = v.nnz ();
   dim_vector dv = v.dims ();
-  int nr = dv(0);
-  int nc = dv (1);
+  octave_idx_type nr = dv(0);
+  octave_idx_type nc = dv (1);
 
   ColumnVector I (nnz), J (nnz);
   ColumnVector S (nnz);
 
-  for (int i = 0, cx = 0; i < nc; i++) 
+  for (octave_idx_type i = 0, cx = 0; i < nc; i++) 
     {
       OCTAVE_QUIT;
-      for (int j = v.cidx(i); j < v.cidx(i+1); j++ ) 
+      for (octave_idx_type j = v.cidx(i); j < v.cidx(i+1); j++ ) 
 	{
 	  I (cx) = static_cast<double> (v.ridx(j) + 1);
 	  J (cx) = static_cast<double> (i + 1);
 	  S (cx) = static_cast<double> (v.data(j));
 	  cx++;
 	}
     }
 
@@ -860,38 +860,38 @@ real.\n\
       else if (arg1.type_id () == \
 	       octave_sparse_complex_matrix::static_type_id ()) \
 	retval(0) = arg1.sparse_complex_matrix_value () .FCN (dim); \
       else \
 	gripe_wrong_type_arg (#FCN, arg1); \
     } \
   else if (single_arg && nargout == 2) \
     { \
-      Array2<int> index; \
+      Array2<octave_idx_type> index; \
  \
       if (arg1.type_id () == octave_sparse_matrix::static_type_id ()) \
 	retval(0) = arg1.sparse_matrix_value () .FCN (index, dim); \
       else if (arg1.type_id () == \
 	       octave_sparse_complex_matrix::static_type_id ()) \
 	retval(0) = arg1.sparse_complex_matrix_value () .FCN (index, dim); \
       else \
 	gripe_wrong_type_arg (#FCN, arg1); \
  \
-      int len = index.numel (); \
+      octave_idx_type len = index.numel (); \
  \
       if (len > 0) \
 	{ \
 	  double nan_val = lo_ieee_nan_value (); \
  \
 	  NDArray idx (index.dims ()); \
  \
-	  for (int i = 0; i < len; i++) \
+	  for (octave_idx_type i = 0; i < len; i++) \
 	    { \
 	      OCTAVE_QUIT; \
-	      int tmp = index.elem (i) + 1; \
+	      octave_idx_type tmp = index.elem (i) + 1; \
 	      idx.elem (i) = (tmp <= 0) \
 		? nan_val : static_cast<double> (tmp); \
 	    } \
  \
 	  retval(1) = idx; \
 	} \
       else \
 	retval(1) = NDArray (); \
@@ -1150,167 +1150,167 @@ The result is in range -pi to pi.\n\
 static octave_value
 make_spdiag (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
 
   if (a.is_complex_type ())
     {
       SparseComplexMatrix m = a.sparse_complex_matrix_value ();
-      int k = b.nint_value(true);
+      octave_idx_type k = b.nint_value(true);
 
       if (error_state) 
 	return retval;
 
-      int nr = m.rows ();
-      int nc = m.columns ();
+      octave_idx_type nr = m.rows ();
+      octave_idx_type nc = m.columns ();
 	
       if (nr == 0 || nc == 0)
 	retval = m;
       else if (nr == 1 || nc == 1) 
 	{
-	  int roff = 0;
-	  int coff = 0;
+	  octave_idx_type roff = 0;
+	  octave_idx_type coff = 0;
 	  if (k > 0) 
 	    {
 	      roff = 0;
 	      coff = k;
 	    } 
 	  else if (k < 0) 
 	    {
 	      k = -k;
 	      roff = k;
 	      coff = 0;
 	    }
 
 	  if (nr == 1) 
 	    {
-	      int n = nc + k;
-	      int nz = m.nnz ();
+	      octave_idx_type n = nc + k;
+	      octave_idx_type nz = m.nnz ();
 	      SparseComplexMatrix r (n, n, nz);
-	      for (int i = 0; i < coff+1; i++)
+	      for (octave_idx_type i = 0; i < coff+1; i++)
 		r.xcidx (i) = 0;
-	      for (int j = 0; j < nc; j++)
+	      for (octave_idx_type j = 0; j < nc; j++)
 		{
-		  for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+		  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 		    {
 		      r.xdata (i) = m.data (i);
 		      r.xridx (i) = j + roff;
 		    }
 		  r.xcidx (j+coff+1) = m.cidx(j+1);
 		}
-	      for (int i = nc+coff+1; i < n+1; i++)
+	      for (octave_idx_type i = nc+coff+1; i < n+1; i++)
 		r.xcidx (i) = nz;
 	      retval = r;
 	    } 
 	  else 
 	    {
-	      int n = nr + k;
-	      int nz = m.nnz ();
-	      int ii = 0;
-	      int ir = m.ridx(0);
+	      octave_idx_type n = nr + k;
+	      octave_idx_type nz = m.nnz ();
+	      octave_idx_type ii = 0;
+	      octave_idx_type ir = m.ridx(0);
 	      SparseComplexMatrix r (n, n, nz);
-	      for (int i = 0; i < coff+1; i++)
+	      for (octave_idx_type i = 0; i < coff+1; i++)
 		r.xcidx (i) = 0;
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  if (ir == i)
 		    {
 		      r.xdata (ii) = m.data (ii);
 		      r.xridx (ii++) = ir + roff;
 		      if (ii != nz)
 			ir = m.ridx (ii);
 		    }
 		  r.xcidx (i+coff+1) = ii;
 		}
-	      for (int i = nr+coff+1; i < n+1; i++)
+	      for (octave_idx_type i = nr+coff+1; i < n+1; i++)
 		r.xcidx (i) = nz;
 	      retval = r;
 	    }
 	} 
       else 
 	{
 	  SparseComplexMatrix r = m.diag (k);
 	  // Don't use numel, since it can overflow for very large matrices
 	  if (r.rows () > 0 && r.cols () > 0)
 	    retval = r;
 	}
     } 
   else if (a.is_real_type ())
     {
       SparseMatrix m = a.sparse_matrix_value ();
 
-      int k = b.nint_value(true);
+      octave_idx_type k = b.nint_value(true);
 
       if (error_state) 
 	return retval;
 
-      int nr = m.rows ();
-      int nc = m.columns ();
+      octave_idx_type nr = m.rows ();
+      octave_idx_type nc = m.columns ();
 	
       if (nr == 0 || nc == 0)
 	retval = m;
       else if (nr == 1 || nc == 1) 
 	{
-	  int roff = 0;
-	  int coff = 0;
+	  octave_idx_type roff = 0;
+	  octave_idx_type coff = 0;
 	  if (k > 0) 
 	    {
 	      roff = 0;
 	      coff = k;
 	    } 
 	  else if (k < 0) 
 	    {
 	      k = -k;
 	      roff = k;
 	      coff = 0;
 	    }
 
 	  if (nr == 1) 
 	    {
-	      int n = nc + k;
-	      int nz = m.nnz ();
+	      octave_idx_type n = nc + k;
+	      octave_idx_type nz = m.nnz ();
 	      SparseMatrix r (n, n, nz);
 
-	      for (int i = 0; i < coff+1; i++)
+	      for (octave_idx_type i = 0; i < coff+1; i++)
 		r.xcidx (i) = 0;
-	      for (int j = 0; j < nc; j++)
+	      for (octave_idx_type j = 0; j < nc; j++)
 		{
-		  for (int i = m.cidx(j); i < m.cidx(j+1); i++)
+		  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 		    {
 		      r.xdata (i) = m.data (i);
 		      r.xridx (i) = j + roff;
 		    }
 		  r.xcidx (j+coff+1) = m.cidx(j+1);
 		}
-	      for (int i = nc+coff+1; i < n+1; i++)
+	      for (octave_idx_type i = nc+coff+1; i < n+1; i++)
 		r.xcidx (i) = nz;
 	      retval = r;
 	    } 
 	  else 
 	    {
-	      int n = nr + k;
-	      int nz = m.nnz ();
-	      int ii = 0;
-	      int ir = m.ridx(0);
+	      octave_idx_type n = nr + k;
+	      octave_idx_type nz = m.nnz ();
+	      octave_idx_type ii = 0;
+	      octave_idx_type ir = m.ridx(0);
 	      SparseMatrix r (n, n, nz);
-	      for (int i = 0; i < coff+1; i++)
+	      for (octave_idx_type i = 0; i < coff+1; i++)
 		r.xcidx (i) = 0;
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  if (ir == i)
 		    {
 		      r.xdata (ii) = m.data (ii);
 		      r.xridx (ii++) = ir + roff;
 		      if (ii != nz)
 			ir = m.ridx (ii);
 		    }
 		  r.xcidx (i+coff+1) = ii;
 		}
-	      for (int i = nr+coff+1; i < n+1; i++)
+	      for (octave_idx_type i = nr+coff+1; i < n+1; i++)
 		r.xcidx (i) = nz;
 	      retval = r;
 	    }
 	} 
       else 
 	{
 	  SparseMatrix r = m.diag (k);
 	  if (r.rows () > 0 && r.cols () > 0)
diff --git a/src/DLD-FUNCTIONS/spdet.cc b/src/DLD-FUNCTIONS/spdet.cc
--- a/src/DLD-FUNCTIONS/spdet.cc
+++ b/src/DLD-FUNCTIONS/spdet.cc
@@ -52,18 +52,18 @@ an estimate of the reciprocal condition 
   if (nargin != 1)
     {
       print_usage ("spdet");
       return retval;
     }
 
   octave_value arg = args(0);
     
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
     {
       retval(0) = 1.0;
       return retval;
     }
 
   int arg_is_empty = empty_arg ("spdet", nr, nc);
@@ -82,17 +82,17 @@ an estimate of the reciprocal condition 
     {
       SparseMatrix m = args(0).sparse_matrix_value ();
 
       if (! error_state)
 	{
 	  // Always compute rcond, so we can detect numerically
 	  // singular matrices.
 
-	  int info;
+	  octave_idx_type info;
 	  double rcond = 0.0;
 	  DET det = m.determinant (info, rcond);
 	  retval(1) = rcond;
 	  volatile double xrcond = rcond;
 	  xrcond += 1.0;
 	  retval(0) = ((info == -1 || xrcond == 1.0) ? 0.0 : det.value ());
 	}
     }
@@ -100,17 +100,17 @@ an estimate of the reciprocal condition 
     {
       SparseComplexMatrix m = args(0).sparse_complex_matrix_value ();
 
       if (! error_state)
 	{
 	  // Always compute rcond, so we can detect numerically
 	  // singular matrices.
 
-	  int info;
+	  octave_idx_type info;
 	  double rcond = 0.0;
 	  ComplexDET det = m.determinant (info, rcond);
 	  retval(1) = rcond;
 	  volatile double xrcond = rcond;
 	  xrcond += 1.0;
 	  retval(0) = ((info == -1 || xrcond == 1.0)
 		       ? Complex (0.0) : det.value ());
 	}
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -45,56 +45,56 @@ getmax (double x, double y)
   return x > y ? x : y;
 }
 
 static double
 frobnorm (const ComplexMatrix& A)
 {
   double sum = 0;
 
-  for (int i = 0; i < A.rows (); i++)
-    for (int j = 0; j < A.columns (); j++)
+  for (octave_idx_type i = 0; i < A.rows (); i++)
+    for (octave_idx_type j = 0; j < A.columns (); j++)
       sum += real (A(i,j) * conj (A(i,j)));
 
   return sqrt (sum);
 }
 
 static double
 frobnorm (const Matrix& A)
 {
   double sum = 0;
-  for (int i = 0; i < A.rows (); i++)
-    for (int j = 0; j < A.columns (); j++)
+  for (octave_idx_type i = 0; i < A.rows (); i++)
+    for (octave_idx_type j = 0; j < A.columns (); j++)
       sum += A(i,j) * A(i,j);
 
   return sqrt (sum);
 }
 
 
 static ComplexMatrix
 sqrtm_from_schur (const ComplexMatrix& U, const ComplexMatrix& T)
 {
-  const int n = U.rows ();
+  const octave_idx_type n = U.rows ();
 
   ComplexMatrix R (n, n, 0.0);
 
-  for (int j = 0; j < n; j++)
+  for (octave_idx_type j = 0; j < n; j++)
     R(j,j) = sqrt (T(j,j));
 
   const double fudge = sqrt (DBL_MIN);
 
-  for (int p = 0; p < n-1; p++)
+  for (octave_idx_type p = 0; p < n-1; p++)
     {
-      for (int i = 0; i < n-(p+1); i++)
+      for (octave_idx_type i = 0; i < n-(p+1); i++)
 	{
-	  const int j = i + p + 1;
+	  const octave_idx_type j = i + p + 1;
 
 	  Complex s = T(i,j);
 
-	  for (int k = i+1; k < j; k++)
+	  for (octave_idx_type k = i+1; k < j; k++)
 	    s -= R(i,k) * R(k,j);
 
 	  // dividing
 	  //     R(i,j) = s/(R(i,i)+R(j,j));
 	  // screwing around to not / 0
 
 	  const Complex d = R(i,i) + R(j,j) + fudge;
 	  const Complex conjd = conj (d);
@@ -124,18 +124,18 @@ Manchester, England, January 1999.\n\
   if (nargin != 1)
     {
       print_usage ("sqrtm");
       return retval;
     }
 
   octave_value arg = args(0);
 
-  int n = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type n = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("sqrtm", n, nc);
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
@@ -191,18 +191,18 @@ Manchester, England, January 1999.\n\
 
 	  const ComplexMatrix U (schur.unitary_matrix ());
 	  const ComplexMatrix T (schur.schur_matrix ());
 	  const ComplexMatrix X (sqrtm_from_schur (U, T));
 
 	  // Check for minimal imaginary part
 	  double normX = 0.0;
 	  double imagX = 0.0;
-	  for (int i = 0; i < n; i++)
-	    for (int j = 0; j < n; j++)
+	  for (octave_idx_type i = 0; i < n; i++)
+	    for (octave_idx_type j = 0; j < n; j++)
 	      {
 		imagX = getmax (imagX, imag (X(i,j)));
 		normX = getmax (normX, abs (X(i,j)));
 	      }
 
 	  if (imagX < normX * 100 * DBL_EPSILON)
 	    retval(0) = real (X);
 	  else
@@ -214,17 +214,17 @@ Manchester, England, January 1999.\n\
 
 	  err = frobnorm (X*X - ComplexMatrix (A)) / frobnorm (A);
 
 	  if (xisnan (err))
 	    err = lo_ieee_inf_value ();
 
 	  // Find min diagonal
 	  minT = lo_ieee_inf_value ();
-	  for (int i=0; i < n; i++)
+	  for (octave_idx_type i=0; i < n; i++)
 	    minT = getmin(minT, abs(T(i,i)));
 	}
       else
 	{
 	  ComplexMatrix A = arg.complex_matrix_value ();
 
 	  if (error_state)
 	    return retval;
@@ -241,17 +241,17 @@ Manchester, England, January 1999.\n\
 	  retval(0) = X;
 
 	  err = frobnorm (X*X - A) / frobnorm (A);
 
 	  if (xisnan (err))
 	    err = lo_ieee_inf_value ();
 
 	  minT = lo_ieee_inf_value ();
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    minT = getmin (minT, abs (T(i,i)));
 	}
 
       retval(1) = err;
 
       if (nargout < 2)
 	{
 	  if (err > 100*(minT+DBL_EPSILON)*n)
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -123,18 +123,18 @@ decomposition, eliminating the unnecessa
   if (nargin < 1 || nargin > 2 || nargout == 2 || nargout > 3)
     {
       print_usage ("svd");
       return retval;
     }
 
   octave_value arg = args(0);
 
-  int nr = arg.rows ();
-  int nc = arg.columns ();
+  octave_idx_type nr = arg.rows ();
+  octave_idx_type nc = arg.columns ();
 
   if (nr == 0 || nc == 0)
     {
       if (nargout == 3)
 	{
 	  retval(3) = identity_matrix (nr, nr);
 	  retval(2) = Matrix (nr, nc);
 	  retval(1) = identity_matrix (nc, nc);
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -68,24 +68,24 @@ syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10;
       print_usage ("syl");
       return retval;
     }
 
   octave_value arg_a = args(0);
   octave_value arg_b = args(1);
   octave_value arg_c = args(2);
 
-  int a_nr = arg_a.rows ();
-  int a_nc = arg_a.columns ();
+  octave_idx_type a_nr = arg_a.rows ();
+  octave_idx_type a_nc = arg_a.columns ();
 
-  int b_nr = arg_b.rows ();
-  int b_nc = arg_b.columns ();
+  octave_idx_type b_nr = arg_b.rows ();
+  octave_idx_type b_nc = arg_b.columns ();
 
-  int c_nr = arg_c.rows ();
-  int c_nc = arg_c.columns ();
+  octave_idx_type c_nr = arg_c.rows ();
+  octave_idx_type c_nc = arg_c.columns ();
 
   int arg_a_is_empty = empty_arg ("syl", a_nr, a_nc);
   int arg_b_is_empty = empty_arg ("syl", b_nr, b_nc);
   int arg_c_is_empty = empty_arg ("syl", c_nr, c_nc);
 
   if (arg_a_is_empty > 0 && arg_b_is_empty > 0 && arg_c_is_empty > 0)
     return octave_value (Matrix ());
   else if (arg_a_is_empty || arg_b_is_empty || arg_c_is_empty)
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -113,64 +113,64 @@ any (eye (2, 4), 2)\n\
 
 // These mapping functions may also be useful in other places, eh?
 
 typedef double (*d_dd_fcn) (double, double);
 
 static Matrix
 map_d_m (d_dd_fcn f, double x, const Matrix& y)
 {
-  int nr = y.rows ();
-  int nc = y.columns ();
+  octave_idx_type nr = y.rows ();
+  octave_idx_type nc = y.columns ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	retval (i, j) = f (x, y (i, j));
       }
 
   return retval;
 }
 
 static Matrix
 map_m_d (d_dd_fcn f, const Matrix& x, double y)
 {
-  int nr = x.rows ();
-  int nc = x.columns ();
+  octave_idx_type nr = x.rows ();
+  octave_idx_type nc = x.columns ();
 
   Matrix retval (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	retval (i, j) = f (x (i, j), y);
       }
 
   return retval;
 }
 
 static Matrix
 map_m_m (d_dd_fcn f, const Matrix& x, const Matrix& y)
 {
-  int x_nr = x.rows ();
-  int x_nc = x.columns ();
+  octave_idx_type x_nr = x.rows ();
+  octave_idx_type x_nc = x.columns ();
 
-  int y_nr = y.rows ();
-  int y_nc = y.columns ();
+  octave_idx_type y_nr = y.rows ();
+  octave_idx_type y_nc = y.columns ();
 
   assert (x_nr == y_nr && x_nc == y_nc);
 
   Matrix retval (x_nr, x_nc);
 
-  for (int j = 0; j < x_nc; j++)
-    for (int i = 0; i < x_nr; i++)
+  for (octave_idx_type j = 0; j < x_nc; j++)
+    for (octave_idx_type i = 0; i < x_nr; i++)
       {
 	OCTAVE_QUIT;
 	retval (i, j) = f (x (i, j), y (i, j));
       }
 
   return retval;
 }
 
@@ -185,32 +185,32 @@ and @var{x}.  The result is in range -pi
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       octave_value arg_y = args(0);
       octave_value arg_x = args(1);
 
-      int y_nr = arg_y.rows ();
-      int y_nc = arg_y.columns ();
+      octave_idx_type y_nr = arg_y.rows ();
+      octave_idx_type y_nc = arg_y.columns ();
 
-      int x_nr = arg_x.rows ();
-      int x_nc = arg_x.columns ();
+      octave_idx_type x_nr = arg_x.rows ();
+      octave_idx_type x_nc = arg_x.columns ();
 
       int arg_y_empty = empty_arg ("atan2", y_nr, y_nc);
       int arg_x_empty = empty_arg ("atan2", x_nr, x_nc);
 
       if (arg_y_empty > 0 && arg_x_empty > 0)
 	return octave_value (Matrix ());
       else if (arg_y_empty || arg_x_empty)
 	return retval;
 
-      int y_is_scalar = (y_nr == 1 && y_nc == 1);
-      int x_is_scalar = (x_nr == 1 && x_nc == 1);
+      octave_idx_type y_is_scalar = (y_nr == 1 && y_nc == 1);
+      octave_idx_type x_is_scalar = (x_nr == 1 && x_nc == 1);
 
       if (y_is_scalar && x_is_scalar)
 	{
 	  double y = arg_y.double_value ();
 
 	  if (! error_state)
 	    {
 	      double x = arg_x.double_value ();
@@ -276,32 +276,32 @@ sign as @var{x}.  If @var{y} is zero, th
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       octave_value arg_x = args(0);
       octave_value arg_y = args(1);
 
-      int y_nr = arg_y.rows ();
-      int y_nc = arg_y.columns ();
+      octave_idx_type y_nr = arg_y.rows ();
+      octave_idx_type y_nc = arg_y.columns ();
 
-      int x_nr = arg_x.rows ();
-      int x_nc = arg_x.columns ();
+      octave_idx_type x_nr = arg_x.rows ();
+      octave_idx_type x_nc = arg_x.columns ();
 
       int arg_y_empty = empty_arg ("fmod", y_nr, y_nc);
       int arg_x_empty = empty_arg ("fmod", x_nr, x_nc);
 
       if (arg_y_empty > 0 && arg_x_empty > 0)
 	return octave_value (Matrix ());
       else if (arg_y_empty || arg_x_empty)
 	return retval;
 
-      int y_is_scalar = (y_nr == 1 && y_nc == 1);
-      int x_is_scalar = (x_nr == 1 && x_nc == 1);
+      octave_idx_type y_is_scalar = (y_nr == 1 && y_nc == 1);
+      octave_idx_type x_is_scalar = (x_nr == 1 && x_nc == 1);
 
       if (y_is_scalar && x_is_scalar)
 	{
 	  double y = arg_y.double_value ();
 
 	  if (! error_state)
 	    {
 	      double x = arg_x.double_value ();
@@ -428,92 +428,92 @@ same orientation as @var{x}.\n\
 {
   DATA_REDUCTION (cumsum);
 }
 
 // XXX FIXME XXX -- we could eliminate some duplicate code here with
 // some template functions or macros.
 
 static octave_value
-make_diag (const Matrix& v, int k)
+make_diag (const Matrix& v, octave_idx_type k)
 {
-  int nr = v.rows ();
-  int nc = v.columns ();
+  octave_idx_type nr = v.rows ();
+  octave_idx_type nc = v.columns ();
   assert (nc == 1 || nr == 1);
 
   octave_value retval;
 
-  int roff = 0;
-  int coff = 0;
+  octave_idx_type roff = 0;
+  octave_idx_type coff = 0;
   if (k > 0)
     {
       roff = 0;
       coff = k;
     }
   else if (k < 0)
     {
       roff = -k;
       coff = 0;
     }
 
   if (nr == 1)
     {
-      int n = nc + std::abs (k);
+      octave_idx_type n = nc + std::abs (k);
       Matrix m (n, n, 0.0);
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	m (i+roff, i+coff) = v (0, i);
       retval = m;
     }
   else
     {
-      int n = nr + std::abs (k);
+      octave_idx_type n = nr + std::abs (k);
       Matrix m (n, n, 0.0);
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	m (i+roff, i+coff) = v (i, 0);
       retval = m;
     }
 
   return retval;
 }
 
 static octave_value
-make_diag (const ComplexMatrix& v, int k)
+make_diag (const ComplexMatrix& v, octave_idx_type k)
 {
-  int nr = v.rows ();
-  int nc = v.columns ();
+  octave_idx_type nr = v.rows ();
+  octave_idx_type nc = v.columns ();
   assert (nc == 1 || nr == 1);
 
   octave_value retval;
 
-  int roff = 0;
-  int coff = 0;
+  octave_idx_type roff = 0;
+  octave_idx_type coff = 0;
   if (k > 0)
     {
       roff = 0;
       coff = k;
     }
   else if (k < 0)
     {
       roff = -k;
       coff = 0;
     }
 
   if (nr == 1)
     {
-      int n = nc + std::abs (k);
+      octave_idx_type n = nc + std::abs (k);
       ComplexMatrix m (n, n, 0.0);
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	m (i+roff, i+coff) = v (0, i);
       retval = m;
     }
   else
     {
-      int n = nr + std::abs (k);
+      octave_idx_type n = nr + std::abs (k);
       ComplexMatrix m (n, n, 0.0);
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	m (i+roff, i+coff) = v (i, 0);
       retval = m;
     }
 
   return retval;
 }
 
 static octave_value
@@ -522,18 +522,18 @@ make_diag (const octave_value& arg)
   octave_value retval;
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
-	  int nr = m.rows ();
-	  int nc = m.columns ();
+	  octave_idx_type nr = m.rows ();
+	  octave_idx_type nc = m.columns ();
 
 	  if (nr == 0 || nc == 0)
 	    retval = Matrix ();
 	  else if (nr == 1 || nc == 1)
 	    retval = make_diag (m, 0);
 	  else
 	    {
 	      ColumnVector v = m.diag ();
@@ -545,18 +545,18 @@ make_diag (const octave_value& arg)
 	gripe_wrong_type_arg ("diag", arg);
     }
   else if (arg.is_complex_type ())
     {
       ComplexMatrix cm = arg.complex_matrix_value ();
 
       if (! error_state)
 	{
-	  int nr = cm.rows ();
-	  int nc = cm.columns ();
+	  octave_idx_type nr = cm.rows ();
+	  octave_idx_type nc = cm.columns ();
 
 	  if (nr == 0 || nc == 0)
 	    retval = Matrix ();
 	  else if (nr == 1 || nc == 1)
 	    retval = make_diag (cm, 0);
 	  else
 	    {
 	      ComplexColumnVector v = cm.diag ();
@@ -573,32 +573,32 @@ make_diag (const octave_value& arg)
   return retval;
 }
 
 static octave_value
 make_diag (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
 
-  int k = b.int_value ();
+  octave_idx_type k = b.int_value ();
 
   if (error_state)
     {
       error ("diag: invalid second argument");      
       return retval;
     }
 
   if (a.is_real_type ())
     {
       Matrix m = a.matrix_value ();
 
       if (! error_state)
 	{
-	  int nr = m.rows ();
-	  int nc = m.columns ();
+	  octave_idx_type nr = m.rows ();
+	  octave_idx_type nc = m.columns ();
 
 	  if (nr == 1 || nc == 1)
 	    retval = make_diag (m, k);
 	  else if (nr == 0 || nc == 0)
 	    retval = Matrix ();
 	  else
 	    {
 	      ColumnVector d = m.diag (k);
@@ -607,18 +607,18 @@ make_diag (const octave_value& a, const 
 	}
     }
   else if (a.is_complex_type ())
     {
       ComplexMatrix cm = a.complex_matrix_value ();
 
       if (! error_state)
 	{
-	  int nr = cm.rows ();
-	  int nc = cm.columns ();
+	  octave_idx_type nr = cm.rows ();
+	  octave_idx_type nc = cm.columns ();
 
 	  if (nr == 1 || nc == 1)
 	    retval = make_diag (cm, k);
 	  else if (nr == 0 || nc == 0)
 	    retval = Matrix ();
 	  else
 	    {
 	      ComplexColumnVector d = cm.diag (k);
@@ -683,17 +683,17 @@ static octave_value
 do_cat (const octave_value_list& args, std::string fname)
 {
   octave_value retval;
 
   int n_args = args.length (); 
 
   if (n_args > 2)
     {
-      int dim = args(0).int_value () - 1;
+      octave_idx_type dim = args(0).int_value () - 1;
 
       if (error_state)
 	{
 	  error ("cat: expecting first argument to be a integer");
 	  return retval;
 	}
   
       if (dim >= 0)
@@ -1052,17 +1052,17 @@ returns the number of columns in the giv
 	  for (int i = 0; i < ndims; i++)
 	    m(0, i) = dimensions(i);
 
 	  retval(0) = m;
 	}
     }
   else if (nargin == 2 && nargout < 2)
     {
-      int nd = args(1).int_value (true);
+      octave_idx_type nd = args(1).int_value (true);
 
       if (error_state)
 	error ("size: expecting scalar as second argument");
       else
 	{
 	  dim_vector dv = args(0).dims ();
 
 	  if (nd > 0)
@@ -1577,27 +1577,27 @@ is equivalent to calling it with an argu
   switch (nargin)
     {
     case 0:
       retval = identity_matrix (1, 1, dt);
       break;
 
     case 1:
       {
-	int nr, nc;
+	octave_idx_type nr, nc;
 	get_dimensions (args(0), "eye", nr, nc);
 
 	if (! error_state)
 	  retval = identity_matrix (nr, nc, dt);
       }
       break;
 
     case 2:
       {
-	int nr, nc;
+	octave_idx_type nr, nc;
 	get_dimensions (args(0), args(1), "eye", nr, nc);
 
 	if (! error_state)
 	  retval = identity_matrix (nr, nc, dt);
       }
       break;
 
     default:
@@ -1786,17 +1786,17 @@ by an empty argument.\n\
       error ("reshape: expecting size to be vector with at least 2 elements");
       return retval;
     }
 
   dim_vector new_dims;
 
   new_dims.resize (n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     new_dims(i) = new_size(i);
 
   octave_value arg = args(0);
 
   if (new_dims.numel () == arg.numel ())
     retval = (new_dims == arg.dims ()) ? arg : arg.reshape (new_dims);
   else
     error ("reshape: size mismatch");
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -108,26 +108,26 @@ maybe_add_or_del_packages (const string_
     return;
 
   unwind_protect::begin_frame ("maybe_add_or_del_packages");
 
   unwind_protect_bool (input_from_startup_file);
 
   input_from_startup_file = true;
 
-  int a_len = a.length ();
-  int b_len = b.length ();
+  octave_idx_type a_len = a.length ();
+  octave_idx_type b_len = b.length ();
 
-  for (int i = 0; i < a_len; i++)
+  for (octave_idx_type i = 0; i < a_len; i++)
     {
       std::string a_dir = a[i];
 
       bool found = false;
 
-      for (int j = 0; j < b_len; j++)
+      for (octave_idx_type j = 0; j < b_len; j++)
 	{
 	  if (b[j] == a_dir)
 	    {
 	      found = true;
 	      break;
 	    }
 	}
 
@@ -178,17 +178,17 @@ subst_octave_home (const std::string& s)
   std::string retval;
 
   std::string prefix = OCTAVE_PREFIX;
 
   retval = s;
 
   if (Voctave_home != prefix)
     {
-      int len = prefix.length ();
+      octave_idx_type len = prefix.length ();
       size_t start = 0;
       while ((start = retval.find (prefix, start)) != NPOS)
 	{
 	  retval.replace (start, len, Voctave_home);
 	  start += len;
 	}
     }
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -609,21 +609,21 @@ fnmatch (\"a*b\", [\"ab\"; \"axyzb\"; \"
       if (error_state)
 	gripe_wrong_type_arg ("fnmatch", args(0));
       else
 	{
 	  glob_match pattern (file_ops::tilde_expand (pat));
 
 	  Array<bool> tmp = pattern.match (str);
 
-	  int n = tmp.length ();
+	  octave_idx_type n = tmp.length ();
 
 	  ColumnVector result (n);
 
-	  for (int i = 0; i < n; i++)
+	  for (octave_idx_type i = 0; i < n; i++)
 	    result(i) = tmp(i);
 
 	  retval = result;
 	}
     }
   else
     print_usage ("fnmatch");
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1033,17 +1033,17 @@ conversions is returned in @var{count}\n
 	  octave_stream os = octave_stream_list::lookup (args(0), who);
 
 	  if (! error_state)
 	    {
 	      if (args(1).is_string ())
 		{
 		  std::string fmt = args(1).string_value ();
 
-		  int count = 0;
+		  octave_idx_type count = 0;
 
 		  Array<double> size = (nargin == 3)
 		    ? args(2).vector_value ()
 		    : Array<double> (1, lo_ieee_inf_value ());
 
 		  if (! error_state)
 		    {
 		      octave_value tmp = os.scanf (fmt, size, count, who);
@@ -1121,17 +1121,17 @@ string is treated as an end-of-file cond
 	      octave_stream os = octave_istrstream::create (data);
 
 	      if (os.is_valid ())
 		{
 		  if (args(1).is_string ())
 		    {
 		      std::string fmt = args(1).string_value ();
 
-		      int count = 0;
+		      octave_idx_type count = 0;
 
 		      Array<double> size = (nargin == 3)
 			? args(2).vector_value ()
 			: Array<double> (1, lo_ieee_inf_value ());
 
 		      octave_value tmp = os.scanf (fmt, size, count, who);
 
 		      // XXX FIXME XXX -- is this the right thing to do?
@@ -1181,17 +1181,17 @@ programs.\n\
     tmp_args (i+1) = args (i);
 
   return Ffscanf (tmp_args, nargout);
 }
 
 static octave_value
 do_fread (octave_stream& os, const octave_value& size_arg,
 	  const octave_value& prec_arg, const octave_value& skip_arg,
-	  const octave_value& arch_arg, int& count)
+	  const octave_value& arch_arg, octave_idx_type& count)
 {
   octave_value retval;
 
   count = -1;
 
   Array<double> size = size_arg.vector_value ();
 
   if (! error_state)
@@ -1443,17 +1443,17 @@ values read is returned in @code{count}\
 	    prec = args(idx++);
 
 	  if (nargin > idx)
 	    skip = args(idx++);
 
 	  if (nargin > idx)
 	    arch = args(idx++);
 
-	  int count = -1;
+	  octave_idx_type count = -1;
 
 	  octave_value tmp = do_fread (os, size, prec, skip, arch, count);
 
 	  retval(1) = count;
 	  retval(0) = tmp;
 	}
     }
   else
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -48,17 +48,17 @@ gripe_range_invalid (void)
 
 void
 gripe_nonconformant (void)
 {
   error ("nonconformant matrices");
 }
 
 void
-gripe_nonconformant (int r1, int c1, int r2, int c2)
+gripe_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
   error ("nonconformant matrices (op1 is %dx%d, op2 is %dx%d)",
 	 r1, c1, r2, c2);
 }
 
 void
 gripe_empty_arg (const char *name, bool is_error)
 {
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -20,32 +20,34 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_gripes_h)
 #define octave_gripes_h 1
 
 #include <string>
 
+#include "oct-types.h"
+
 class octave_value;
 
 extern void
 gripe_not_supported (const char *);
 
 extern void
 gripe_string_invalid (void);
 
 extern void
 gripe_range_invalid (void);
 
 extern void
 gripe_nonconformant (void);
 
 extern void
-gripe_nonconformant (int r1, int c1, int r2, int c2);
+gripe_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
 
 extern void
 gripe_empty_arg (const char *name, bool is_error);
 
 extern void
 gripe_square_matrix_required (const char *name);
 
 extern void
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -103,17 +103,17 @@ get_mat_data_input_line (std::istream& i
 	}
     }
   while (! (have_data || is.eof ()));
 
   return retval;
 }
 
 static void
-get_lines_and_columns (std::istream& is, const std::string& filename, int& nr, int& nc)
+get_lines_and_columns (std::istream& is, const std::string& filename, octave_idx_type& nr, octave_idx_type& nc)
 {
   std::streampos pos = is.tellg ();
 
   int file_line_number = 0;
 
   nr = 0;
   nc = 0;
 
@@ -133,17 +133,17 @@ get_lines_and_columns (std::istream& is,
 
       if (beg != NPOS && buf[beg] == '\r' && beg == buf.length () - 1)
 	{
 	  // We had a blank line ending with a CRLF.  Handle it the
 	  // same as an empty line.
 	  beg = NPOS;
 	}
 
-      int tmp_nc = 0;
+      octave_idx_type tmp_nc = 0;
 
       while (beg != NPOS)
 	{
 	  tmp_nc++;
 
 	  size_t end = buf.find_first_of (", \t", beg);
 
 	  if (end != NPOS)
@@ -223,45 +223,45 @@ read_mat_ascii_data (std::istream& is, c
 	varname[i] = '_';
     }
 
   if (is_keyword (varname) || ! isalpha (varname[0]))
     varname.insert (0, "X");
 
   if (valid_identifier (varname))
     {
-      int nr = 0;
-      int nc = 0;
+      octave_idx_type nr = 0;
+      octave_idx_type nc = 0;
 
       int total_count = 0;
 
       get_lines_and_columns (is, filename, nr, nc);
 
       OCTAVE_QUIT;
 
       if (! error_state && nr > 0 && nc > 0)
 	{
 	  Matrix tmp (nr, nc);
 
 	  if (nr < 1 || nc < 1)
 	    is.clear (std::ios::badbit);
 	  else
 	    {
 	      double d;
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  std::string buf = get_mat_data_input_line (is);
 
 #ifdef HAVE_SSTREAM
 		  std::istringstream tmp_stream (buf);
 #else
 		  std::istrstream tmp_stream (buf.c_str ());
 #endif
 
-		  for (int j = 0; j < nc; j++)
+		  for (octave_idx_type j = 0; j < nc; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      d = octave_read_double (tmp_stream);
 
 		      if (tmp_stream || tmp_stream.eof ())
 			{
 			  tmp.elem (i, j) = d;
@@ -300,17 +300,17 @@ read_mat_ascii_data (std::istream& is, c
 
 	  if (is || is.eof ())
 	    {
 	      // XXX FIXME XXX -- not sure this is best, but it works.
 
 	      if (is.eof ())
 		is.clear ();
 
-	      int expected = nr * nc;
+	      octave_idx_type expected = nr * nc;
 
 	      if (expected == total_count)
 		{
 		  tc = tmp;
 		  retval = varname;
 		}
 	      else
 		error ("load: expected %d elements, found %d",
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -327,17 +327,17 @@ read_mat_binary_data (std::istream& is, 
     retval = name;
 
     dlen = nr * nc;
     if (dlen < 0)
       goto data_read_error;
 
     if (order)
       {
-	int tmp = nr;
+	octave_idx_type tmp = nr;
 	nr = nc;
 	nc = tmp;
       }
 
       re.resize (nr, nc);
 
       read_mat_binary_data (is, re.fortran_vec (), prec, dlen, swap, flt_fmt);
 
@@ -357,18 +357,18 @@ read_mat_binary_data (std::istream& is, 
 	  if (! is || error_state)
 	    {
 	      error ("load: reading imaginary matrix data for `%s'", name);
 	      goto data_read_error;
 	    }
 
 	  ComplexMatrix ctmp (nr, nc);
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = 0; i < nr; i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = 0; i < nr; i++)
 	      ctmp (i, j) = Complex (re (i, j), im (i, j));
 
 	  tc = order ? ctmp.transpose () : ctmp;
 	}
       else
 	tc = order ? re.transpose () : re;
 
       if (type == 1)
@@ -401,17 +401,17 @@ save_mat_binary_data (std::ostream& os, 
   os.write (X_CAST (char *, &mopt), 4);
   
   FOUR_BYTE_INT nr = tc.rows ();
   os.write (X_CAST (char *, &nr), 4);
 
   FOUR_BYTE_INT nc = tc.columns ();
   os.write (X_CAST (char *, &nc), 4);
 
-  int len = nr * nc;
+  octave_idx_type len = nr * nc;
 
   FOUR_BYTE_INT imag = tc.is_complex_type () ? 1 : 0;
   os.write (X_CAST (char *, &imag), 4);
 
   // LEN includes the terminating character, and the file is also
   // supposed to include it.
 
   FOUR_BYTE_INT name_len = name.length () + 1;
@@ -420,40 +420,40 @@ save_mat_binary_data (std::ostream& os, 
   os << name << '\0';
 
   if (tc.is_string ())
     {
       unwind_protect::begin_frame ("save_mat_binary_data");
 
       charMatrix chm = tc.char_matrix_value ();
 
-      int nrow = chm.rows ();
-      int ncol = chm.cols ();
+      octave_idx_type nrow = chm.rows ();
+      octave_idx_type ncol = chm.cols ();
 	
       OCTAVE_LOCAL_BUFFER (double, buf, ncol*nrow);
 	
-      for (int i = 0; i < nrow; i++)
+      for (octave_idx_type i = 0; i < nrow; i++)
       	{
 	  std::string tstr = chm.row_as_string (i);
 	  const char *s = tstr.data ();
 	  
-	  for (int j = 0; j < ncol; j++)
+	  for (octave_idx_type j = 0; j < ncol; j++)
 	    buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
        	}
       os.write ((char *)buf, nrow*ncol*sizeof(double));
       
       unwind_protect::run_frame ("save_mat_binary_data");
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
-      int nel = r.nelem ();
-      for (int i = 0; i < nel; i++)
+      octave_idx_type nel = r.nelem ();
+      for (octave_idx_type i = 0; i < nel; i++)
 	{
 	  double x = base + i * inc;
 	  os.write (X_CAST (char *, &x), 8);
 	}
     }
   else if (tc.is_real_scalar ())
     {
       double tmp = tc.double_value ();
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -581,25 +581,29 @@ read_mat5_binary_element (std::istream& 
 	NDArray re;
 	int *ridx;
 	int *cidx;
 	double *data;
 
 	// Setup return value
 	if (imag)
 	  {
-	    scm = SparseComplexMatrix (nr, nc, nnz);
+	    scm = SparseComplexMatrix (static_cast<octave_idx_type> (nr),
+				       static_cast<octave_idx_type> (nc),
+				       static_cast<octave_idx_type> (nnz));
 	    ridx = scm.ridx ();
 	    cidx = scm.cidx ();
 	    re = NDArray (dim_vector (static_cast<int> (nnz)));
 	    data = re.fortran_vec ();
 	  }
 	else
 	  {
-	    sm = SparseMatrix (nr, nc, nnz);
+	    sm = SparseMatrix (static_cast<octave_idx_type> (nr),
+			       static_cast<octave_idx_type> (nc),
+			       static_cast<octave_idx_type> (nnz));
 	    ridx = sm.ridx ();
 	    cidx = sm.cidx ();
 	    data = sm.data ();
 	  }
 
 	// row indices
 	std::streampos tmp_pos;
 	  
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -69,25 +69,25 @@ Software Foundation, 59 Temple Place - S
 // The number of decimal digits to use when writing ascii data.
 static int Vsave_precision;
 
 // Functions for reading ascii data.
 
 static Matrix
 strip_infnan (const Matrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   Matrix retval (nr, nc);
 
-  int k = 0;
-  for (int i = 0; i < nr; i++)
+  octave_idx_type k = 0;
+  for (octave_idx_type i = 0; i < nr; i++)
     {
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  double d = m (i, j);
 	  if (xisnan (d))
 	    goto next_row;
 	  else
 	    retval (k, j) = xisinf (d) ? (d > 0 ? OCT_RBV : -OCT_RBV) : d;
 	}
       k++;
@@ -173,137 +173,16 @@ extract_keyword (std::istream& is, const
 	      break;
 	    }
 	}
     }
 
   return retval;
 }
 
-// Match KEYWORD on stream IS, placing the associated value in VALUE,
-// returning TRUE if successful and FALSE otherwise.
-//
-// Input should look something like:
-//
-//  [%#][ \t]*keyword[ \t]*int-value.*\n
-
-bool
-extract_keyword (std::istream& is, const char *keyword, int& value, 
-		 const bool next_only)
-{
-  bool status = false;
-  value = 0;
-
-  char c;
-  while (is.get (c))
-    {
-      if (c == '%' || c == '#')
-	{
-	  OSSTREAM buf;
-
-	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
-	    ; // Skip whitespace and comment characters.
-
-	  if (isalpha (c))
-	    buf << c;
-
-	  while (is.get (c) && isalpha (c))
-	    buf << c;
-
-	  buf << OSSTREAM_ENDS;
-	  const char *tmp = OSSTREAM_C_STR (buf);
-	  int match = (strncmp (tmp, keyword, strlen (keyword)) == 0);
-	  OSSTREAM_FREEZE (buf);
-
-	  if (match)
-	    {
-	      while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
-		; // Skip whitespace and the colon.
-
-	      is.putback (c);
-	      if (c != '\n')
-		is >> value;
-	      if (is)
-		status = true;
-	      while (is.get (c) && c != '\n')
-		; // Skip to beginning of next line;
-	      break;
-	    }
-	  else if (next_only)
-	    break;
-	}
-    }
-  return status;
-}
-
-// Match one of the elements in KEYWORDS on stream IS, placing the
-// matched keyword in KW and the associated value in VALUE,
-// returning TRUE if successful and FALSE otherwise.
-//
-// Input should look something like:
-//
-//  [%#][ \t]*keyword[ \t]*int-value.*\n
-
-bool
-extract_keyword (std::istream& is, const string_vector& keywords,
-		 std::string& kw, int& value, const bool next_only)
-{
-  bool status = false;
-  kw = "";
-  value = 0;
-
-  char c;
-  while (is.get (c))
-    {
-      if (c == '%' || c == '#')
-	{
-	  OSSTREAM buf;
-
-	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
-	    ; // Skip whitespace and comment characters.
-
-	  if (isalpha (c))
-	    buf << c;
-
-	  while (is.get (c) && isalpha (c))
-	    buf << c;
-
-	  buf << OSSTREAM_ENDS;
-	  std::string tmp = OSSTREAM_STR (buf);
-	  OSSTREAM_FREEZE (buf);
-
-	  for (int i = 0; i < keywords.length (); i++)
-	    {
-	      int match = (tmp == keywords[i]);
-
-	      if (match)
-		{
-		  kw = keywords[i];
-
-		  while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
-		    ; // Skip whitespace and the colon.
-
-		  is.putback (c);
-		  if (c != '\n')
-		    is >> value;
-		  if (is)
-		    status = true;
-		  while (is.get (c) && c != '\n')
-		    ; // Skip to beginning of next line;
-		  return status;
-		}
-	    }
-
-	  if (next_only)
-	    break;
-	}
-    }
-  return status;
-}
-
 // Extract one value (scalar, matrix, string, etc.) from stream IS and
 // place it in TC, returning the name of the variable.  If the value
 // is tagged as global in the file, return TRUE in GLOBAL.
 //
 // Each type supplies its own function to load the data, and so this
 // function is extensible.
 //
 // FILENAME is used for error messages.
@@ -518,50 +397,50 @@ save_ascii_data_for_plotting (std::ostre
 // making a 3-dimensional plot with gnuplot.  If PARAMETRIC is
 // TRUE, assume a parametric 3-dimensional plot will be generated.
 
 bool
 save_three_d (std::ostream& os, const octave_value& tc, bool parametric)
 {
   bool fail = false;
 
-  int nr = tc.rows ();
-  int nc = tc.columns ();
+  octave_idx_type nr = tc.rows ();
+  octave_idx_type nc = tc.columns ();
 
   if (tc.is_real_matrix ())
     {
       os << "# 3D data...\n"
 	 << "# type: matrix\n"
 	 << "# total rows: " << nr << "\n"
 	 << "# total columns: " << nc << "\n";
 
       if (parametric)
 	{
-	  int extras = nc % 3;
+	  octave_idx_type extras = nc % 3;
 	  if (extras)
 	    warning ("ignoring last %d columns", extras);
 
 	  Matrix tmp = tc.matrix_value ();
 	  tmp = strip_infnan (tmp);
 	  nr = tmp.rows ();
 
-	  for (int i = 0; i < nc-extras; i += 3)
+	  for (octave_idx_type i = 0; i < nc-extras; i += 3)
 	    {
 	      os << tmp.extract (0, i, nr-1, i+2);
 	      if (i+3 < nc-extras)
 		os << "\n";
 	    }
 	}
       else
 	{
 	  Matrix tmp = tc.matrix_value ();
 	  tmp = strip_infnan (tmp);
 	  nr = tmp.rows ();
 
-	  for (int i = 0; i < nc; i++)
+	  for (octave_idx_type i = 0; i < nc; i++)
 	    {
 	      os << tmp.extract (0, i, nr-1, i);
 	      if (i+1 < nc)
 		os << "\n";
 	    }
 	}
     }
   else
diff --git a/src/ls-oct-ascii.h b/src/ls-oct-ascii.h
--- a/src/ls-oct-ascii.h
+++ b/src/ls-oct-ascii.h
@@ -22,54 +22,169 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_ls_oct_ascii_h)
 #define octave_ls_oct_ascii_h 1
 
 #include <cfloat>
 
 #include <string>
 
+#include "lo-sstream.h"
 #include "str-vec.h"
 
 // Flag for cell elements
 #define CELL_ELT_TAG "<cell-element>"
 
 // Used when converting Inf to something that gnuplot can read.
 
 #ifndef OCT_RBV
 #define OCT_RBV DBL_MAX / 100.0
 #endif
 
 extern std::string
 extract_keyword (std::istream& is, const char *keyword, 
 		 const bool next_only = false);
 
-extern  bool
-extract_keyword (std::istream& is, const char *keyword, int& value,
-		 const bool next_only = false);
-
-extern  bool
-extract_keyword (std::istream& is, const string_vector& keywords,
-		 std::string& keyword, int& value,
-		 const bool next_only = false);
-
 extern std::string
 read_ascii_data (std::istream& is, const std::string& filename, bool& global,
 		 octave_value& tc, int count);
 
 extern bool
 save_ascii_data (std::ostream& os, const octave_value& val_arg,
 		 const std::string& name, bool& infnan_warned,
 		 bool strip_nan_and_inf, bool mark_as_global,
 		 int precision);
 
 extern bool
 save_ascii_data_for_plotting (std::ostream& os, const octave_value& t,
 			      const std::string& name);
 
+// Match KEYWORD on stream IS, placing the associated value in VALUE,
+// returning TRUE if successful and FALSE otherwise.
+//
+// Input should look something like:
+//
+//  [%#][ \t]*keyword[ \t]*int-value.*\n
+
+template <class T>
+bool
+extract_keyword (std::istream& is, const char *keyword, T& value, 
+		 const bool next_only = false)
+{
+  bool status = false;
+  value = 0;
+
+  char c;
+  while (is.get (c))
+    {
+      if (c == '%' || c == '#')
+	{
+	  OSSTREAM buf;
+
+	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
+	    ; // Skip whitespace and comment characters.
+
+	  if (isalpha (c))
+	    buf << c;
+
+	  while (is.get (c) && isalpha (c))
+	    buf << c;
+
+	  buf << OSSTREAM_ENDS;
+	  const char *tmp = OSSTREAM_C_STR (buf);
+	  int match = (strncmp (tmp, keyword, strlen (keyword)) == 0);
+	  OSSTREAM_FREEZE (buf);
+
+	  if (match)
+	    {
+	      while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
+		; // Skip whitespace and the colon.
+
+	      is.putback (c);
+	      if (c != '\n')
+		is >> value;
+	      if (is)
+		status = true;
+	      while (is.get (c) && c != '\n')
+		; // Skip to beginning of next line;
+	      break;
+	    }
+	  else if (next_only)
+	    break;
+	}
+    }
+  return status;
+}
+
+// Match one of the elements in KEYWORDS on stream IS, placing the
+// matched keyword in KW and the associated value in VALUE,
+// returning TRUE if successful and FALSE otherwise.
+//
+// Input should look something like:
+//
+//  [%#][ \t]*keyword[ \t]*int-value.*\n
+
+template <class T>
+bool
+extract_keyword (std::istream& is, const string_vector& keywords,
+		 std::string& kw, T& value, const bool next_only = false)
+{
+  bool status = false;
+  kw = "";
+  value = 0;
+
+  char c;
+  while (is.get (c))
+    {
+      if (c == '%' || c == '#')
+	{
+	  OSSTREAM buf;
+
+	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
+	    ; // Skip whitespace and comment characters.
+
+	  if (isalpha (c))
+	    buf << c;
+
+	  while (is.get (c) && isalpha (c))
+	    buf << c;
+
+	  buf << OSSTREAM_ENDS;
+	  std::string tmp = OSSTREAM_STR (buf);
+	  OSSTREAM_FREEZE (buf);
+
+	  for (int i = 0; i < keywords.length (); i++)
+	    {
+	      int match = (tmp == keywords[i]);
+
+	      if (match)
+		{
+		  kw = keywords[i];
+
+		  while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
+		    ; // Skip whitespace and the colon.
+
+		  is.putback (c);
+		  if (c != '\n')
+		    is >> value;
+		  if (is)
+		    status = true;
+		  while (is.get (c) && c != '\n')
+		    ; // Skip to beginning of next line;
+		  return status;
+		}
+	    }
+
+	  if (next_only)
+	    break;
+	}
+    }
+  return status;
+}
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
 
diff --git a/src/oct-conf.h.in b/src/oct-conf.h.in
--- a/src/oct-conf.h.in
+++ b/src/oct-conf.h.in
@@ -279,16 +279,20 @@ Software Foundation, 59 Temple Place - S
 #ifndef OCTAVE_CONF_STATIC_LIBS
 #define OCTAVE_CONF_STATIC_LIBS %OCTAVE_CONF_STATIC_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_UGLY_DEFS
 #define OCTAVE_CONF_UGLY_DEFS %OCTAVE_CONF_UGLY_DEFS%
 #endif
 
+#ifndef OCTAVE_CONF_USE_64_BIT_IDX_T
+#define OCTAVE_CONF_USE_64_BIT_IDX_T %OCTAVE_CONF_USE_64_BIT_IDX_T%
+#endif
+
 #ifndef OCTAVE_CONF_ENABLE_DYNAMIC_LINKING
 #define OCTAVE_CONF_ENABLE_DYNAMIC_LINKING %OCTAVE_CONF_ENABLE_DYNAMIC_LINKING%
 #endif
 
 #ifndef OCTAVE_CONF_XTRA_CFLAGS
 #define OCTAVE_CONF_XTRA_CFLAGS %OCTAVE_CONF_XTRA_CFLAGS%
 #endif
 
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -63,21 +63,21 @@ Octave_map::stringfield (const std::stri
     retval = c(0).string_value ();
 
   return retval;
 }
 
 string_vector
 Octave_map::keys (void) const
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   string_vector names (len);
 
-  int i = 0;
+  octave_idx_type i = 0;
   for (const_iterator p = begin (); p != end (); p++)
     names[i++] = key (p);
 
   return names;
 }
 
 Octave_map
 Octave_map::reshape (const dim_vector& new_dims) const
@@ -92,20 +92,20 @@ Octave_map::reshape (const dim_vector& n
       retval.dimensions = new_dims;
     }
   else
     retval = *this;
 
   return retval;
 }
 
-int
+octave_idx_type
 Octave_map::numel (void) const
 {
-  int retval;
+  octave_idx_type retval;
 
   if (empty ())
     retval = 0;
   else
     {
       Cell tmp = contents (begin ());
       retval = tmp.numel ();
     }
@@ -132,17 +132,17 @@ Octave_map::resize (const dim_vector& dv
   else
     retval = *this;
 
 
   return retval;
 }
 
 Octave_map
-Octave_map::concat (const Octave_map& rb, const Array<int>& ra_idx)
+Octave_map::concat (const Octave_map& rb, const Array<octave_idx_type>& ra_idx)
 {
   Octave_map retval;
 
   if (length() == rb.length())
     {
       for (Octave_map::const_iterator pa = begin (); pa != end (); pa++)
 	{
 	  Octave_map::const_iterator pb = rb.seek (key(pa));
@@ -166,22 +166,22 @@ Octave_map::concat (const Octave_map& rb
 static string_vector
 equiv_keys (const Octave_map& a, const Octave_map& b)
 {
   string_vector retval;
 
   string_vector a_keys = a.keys().qsort ();
   string_vector b_keys = b.keys().qsort ();
 
-  int a_len = a_keys.length ();
-  int b_len = b_keys.length ();
+  octave_idx_type a_len = a_keys.length ();
+  octave_idx_type b_len = b_keys.length ();
 
   if (a_len == b_len)
     {
-      for (int i = 0; i < a_len; i++)
+      for (octave_idx_type i = 0; i < a_len; i++)
 	{
 	  if (a_keys[i] != b_keys[i])
 	    return retval;
 	}
 
       retval = a_keys;
     }
   
@@ -190,19 +190,19 @@ equiv_keys (const Octave_map& a, const O
 
 Octave_map&
 Octave_map::assign (const octave_value_list& idx, const Octave_map& rhs)
 {
   string_vector t_keys = empty () ? rhs.keys () : equiv_keys (*this, rhs);
 
   if (! t_keys.empty ())
     {
-      int len = t_keys.length ();
+      octave_idx_type len = t_keys.length ();
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	{
 	  std::string k = t_keys[i];
 
 	  Cell t_rhs = rhs.contents (k);
 
 	  assign (idx, k, t_rhs);
 
 	  if (error_state)
@@ -215,35 +215,35 @@ Octave_map::assign (const octave_value_l
   return *this;
 }
 
 static dim_vector
 common_size (const dim_vector& a, const dim_vector& b)
 {
   dim_vector retval;
 
-  int a_len = a.length ();
-  int b_len = b.length ();
+  octave_idx_type a_len = a.length ();
+  octave_idx_type b_len = b.length ();
 
-  int new_len = std::max (a_len, b_len);
-  int min_len = std::min (a_len, b_len);
+  octave_idx_type new_len = std::max (a_len, b_len);
+  octave_idx_type min_len = std::min (a_len, b_len);
 
   retval.resize (new_len);
 
-  for (int i = 0; i < min_len; i++)
+  for (octave_idx_type i = 0; i < min_len; i++)
     retval(i) = std::max (a(i), b(i));
 
   if (a_len < b_len)
     {
-      for (int i = min_len; i < b_len; i++)
+      for (octave_idx_type i = min_len; i < b_len; i++)
 	retval(i) = b(i);
     }
   else if (a_len > b_len)
     {
-      for (int i = min_len; i < a_len; i++)
+      for (octave_idx_type i = min_len; i < a_len; i++)
 	retval(i) = a(i);
     }
 
   return retval;
 }
 
 Octave_map&
 Octave_map::assign (const octave_value_list& idx, const std::string& k,
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -66,17 +66,17 @@ Octave_map
 	}
 
       return *this;
     }
 
   ~Octave_map (void) { }
 
   // This is the number of keys.
-  int length (void) const { return map.size (); }
+  octave_idx_type length (void) const { return map.size (); }
 
   int empty (void) const { return map.empty (); }
 
   void del (const std::string& k)
     {
       iterator p = map.find (k);
       if (p != map.end ())
 	map.erase (p);
@@ -104,29 +104,29 @@ Octave_map
 
   bool contains (const std::string& k) const
     { return (seek (k) != map.end ()); }
 
   void clear (void) { map.clear (); }
 
   string_vector keys (void) const;
 
-  int rows (void) const { return dimensions(0); }
+  octave_idx_type rows (void) const { return dimensions(0); }
 
-  int columns (void) const { return dimensions(1); }
+  octave_idx_type columns (void) const { return dimensions(1); }
 
   dim_vector dims (void) const { return dimensions; }
 
   Octave_map reshape (const dim_vector& new_dims) const;
 
   Octave_map resize (const dim_vector& dv) const;
 
-  int numel (void) const;
+  octave_idx_type numel (void) const;
 
-  Octave_map concat (const Octave_map& rb, const Array<int>& ra_idx);
+  Octave_map concat (const Octave_map& rb, const Array<octave_idx_type>& ra_idx);
 
   Octave_map& assign (const octave_value_list& idx, const Octave_map& rhs);
 
   Octave_map& assign (const octave_value_list& idx, const std::string& k,
 		      const Cell& rhs);
 
   Octave_map& assign (const std::string& k, const octave_value& rhs);
 
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -28,45 +28,45 @@ Software Foundation, 59 Temple Place - S
 #include "oct-obj.h"
 
 octave_allocator
 octave_value_list::allocator (sizeof (octave_value_list));
 
 bool
 octave_value_list::valid_scalar_indices (void) const
 {
-  int n = length ();
+  octave_idx_type n = length ();
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     if (! data[i].valid_as_scalar_index ())
       return false;
 
   return true;
 }
 
 void
-octave_value_list::resize (int n, const octave_value& val)
+octave_value_list::resize (octave_idx_type n, const octave_value& val)
 {
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (n > len)
     {
       data.resize (n);
 
-      for (int i = len; i < n; i++)
+      for (octave_idx_type i = len; i < n; i++)
 	data[i] = val;
     }
   else if (n < len)
     data.resize (n);
 }
 
 octave_value_list&
 octave_value_list::prepend (const octave_value& val)
 {
-  int n = length ();
+  octave_idx_type n = length ();
 
   resize (n + 1);
 
   while (n > 0)
     {
       elem (n) = elem (n - 1);
       n--;
     }
@@ -74,146 +74,146 @@ octave_value_list::prepend (const octave
   elem (0) = val;
   
   return *this;
 }
 
 octave_value_list&
 octave_value_list::append (const octave_value& val)
 {
-  int n = length ();
+  octave_idx_type n = length ();
 
   resize (n + 1);
 
   elem (n) = val;
 
   return *this;
 }
 
 octave_value_list&
 octave_value_list::append (const octave_value_list& lst)
 {
-  int len = length ();
-  int lst_len = lst.length ();
+  octave_idx_type len = length ();
+  octave_idx_type lst_len = lst.length ();
 
   resize (len + lst_len);
 
-  for (int i = 0; i < lst_len; i++)
+  for (octave_idx_type i = 0; i < lst_len; i++)
     elem (len + i) = lst (i);
 
   return *this;
 }
 
 octave_value_list&
 octave_value_list::reverse (void)
 {
-  int n = length ();
+  octave_idx_type n = length ();
 
-  for (int i = 0; i < n / 2; i++)
+  for (octave_idx_type i = 0; i < n / 2; i++)
     {
       octave_value tmp = elem (i);
       elem (i) = elem (n - i - 1);
       elem (n - i - 1) = tmp;
     }
 
   return *this;
 }
 
 octave_value_list
-octave_value_list::splice (int offset, int rep_length,
+octave_value_list::splice (octave_idx_type offset, octave_idx_type rep_length,
 			   const octave_value_list& lst) const
 { 
   octave_value_list retval;
 
-  int len = length ();
+  octave_idx_type len = length ();
 
   if (offset < 0 || offset >= len)
     {
       if (! (rep_length == 0 && offset == len))
 	{
 	  error ("octave_value_list::splice: invalid OFFSET");
 	  return retval;
 	}
     }
 
   if (rep_length < 0 || rep_length + offset > len)
     {
       error ("octave_value_list::splice: invalid LENGTH");
       return retval;
     }
 
-  int lst_len = lst.length ();
+  octave_idx_type lst_len = lst.length ();
 
-  int new_len = len - rep_length + lst_len;
+  octave_idx_type new_len = len - rep_length + lst_len;
 
   retval.resize (new_len);
 
-  int k = 0;
+  octave_idx_type k = 0;
 
-  for (int i = 0; i < offset; i++)
+  for (octave_idx_type i = 0; i < offset; i++)
     retval(k++) = elem (i);
 
-  for (int i = 0; i < lst_len; i++)
+  for (octave_idx_type i = 0; i < lst_len; i++)
     retval(k++) = lst(i);
 
-  for (int i = offset + rep_length; i < len; i++)
+  for (octave_idx_type i = offset + rep_length; i < len; i++)
     retval(k++) = elem (i);
 
   return retval;
 }
 
 bool
 octave_value_list::all_strings_p (void) const
 {
-  int n = length ();
+  octave_idx_type n = length ();
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     if (! elem(i).is_string ())
       return 0;
 
   return 1;
 }
 
 string_vector
 octave_value_list::make_argv (const std::string& fcn_name) const
 {
   string_vector argv;
 
   if (all_strings_p ())
     {
-      int len = length ();
+      octave_idx_type len = length ();
 
-      int total_nr = 0;
+      octave_idx_type total_nr = 0;
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	{
 	  // An empty std::string ("") has zero columns and zero rows (a
 	  // change that was made for Matlab contemptibility.
 
-	  int n = elem(i).rows ();
+	  octave_idx_type n = elem(i).rows ();
 
 	  total_nr += n ? n : 1;
 	}
 
       argv.resize (total_nr+1);
 
       argv[0] = fcn_name;
 
-      int k = 1;
-      for (int i = 0; i < len; i++)
+      octave_idx_type k = 1;
+      for (octave_idx_type i = 0; i < len; i++)
 	{
-	  int nr = elem(i).rows ();
+	  octave_idx_type nr = elem(i).rows ();
 
 	  if (nr < 2)
 	    argv[k++] = elem(i).string_value ();
 	  else
 	    {
 	      string_vector tmp = elem(i).all_strings ();
 
-	      for (int j = 0; j < nr; j++)
+	      for (octave_idx_type j = 0; j < nr; j++)
 		argv[k++] = tmp[j];
 	    }
 	}
     }
   else
     error ("%s: expecting all arguments to be strings", fcn_name.c_str ());
 
   return argv;
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -34,17 +34,17 @@ Software Foundation, 59 Temple Place - S
 class
 octave_value_list
 {
 public:
 
   octave_value_list (void)
     : data () { }
 
-  octave_value_list (int n, const octave_value& val)
+  octave_value_list (octave_idx_type n, const octave_value& val)
     : data (n, val) { }
 
   octave_value_list (const octave_value& tc)
     : data (1, tc) { }
 
   octave_value_list (const octave_value_list& obj)
     : data (obj.data), names (obj.names) { }
 
@@ -80,37 +80,37 @@ public:
 
       return *this;
     }
 
   bool valid_scalar_indices (void) const;
 
   // Assignment will resize on range errors.
 
-  octave_value& operator () (int n) { return elem (n); }
+  octave_value& operator () (octave_idx_type n) { return elem (n); }
 
-  octave_value operator () (int n) const { return elem (n); }
+  octave_value operator () (octave_idx_type n) const { return elem (n); }
 
-  int length (void) const { return data.size (); }
+  octave_idx_type length (void) const { return data.size (); }
 
   bool empty (void) const { return length () == 0; }
 
-  void resize (int n) { data.resize (n); }
+  void resize (octave_idx_type n) { data.resize (n); }
 
-  void resize (int n, const octave_value& val);
+  void resize (octave_idx_type n, const octave_value& val);
 
   octave_value_list& prepend (const octave_value& val);
 
   octave_value_list& append (const octave_value& val);
 
   octave_value_list& append (const octave_value_list& lst);
 
   octave_value_list& reverse (void);
 
-  octave_value_list splice (int offset, int length,
+  octave_value_list splice (octave_idx_type offset, octave_idx_type length,
 			    const octave_value_list& lst) const;
 
   bool all_strings_p (void) const;
 
   string_vector make_argv (const std::string&) const;
 
   void stash_name_tags (const string_vector& nm) { names = nm; }
 
@@ -135,31 +135,31 @@ private:
   // from doing different things.  Instead, you have to use the
   // constructor
   //
   //   octave_value_list (n, val);
   //
   // and supply a default value to create a vector-valued
   // octave_value_list.
 
-  octave_value_list (int n);
+  octave_value_list (octave_idx_type n);
 
   octave_value_list (const Array<octave_value>& d);
 
-  octave_value& elem (int n)
+  octave_value& elem (octave_idx_type n)
     {
       static Matrix empty_matrix;
 
       if (n >= length ())
 	resize (n+1, empty_matrix);
 
       return data[n];
     }
 
-  octave_value elem (int n) const
+  octave_value elem (octave_idx_type n) const
     {
 #if defined (BOUNDS_CHECKING)
       return data.at (n);
 #else
       return data[n];
 #endif
     }
 };
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -107,28 +107,28 @@ get_size (double d, const std::string& w
     }
   else
     ::error ("%s: NaN is invalid as size specification", who.c_str ());
 
   return retval;
 }
 
 static void
-get_size (const Array<double>& size, int& nr, int& nc, bool& one_elt_size_spec,
+get_size (const Array<double>& size, octave_idx_type& nr, octave_idx_type& nc, bool& one_elt_size_spec,
 	  const std::string& who)
 {
   nr = -1;
   nc = -1;
 
   one_elt_size_spec = false;
 
   double dnr = -1.0;
   double dnc = -1.0;
 
-  int sz_len = size.length ();
+  octave_idx_type sz_len = size.length ();
 
   if (sz_len == 1)
     {
       one_elt_size_spec = true;
 
       dnr = size (0);
 
       dnc = (dnr == 0.0) ? 0.0 : 1.0;
@@ -229,19 +229,19 @@ scanf_format_list::scanf_format_list (co
 
   list.resize (num_elts);
 
   delete buf;
 }
 
 scanf_format_list::~scanf_format_list (void)
 {
-  int n = list.length ();
-
-  for (int i = 0; i < n; i++)
+  octave_idx_type n = list.length ();
+
+  for (octave_idx_type i = 0; i < n; i++)
     {
       scanf_format_elt *elt = list(i);
       delete elt;
     }	
 }
 
 void
 scanf_format_list::add_elt_to_list (int width, bool discard, char type,
@@ -958,17 +958,17 @@ octave_base_stream::clearerr (void)
   if (os)
     os->clear ();
 }
 
 // Functions that are defined for all input streams (input streams
 // are those that define is).
 
 std::string
-octave_base_stream::do_gets (int max_len, bool& err,
+octave_base_stream::do_gets (octave_idx_type max_len, bool& err,
 			     bool strip_newline, const std::string& who)
 {
   std::string retval;
 
   err = false;
 
   std::istream *isp = input_stream ();
 
@@ -1023,23 +1023,23 @@ octave_base_stream::do_gets (int max_len
       err = true;
       invalid_operation (who, "reading");
     }
 
   return retval;
 }
 
 std::string
-octave_base_stream::getl (int max_len, bool& err, const std::string& who)
+octave_base_stream::getl (octave_idx_type max_len, bool& err, const std::string& who)
 {
   return do_gets (max_len, err, true, who);
 }
 
 std::string
-octave_base_stream::gets (int max_len, bool& err, const std::string& who)
+octave_base_stream::gets (octave_idx_type max_len, bool& err, const std::string& who)
 {
   return do_gets (max_len, err, false, who);
 }
 
 #if defined (__GNUG__) && ! defined (CXX_ISO_COMPLIANT_LIBRARY)
 
 #define OCTAVE_SCAN(is, fmt, arg) is.scan ((fmt).text, arg)
 
@@ -1320,18 +1320,18 @@ octave_scan (std::istream& is, const sca
 template std::istream&
 octave_scan (std::istream&, const scanf_format_elt&, double*);
 
 #endif
 
 template <class T>
 void
 do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
-	       T valptr, Matrix& mval, double *data, int& idx,
-	       int& conversion_count, int nr, int max_size,
+	       T valptr, Matrix& mval, double *data, octave_idx_type& idx,
+	       octave_idx_type& conversion_count, octave_idx_type nr, octave_idx_type max_size,
 	       bool discard) 
 {
   OCTAVE_SCAN (is, fmt, valptr);
 
   if (is)
     {
       if (idx == max_size && ! discard)
 	{
@@ -1350,47 +1350,47 @@ do_scanf_conv (std::istream& is, const s
 	  conversion_count++;
 	  data[idx++] = *(valptr);
 	}
     }
 }
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, int*,
-	       Matrix&, double*, int&, int&, int, int, bool);
+	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, long int*,
-	       Matrix&, double*, int&, int&, int, int, bool);
+	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, short int*,
-	       Matrix&, double*, int&, int&, int, int, bool);
+	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned int*,
-	       Matrix&, double*, int&, int&, int, int, bool);
+	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned long int*,
-	       Matrix&, double*, int&, int&, int, int, bool);
+	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned short int*,
-	       Matrix&, double*, int&, int&, int, int, bool);
+	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 #if 0
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, float*,
-	       Matrix&, double*, int&, int&, int, int, bool);
+	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 #endif
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, double*,
-	       Matrix&, double*, int&, int&, int, int, bool);
+	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 #define DO_WHITESPACE_CONVERSION() \
   do \
     { \
       int c = EOF; \
  \
       while (is && (c = is.get ()) != EOF && isspace (c)) \
 	/* skip whitespace */; \
@@ -1590,24 +1590,24 @@ do_scanf_conv (std::istream&, const scan
 		} \
 	    } \
 	} \
     } \
   while (0)
 
 octave_value
 octave_base_stream::do_scanf (scanf_format_list& fmt_list,
-			      int nr, int nc, bool one_elt_size_spec,
-			      int& conversion_count, const std::string& who)
+			      octave_idx_type nr, octave_idx_type nc, bool one_elt_size_spec,
+			      octave_idx_type& conversion_count, const std::string& who)
 {
   conversion_count = 0;
 
   int nconv = fmt_list.num_conversions ();
 
-  int data_index = 0;
+  octave_idx_type data_index = 0;
 
   octave_value retval = Matrix ();
 
   if (nr == 0 || nc == 0)
     {
       if (one_elt_size_spec)
 	nc = 0;
 
@@ -1615,21 +1615,21 @@ octave_base_stream::do_scanf (scanf_form
     }
 
   std::istream *isp = input_stream ();
 
   bool all_char_conv = fmt_list.all_character_conversions ();
 
   Matrix mval;
   double *data = 0;
-  int max_size = 0;
-  int max_conv = 0;
-
-  int final_nr = 0;
-  int final_nc = 0;
+  octave_idx_type max_size = 0;
+  octave_idx_type max_conv = 0;
+
+  octave_idx_type final_nr = 0;
+  octave_idx_type final_nc = 0;
 
   if (all_char_conv)
     {
       // Any of these could be resized later (if we have %s
       // conversions, we may read more than one element for each
       // conversion).
 
       if (one_elt_size_spec)
@@ -1951,34 +1951,34 @@ octave_base_stream::do_scanf (scanf_form
 	retval = retval.convert_to_str ();
     }
 
   return retval;
 }
 
 octave_value
 octave_base_stream::scanf (const std::string& fmt, const Array<double>& size,
-			   int& conversion_count, const std::string& who)
+			   octave_idx_type& conversion_count, const std::string& who)
 {
   octave_value retval = Matrix ();
 
   conversion_count = 0;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       scanf_format_list fmt_list (fmt);
 
       if (fmt_list.num_conversions () == -1)
 	::error ("%s: invalid format specified", who.c_str ());
       else
 	{
-	int nr = -1;
-	int nc = -1;
+	octave_idx_type nr = -1;
+	octave_idx_type nc = -1;
 
 	bool one_elt_size_spec;
 
 	get_size (size, nr, nc, one_elt_size_spec, who);
 
 	if (! error_state)
 	  retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
 			     conversion_count, who);
@@ -2165,17 +2165,17 @@ octave_base_stream::oscanf (const std::s
 	  retval.resize (nconv+1, Matrix ());
 
 	  const scanf_format_elt *elt = fmt_list.first ();
 
 	  int num_values = 0;
 
 	  bool quit = false;
 
-	  for (int i = 0; i < len; i++)
+	  for (octave_idx_type i = 0; i < len; i++)
 	    {
 	      octave_value tmp;
 
 	      quit = do_oscanf (elt, tmp, who);
 
 	      if (quit)
 		break;
 	      else
@@ -2373,25 +2373,25 @@ printf_value_cache::string_value (void)
       if (tval.rows () == 1)
 	retval = tval.string_value ();
       else
 	{
 	  // In the name of Matlab compatibility.
 
 	  charMatrix chm = tval.char_matrix_value ();
 
-	  int nr = chm.rows ();
-	  int nc = chm.columns ();
+	  octave_idx_type nr = chm.rows ();
+	  octave_idx_type nc = chm.columns ();
 
 	  int k = 0;
 
 	  retval.resize (nr * nc, '\0');
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = 0; i < nr; i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = 0; i < nr; i++)
 	      retval[k++] = chm(i,j);
 	}
 
       if (error_state)
 	curr_state = conversion_error;
     }
 
   return retval;
@@ -2766,17 +2766,17 @@ octave_stream::flush (void)
 
   if (stream_ok ("fflush"))
     retval = rep->flush ();
 
   return retval;
 }
 
 std::string
-octave_stream::getl (int max_len, bool& err, const std::string& who)
+octave_stream::getl (octave_idx_type max_len, bool& err, const std::string& who)
 {
   std::string retval;
 
   if (stream_ok (who))
     retval = rep->getl (max_len, err, who);
 
   return retval;
 }
@@ -2800,17 +2800,17 @@ octave_stream::getl (const octave_value&
     }
   else
     retval = getl (max_len, err, who);
 
   return retval;
 }
 
 std::string
-octave_stream::gets (int max_len, bool& err, const std::string& who)
+octave_stream::gets (octave_idx_type max_len, bool& err, const std::string& who)
 {
   std::string retval;
 
   if (stream_ok (who))
     retval = rep->gets (max_len, err, who);
 
   return retval;
 }
@@ -2982,35 +2982,35 @@ void
 octave_stream::close (void)
 {
   if (stream_ok ("close"))
     rep->close ();
 }
 
 template <class RET_T, class READ_T>
 octave_value
-do_read (octave_stream& strm, int nr, int nc, int block_size,
-	 int skip, bool do_float_fmt_conv,
-	 oct_mach_info::float_format from_flt_fmt, int& count)
+do_read (octave_stream& strm, octave_idx_type nr, octave_idx_type nc, octave_idx_type block_size,
+	 octave_idx_type skip, bool do_float_fmt_conv,
+	 oct_mach_info::float_format from_flt_fmt, octave_idx_type& count)
 {
   octave_value retval;
 
   RET_T nda;
 
   count = 0;
 
   typename octave_array_type_traits<RET_T>::element_type elt_zero
     = typename octave_array_type_traits<RET_T>::element_type ();
 
   typename octave_array_type_traits<RET_T>::element_type *dat = 0;
 
-  int max_size = 0;
-
-  int final_nr = 0;
-  int final_nc = 1;
+  octave_idx_type max_size = 0;
+
+  octave_idx_type final_nr = 0;
+  octave_idx_type final_nc = 1;
 
   if (nr > 0)
     {
       if (nc > 0)
 	{
 	  nda.resize (dim_vector (nr, nc), elt_zero);
 	  dat = nda.fortran_vec ();
 	  max_size = nr * nc;
@@ -3047,17 +3047,17 @@ do_read (octave_stream& strm, int nr, in
   } u;
 
   std::istream *isp = strm.input_stream ();
 
   if (isp)
     {
       std::istream& is = *isp;
 
-      int elts_read = 0;
+      octave_idx_type elts_read = 0;
 
       for (;;)
 	{
 	  // XXX FIXME XXX -- maybe there should be a special case for
 	  // skip == 0.
 
 	  if (is)
 	    {
@@ -3145,18 +3145,18 @@ do_read (octave_stream& strm, int nr, in
 
   retval = nda;
 
   return retval;
 }
 
 #define DO_READ_VAL_TEMPLATE(RET_T, READ_T) \
   template octave_value \
-  do_read<RET_T, READ_T> (octave_stream&, int, int, int, int, bool, \
-			  oct_mach_info::float_format, int&)
+  do_read<RET_T, READ_T> (octave_stream&, octave_idx_type, octave_idx_type, octave_idx_type, octave_idx_type, bool, \
+			  oct_mach_info::float_format, octave_idx_type&)
 
 // XXX FIXME XXX -- should we only have float if it is a different
 // size from double?
 
 #define INSTANTIATE_DO_READ(VAL_T) \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_int8); \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_uint8); \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_int16); \
@@ -3178,18 +3178,18 @@ INSTANTIATE_DO_READ (uint16NDArray);
 INSTANTIATE_DO_READ (int32NDArray);
 INSTANTIATE_DO_READ (uint32NDArray);
 INSTANTIATE_DO_READ (int64NDArray);
 INSTANTIATE_DO_READ (uint64NDArray);
 // INSTANTIATE_DO_READ (floatNDArray);
 INSTANTIATE_DO_READ (NDArray);
 INSTANTIATE_DO_READ (charNDArray);
 
-typedef octave_value (*read_fptr) (octave_stream&, int, int, int, int, bool,
-				   oct_mach_info::float_format ffmt, int&);
+typedef octave_value (*read_fptr) (octave_stream&, octave_idx_type, octave_idx_type, octave_idx_type, octave_idx_type, bool,
+				   oct_mach_info::float_format ffmt, octave_idx_type&);
 
 INSTANTIATE_ARRAY (read_fptr);
 template class Array2<read_fptr>;
 
 #define FILL_TABLE_ROW(R, VAL_T) \
   read_fptr_table(R,oct_data_conv::dt_int8) = do_read<VAL_T, octave_int8>; \
   read_fptr_table(R,oct_data_conv::dt_uint8) = do_read<VAL_T, octave_uint8>; \
   read_fptr_table(R,oct_data_conv::dt_int16) = do_read<VAL_T, octave_int16>; \
@@ -3201,21 +3201,21 @@ template class Array2<read_fptr>;
   read_fptr_table(R,oct_data_conv::dt_single) = do_read<VAL_T, float>; \
   read_fptr_table(R,oct_data_conv::dt_double) = do_read<VAL_T, double>; \
   read_fptr_table(R,oct_data_conv::dt_char) = do_read<VAL_T, char>; \
   read_fptr_table(R,oct_data_conv::dt_schar) = do_read<VAL_T, signed char>; \
   read_fptr_table(R,oct_data_conv::dt_uchar) = do_read<VAL_T, unsigned char>; \
   read_fptr_table(R,oct_data_conv::dt_logical) = do_read<VAL_T, unsigned char>
 
 octave_value
-octave_stream::read (const Array<double>& size, int block_size,
+octave_stream::read (const Array<double>& size, octave_idx_type block_size,
 		     oct_data_conv::data_type input_type,
 		     oct_data_conv::data_type output_type,
-		     int skip, oct_mach_info::float_format ffmt,
-		     int& char_count)
+		     octave_idx_type skip, oct_mach_info::float_format ffmt,
+		     octave_idx_type& char_count)
 {
   static bool initialized = false;
 
   // Table function pointers for return types x read types.
 
   static Array2<read_fptr> read_fptr_table (oct_data_conv::dt_unknown, 14, 0);
 
   if (! initialized)
@@ -3244,18 +3244,18 @@ octave_stream::read (const Array<double>
       // XXX FIXME XXX -- we may eventually want to make this extensible.
 
       // XXX FIXME XXX -- we need a better way to ensure that this
       // numbering stays consistent with the order of the elements in the
       // data_type enum in the oct_data_conv class.
 
       char_count = 0;
 
-      int nr = -1;
-      int nc = -1;
+      octave_idx_type nr = -1;
+      octave_idx_type nc = -1;
 
       bool ignore;
 
       get_size (size, nr, nc, ignore, "fread");
 
       if (! error_state)
 	{
 	  if (nr == 0 || nc == 0)
@@ -3290,31 +3290,31 @@ octave_stream::read (const Array<double>
 	}
       else
 	invalid_operation ("fread", "reading");
     }
 
   return retval;
 }
 
-int
-octave_stream::write (const octave_value& data, int block_size,
-		      oct_data_conv::data_type output_type, int skip,
+octave_idx_type
+octave_stream::write (const octave_value& data, octave_idx_type block_size,
+		      oct_data_conv::data_type output_type, octave_idx_type skip,
 		      oct_mach_info::float_format flt_fmt)
 {
-  int retval = -1;
+  octave_idx_type retval = -1;
 
   if (stream_ok ("fwrite"))
     {
       if (! error_state)
 	{
 	  if (flt_fmt == oct_mach_info::flt_fmt_unknown)
 	    flt_fmt = float_format ();
 
-	  int status = data.write (*this, block_size, output_type,
+	  octave_idx_type status = data.write (*this, block_size, output_type,
 				   skip, flt_fmt);
 
 	  if (status < 0)
 	    error ("fwrite: write error");
 	  else
 	    retval = status;
 	}
       else
@@ -3430,30 +3430,30 @@ do_write (std::ostream& os, const T& val
 	("write: invalid type specification");
       break;
     }
 
   return retval;
 }
 
 template <class T>
-int
-octave_stream::write (const Array<T>& data, int block_size,
+octave_idx_type
+octave_stream::write (const Array<T>& data, octave_idx_type block_size,
 		      oct_data_conv::data_type output_type,
-		      int skip, oct_mach_info::float_format flt_fmt)
+		      octave_idx_type skip, oct_mach_info::float_format flt_fmt)
 {
-  int retval = -1;
+  octave_idx_type retval = -1;
 
   bool status = true;
 
-  int count = 0;
+  octave_idx_type count = 0;
 
   const T *d = data.data ();
 
-  int n = data.length ();
+  octave_idx_type n = data.length ();
 
   oct_mach_info::float_format native_flt_fmt
     = oct_mach_info::float_format ();
 
   bool do_float_conversion = (flt_fmt != native_flt_fmt);
 
   // XXX FIXME XXX -- byte order for Cray?
 
@@ -3461,17 +3461,17 @@ octave_stream::write (const Array<T>& da
 
   if (oct_mach_info::words_big_endian ())
     swap = (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
 	    || flt_fmt == oct_mach_info::flt_fmt_vax_g
 	    || flt_fmt == oct_mach_info::flt_fmt_vax_g);
   else
     swap = (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     {
       std::ostream *osp = output_stream ();
 
       if (osp)
 	{
 	  std::ostream& os = *osp;
 
 	  // It seems that Matlab writes zeros instead of actually
@@ -3511,74 +3511,74 @@ octave_stream::write (const Array<T>& da
     }
 
   if (status)
     retval = count;
 
   return retval;
 }
 
-template int
-octave_stream::write (const Array<char>&, int,
+template octave_idx_type
+octave_stream::write (const Array<char>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<bool>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<bool>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<double>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<double>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<octave_int8>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<octave_int8>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<octave_uint8>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<octave_uint8>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<octave_int16>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<octave_int16>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<octave_uint16>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<octave_uint16>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<octave_int32>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<octave_int32>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<octave_uint32>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<octave_uint32>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<octave_int64>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<octave_int64>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
-
-template int
-octave_stream::write (const Array<octave_uint64>&, int,
+		      octave_idx_type, oct_mach_info::float_format);
+
+template octave_idx_type
+octave_stream::write (const Array<octave_uint64>&, octave_idx_type,
 		      oct_data_conv::data_type,
-		      int, oct_mach_info::float_format);
+		      octave_idx_type, oct_mach_info::float_format);
 
 octave_value
 octave_stream::scanf (const std::string& fmt, const Array<double>& size,
-		      int& count, const std::string& who)
+		      octave_idx_type& count, const std::string& who)
 {
   octave_value retval;
 
   if (stream_ok (who))
     retval = rep->scanf (fmt, size, count, who);
 
   return retval;
 }
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -401,17 +401,17 @@ protected:
 
   // Clear stream state.
 
   void clearerr (void);
 
 private:
 
   // A reference count.
-  int count;
+  octave_idx_type count;
 
   // The permission bits for the file.  Should be some combination of
   // std::ios::open_mode bits.
   int md;
 
   // Data format.
   oct_mach_info::float_format flt_fmt;
 
@@ -422,28 +422,28 @@ private:
   bool open_state;
 
   // Should contain error message if fail is TRUE.
   std::string errmsg;
 
   // Functions that are defined for all input streams (input streams
   // are those that define is).
 
-  std::string do_gets (int max_len, bool& err, bool strip_newline,
+  std::string do_gets (octave_idx_type max_len, bool& err, bool strip_newline,
 		       const std::string& who /* = "gets" */);
 
-  std::string getl (int max_len, bool& err, const std::string& who /* = "getl" */);
-  std::string gets (int max_len, bool& err, const std::string& who /* = "gets" */);
+  std::string getl (octave_idx_type max_len, bool& err, const std::string& who /* = "getl" */);
+  std::string gets (octave_idx_type max_len, bool& err, const std::string& who /* = "gets" */);
 
-  octave_value do_scanf (scanf_format_list& fmt_list, int nr, int nc,
-			 bool one_elt_size_spec, int& count,
+  octave_value do_scanf (scanf_format_list& fmt_list, octave_idx_type nr, octave_idx_type nc,
+			 bool one_elt_size_spec, octave_idx_type& count,
 			 const std::string& who /* = "scanf" */);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
-		      int& count, const std::string& who /* = "scanf" */);
+		      octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   bool do_oscanf (const scanf_format_elt *elt, octave_value&,
 		  const std::string& who /* = "scanf" */);
 
   octave_value_list oscanf (const std::string& fmt,
 			    const std::string& who /* = "scanf" */);
 
   // Functions that are defined for all output streams (output streams
@@ -483,52 +483,52 @@ public:
   ~octave_stream (void);
 
   octave_stream (const octave_stream&);
 
   octave_stream& operator = (const octave_stream&);
 
   int flush (void);
 
-  std::string getl (int max_len, bool& err, const std::string& who /* = "getl" */);
+  std::string getl (octave_idx_type max_len, bool& err, const std::string& who /* = "getl" */);
   std::string getl (const octave_value& max_len, bool& err,
 		    const std::string& who /* = "getl" */);
 
-  std::string gets (int max_len, bool& err, const std::string& who /* = "gets" */);
+  std::string gets (octave_idx_type max_len, bool& err, const std::string& who /* = "gets" */);
   std::string gets (const octave_value& max_len, bool& err,
 		    const std::string& who /* = "gets" */);
 
   int seek (long offset, int origin);
   int seek (const octave_value& offset, const octave_value& origin);
 
   long tell (void);
 
   int rewind (void);
 
   bool is_open (void) const;
 
   void close (void);
 
-  octave_value read (const Array<double>& size, int block_size,
+  octave_value read (const Array<double>& size, octave_idx_type block_size,
 		     oct_data_conv::data_type input_type,
 		     oct_data_conv::data_type output_type,
-		     int skip, oct_mach_info::float_format flt_fmt,
-		     int& count);
+		     octave_idx_type skip, oct_mach_info::float_format flt_fmt,
+		     octave_idx_type& count);
 
-  int write (const octave_value& data, int block_size,
+  octave_idx_type write (const octave_value& data, octave_idx_type block_size,
 	     oct_data_conv::data_type output_type,
-	     int skip, oct_mach_info::float_format flt_fmt);
+	     octave_idx_type skip, oct_mach_info::float_format flt_fmt);
 
   template <class T>
-  int write (const Array<T>&, int block_size,
+  octave_idx_type write (const Array<T>&, octave_idx_type block_size,
 	     oct_data_conv::data_type output_type,
-	     int skip, oct_mach_info::float_format flt_fmt);
+	     octave_idx_type skip, oct_mach_info::float_format flt_fmt);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
-		      int& count, const std::string& who /* = "scanf" */);
+		      octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   octave_value_list oscanf (const std::string& fmt,
 			    const std::string& who /* = "scanf" */);
 
   int printf (const std::string& fmt, const octave_value_list& args,
 	      const std::string& who /* = "printf" */);
 
   int puts (const std::string& s, const std::string& who /* = "puts" */);
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -69,17 +69,17 @@ Software Foundation, 59 Temple Place - S
 #include "sysdep.h"
 #include "ov.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include <version.h>
 
 // Kluge.
-extern "C" void F77_FUNC (xerbla, XERBLA) (const char *, int, long);
+extern "C" void F77_FUNC (xerbla, XERBLA) (const char *, octave_idx_type, long);
 
 extern void install_builtins (void);
 
 #if !defined (HAVE_ATEXIT) && defined (HAVE_ON_EXIT)
 extern "C" int on_exit ();
 #define atexit on_exit
 #endif
 
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -65,23 +65,23 @@ extern void install_ops (void);
   octave_value_typeinfo::register_widening_op \
     (t1::static_type_id (), t2::static_type_id (), oct_conv_ ## f);
 
 #define BOOL_OP1(xt, xn, get_x, yt, yn, get_y) \
   xt xn = get_x; \
   yt yn = get_y;
 
 #define BOOL_OP2(x) \
-  int nr = x.rows (); \
-  int nc = x.columns ();
+  octave_idx_type nr = x.rows (); \
+  octave_idx_type nc = x.columns ();
 
 #define BOOL_OP3(test) \
   boolMatrix retval (nr, nc); \
-  for (int j = 0; j < nc; j++) \
-    for (int i = 0; i < nr; i++) \
+  for (octave_idx_type j = 0; j < nc; j++) \
+    for (octave_idx_type i = 0; i < nr; i++) \
       retval (i, j) = test; \
   return retval;
 
 #define SC_MX_BOOL_OP(st, sn, get_s, mt, mn, get_m, test, empty_result) \
   do \
     { \
       BOOL_OP1 (st, sn, get_s, mt, mn, get_m) \
       BOOL_OP2 (mn) \
@@ -102,20 +102,20 @@ extern void install_ops (void);
     } \
   while (0)
 
 #define MX_MX_BOOL_OP(m1t, m1n, get_m1, m2t, m2n, get_m2, test, op, \
 		      one_empty_result, two_empty_result) \
   do \
     { \
       BOOL_OP1 (m1t, m1n, get_m1, m2t, m2n, get_m2) \
-      int m1_nr = m1n.rows (); \
-      int m1_nc = m1n.cols (); \
-      int m2_nr = m2n.rows (); \
-      int m2_nc = m2n.cols (); \
+      octave_idx_type m1_nr = m1n.rows (); \
+      octave_idx_type m1_nc = m1n.cols (); \
+      octave_idx_type m2_nr = m2n.rows (); \
+      octave_idx_type m2_nc = m2n.cols (); \
       if (m1_nr == m2_nr && m1_nc == m2_nc) \
 	{ \
 	  if (m1_nr == 0 && m1_nc == 0) \
 	    return two_empty_result; \
 	  else \
 	    { \
 	      BOOL_OP2 (m1n) \
 	      BOOL_OP3 (test) \
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -126,17 +126,17 @@ octave_base_matrix<MT>::subsasgn (const 
 
 template <class MT>
 octave_value
 octave_base_matrix<MT>::do_index_op (const octave_value_list& idx,
 				     int resize_ok)
 {
   octave_value retval;
 
-  int n_idx = idx.length ();
+  octave_idx_type n_idx = idx.length ();
 
   int nd = matrix.ndims ();
 
   switch (n_idx)
     {
     case 0:
       error ("invalid number of indices (= 0) for %d-dimensional array", nd);
       break;
@@ -164,17 +164,17 @@ octave_base_matrix<MT>::do_index_op (con
 		  retval = MT (matrix.index (i, j, resize_ok,
 					     MT::resize_fill_value ()));
 	      }
 	  }
 	else
 	  {
 	    Array<idx_vector> idx_vec (n_idx);
 
-	    for (int i = 0; i < n_idx; i++)
+	    for (octave_idx_type i = 0; i < n_idx; i++)
 	      {
 		idx_vec(i) = idx(i).index_vector ();
 
 		if (error_state)
 		  break;
 	      }
 
 	    if (! error_state)
@@ -187,19 +187,19 @@ octave_base_matrix<MT>::do_index_op (con
 
   return retval;
 }
 
 template <class MT>
 void
 octave_base_matrix<MT>::assign (const octave_value_list& idx, const MT& rhs)
 {
-  int len = idx.length ();
+  octave_idx_type len = idx.length ();
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, rhs, MT::resize_fill_value ());
 }
 
 template <class MT>
 bool
 octave_base_matrix<MT>::is_true (void) const
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -42,17 +42,17 @@ Software Foundation, 59 Temple Place - S
 
 template <class T>
 octave_value
 octave_base_sparse<T>::do_index_op (const octave_value_list& idx, 
 				    int resize_ok)
 {
   octave_value retval;
 
-  int n_idx = idx.length ();
+  octave_idx_type n_idx = idx.length ();
 
   int nd = matrix.ndims ();
 
   switch (n_idx)
     {
     case 0:
       error ("invalid number of indices (= 0) for %d-dimensional array", nd);
       break;
@@ -79,17 +79,17 @@ octave_base_sparse<T>::do_index_op (cons
 		if (! error_state)
 		  retval = octave_value (matrix.index (i, j, resize_ok));
 	      }
 	  }
 	else
 	  {
 	    Array<idx_vector> idx_vec (n_idx);
 
-	    for (int i = 0; i < n_idx; i++)
+	    for (octave_idx_type i = 0; i < n_idx; i++)
 	      {
 		idx_vec(i) = idx(i).index_vector ();
 
 		if (error_state)
 		  break;
 	      }
 
 	    if (! error_state)
@@ -176,33 +176,33 @@ octave_base_sparse<T>::subsasgn (const s
 
   return retval;
 }
 
 template <class T>
 void 
 octave_base_sparse<T>::assign (const octave_value_list& idx, const T& rhs)
 {
-  int len = idx.length ();
+  octave_idx_type len = idx.length ();
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, rhs);
 }
 
 
 template <class T>
 bool 
 octave_base_sparse<T>::is_true (void) const
 {
   bool retval = false;
   dim_vector dv = matrix.dims ();
-  int nel = dv.numel ();
-  int nz = nnz ();
+  octave_idx_type nel = dv.numel ();
+  octave_idx_type nz = nnz ();
 
   if (nz == nel && nel > 0)
     {
       T t1 (matrix.reshape (dim_vector (nel, 1)));
 
       SparseBoolMatrix t2 = t1.all ();
 
       retval = t2(0);
@@ -236,33 +236,33 @@ octave_base_sparse<T>::print_info (std::
   matrix.print_info (os, prefix);
 }
 
 template <class T>
 void
 octave_base_sparse<T>::print_raw (std::ostream& os,
 				      bool pr_as_read_syntax) const
 {
-  int nr = matrix.rows ();
-  int nc = matrix.cols ();
-  int nz = nonzero ();
+  octave_idx_type nr = matrix.rows ();
+  octave_idx_type nc = matrix.cols ();
+  octave_idx_type nz = nonzero ();
 
   os << "Compressed Column Sparse (rows=" << nr <<
     ", cols=" << nc <<
     ", nnz=" << nz << ")";
 
   // add one to the printed indices to go from
   //  zero-based to one-based arrays
 
   if (nz != 0)
     {
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  OCTAVE_QUIT;
-	  for (int i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
+	  for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
 	    {
 	      os << "\n";
 	      os << "  (" << matrix.ridx(i)+1 <<
 		" , "  << j+1 << ") -> ";
 	      octave_print_internal( os, matrix.data(i), pr_as_read_syntax);
 	    }
 	}
     }
@@ -285,19 +285,19 @@ octave_base_sparse<T>::save_ascii (std::
 
   return true;
 }
 
 template <class T>
 bool 
 octave_base_sparse<T>::load_ascii (std::istream& is)
 {
-  int nz = 0;
-  int nr = 0;
-  int nc = 0;
+  octave_idx_type nz = 0;
+  octave_idx_type nr = 0;
+  octave_idx_type nc = 0;
   bool success = true;
 
   if (extract_keyword (is, "nnz", nz, true) &&
       extract_keyword (is, "rows", nr, true) &&
       extract_keyword (is, "columns", nc, true))
     {
       T tmp (nr, nc, nz);
 
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -69,18 +69,18 @@ octave_base_sparse : public octave_base_
     octave_base_value (), matrix (a.matrix), typ (a.typ) { }
 
   ~octave_base_sparse (void) { }
 
   octave_value *clone (void) const { return new octave_base_sparse (*this); }
   octave_value *empty_clone (void) const 
     { return new octave_base_sparse (); }
 
-  int nnz (void) const { return matrix.nnz (); }
-  int nonzero (void) const { return matrix.nonzero (); }
+  octave_idx_type nnz (void) const { return matrix.nnz (); }
+  octave_idx_type nonzero (void) const { return matrix.nonzero (); }
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return matrix.squeeze (); }
 
   octave_value subsref (const std::string& type,
 			const std::list<octave_value_list>& idx);
 
@@ -121,17 +121,17 @@ octave_base_sparse : public octave_base_
   bool is_numeric_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_true (void) const;
 
-  int capacity (void) const { return matrix.capacity (); }
+  octave_idx_type capacity (void) const { return matrix.capacity (); }
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -87,19 +87,19 @@ public:
   idx_vector index_vector (void) const;
 
   octave_value subsasgn (const std::string& type,
 			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
   dim_vector dims (void) const { return dim_vector (-1, -1); }
 
-  int numel (void) const { return dims ().numel (); }
+  octave_idx_type numel (void) const { return dims ().numel (); }
 
-  int capacity (void) const { return numel (); }
+  octave_idx_type capacity (void) const { return numel (); }
 
   size_t byte_size (void) const { return 0; }
 
   octave_value reshape (const dim_vector&) const;
 
   octave_value permute (const Array<int>& vec, bool = false) const;
 
   octave_value resize (const dim_vector&) const;
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -71,18 +71,18 @@ octave_value *
 octave_bool_matrix::try_narrowing_conversion (void)
 {
   octave_value *retval = 0;
 
   if (matrix.ndims () == 2)
     {
       boolMatrix bm = matrix.matrix_value ();
 
-      int nr = bm.rows ();
-      int nc = bm.cols ();
+      octave_idx_type nr = bm.rows ();
+      octave_idx_type nc = bm.cols ();
 
       if (nr == 1 && nc == 1)
 	retval = new octave_bool (bm (0, 0));
     }
 
   return retval;
 }
 
@@ -155,17 +155,17 @@ octave_bool_matrix::save_ascii (std::ost
 				bool /* strip_nan_and_inf */)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
       os << "# ndims: " << d.length () << "\n";
 
-      for (int i=0; i < d.length (); i++)
+      for (int i = 0; i < d.length (); i++)
 	os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
@@ -186,23 +186,23 @@ octave_bool_matrix::load_ascii (std::ist
   bool success = true;
 
   string_vector keywords (2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
-  int val = 0;
+  octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
 	{
-	  int mdims = val;
+	  int mdims = static_cast<int> (val);
 
 	  if (mdims >= 0)
 	    {
 	      dim_vector dv;
 	      dv.resize (mdims);
 
 	      for (int i = 0; i < mdims; i++)
 		is >> dv(i);
@@ -212,47 +212,47 @@ octave_bool_matrix::load_ascii (std::ist
 
 	      if (!is)
 		{
 		  error ("load: failed to load matrix constant");
 		  success = false;
 		}
 
 	      boolNDArray btmp (dv);
-	      for (int i = 0; i < btmp.nelem (); i++)
+	      for (octave_idx_type i = 0; i < btmp.nelem (); i++)
 		btmp.elem (i) = (tmp.elem (i) != 0.);
 
 	      matrix = btmp;
 	    }
 	  else
 	    {
 	      error ("load: failed to extract number of rows and columns");
 	      success = false;
 	    }
 	}
       else if (kw == "rows")
 	{
-	  int nr = val;
-	  int nc = 0;
+	  octave_idx_type nr = val;
+	  octave_idx_type nc = 0;
 
 	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
 	    {
 	      if (nr > 0 && nc > 0)
 		{
 		  Matrix tmp (nr, nc);
 		  is >> tmp;
 		  if (!is) 
 		    {
 		      error ("load: failed to load matrix constant");
 		      success = false;
 		    }
 
-		  boolMatrix btmp (nr,nc);
-		  for (int j = 0; j < nc; j++)
-		    for (int i = 0; i < nr; i++)
+		  boolMatrix btmp (nr, nc);
+		  for (octave_idx_type j = 0; j < nc; j++)
+		    for (octave_idx_type i = 0; i < nr; i++)
 		      btmp.elem (i,j) = (tmp.elem (i, j) != 0.);
 
 		  matrix = btmp;
 		}
 	      else if (nr == 0 || nc == 0)
 		matrix = boolMatrix (nr, nc);
 	      else
 		panic_impossible ();
@@ -281,28 +281,28 @@ octave_bool_matrix::save_binary (std::os
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   FOUR_BYTE_INT tmp = - d.length();
   os.write (X_CAST (char *, &tmp), 4);
-  for (int i=0; i < d.length (); i++)
+  for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (X_CAST (char *, &tmp), 4);
     }
 
   boolNDArray m = bool_array_value ();
   bool *mtmp = m.fortran_vec ();
-  int nel = m.nelem ();
+  octave_idx_type nel = m.nelem ();
   OCTAVE_LOCAL_BUFFER (char, htmp, nel);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     htmp[i] = (mtmp[i] ? 1 : 0);
 
   os.write (htmp, nel);
 
   return true;
 }
 
 bool 
@@ -341,23 +341,23 @@ octave_bool_matrix::load_binary (std::is
   if (mdims == 1)
     {
       mdims = 2;
       dv.resize (mdims);
       dv(1) = dv(0);
       dv(0) = 1;
     }
 
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
   OCTAVE_LOCAL_BUFFER (char, htmp, nel);
   if (! is.read (htmp, nel))
     return false;
   boolNDArray m(dv);
   bool *mtmp = m.fortran_vec ();
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     mtmp[i] = (htmp[i] ? 1 : 0);
   matrix = m;
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
@@ -387,21 +387,21 @@ octave_bool_matrix::save_hdf5 (hid_t loc
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid, 
 			H5P_DEFAULT);
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
-  int nel = m.nelem ();
+  octave_idx_type nel = m.nelem ();
   bool *mtmp = m.fortran_vec ();
   hbool_t htmp[nel];
   
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     htmp[i] = mtmp[i];
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
 		     H5P_DEFAULT, htmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
@@ -446,25 +446,25 @@ octave_bool_matrix::load_hdf5 (hid_t loc
     }
   else
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
 	dv(j) = hdims[i];
     }
 
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
   hbool_t htmp[nel];
   if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, 
 	       H5P_DEFAULT, htmp) >= 0) 
     {
       retval = true;
 
       boolNDArray btmp (dv);
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	  btmp.elem (i) = htmp[i];
 
       matrix = btmp;
     }
 
   H5Dclose (data_hid);
 
   return retval;
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -270,17 +270,19 @@ octave_sparse_bool_matrix::load_binary (
 
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
-  SparseBoolMatrix m (nr, nc, nz);
+  SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
+		      static_cast<octave_idx_type> (nc),
+		      static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       OCTAVE_QUIT;
       if (! is.read (X_CAST (char *, &tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
@@ -566,17 +568,19 @@ octave_sparse_bool_matrix::load_hdf5 (hi
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-  SparseBoolMatrix m (nr, nc, nz);
+  SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
+		      static_cast<octave_idx_type> (nc),
+		      static_cast<octave_idx_type> (nz));
 
   data_hid = H5Dopen (group_hid, "cidx");
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -74,21 +74,21 @@ octave_cell::subsref (const std::string&
 	if (! error_state)
 	  {
 	    Cell tcell = tmp.cell_value ();
 
 	    if (tcell.length () == 1)
 	      retval(0) = tcell(0,0);
 	    else
 	      {
-		int n = tcell.numel ();
+		octave_idx_type n = tcell.numel ();
 
 		octave_value_list lst (n, octave_value ());
 
-		for (int i = 0; i < n; i++)
+		for (octave_idx_type i = 0; i < n; i++)
 		  {
 		    OCTAVE_QUIT;
 		    lst(i) = tcell(i);
 		  }
 
 		retval(0) = octave_value (lst, true);
 	      }
 	  }
@@ -248,93 +248,93 @@ octave_cell::assign (const octave_value_
     octave_base_matrix<Cell>::assign (idx, Cell (rhs));
 }
 
 size_t
 octave_cell::byte_size (void) const
 {
   size_t retval = 0;
 
-  for (int i = 0; i < numel (); i++)
+  for (octave_idx_type i = 0; i < numel (); i++)
     retval += matrix(i).byte_size ();
 
   return retval;
 }
 
 octave_value_list
 octave_cell::list_value (void) const
 {
   octave_value_list retval;
 
-  int nr = rows ();
-  int nc = columns ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = columns ();
 
   if (nr == 1 && nc > 0)
     {
       retval.resize (nc);
 
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	retval(i) = matrix(0,i);
     }
   else if (nc == 1 && nr > 0)
     {
       retval.resize (nr);
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	retval(i) = matrix(i,0);
     }
   else
     error ("invalid conversion from cell array to list");
 
   return retval;
 }
 
 string_vector
 octave_cell::all_strings (bool pad, bool) const
 {
   string_vector retval;
 
-  int nr = rows ();
-  int nc = columns ();
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = columns ();
 
   int n_elts = 0;
 
-  int max_len = 0;
+  octave_idx_type max_len = 0;
 
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  string_vector s = matrix(i,j).all_strings ();
 
 	  if (error_state)
 	    return retval;
 
 	  n_elts += s.length ();
 
-	  int s_max_len = s.max_length ();
+	  octave_idx_type s_max_len = s.max_length ();
 
 	  if (s_max_len > max_len)
 	    max_len = s_max_len;
 	}
     }
 
   retval.resize (n_elts);
 
-  int k = 0;
+  octave_idx_type k = 0;
 
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  string_vector s = matrix(i,j).all_strings ();
 
 	  int n = s.length ();
 
-	  for (int ii = 0; ii < n; ii++)
+	  for (octave_idx_type ii = 0; ii < n; ii++)
 	    {
 	      std::string t = s[ii];
 	      int t_len = t.length ();
 
 	      if (pad && max_len > t_len)
 		t += std::string (max_len - t_len, ' ');
 
 	      retval[k++] = t;
@@ -359,30 +359,30 @@ octave_cell::print (std::ostream& os, bo
 
 void
 octave_cell::print_raw (std::ostream& os, bool) const
 {
   int nd = matrix.ndims ();
 
   if (nd == 2)
     {
-      int nr = rows ();
-      int nc = columns ();
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = columns ();
 
       if (nr > 0 && nc > 0)
 	{
 	  indent (os);
 	  os << "{";
 	  newline (os);
 
 	  increment_indent_level ();
 
-	  for (int j = 0; j < nc; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  OCTAVE_QUIT;
 
 		  OSSTREAM buf;
 		  buf << "[" << i+1 << "," << j+1 << "]" << OSSTREAM_ENDS;
 
 		  octave_value val = matrix(i,j);
 
@@ -421,23 +421,23 @@ bool
 octave_cell::save_ascii (std::ostream& os, bool& infnan_warned, 
 			       bool strip_nan_and_inf)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       os << "# ndims: " << d.length () << "\n";
       
-      for (int i=0; i < d.length (); i++)
+      for (int i = 0; i < d.length (); i++)
 	os << " " << d (i);
       os << "\n";
 
       Cell tmp = cell_value ();
       
-      for (int i = 0; i < d.numel (); i++)
+      for (octave_idx_type i = 0; i < d.numel (); i++)
 	{
 	  octave_value o_val = tmp.elem (i);
 
 	  // Recurse to print sub-value.
 	  bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, infnan_warned, 
 				    strip_nan_and_inf, 0, 0);
 	      
 	  if (! b)
@@ -448,19 +448,19 @@ octave_cell::save_ascii (std::ostream& o
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
 	 << "# columns: " << columns () << "\n";
 
       Cell tmp = cell_value ();
       
-      for (int j = 0; j < tmp.cols (); j++)
+      for (octave_idx_type j = 0; j < tmp.cols (); j++)
 	{
-	  for (int i = 0; i < tmp.rows (); i++)
+	  for (octave_idx_type i = 0; i < tmp.rows (); i++)
 	    {
 	      octave_value o_val = tmp.elem (i, j);
 
 	      // Recurse to print sub-value.
 	      bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, 
 					infnan_warned, 
 					strip_nan_and_inf, 0, 0);
 	      
@@ -481,35 +481,35 @@ octave_cell::load_ascii (std::istream& i
   bool success = true;
 
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
-  int val = 0;
+  octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
 	{
-	  int mdims = val;
+	  int mdims = static_cast<int> (val);
 
 	  if (mdims >= 0)
 	    {
 	      dim_vector dv;
 	      dv.resize (mdims);
 
 	      for (int i = 0; i < mdims; i++)
 		is >> dv(i);
 
 	      Cell tmp(dv);
 
-	      for (int i = 0; i < dv.numel (); i++)
+	      for (octave_idx_type i = 0; i < dv.numel (); i++)
 		{
 		  octave_value t2;
 		  bool dummy;
 
 		  // recurse to read cell elements
 		  std::string nm = read_ascii_data (is, std::string (), 
 						    dummy, t2, count);
 
@@ -537,28 +537,28 @@ octave_cell::load_ascii (std::istream& i
 	  else
 	    {
 	      error ("load: failed to extract number of rows and columns");
 	      success = false;
 	    }
 	}
       else if (kw == "rows")
 	{
-	  int nr = val;
-	  int nc = 0;
+	  octave_idx_type nr = val;
+	  octave_idx_type nc = 0;
 
 	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
 	    {
 	      if (nr > 0 && nc > 0)
 		{
 		  Cell tmp (nr, nc);
 
-		  for (int j = 0; j < nc; j++)
+		  for (octave_idx_type j = 0; j < nc; j++)
 		    {
-		      for (int i = 0; i < nr; i++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			{
 			  octave_value t2;
 			  bool dummy;
 
 			  // recurse to read cell elements
 			  std::string nm = read_ascii_data (is, std::string (),
 							    dummy, t2, count);
 
@@ -614,25 +614,25 @@ octave_cell::save_binary (std::ostream& 
 {
   dim_vector d = dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims
   FOUR_BYTE_INT di = - d.length();
   os.write (X_CAST (char *, &di), 4);
-  for (int i=0; i < d.length (); i++)
+  for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
       os.write (X_CAST (char *, &di), 4);
     }
   
   Cell tmp = cell_value ();
       
-  for (int i = 0; i < d.numel (); i++)
+  for (octave_idx_type i = 0; i < d.numel (); i++)
     {
       octave_value o_val = tmp.elem (i);
 
       // Recurse to print sub-value.
       bool b = save_binary_data (os, o_val, CELL_ELT_TAG, "", 0, 
 				 save_as_floats);
 	      
       if (! b)
@@ -676,20 +676,20 @@ octave_cell::load_binary (std::istream& 
   if (mdims == 1)
     {
       mdims = 2;
       dv.resize (mdims);
       dv(1) = dv(0);
       dv(0) = 1;
     }
 
-  int nel = dv.numel ();
+  octave_idx_type nel = dv.numel ();
   Cell tmp(dv);
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_value t2;
       bool dummy;
       std::string doc;
 
       // recurse to read cell elements
       std::string nm = read_binary_data (is, swap, fmt, std::string (), 
 					 dummy, t2, doc);
@@ -773,17 +773,17 @@ octave_cell::save_hdf5 (hid_t loc_id, co
 
   H5Dclose (size_hid);
   H5Sclose (space_hid);
 
   // Recursively add each element of the cell to this group.
 
   Cell tmp = cell_value ();
   
-  for (int i = 0; i < dv.numel (); i++)
+  for (octave_idx_type i = 0; i < dv.numel (); i++)
     {
       char s[20];
       sprintf (s, "_%d", i);
 
       if (! add_hdf5_data(data_hid, tmp.elem (i), s, "", false,
 			  save_as_floats))
 	{
 	  H5Gclose (data_hid);
@@ -862,17 +862,17 @@ octave_cell::load_hdf5 (hid_t loc_id, co
 
 #ifdef HAVE_H5GGET_NUM_OBJS
   hsize_t num_obj = 0;
   group_id = H5Gopen (loc_id, name); 
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 #endif
 
-  for (int i = 0; i < dv.numel (); i++)
+  for (octave_idx_type i = 0; i < dv.numel (); i++)
     {
 
 #ifdef HAVE_H5GGET_NUM_OBJS
       if (current_item >= static_cast<int> (num_obj))
 	retval2 = -1;
       else
 #endif
 	retval2 = H5Giterate (loc_id, name, &current_item,
@@ -1084,17 +1084,17 @@ cell array will have a dimension vector 
       Octave_map m = args(0).map_value ();
 
       if (! error_state)
 	{
 	  dim_vector m_dv = m.dims ();
 
 	  string_vector keys = m.keys ();
 
-	  int fields_numel = keys.length ();
+	  octave_idx_type fields_numel = keys.length ();
 
 	  // The resulting dim_vector should have dimensions:
 	  // [numel(fields) size(struct)]
 
 	  dim_vector result_dv;
 	  result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
 
 	  result_dv(0) = fields_numel;
@@ -1108,22 +1108,22 @@ cell array will have a dimension vector 
 	  result_dv = result_dv.squeeze ();
 
 	  Cell c (result_dv);
 
 	  // Use ra_idx both for counting and for assignments, so
 	  // ra_idx(0) will both contain fields_numel for each call to
 	  // increment_index and j for each assignment.
 
-	  Array<int> ra_idx (result_dv.length (), 0);
+	  Array<octave_idx_type> ra_idx (result_dv.length (), 0);
 	  ra_idx(0) = fields_numel;
 
-	  for (int i = 0; i < m_dv.numel (); i++)
+	  for (octave_idx_type i = 0; i < m_dv.numel (); i++)
 	    {
-	      for (int j = 0; j < fields_numel; j++)
+	      for (octave_idx_type j = 0; j < fields_numel; j++)
 		{
 		  ra_idx(0) = j;
 
 		  Cell c_tmp = m.contents (keys(j));
 
 		  if (c_tmp.length () > 1) // Is a cell.
 		    c(ra_idx) = c_tmp;
 		  else if (c_tmp.length () == 1) // Get octave_value.
diff --git a/src/ov-cs-list.cc b/src/ov-cs-list.cc
--- a/src/ov-cs-list.cc
+++ b/src/ov-cs-list.cc
@@ -36,46 +36,46 @@ Software Foundation, 59 Temple Place - S
 
 DEFINE_OCTAVE_ALLOCATOR (octave_cs_list);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cs_list, "cs-list", "cs-list");
 
 octave_cs_list::octave_cs_list (const Cell& c)
   : octave_base_value (), lst ()
 {
-  int n = c.length ();
+  octave_idx_type n = c.length ();
 
   lst.resize (n);
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     lst(i) = c(i);
 }
 
 void
 octave_cs_list::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_cs_list::print_raw (std::ostream& os, bool) const
 {
   unwind_protect::begin_frame ("octave_cs_list_print");
 
-  int n = lst.length ();
+  octave_idx_type n = lst.length ();
 
   if (n > 0)
     {
       indent (os);
       os << "(,";
       newline (os);
 
       increment_indent_level ();
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  OSSTREAM buf;
 	  buf << "[" << i+1 << "]" << OSSTREAM_ENDS;
 
 	  octave_value val = lst(i);
 
 	  val.print_with_name (os, OSSTREAM_STR (buf));
 
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -61,18 +61,18 @@ octave_value *
 octave_complex_matrix::try_narrowing_conversion (void)
 {
   octave_value *retval = 0;
 
   if (matrix.ndims () == 2)
     {
       ComplexMatrix cm = matrix.matrix_value ();
 
-      int nr = cm.rows ();
-      int nc = cm.cols ();
+      octave_idx_type nr = cm.rows ();
+      octave_idx_type nc = cm.cols ();
 
       if (nr == 1 && nc == 1)
 	{
 	  Complex c = matrix (0, 0);
 
 	  if (std::imag (c) == 0.0)
 	    retval = new octave_scalar (std::real (c));
 	  else
@@ -95,19 +95,19 @@ octave_complex_matrix::assign (const oct
 {
   octave_base_matrix<ComplexNDArray>::assign (idx, rhs);
 }
 
 void
 octave_complex_matrix::assign (const octave_value_list& idx,
 			       const NDArray& rhs)
 {
-  int len = idx.length ();
+  octave_idx_type len = idx.length ();
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, rhs);
 }
 
 bool
 octave_complex_matrix::valid_as_scalar_index (void) const
 {
@@ -196,25 +196,25 @@ SparseComplexMatrix
 octave_complex_matrix::sparse_complex_matrix_value (bool) const
 {
   return SparseComplexMatrix (matrix.matrix_value ());
 }
 
 static ComplexMatrix
 strip_infnan (const ComplexMatrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   ComplexMatrix retval (nr, nc);
 
-  int k = 0;
-  for (int i = 0; i < nr; i++)
+  octave_idx_type k = 0;
+  for (octave_idx_type i = 0; i < nr; i++)
     {
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  Complex c = m (i, j);
 	  if (xisnan (c))
 	    goto next_row;
 	  else
 	    {
 	      double re = std::real (c);
 	      double im = std::imag (c);
@@ -255,17 +255,17 @@ octave_complex_matrix::save_ascii (std::
       else if (! infnan_warned && tmp.any_element_is_inf_or_nan ())
 	{
 	  warning ("save: Inf or NaN values may not be reloadable");
 	  infnan_warned = true;
 	}
 
       os << "# ndims: " << d.length () << "\n";
 
-      for (int i=0; i < d.length (); i++)
+      for (int i = 0; i < d.length (); i++)
 	os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
@@ -294,23 +294,23 @@ octave_complex_matrix::load_ascii (std::
   bool success = true;
 
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
-  int val = 0;
+  octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
 	{
-	  int mdims = val;
+	  int mdims = static_cast<int> (val);
 
 	  if (mdims >= 0)
 	    {
 	      dim_vector dv;
 	      dv.resize (mdims);
 
 	      for (int i = 0; i < mdims; i++)
 		is >> dv(i);
@@ -328,18 +328,18 @@ octave_complex_matrix::load_ascii (std::
 	  else
 	    {
 	      error ("load: failed to extract number of rows and columns");
 	      success = false;
 	    }
 	}
       else if (kw == "rows")
 	{
-	  int nr = val;
-	  int nc = 0;
+	  octave_idx_type nr = val;
+	  octave_idx_type nc = 0;
 
 	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
 	    {
 	      if (nr > 0 && nc > 0)
 		{
 		  ComplexMatrix tmp (nr, nc);
 		  is >> tmp;
 		  if (!is)
@@ -377,17 +377,17 @@ octave_complex_matrix::save_binary (std:
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   FOUR_BYTE_INT tmp = - d.length();
   os.write (X_CAST (char *, &tmp), 4);
-  for (int i=0; i < d.length (); i++)
+  for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (X_CAST (char *, &tmp), 4);
     }
 
   ComplexNDArray m = complex_array_value ();
   save_type st = LS_DOUBLE;
   if (save_as_floats)
@@ -470,17 +470,17 @@ octave_complex_matrix::load_binary (std:
       if (! is.read (X_CAST (char *, &nc), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&nc);
       if (! is.read (X_CAST (char *, &tmp), 1))
 	return false;
       ComplexMatrix m (nr, nc);
       Complex *im = m.fortran_vec ();
-      int len = nr * nc;
+      octave_idx_type len = nr * nc;
       read_doubles (is, X_CAST (double *, im),
 		    X_CAST (save_type, tmp), 2*len, swap, fmt);
       if (error_state || ! is)
 	return false;
       matrix = m;
     }
   return true;
 }
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -290,17 +290,19 @@ octave_sparse_complex_matrix::load_binar
 
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
-  SparseComplexMatrix m (nr, nc, nz);
+  SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
+			 static_cast<octave_idx_type> (nc),
+			 static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       OCTAVE_QUIT;
       if (! is.read (X_CAST (char *, &tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
@@ -621,17 +623,19 @@ octave_sparse_complex_matrix::load_hdf5 
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-  SparseComplexMatrix m (nr, nc, nz);
+  SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
+			 static_cast<octave_idx_type> (nc),
+			 static_cast<octave_idx_type> (nz));
 
   data_hid = H5Dopen (group_hid, "cidx");
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -199,17 +199,17 @@ public:
       ComplexNDArray retval (dim_vector (1,1)); 
       retval(0) = Complex (double (scalar));
       return retval;
     }
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   int write (octave_stream& os, int block_size,
-	     oct_data_conv::data_type output_type, int skip,
+	     oct_data_conv::data_type output_type, octave_idx_type skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (),
 		       block_size, output_type, skip, flt_fmt);
     }
 
 private:
 
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -44,21 +44,21 @@ Software Foundation, 59 Temple Place - S
 
 DEFINE_OCTAVE_ALLOCATOR (octave_list);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_list, "list", "list");
 
 octave_list::octave_list (const Cell& c)
   : octave_base_value (), data ()
 {
-  int n = c.length ();
+  octave_idx_type n = c.length ();
 
   data.resize (dim_vector (1, n));
 
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     data(i) = c(i);
 }
 
 octave_value_list
 octave_list::subsref (const std::string& type,
 		      const std::list<octave_value_list>& idx, int nargout)
 {
   octave_value_list retval;
@@ -142,17 +142,17 @@ octave_list::do_index_op (const octave_v
 
 octave_value
 octave_list::subsasgn (const std::string& type,
 		       const std::list<octave_value_list>& idx,
 		       const octave_value& rhs)
 {
   octave_value retval;
 
-  int n = type.length ();
+  octave_idx_type n = type.length ();
 
   octave_value t_rhs = rhs;
 
   if (n > 1)
     {
       switch (type[0])
 	{
 	case '(':
@@ -189,19 +189,19 @@ octave_list::subsasgn (const std::string
   if (! error_state)
     {
       switch (type[0])
 	{
 	case '(':
 	  {
 	    octave_value_list i = idx.front ();
 
-	    int len = i.length ();
+	    octave_idx_type len = i.length ();
 
-	    for (int k = 0; k < len; k++)
+	    for (octave_idx_type k = 0; k < len; k++)
 	      data.set_index (i(k).index_vector ());
 
 	    ::assign (data, Cell (t_rhs), Cell::resize_fill_value ());
 
 	    retval = octave_value (this, count + 1);
 	  }
 	  break;
 
@@ -225,17 +225,17 @@ void
 octave_list::assign (const octave_value_list& idx, const octave_value& rhs)
 {
   if (idx.length () == 1)
     {
       int i = idx(0).int_value (true);
 
       if (! error_state)
 	{
-	  int n = data.length ();
+	  octave_idx_type n = data.length ();
 
 	  if (i > 0)
 	    {
 	      if (Vwarn_resize_on_range_error && i > n)
 		warning ("list index = %d out of range", i);
 
 	      data(i-1) = rhs;
 	    }
@@ -249,59 +249,59 @@ octave_list::assign (const octave_value_
     error ("lists may only be indexed by a single scalar");
 }
 
 size_t
 octave_list::byte_size (void) const
 {
   size_t retval = 0;
 
-  for (int i = 0; i < numel (); i++)
+  for (octave_idx_type i = 0; i < numel (); i++)
     retval += data(i).byte_size ();
 
   return retval;
 }
 
 octave_value_list
 octave_list::list_value (void) const
 {
   octave_value_list retval;
 
-  int n = data.length ();
+  octave_idx_type n = data.length ();
 
   retval.resize (n);
   
-  for (int i = 0; i < n; i++)
+  for (octave_idx_type i = 0; i < n; i++)
     retval(i) = data(i);
 
   return retval;
 }
 
 void
 octave_list::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_list::print_raw (std::ostream& os, bool) const
 {
   unwind_protect::begin_frame ("octave_list_print");
 
-  int n = data.length ();
+  octave_idx_type n = data.length ();
 
   if (n > 0)
     {
       indent (os);
       os << "(";
       newline (os);
 
       increment_indent_level ();
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	{
 	  OSSTREAM buf;
 
 	  buf << "[" << i+1 << "]" << OSSTREAM_ENDS;
 
 	  octave_value val = data(i);
 
 	  val.print_with_name (os, OSSTREAM_STR (buf));
@@ -628,17 +628,17 @@ octave_list::load_binary (std::istream& 
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
   if (len > 0)
     {
       octave_value_list lst;
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	{
 	  octave_value t2;
 	  bool dummy;
 	  std::string doc;
 	  
 	  // recurse to read list elements
 	  std::string nm = read_binary_data (is, swap, fmt, std::string (), 
 					     dummy, t2, doc);
@@ -674,17 +674,17 @@ octave_list::save_hdf5 (hid_t loc_id, co
   hid_t data_hid = -1;
 
   data_hid = H5Gcreate (loc_id, name, 0);
   if (data_hid < 0) return false;
 
   // recursively add each element of the list to this group
   octave_value_list lst = list_value ();
 
-  for (int i = 0; i < lst.length (); ++i)
+  for (octave_idx_type i = 0; i < lst.length (); ++i)
     {
       // should we use lst.name_tags () to label the elements?
       char s[20];
       sprintf (s, "_%d", i);
       bool retval2 = add_hdf5_data (data_hid, lst (i), s, "",
 				    false, save_as_floats);
       if (! retval2)
 	break;
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
--- a/src/ov-mapper.cc
+++ b/src/ov-mapper.cc
@@ -38,35 +38,35 @@ DEFINE_OCTAVE_ALLOCATOR (octave_mapper);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_mapper,
 				     "built-in mapper function",
 				     "built-in mapper function");
 
 static bool
 any_element_less_than (const NDArray& a, double val)
 {
-  int len = a.length ();
+  octave_idx_type len = a.length ();
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     {
       OCTAVE_QUIT;
 
       if (a(i) < val)
 	return true;
     }
 
   return false;
 }
 
 static bool
 any_element_greater_than (const NDArray& a, double val)
 {
-  int len = a.length ();
+  octave_idx_type len = a.length ();
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     {
       OCTAVE_QUIT;
 
       if (a(i) > val)
 	return true;
     }
 
   return false;
@@ -75,21 +75,21 @@ any_element_greater_than (const NDArray&
 // In most cases, we could use the map member function from the NDArray
 // classes, but as currently implemented, they don't allow us to
 // detect errors and abort properly.  So use these macros to do the
 // looping here instead.
 
 #define MAPPER_LOOP_2(T, F, M, CONV, R) \
   do \
     { \
-      int len = M.length (); \
+      octave_idx_type len = M.length (); \
  \
       T result (M.dims ()); \
  \
-      for (int i = 0; i < len; i++) \
+      for (octave_idx_type i = 0; i < len; i++) \
 	{ \
           OCTAVE_QUIT; \
  \
 	  result(i) = CONV (F (M(i))); \
  \
 	  if (error_state) \
 	    return retval; \
 	} \
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -126,17 +126,17 @@ octave_range::do_index_op (const octave_
   return tmp.do_index_op (idx, resize_ok);
 }
 
 double
 octave_range::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  int nel = range.nelem ();
+  octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
       // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("range", "real scalar");
 
       retval = range.base ();
@@ -186,17 +186,17 @@ octave_range::is_true (void) const
 
 Complex
 octave_range::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  int nel = range.nelem ();
+  octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
       // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("range", "complex scalar");
 
       retval = range.base ();
@@ -228,17 +228,17 @@ octave_range::print_raw (std::ostream& o
 			 current_print_indent_level ());
 }
 
 bool
 octave_range::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
-  int n = range.nelem ();
+  octave_idx_type n = range.nelem ();
 
   indent (os);
 
   if (n == 0 || n == 1)
     os << name << " = ";
   else
     {
       os << name << " =";
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -95,18 +95,18 @@ public:
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   octave_value do_index_op (const octave_value_list& idx)
     { return do_index_op (idx, 0); }
 
   idx_vector index_vector (void) const { return idx_vector (range); }
 
   dim_vector dims (void) const
-    {
-      int n = range.nelem ();
+    { 
+      octave_idx_type n = range.nelem ();
       return dim_vector (n > 0, n);
     }
 
   octave_value resize (const dim_vector& dv) const
     { NDArray retval = array_value (); retval.resize (dv); return retval; }
 
   size_t byte_size (void) const { return 3 * sizeof (double); }
 
@@ -124,24 +124,24 @@ public:
   octave_value any (int dim = 0) const;
 
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const
     {
       double b = range.base ();
       return (range.nelem () == 1
-	      && ! xisnan (b) && D_NINT (b) == b && NINT (b) == 1);
+	      && ! xisnan (b) && D_NINT (b) == b && NINTbig (b) == 1);
     }
 
   bool valid_as_zero_index (void) const
     {
       double b = range.base ();
       return (range.nelem () == 1
-	      && ! xisnan (b) && D_NINT (b) == b && NINT (b) == 0);
+	      && ! xisnan (b) && D_NINT (b) == b && NINTbig (b) == 0);
     }
 
   bool is_numeric_type (void) const { return true; }
 
   // XXX DO ME XXX
   bool is_true (void) const;
 
   double double_value (bool = false) const;
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -147,19 +147,19 @@ octave_matrix::complex_array_value (bool
   return ComplexNDArray (matrix);
 }
 
 charNDArray
 octave_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims ());
 
-  int nel = numel ();
+  octave_idx_type nel = numel ();
   
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     retval.elem (i) = static_cast<char>(matrix.elem (i));
 
   return retval;
 }
   
 SparseMatrix 
 octave_matrix::sparse_matrix_value (bool) const
 {
@@ -175,19 +175,19 @@ octave_matrix::sparse_complex_matrix_val
   return SparseComplexMatrix (sparse_matrix_value ());
 }
 
 streamoff_array
 octave_matrix::streamoff_array_value (void) const
 {
   streamoff_array retval (dims ());
 
-  int nel = numel ();
+  octave_idx_type nel = numel ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = matrix(i);
 
       if (D_NINT (d) == d)
 	retval(i) = std::streamoff (static_cast<long> (d));
       else
 	{
 	  error ("conversion to streamoff_array value failed");
@@ -211,17 +211,17 @@ octave_matrix::convert_to_str_internal (
       retval = octave_value (&s);
     }
   else
     {
       charNDArray chm (dv);
 	  
       bool warned = false;
 
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
 	{
 	  OCTAVE_QUIT;
 
 	  double d = matrix (i);
 
 	  if (xisnan (d))
 	    {
 	      ::error ("invalid conversion from NaN to character");
@@ -253,25 +253,25 @@ octave_matrix::convert_to_str_internal (
     }
 
   return retval;
 }
 
 static Matrix
 strip_infnan (const Matrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   Matrix retval (nr, nc);
 
-  int k = 0;
-  for (int i = 0; i < nr; i++)
+  octave_idx_type k = 0;
+  for (octave_idx_type i = 0; i < nr; i++)
     {
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  double d = m (i, j);
 	  if (xisnan (d))
 	    goto next_row;
 	  else
 	    retval (k, j) = xisinf (d) ? (d > 0 ? OCT_RBV : -OCT_RBV) : d;
 	}
       k++;
@@ -343,23 +343,23 @@ octave_matrix::load_ascii (std::istream&
   bool success = true;
 
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
 
   std::string kw;
-  int val = 0;
+  octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
 	{
-	  int mdims = val;
+	  int mdims = static_cast<int> (val);
 
 	  if (mdims >= 0)
 	    {
 	      dim_vector dv;
 	      dv.resize (mdims);
 
 	      for (int i = 0; i < mdims; i++)
 		is >> dv(i);
@@ -377,18 +377,18 @@ octave_matrix::load_ascii (std::istream&
 	  else
 	    {
 	      error ("load: failed to extract number of rows and columns");
 	      success = false;
 	    }
 	}
       else if (kw == "rows")
 	{
-	  int nr = val;
-	  int nc = 0;
+	  octave_idx_type nr = val;
+	  octave_idx_type nc = 0;
 
 	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
 	    {
 	      if (nr > 0 && nc > 0)
 		{
 		  Matrix tmp (nr, nc);
 		  is >> tmp;
 		  if (is)
@@ -428,17 +428,17 @@ octave_matrix::save_binary (std::ostream
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   FOUR_BYTE_INT tmp = - d.length();
   os.write (X_CAST (char *, &tmp), 4);
-  for (int i=0; i < d.length (); i++)
+  for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (X_CAST (char *, &tmp), 4);
     }
 
   NDArray m = array_value ();
   save_type st = LS_DOUBLE;
   if (save_as_floats)
@@ -519,17 +519,17 @@ octave_matrix::load_binary (std::istream
       if (! is.read (X_CAST (char *, &nc), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&nc);
       if (! is.read (X_CAST (char *, &tmp), 1))
 	return false;
       Matrix m (nr, nc);
       double *re = m.fortran_vec ();
-      int len = nr * nc;
+      octave_idx_type len = nr * nc;
       read_doubles (is, re, X_CAST (save_type, tmp), len, swap, fmt);
       if (error_state || ! is)
 	return false;
       matrix = m;
     }
   return true;
 }
 
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -261,17 +261,19 @@ octave_sparse_matrix::load_binary (std::
 
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
-  SparseMatrix m (nr, nc, nz);
+  SparseMatrix m (static_cast<octave_idx_type> (nr),
+		  static_cast<octave_idx_type> (nc),
+		  static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       OCTAVE_QUIT;
       if (! is.read (X_CAST (char *, &tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
@@ -575,17 +577,19 @@ octave_sparse_matrix::load_hdf5 (hid_t l
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
-  SparseMatrix m (nr, nc, nz);
+  SparseMatrix m (static_cast<octave_idx_type> (nr),
+		  static_cast<octave_idx_type> (nc),
+		  static_cast<octave_idx_type> (nz));
 
   data_hid = H5Dopen (group_hid, "cidx");
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 2)
     {
       H5Sclose (space_hid);
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -80,24 +80,24 @@ public:
   bool is_real_scalar (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const
     {
       return (! xisnan (scalar)
 	      && D_NINT (scalar) == scalar
-	      && NINT (scalar) == 1);
+	      && NINTbig (scalar) == 1);
     }
 
   bool valid_as_zero_index (void) const
     {
       return (! xisnan (scalar)
 	      && D_NINT (scalar) == scalar
-	      && NINT (scalar) == 0);
+	      && NINTbig (scalar) == 0);
     }
 
   double double_value (bool = false) const { return scalar; }
 
   double scalar_value (bool = false) const { return scalar; }
 
   Matrix matrix_value (bool = false) const
     { return Matrix (1, 1, scalar); }
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -78,17 +78,17 @@ octave_char_matrix_str::numeric_conversi
 }
 
 octave_value
 octave_char_matrix_str::do_index_op (const octave_value_list& idx,
 				     int resize_ok)
 {
   octave_value retval;
 
-  int len = idx.length ();
+  octave_idx_type len = idx.length ();
 
   switch (len)
     {
     case 2:
       {
 	idx_vector i = idx (0).index_vector ();
 	idx_vector j = idx (1).index_vector ();
 
@@ -107,41 +107,41 @@ octave_char_matrix_str::do_index_op (con
 				 true);
       }
       break;
 
     default:
       {
 	Array<idx_vector> idx_vec (len);
 
-	for (int i = 0; i < len; i++)
+	for (octave_idx_type i = 0; i < len; i++)
 	  idx_vec(i) = idx(i).index_vector ();
 
 	if (! error_state)
 	  retval = octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
 				 true);
       }
       break;
     }
 
   return retval;
 }
 
 void
 octave_char_matrix_str::assign (const octave_value_list& idx,
 				const charMatrix& rhs)
 {
-  int len = idx.length ();
+  octave_idx_type len = idx.length ();
 
   // XXX FIXME XXX
   charMatrix tmp = rhs;
   if (tmp.rows () == 1 && tmp.columns () == 0)
     tmp.resize (0, 0);    
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, tmp, Vstring_fill_char);
 }
 
 bool
 octave_char_matrix_str::valid_as_scalar_index (void) const
 {
@@ -206,21 +206,21 @@ string_vector
 octave_char_matrix_str::all_strings (bool, bool) const
 {
   string_vector retval;
 
   if (matrix.ndims () == 2)
     {
       charMatrix chm = matrix.matrix_value ();
 
-      int n = chm.rows ();
+      octave_idx_type n = chm.rows ();
 
       retval.resize (n);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	retval[i] = chm.row_as_string (i, true);
     }
   else
     error ("invalid conversion of charNDArray to string_vector");
 
   return retval;
 }
 
@@ -264,19 +264,19 @@ octave_char_matrix_str::save_ascii (std:
       os.write (X_CAST (char *, tmp.fortran_vec ()), d.numel ());
       os << "\n";
     }
   else
     {
       // Keep this case, rather than use generic code above for
       // backward compatiability. Makes load_ascii much more complex!!
       charMatrix chm = char_matrix_value ();
-      int elements = chm.rows ();
+      octave_idx_type elements = chm.rows ();
       os << "# elements: " << elements << "\n";
-      for (int i = 0; i < elements; i++)
+      for (octave_idx_type i = 0; i < elements; i++)
 	{
 	  unsigned len = chm.cols ();
 	  os << "# length: " << len << "\n";
 	  std::string tstr = chm.row_as_string (i, false, true);
 	  const char *tmp = tstr.data ();
 	  if (tstr.length () > len)
 	    panic_impossible ();
 	  os.write (X_CAST (char *, tmp), len);
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -397,17 +397,17 @@ octave_struct::print_raw (std::ostream& 
       Vstruct_levels_to_print--;
 
       indent (os);
       os << "{";
       newline (os);
 
       increment_indent_level ();
 
-      int n = map.numel ();
+      octave_idx_type n = map.numel ();
 
       if (n > 1 && print_keys_only)
 	{
 	  indent (os);
 	  dim_vector dv = dims ();
 	  os << dv.str () << " struct array containing the fields:";
 	  newline (os);
 	  newline (os);
@@ -728,22 +728,23 @@ cell2struct_check_args (const dim_vector
 
       retval = false;
     }
 
   return retval;
 }
 
 static void
-cell2struct_construct_idx (Array<int>& ra_idx1, const Array<int>& ra_idx2,
-			   int dim, int fill_value)
+cell2struct_construct_idx (Array<octave_idx_type>& ra_idx1,
+			   const Array<octave_idx_type>& ra_idx2,
+			   octave_idx_type dim, octave_idx_type fill_value)
 {
-  int iidx = 0;
+  octave_idx_type iidx = 0;
 
-  for (int idx = 0; idx < ra_idx1.length (); idx++)
+  for (octave_idx_type idx = 0; idx < ra_idx1.length (); idx++)
     {
       if (idx == dim)
 	ra_idx1.elem (idx) = fill_value;
       else
 	ra_idx1.elem (idx) = ra_idx2(iidx++);
     }
 }
 
@@ -795,78 +796,78 @@ A(1)\n\
 
 	  if (! error_state)
 	    {
 	      // Retrieve the dimension value.
 
 	      // XXX FIX ME XXX --  int_value () should print out the
 	      // conversions it does to be Matlab compatible.
 
-	      int dim = args(2).int_value () - 1;
+	      octave_idx_type dim = args(2).int_value () - 1;
 
 	      if (! error_state)
 		{
 		  dim_vector c_dv = c.dims ();
 		  dim_vector field_dv = field.dims ();
 
 		  if (cell2struct_check_args (c_dv, field_dv, field_is_cell,
 					      dim))
 		    {
-		      int c_dv_length = c_dv.length ();
+		      octave_idx_type c_dv_length = c_dv.length ();
 
 		      // Dimension vector for the Cell arrays to be
 		      // put into the structure.
 
 		      dim_vector value_dv;
 
 		      // Initialize c_value_dv.
 
 		      if (c_dv_length == 2)
 			value_dv = dim_vector (1, 1);
 		      else
 			value_dv.resize (c_dv_length - 1);
 
-		      int idx_tmp = 0;
+		      octave_idx_type idx_tmp = 0;
 
-		      for (int i = 0; i < c_dv_length; i++)
+		      for (octave_idx_type i = 0; i < c_dv_length; i++)
 			{
 			  if (i != dim)
 			    value_dv.elem (idx_tmp++) = c_dv.elem (i);
 			}
 
 		      // All initializing is done, we can start moving
 		      // values.
 
 		      Octave_map map;
 
 		      // If field is a cell array then we use all
 		      // elements in array, on the other hand when
 		      // field is a character array the number of
 		      // elements is equals the number of rows.
 
-		      int field_numel
+		      octave_idx_type field_numel
 			= field_is_cell ? field_dv.numel (): field_dv(0);
 
 		      // For matlab compatibility.
 
 		      if (field_numel == 0)
 			map.reshape (dim_vector (0, 1));
 
-		      for (int i = 0; i < field_numel; i++)
+		      for (octave_idx_type i = 0; i < field_numel; i++)
 			{
 			  // Construct cell array which goes into the
 			  // structure together with the appropriate
 			  // field name.
 
 			  Cell c_value (value_dv);
 
-			  Array<int> value_idx (value_dv.length (), 0);
-			  Array<int> c_idx (c_dv_length, 0);
+			  Array<octave_idx_type> value_idx (value_dv.length (), 0);
+			  Array<octave_idx_type> c_idx (c_dv_length, 0);
 
-			  for (int j = 0; j < value_dv.numel (); j++)
+			  for (octave_idx_type j = 0; j < value_dv.numel (); j++)
 			    {
 			      // Need to do this to construct the
 			      // appropriate idx for getting elements
 			      // from the original cell array.
 
 			      cell2struct_construct_idx (c_idx, value_idx,
 							 dim, i);
 
@@ -998,26 +999,26 @@ octave_struct::save_ascii (std::ostream&
     }
 
   return true;
 }
 
 bool 
 octave_struct::load_ascii (std::istream& is)
 {
-  int len = 0;
+  octave_idx_type len = 0;
   bool success = true;
 
   if (extract_keyword (is, "length", len) && len >= 0)
     {
       if (len > 0)
 	{
 	  Octave_map m (map);
 
-	  for (int j = 0; j < len; j++)
+	  for (octave_idx_type j = 0; j < len; j++)
 	    {
 	      octave_value t2;
 	      bool dummy;
 
 	      // recurse to read cell elements
 	      std::string nm
 		= read_ascii_data (is, std::string (), dummy, t2, count);
 
@@ -1083,17 +1084,17 @@ octave_struct::load_binary (std::istream
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
   if (len > 0)
     {
       Octave_map m (map);
 
-      for (int j = 0; j < len; j++)
+      for (octave_idx_type j = 0; j < len; j++)
 	{
 	  octave_value t2;
 	  bool dummy;
 	  std::string doc;
 
 	  // recurse to read cell elements
 	  std::string nm = read_binary_data (is, swap, fmt, std::string (), 
 					     dummy, t2, doc);
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1007,33 +1007,33 @@ octave_value::assign (assign_op op, cons
       if (error_state)
 	gripe_assign_failed_or_no_method (assign_op_as_string (op),
 					  type_name (), rhs.type_name ());
     }
 
   return *this;
 }
 
-int
+octave_idx_type
 octave_value::rows (void) const
 {
   dim_vector dv = dims ();
 
   return (dv.length () > 0) ? dv(0) : -1;
 }
 
-int
+octave_idx_type
 octave_value::columns (void) const
 {
   dim_vector dv = dims ();
 
   return (dv.length () > 1) ? dv(1) : -1;
 }
 
-int
+octave_idx_type
 octave_value::length (void) const
 {
   int retval = 0;
 
   dim_vector dv = dims ();
 
   for (int i = 0; i < dv.length (); i++)
     {
@@ -1153,23 +1153,23 @@ octave_value::column_vector_value (bool 
 {
   ColumnVector retval;
 
   Matrix m = matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   if (nc == 1)
     {
       retval.resize (nr);
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	retval (i) = m (i, 0);
     }
   else
     {
       std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "real column vector");
     }
 
@@ -1182,23 +1182,23 @@ octave_value::complex_column_vector_valu
 {
   ComplexColumnVector retval;
 
   ComplexMatrix m = complex_matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   if (nc == 1)
     {
       retval.resize (nr);
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	retval (i) = m (i, 0);
     }
   else
     {
       std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "complex column vector");
     }
 
@@ -1211,23 +1211,23 @@ octave_value::row_vector_value (bool for
 {
   RowVector retval;
 
   Matrix m = matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   if (nr == 1)
     {
       retval.resize (nc);
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	retval (i) = m (0, i);
     }
   else
     {
       std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "real row vector");
     }
 
@@ -1240,23 +1240,23 @@ octave_value::complex_row_vector_value (
 {
   ComplexRowVector retval;
 
   ComplexMatrix m = complex_matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   if (nr == 1)
     {
       retval.resize (nc);
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	retval (i) = m (0, i);
     }
   else
     {
       std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "complex row vector");
     }
 
@@ -1271,41 +1271,41 @@ octave_value::vector_value (bool force_s
 {
   Array<double> retval;
 
   Matrix m = matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   if (nr == 1)
     {
       retval.resize (nc);
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	retval (i) = m (0, i);
     }
   else if (nc == 1)
     {
       retval.resize (nr);
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	retval (i) = m (i, 0);
     }
   else if (nr > 0 && nc > 0)
     {
       // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
       if (! force_vector_conversion && Vwarn_fortran_indexing)
 	gripe_implicit_conversion (type_name (), "real vector");
 
       retval.resize (nr * nc);
-      int k = 0;
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      octave_idx_type k = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 
 	    retval (k++) = m (i, j);
 	  }
     }
   else
     {
@@ -1322,23 +1322,23 @@ octave_value::int_vector_value (bool for
 {
   Array<int> retval;
 
   Matrix m = matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   if (nr == 1)
     {
       retval.resize (nc);
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	{
 	  OCTAVE_QUIT;
 
 	  double d = m (0, i);
 
 	  if (require_int && D_NINT (d) != d)
 	    {
 	      error ("conversion to integer value failed");
@@ -1346,17 +1346,17 @@ octave_value::int_vector_value (bool for
 	    }
 
 	  retval (i) = static_cast<int> (d);
 	}
     }
   else if (nc == 1)
     {
       retval.resize (nr);
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 
 	  double d = m (i, 0);
 
 	  if (require_int && D_NINT (d) != d)
 	    {
 	      error ("conversion to integer value failed");
@@ -1368,20 +1368,20 @@ octave_value::int_vector_value (bool for
     }
   else if (nr > 0 && nc > 0)
     {
       // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
       if (! force_vector_conversion && Vwarn_fortran_indexing)
 	gripe_implicit_conversion (type_name (), "real vector");
 
       retval.resize (nr * nc);
-      int k = 0;
-      for (int j = 0; j < nc; j++)
+      octave_idx_type k = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 
 	      double d = m (i, j);
 
 	      if (require_int && D_NINT (d) != d)
 		{
 		  error ("conversion to integer value failed");
@@ -1407,47 +1407,47 @@ octave_value::complex_vector_value (bool
 {
   Array<Complex> retval;
 
   ComplexMatrix m = complex_matrix_value (force_string_conv);
 
   if (error_state)
     return retval;
 
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   if (nr == 1)
     {
       retval.resize (nc);
-      for (int i = 0; i < nc; i++)
+      for (octave_idx_type i = 0; i < nc; i++)
 	{
 	  OCTAVE_QUIT;
 	  retval (i) = m (0, i);
 	}
     }
   else if (nc == 1)
     {
       retval.resize (nr);
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  retval (i) = m (i, 0);
 	}
     }
   else if (nr > 0 && nc > 0)
     {
       // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
       if (! force_vector_conversion && Vwarn_fortran_indexing)
 	gripe_implicit_conversion (type_name (), "complex vector");
 
       retval.resize (nr * nc);
-      int k = 0;
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      octave_idx_type k = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    retval (k++) = m (i, j);
 	  }
     }
   else
     {
       std::string tn = type_name ();
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -349,30 +349,30 @@ public:
   virtual idx_vector index_vector (void) const
     { return rep->index_vector (); }
 
   // Size.
 
   virtual dim_vector dims (void) const
     { return rep->dims (); }
 
-  int rows (void) const;
+  octave_idx_type rows (void) const;
 
-  int columns (void) const;
+  octave_idx_type columns (void) const;
 
-  int length (void) const;
+  octave_idx_type length (void) const;
 
   int ndims (void) const;
 
   bool all_zero_dims (void) const { return dims().all_zero (); }
 
-  virtual int numel (void) const
+  virtual octave_idx_type numel (void) const
     { return rep->numel (); }
 
-  virtual int capacity (void) const
+  virtual octave_idx_type capacity (void) const
     { return rep->capacity (); }
 
   virtual size_t byte_size (void) const
     { return rep->byte_size (); }
 
   virtual octave_value reshape (const dim_vector& dv) const
     { return rep->reshape (dv); }
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -222,45 +222,45 @@ operator << (std::ostream& os, const pr_
 static float_format *curr_real_fmt = 0;
 
 // Current format for the imaginary part of complex numbers.
 static float_format *curr_imag_fmt = 0;
 
 static double
 pr_max_internal (const Matrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   double result = -DBL_MAX;
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	double val = m(i,j);
 	if (xisinf (val) || octave_is_NaN_or_NA (val))
 	  continue;
 
 	if (val > result)
 	  result = val;
       }
 
   return result;
 }
 
 static double
 pr_min_internal (const Matrix& m)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   double result = DBL_MAX;
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	double val = m(i,j);
 	if (xisinf (val) || octave_is_NaN_or_NA (val))
 	  continue;
 
 	if (val < result)
 	  result = val;
       }
@@ -1258,17 +1258,17 @@ pr_complex (std::ostream& os, const Comp
 
 	  pr_imag_float (os, i, i_fw);
 	}
       os << "i";
     }
 }
 
 static void
-print_empty_matrix (std::ostream& os, int nr, int nc, bool pr_as_read_syntax)
+print_empty_matrix (std::ostream& os, octave_idx_type nr, octave_idx_type nc, bool pr_as_read_syntax)
 {
   assert (nr == 0 || nc == 0);
 
   if (pr_as_read_syntax)
     {
       if (nr == 0 && nc == 0)
 	os << "[]";
       else
@@ -1313,30 +1313,30 @@ pr_scale_header (std::ostream& os, doubl
 	 << " *\n";
 
       if (! compact_format)
 	os << "\n";
     }
 }
 
 static void
-pr_col_num_header (std::ostream& os, int total_width, int max_width,
-		   int lim, int col, int extra_indent)
+pr_col_num_header (std::ostream& os, octave_idx_type total_width, int max_width,
+		   octave_idx_type lim, octave_idx_type col, int extra_indent)
 {
   if (total_width > max_width && Vsplit_long_rows)
     {
       if (col != 0)
 	{
 	  if (compact_format)
 	    os << "\n";
 	  else
 	    os << "\n\n";
 	}
 
-      int num_cols = lim - col;
+      octave_idx_type num_cols = lim - col;
 
       os << std::setw (extra_indent) << "";
 
       if (num_cols == 1)
 	os << " Column " << col + 1 << ":\n";
       else if (num_cols == 2)
 	os << " Columns " << col + 1 << " and " << lim << ":\n";
       else
@@ -1376,44 +1376,44 @@ octave_print_internal (std::ostream& os,
 	pr_float (os, d);
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const Matrix& m,
 		       bool pr_as_read_syntax, int extra_indent)
 {
-  int nr = m.rows ();
-  int nc = m.columns ();
+  octave_idx_type nr = m.rows ();
+  octave_idx_type nc = m.columns ();
 
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  for (int j = 0; j < nc; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 
 	      pr_plus_format (os, m(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
 	}
     }
   else
     {
       int fw;
       double scale = 1.0;
       set_format (m, fw, scale);
       int column_width = fw + 2;
-      int total_width = nc * column_width;
-      int max_width = command_editor::terminal_cols ();
+      octave_idx_type total_width = nc * column_width;
+      octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
 	max_width -= 4;
       else
 	max_width -= extra_indent;
 
       if (max_width < 0)
 	max_width = 0;
@@ -1426,34 +1426,34 @@ octave_print_internal (std::ostream& os,
 	  os << m;
 
 	  if (pr_as_read_syntax)
 	    os << "]";
 
 	  return;
 	}
 
-      int inc = nc;
+      octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
 	{
 	  inc = max_width / column_width;
 	  if (inc == 0)
 	    inc++;
 	}
 
       if (pr_as_read_syntax)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      int col = 0;
+	      octave_idx_type col = 0;
 	      while (col < nc)
 		{
-		  int lim = col + inc < nc ? col + inc : nc;
-
-		  for (int j = col; j < lim; j++)
+		  octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+		  for (octave_idx_type j = col; j < lim; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (i == 0 && j == 0)
 			os << "[ ";
 		      else
 			{
 			  if (j > col && j < lim)
@@ -1478,28 +1478,28 @@ octave_print_internal (std::ostream& os,
 		    os << " ...\n";
 		}
 	    }
 	}
       else
 	{
 	  pr_scale_header (os, scale);
 
-	  for (int col = 0; col < nc; col += inc)
+	  for (octave_idx_type col = 0; col < nc; col += inc)
 	    {
-	      int lim = col + inc < nc ? col + inc : nc;
+	      octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
 	      pr_col_num_header (os, total_width, max_width, lim, col,
 				 extra_indent);
 
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
-		  for (int j = col; j < lim; j++)
+		  for (octave_idx_type j = col; j < lim; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      os << "  ";
 
 		      pr_float (os, m(i,j), fw, scale);
 		    }
 
@@ -1518,27 +1518,27 @@ octave_print_internal (std::ostream& os,
         print_empty_nd_array (os, nda.dims (), pr_as_read_syntax); \
       else \
         { \
  \
           int ndims = nda.ndims (); \
  \
           dim_vector dims = nda.dims (); \
  \
-          Array<int> ra_idx (ndims, 0); \
+          Array<octave_idx_type> ra_idx (ndims, 0); \
  \
-          int m = 1; \
+          octave_idx_type m = 1; \
  \
           for (int i = 2; i < ndims; i++) \
             m *= dims(i); \
  \
-          int nr = dims(0); \
-          int nc = dims(1); \
+          octave_idx_type nr = dims(0); \
+          octave_idx_type nc = dims(1); \
  \
-          for (int i = 0; i < m; i++) \
+          for (octave_idx_type i = 0; i < m; i++) \
             { \
 	      OCTAVE_QUIT; \
  \
               std::string nm = "ans"; \
  \
               if (m > 1) \
                 { \
                   nm += "(:,:,"; \
@@ -1637,26 +1637,26 @@ octave_print_internal (std::ostream& os,
 	pr_complex (os, c);
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const ComplexMatrix& cm,
 		       bool pr_as_read_syntax, int extra_indent)
 {
-  int nr = cm.rows ();
-  int nc = cm.columns ();
+  octave_idx_type nr = cm.rows ();
+  octave_idx_type nc = cm.columns ();
 
  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
-	  for (int j = 0; j < nc; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      OCTAVE_QUIT;
 
 	      pr_plus_format (os, cm(i,j));
 	    }
 
 	  if (i < nr - 1)
 	    os << "\n";
@@ -1664,18 +1664,18 @@ octave_print_internal (std::ostream& os,
     }
   else
     {
       int r_fw, i_fw;
       double scale = 1.0;
       set_format (cm, r_fw, i_fw, scale);
       int column_width = i_fw + r_fw;
       column_width += (bank_format || hex_format|| bit_format) ? 2 : 7;
-      int total_width = nc * column_width;
-      int max_width = command_editor::terminal_cols ();
+      octave_idx_type total_width = nc * column_width;
+      octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
 	max_width -= 4;
       else
 	max_width -= extra_indent;
 
       if (max_width < 0)
 	max_width = 0;
@@ -1688,34 +1688,34 @@ octave_print_internal (std::ostream& os,
 	  os << cm;
 
 	  if (pr_as_read_syntax)
 	    os << "]";
 
 	  return;
 	}
 
-      int inc = nc;
+      octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
 	{
 	  inc = max_width / column_width;
 	  if (inc == 0)
 	    inc++;
 	}
 
       if (pr_as_read_syntax)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
-	      int col = 0;
+	      octave_idx_type col = 0;
 	      while (col < nc)
 		{
-		  int lim = col + inc < nc ? col + inc : nc;
-
-		  for (int j = col; j < lim; j++)
+		  octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+		  for (octave_idx_type j = col; j < lim; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (i == 0 && j == 0)
 			os << "[ ";
 		      else
 			{
 			  if (j > col && j < lim)
@@ -1740,28 +1740,28 @@ octave_print_internal (std::ostream& os,
 		    os << " ...\n";
 		}
 	    }
 	}
       else
 	{
 	  pr_scale_header (os, scale);
 
-	  for (int col = 0; col < nc; col += inc)
+	  for (octave_idx_type col = 0; col < nc; col += inc)
 	    {
-	      int lim = col + inc < nc ? col + inc : nc;
+	      octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
 	      pr_col_num_header (os, total_width, max_width, lim, col,
 				 extra_indent);
 
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  os << std::setw (extra_indent) << "";
 
-		  for (int j = col; j < lim; j++)
+		  for (octave_idx_type j = col; j < lim; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      os << "  ";
 
 		      pr_complex (os, cm(i,j), r_fw, i_fw, scale);
 		    }
 
@@ -1793,21 +1793,21 @@ octave_print_internal (std::ostream& os,
 
 void
 octave_print_internal (std::ostream& os, const Range& r,
 		       bool pr_as_read_syntax, int extra_indent)
 {
   double base = r.base ();
   double increment = r.inc ();
   double limit = r.limit ();
-  int num_elem = r.nelem ();
+  octave_idx_type num_elem = r.nelem ();
 
   if (plus_format && ! pr_as_read_syntax)
     {
-      for (int i = 0; i < num_elem; i++)
+      for (octave_idx_type i = 0; i < num_elem; i++)
 	{
 	  OCTAVE_QUIT;
 
 	  double val = base + i * increment;
 
 	  pr_plus_format (os, val);
 	}
     }
@@ -1836,51 +1836,51 @@ octave_print_internal (std::ostream& os,
 		  os << " : ";
 		}
 	      pr_float (os, limit, fw);
 	    }
 	}
       else
 	{
 	  int column_width = fw + 2;
-	  int total_width = num_elem * column_width;
-	  int max_width = command_editor::terminal_cols ();
+	  octave_idx_type total_width = num_elem * column_width;
+	  octave_idx_type max_width = command_editor::terminal_cols ();
 
 	  if (free_format)
 	    {
 	      os << r;
 	      return;
 	    }
 
-	  int inc = num_elem;
+	  octave_idx_type inc = num_elem;
 	  if (total_width > max_width && Vsplit_long_rows)
 	    {
 	      inc = max_width / column_width;
 	      if (inc == 0)
 		inc++;
 	    }
 
 	  max_width -= extra_indent;
 
 	  if (max_width < 0)
 	    max_width = 0;
 
 	  pr_scale_header (os, scale);
 
-	  int col = 0;
+	  octave_idx_type col = 0;
 	  while (col < num_elem)
 	    {
-	      int lim = col + inc < num_elem ? col + inc : num_elem;
+	      octave_idx_type lim = col + inc < num_elem ? col + inc : num_elem;
 
 	      pr_col_num_header (os, total_width, max_width, lim, col,
 				 extra_indent);
 
 	      os << std::setw (extra_indent) << "";
 
-	      for (int i = col; i < lim; i++)
+	      for (octave_idx_type i = col; i < lim; i++)
 		{
 		  OCTAVE_QUIT;
 
 		  double val = base + i * increment;
 
 		  if (i == num_elem - 1)
 		    {
 		      // See the comments in Range::matrix_value.
@@ -1935,24 +1935,24 @@ octave_print_internal (std::ostream& os,
 void
 octave_print_internal (std::ostream& os, const charMatrix& chm,
 		       bool pr_as_read_syntax,
 		       int /* extra_indent XXX FIXME XXX */,
 		       bool pr_as_string)
 {
   if (pr_as_string)
     {
-      int nstr = chm.rows ();
+      octave_idx_type nstr = chm.rows ();
 
       if (pr_as_read_syntax && nstr > 1)
 	os << "[ ";
 
       if (nstr != 0)
 	{
-	  for (int i = 0; i < nstr; i++)
+	  for (octave_idx_type i = 0; i < nstr; i++)
 	    {
 	      OCTAVE_QUIT;
 
 	      std::string row = chm.row_as_string (i);
 
 	      if (pr_as_read_syntax)
 		{
 		  os << "\"" << undo_string_escapes (row) << "\"";
@@ -2021,27 +2021,27 @@ octave_print_internal (std::ostream& os,
       os << nda(0);
     }
   else
     {
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
 
-      Array<int> ra_idx (ndims, 0);
-
-      int m = 1;
+      Array<octave_idx_type> ra_idx (ndims, 0);
+
+      octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
 	m *= dims(i);
 
-      int nr = dims(0);
-      int nc = dims(1);
-
-      for (int i = 0; i < m; i++)
+      octave_idx_type nr = dims(0);
+      octave_idx_type nc = dims(1);
+
+      for (octave_idx_type i = 0; i < m; i++)
 	{
 	  std::string nm = "ans";
 
 	  if (m > 1)
 	    {
 	      nm += "(:,:,";
 
 	      OSSTREAM buf;
@@ -2071,24 +2071,24 @@ octave_print_internal (std::ostream& os,
 	  for (int k = 2; k < ndims; k++)
 	    idx(k) = idx_vector (ra_idx(k) + 1);
 
 	  Array2<std::string> page (nda.index (idx), nr, nc);
 
 	  // XXX FIXME XXX -- need to do some more work to put these
 	  // in neatly aligned columns...
 
-	  int n_rows = page.rows ();
-	  int n_cols = page.cols ();
+	  octave_idx_type n_rows = page.rows ();
+	  octave_idx_type n_cols = page.cols ();
 
 	  os << nm << " =\n\n";
 
-	  for (int ii = 0; ii < n_rows; ii++)
+	  for (octave_idx_type ii = 0; ii < n_rows; ii++)
 	    {
-	      for (int jj = 0; jj < n_cols; jj++)
+	      for (octave_idx_type jj = 0; jj < n_cols; jj++)
 		os << "  " << page(ii,jj);
 
 	      os << "\n";
 	    }
 
 	  if (i < m - 1)
 	    os << "\n";
 
@@ -2182,29 +2182,29 @@ octave_print_internal (std::ostream& os,
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     octave_print_internal (os, nda (0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       int ndims = nda.ndims ();
 
-      Array<int> ra_idx (ndims, 0);
+      Array<octave_idx_type> ra_idx (ndims, 0);
 
       dim_vector dims = nda.dims ();
 
-      int m = 1;
+      octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
 	m *= dims(i);
 
-      int nr = dims(0);
-      int nc = dims(1);
-
-      for (int i = 0; i < m; i++)
+      octave_idx_type nr = dims(0);
+      octave_idx_type nc = dims(1);
+
+      for (octave_idx_type i = 0; i < m; i++)
 	{
 	  if (m > 1)
 	    {
 	      std::string nm = "ans(:,:,";
 
 	      OSSTREAM buf;
 
 	      for (int k = 2; k < ndims; k++)
@@ -2231,19 +2231,19 @@ octave_print_internal (std::ostream& os,
 	  idx(0) = idx_vector (':');
 	  idx(1) = idx_vector (':');
 
 	  for (int k = 2; k < ndims; k++)
 	    idx(k) = idx_vector (ra_idx(k) + 1);
 
 	  Array2<T> page (nda.index (idx), nr, nc);
 
-	  for (int ii = 0; ii < nr; ii++)
+	  for (octave_idx_type ii = 0; ii < nr; ii++)
 	    {
-	      for (int jj = 0; jj < nc; jj++)
+	      for (octave_idx_type jj = 0; jj < nc; jj++)
 		{
 		  OCTAVE_QUIT;
 
 		  pr_plus_format (os, page(ii,jj));
 		}
 
 	      if ((ii < nr - 1) || (i < m -1))
 		os << "\n";
@@ -2257,63 +2257,63 @@ octave_print_internal (std::ostream& os,
 	}
     }
   else
     {
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
 
-      Array<int> ra_idx (ndims, 0);
-
-      int m = 1;
+      Array<octave_idx_type> ra_idx (ndims, 0);
+
+      octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
 	m *= dims(i);
 
-      int nr = dims(0);
-      int nc = dims(1);
+      octave_idx_type nr = dims(0);
+      octave_idx_type nc = dims(1);
 
       int fw = 0;
       if (hex_format)
 	fw = 2 * nda(0).byte_size ();
       else if (bit_format)
 	fw = nda(0).nbits ();
       else
 	{
 	  bool isneg = false;
 	  int digits = 0;
 
-	  for (int i = 0; i < dims.numel (); i++)
+	  for (octave_idx_type i = 0; i < dims.numel (); i++)
 	    {
 	      int new_digits = static_cast<int> 
 		(floor (log10 (double (abs (nda(i).value ()))) + 1.0));
 
 	      if (new_digits > digits)
 		digits = new_digits;
 
 	      if (! isneg)
 	      isneg = (abs (nda(i).value ()) != nda(i).value ());
 	    }
 
 	  fw = digits + isneg;
 	}
 
       int column_width = fw + (bank_format ? 5 : 2);
-      int total_width = nc * column_width;
+      octave_idx_type total_width = nc * column_width;
       int max_width = command_editor::terminal_cols () - extra_indent;
-      int inc = nc;
+      octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
 	{
 	  inc = max_width / column_width;
 	  if (inc == 0)
 	    inc++;
 	}
 
-      for (int i = 0; i < m; i++)
+      for (octave_idx_type i = 0; i < m; i++)
 	{
 	  if (m > 1)
 	    {
 	      std::string nm = "ans(:,:,";
 
 	      OSSTREAM buf;
 
 	      for (int k = 2; k < ndims; k++)
@@ -2345,47 +2345,47 @@ octave_print_internal (std::ostream& os,
 
 	  Array2<T> page (nda.index (idx), nr, nc);
 
 	  if (free_format)
 	    {
 	      if (pr_as_read_syntax)
 		os << "[\n";
 
-	      for (int ii = 0; ii < nr; ii++)
+	      for (octave_idx_type ii = 0; ii < nr; ii++)
 		{
-		  for (int jj = 0; jj < nc; jj++)
+		  for (octave_idx_type jj = 0; jj < nc; jj++)
 		    {
 		      OCTAVE_QUIT;
 		      os << "  ";
 		      os << typename octave_print_conv<T>::print_conv_type (page(ii,jj));
 		    }
 		  os << "\n";
 		}
 
 	      if (pr_as_read_syntax)
 		os << "]";
 	    }
 	  else
 	    {
-	      int n_rows = page.rows ();
-	      int n_cols = page.cols ();
-
-	      for (int col = 0; col < n_cols; col += inc)
+	      octave_idx_type n_rows = page.rows ();
+	      octave_idx_type n_cols = page.cols ();
+
+	      for (octave_idx_type col = 0; col < n_cols; col += inc)
 		{
-		  int lim = col + inc < n_cols ? col + inc : n_cols;
+		  octave_idx_type lim = col + inc < n_cols ? col + inc : n_cols;
 
 		  pr_col_num_header (os, total_width, max_width, lim, col,
 				     extra_indent);
 
-		  for (int ii = 0; ii < n_rows; ii++)
+		  for (octave_idx_type ii = 0; ii < n_rows; ii++)
 		    {
 		      os << std::setw (extra_indent) << "";
 		      
-		      for (int jj = col; jj < lim; jj++)
+		      for (octave_idx_type jj = col; jj < lim; jj++)
 			{
 			  OCTAVE_QUIT;
 			  os << "  ";
 			  pr_int (os, page(ii,jj), fw);
 			}
 		      if ((ii < n_rows - 1) || (i < m -1))
 			os << "\n";
 		    }
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -120,17 +120,17 @@ DEFCONSTFUN (__end__, , ,
   if (indexed_object)
     {
       dim_vector dv = indexed_object->dims ();
 
       switch (index_position)
 	{
 	case -1:
 	  {
-	    int numel = dv.numel ();
+	    octave_idx_type numel = dv.numel ();
 
 	    if (numel < 0)
 	      {
 		std::string dv_str = dv.str ();
 		::error ("invalid use of end: (index 1, dims %s)",
 			 dv_str.c_str ());
 	      }
 	    else
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -41,18 +41,18 @@ Software Foundation, 59 Temple Place - S
 
 octave_value
 tree_cell::rvalue (void)
 {
   octave_value retval;
 
   MAYBE_DO_BREAKPOINT;
 
-  int nr = length ();
-  int nc = -1;
+  octave_idx_type nr = length ();
+  octave_idx_type nc = -1;
 
   Cell val;
 
   int i = 0;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_argument_list *elt = *p;
@@ -62,26 +62,26 @@ tree_cell::rvalue (void)
       if (nc < 0)
 	{
 	  nc = row.length ();
 
 	  val = Cell (nr, nc);
 	}
       else
 	{
-	  int this_nc = row.length ();
+	  octave_idx_type this_nc = row.length ();
 
 	  if (nc != this_nc)
 	    {
 	      ::error ("number of columns must match");
 	      return retval;
 	    }
 	}
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	val(i,j) = row(j);
 
       i++;
     }
 
   retval = val;
 
   return retval;
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -237,21 +237,21 @@ tree_simple_for_command::do_for_loop_onc
     } \
   while (0)
 
 #define DO_ND_LOOP(arg) \
   do \
     { \
       int ndims = dv.length (); \
       Array<idx_vector> idx; \
-      int steps = dv.numel () / dv (0); \
-      idx.resize (ndims, idx_vector (1)); \
+      octave_idx_type steps = dv.numel () / dv (0); \
+      idx.resize (ndims, idx_vector (static_cast<octave_idx_type> (1))); \
       idx (0) = idx_vector (':'); \
  \
-      for (int i = 0; i < steps; i++) \
+      for (octave_idx_type i = 0; i < steps; i++) \
 	{ \
 	  MAYBE_DO_BREAKPOINT; \
  \
 	  octave_value val (arg.index(idx)); \
  \
 	  bool quit = false; \
  \
 	  do_for_loop_once (ult, val, quit); \
@@ -261,17 +261,17 @@ tree_simple_for_command::do_for_loop_onc
 	    break; \
  \
 	  for (int j = 1; j < ndims; j++) \
 	    { \
 	      idx(j) = idx_vector (idx(j)(0) + 2); \
 	      if (idx(j)(0) < dv(j)) \
 		break; \
 	      else \
-		idx(j) = idx_vector (1); \
+		idx(j) = idx_vector (static_cast<octave_idx_type> (1)); \
 	    } \
 	} \
     } \
   while (0)
 
 void
 tree_simple_for_command::eval (void)
 {
@@ -300,21 +300,21 @@ tree_simple_for_command::eval (void)
 	eval_error ();
 	goto cleanup;
       }
 
     if (rhs.is_range ())
       {
 	Range rng = rhs.range_value ();
 
-	int steps = rng.nelem ();
+	octave_idx_type steps = rng.nelem ();
 	double b = rng.base ();
 	double increment = rng.inc ();
 
-	for (int i = 0; i < steps; i++)
+	for (octave_idx_type i = 0; i < steps; i++)
 	  {
 	    MAYBE_DO_BREAKPOINT;
 
 	    double tmp_val = b + i * increment;
 
 	    octave_value val (tmp_val);
 
 	    bool quit = false;
@@ -331,27 +331,27 @@ tree_simple_for_command::eval (void)
 
 	MAYBE_DO_BREAKPOINT;
 
 	do_for_loop_once (ult, rhs, quit);
       }
     else if (rhs.is_string ())
       {
 	charMatrix chm_tmp = rhs.char_matrix_value ();
-	int nr = chm_tmp.rows ();
-	int steps = chm_tmp.columns ();
+	octave_idx_type nr = chm_tmp.rows ();
+	octave_idx_type steps = chm_tmp.columns ();
 
 	if (error_state)
 	  goto cleanup;
 
 	if (nr == 1)
 	  DO_LOOP (chm_tmp (0, i));
 	else
 	  {
-	    for (int i = 0; i < steps; i++)
+	    for (octave_idx_type i = 0; i < steps; i++)
 	      {
 		MAYBE_DO_BREAKPOINT;
 
 		octave_value val (chm_tmp.extract (0, i, nr-1, i), true);
 
 		bool quit = false;
 
 		do_for_loop_once (ult, val, quit);
@@ -516,17 +516,17 @@ tree_complex_for_command::eval (void)
       Octave_map tmp_val (rhs.map_value ());
 
       for (Octave_map::iterator q = tmp_val.begin (); q != tmp_val.end (); q++)
 	{
 	  octave_value key = tmp_val.key (q);
 
 	  Cell val_lst = tmp_val.contents (q);
 
-	  int n = tmp_val.numel ();
+	  octave_idx_type n = tmp_val.numel ();
 
 	  octave_value val = (n == 1) ? val_lst(0) : octave_value (val_lst);
 
 	  MAYBE_DO_BREAKPOINT;
 
 	  bool quit = false;
 
 	  do_for_loop_once (key_ref, val_ref, key, val, quit);
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -135,20 +135,20 @@ public:
   }
 
   ~tm_row_const (void)
   {
     if (rep && --rep->count == 0)
       delete rep;
   }
 
-  int rows (void)
+  octave_idx_type rows (void)
   { return (rep->dv.length () > 0 ? rep->dv(0) : 0); }
 
-  int cols (void)
+  octave_idx_type cols (void)
   { return (rep->dv.length () > 1 ? rep->dv(1) : 0); }
 
   dim_vector dims (void) { return rep->dv; }
 
   bool all_strings_p (void) const { return rep->all_str; }
   bool some_strings_p (void) const { return rep->some_str; }
   bool complex_p (void) const { return rep->is_cmplx; }
   bool all_empty_p (void) const { return rep->all_mt; }
@@ -166,18 +166,18 @@ private:
   tm_row_const_rep *rep;
 };
 
 bool
 tm_row_const::tm_row_const_rep::do_init_element (tree_expression *elt,
 						 const octave_value& val,
 						 bool& first_elem)
 {
-  int this_elt_nr = val.rows ();
-  int this_elt_nc = val.columns ();
+  octave_idx_type this_elt_nr = val.rows ();
+  octave_idx_type this_elt_nc = val.columns ();
 
   dim_vector this_elt_dv = val.dims ();
 
   if (!this_elt_dv.all_zero ())
     {
       all_mt = false;
 
       if (first_elem)
@@ -267,17 +267,17 @@ tm_row_const::tm_row_const_rep::init (co
       if (error_state || tmp.is_undefined ())
 	break;
       else
 	{
 	  if (tmp.is_cs_list ())
 	    {
 	      octave_value_list tlst = tmp.list_value ();
 
-	      for (int i = 0; i < tlst.length (); i++)
+	      for (octave_idx_type i = 0; i < tlst.length (); i++)
 		{
 		  if (! do_init_element (elt, tlst(i), first_elem))
 		    goto done;
 		}
 	    }
 	  else
 	    {
 	      if (! do_init_element (elt, tmp, first_elem))
@@ -328,18 +328,18 @@ public:
 
   tm_const (const tree_matrix& tm)
     : dv (), all_str (false), some_str (false), is_cmplx (false),
       all_mt (true), ok (false)
       { init (tm); }
 
   ~tm_const (void) { }
 
-  int rows (void) const { return (dv.length () > 0 ? dv.elem (0) : 0); }
-  int cols (void) const { return (dv.length () > 1 ? dv.elem (1) : 0); }
+  octave_idx_type rows (void) const { return (dv.length () > 0 ? dv.elem (0) : 0); }
+  octave_idx_type cols (void) const { return (dv.length () > 1 ? dv.elem (1) : 0); }
 
   dim_vector dims (void) const { return dv; }
 
   bool all_strings_p (void) const { return all_str; }
   bool some_strings_p (void) const { return some_str; }
   bool complex_p (void) const { return is_cmplx; }
   bool all_empty_p (void) const { return all_mt; }
 
@@ -404,18 +404,18 @@ tm_const::init (const tree_matrix& tm)
     }
 
   if (! error_state)
     {
       for (iterator p = begin (); p != end (); p++)
 	{
 	  tm_row_const elt = *p;
 
-	  int this_elt_nr = elt.rows ();
-	  int this_elt_nc = elt.cols ();
+	  octave_idx_type this_elt_nr = elt.rows ();
+	  octave_idx_type this_elt_nc = elt.cols ();
 
 	  dim_vector this_elt_dv = elt.dims ();
 
 	  if (!this_elt_dv.all_zero ())
 	    {
 	      all_mt = false;
 
 	      if (first_elem)
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -147,19 +147,19 @@ tree_switch_case::label_matches (const o
   octave_value label_value = label->rvalue ();
 
   if (! error_state && label_value.is_defined() )
     {
       if (label_value.is_cell ())
 	{
 	  Cell cell (label_value.cell_value ());
 
-	  for (int i = 0; i < cell.rows (); i++)
+	  for (octave_idx_type i = 0; i < cell.rows (); i++)
 	    {
-	      for (int j = 0; j < cell.columns (); j++)
+	      for (octave_idx_type j = 0; j < cell.columns (); j++)
 		{
 		  bool match = equal (val, cell(i,j));
 
 		  if (error_state)
 		    {
 		      eval_error ();
 		      return false;
 		    }
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-spparms.h"
 #include "sparse-xdiv.h"
 
 static inline bool
-result_ok (int info)
+result_ok (octave_idx_type info)
 {
 #ifdef HAVE_LSSOLVE
   return (info != -2 && info != -1);
 #else
   // If the matrix is singular, who cares as we don't have QR based solver yet
   return (info != -1);
 #endif
 }
@@ -52,23 +52,23 @@ solve_singularity_warning (double rcond)
   warning ("matrix singular to machine precision, rcond = %g", rcond);
   warning ("attempting to find minimum norm solution");
 }
 
 template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b)
 {
-  int a_nr = a.rows ();
-  int b_nr = b.rows ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
-      int a_nc = a.cols ();
-      int b_nc = b.cols ();
+      octave_idx_type a_nc = a.cols ();
+      octave_idx_type b_nc = b.cols ();
 
       gripe_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
       return false;
     }
 
   return true;
 }
 
@@ -83,23 +83,23 @@ INSTANTIATE_MX_LEFTDIV_CONFORM (SparseMa
 INSTANTIATE_MX_LEFTDIV_CONFORM (SparseMatrix, ComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (SparseComplexMatrix, Matrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (SparseComplexMatrix, ComplexMatrix);
 
 template <class T1, class T2>
 bool
 mx_div_conform (const T1& a, const T2& b)
 {
-  int a_nc = a.cols ();
-  int b_nc = b.cols ();
+  octave_idx_type a_nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
-      int a_nr = a.rows ();
-      int b_nr = b.rows ();
+      octave_idx_type a_nr = a.rows ();
+      octave_idx_type b_nr = b.rows ();
 
       gripe_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
       return false;
     }
 
   return true;
 }
 
@@ -129,225 +129,225 @@ Matrix
 xdiv (const Matrix& a, const SparseMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   Matrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       Matrix result = btmp.solve (atmp, info, rcond, 
 				  solve_singularity_warning);
 
       if (result_ok (info))
 	return Matrix (result.transpose ());
     }
 
-  int rank;
+  octave_idx_type rank;
   Matrix result = btmp.lssolve (atmp, info, rank);
 
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xdiv (const Matrix& a, const SparseComplexMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   Matrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const SparseMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const SparseComplexMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // -*- 5 -*-
 SparseMatrix
 xdiv (const SparseMatrix& a, const SparseMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return SparseMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       SparseMatrix result = btmp.solve (atmp, info, rcond, 
 					solve_singularity_warning);
 
       if (result_ok (info))
 	return SparseMatrix (result.transpose ());
     }
 
-  int rank;
+  octave_idx_type rank;
   SparseMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.transpose ();
 }
 
 // -*- 6 -*-
 SparseComplexMatrix
 xdiv (const SparseMatrix& a, const SparseComplexMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
 xdiv (const SparseComplexMatrix& a, const SparseMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
 xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
@@ -355,84 +355,84 @@ xdiv (const SparseComplexMatrix& a, cons
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 Matrix
 x_el_div (double a, const SparseMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   Matrix result;
   if (a == 0.)
     result = Matrix (nr, nc, octave_NaN);
   else if (a > 0.)
     result = Matrix (nr, nc, octave_Inf);
   else
     result = Matrix (nr, nc, -octave_Inf);
 
 
-  for (int j = 0; j < nc; j++)
-    for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
 	OCTAVE_QUIT;
 	result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const SparseComplexMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   ComplexMatrix  result (nr, nc, Complex(octave_NaN, octave_NaN));
 
-  for (int j = 0; j < nc; j++)
-    for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
 	OCTAVE_QUIT;
 	result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
-  for (int j = 0; j < nc; j++)
-    for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
 	OCTAVE_QUIT;
 	result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseComplexMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
-  for (int j = 0; j < nc; j++)
-    for (int i = b.cidx(j); i < b.cidx(j+1); i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
 	OCTAVE_QUIT;
 	result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
@@ -451,190 +451,190 @@ x_el_div (const Complex a, const SparseC
 
 // -*- 1 -*-
 Matrix
 xleftdiv (const SparseMatrix& a, const Matrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return Matrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       Matrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xleftdiv (const SparseMatrix& a, const ComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 3 -*-
 SparseMatrix
 xleftdiv (const SparseMatrix& a, const SparseMatrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       SparseMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 4 -*-
 SparseComplexMatrix
 xleftdiv (const SparseMatrix& a, const SparseComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 5 -*-
 ComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const Matrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 6 -*-
 ComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const ComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const SparseMatrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -52,47 +52,47 @@ xisint (double x)
 // Safer pow functions. Only two make sense for sparse matrices, the
 // others should all promote to full matrices.
 
 octave_value
 xpow (const SparseMatrix& a, double b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
 	{
 	  int btmp = static_cast<int> (b);
 	  if (btmp == 0)
 	    {
 	      SparseMatrix tmp = SparseMatrix (nr, nr, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  tmp.data (i) = 1.0;
 		  tmp.ridx (i) = i;
 		}
-	      for (int i = 0; i < nr + 1; i++)
+	      for (octave_idx_type i = 0; i < nr + 1; i++)
 		tmp.cidx (i) = i;
 
 	      retval = tmp;
 	    }
 	  else
 	    {
 	      SparseMatrix atmp;
 	      if (btmp < 0)
 		{
 		  btmp = -btmp;
 
-		  int info;
+		  octave_idx_type info;
 		  double rcond = 0.0;
 
 		  atmp = a.inverse (info, rcond, 1);
 
 		  if (info == -1)
 		    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
 		}
@@ -124,47 +124,47 @@ xpow (const SparseMatrix& a, double b)
   return retval;
 }
 
 octave_value
 xpow (const SparseComplexMatrix& a, double b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
 	{
 	  int btmp = static_cast<int> (b);
 	  if (btmp == 0)
 	    {
 	      SparseMatrix tmp = SparseMatrix (nr, nr, nr);
-	      for (int i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  tmp.data (i) = 1.0;
 		  tmp.ridx (i) = i;
 		}
-	      for (int i = 0; i < nr + 1; i++)
+	      for (octave_idx_type i = 0; i < nr + 1; i++)
 		tmp.cidx (i) = i;
 
 	      retval = tmp;
 	    }
 	  else
 	    {
 	      SparseComplexMatrix atmp;
 	      if (btmp < 0)
 		{
 		  btmp = -btmp;
 
-		  int info;
+		  octave_idx_type info;
 		  double rcond = 0.0;
 
 		  atmp = a.inverse (info, rcond, 1);
 
 		  if (info == -1)
 		    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
 		}
@@ -226,69 +226,69 @@ xpow (const SparseComplexMatrix& a, doub
 // library...
 
 // -*- 1 -*-
 octave_value
 elem_xpow (double a, const SparseMatrix& b)
 {
   octave_value retval;
 
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   double d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result (i, j) = pow (atmp, b(i,j));
 	    }
 	}
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result (i, j) = pow (a, b(i,j));
 	    }
 	}
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
 octave_value
 elem_xpow (double a, const SparseComplexMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   Complex atmp (a);
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  result (i, j) = pow (atmp, b(i,j));
 	}
     }
 
   return result;
 }
@@ -298,62 +298,62 @@ octave_value
 elem_xpow (const SparseMatrix& a, double b)
 {
   // XXX FIXME XXX What should a .^ 0 give?? Matlab gives a 
   // sparse matrix with same structure as a, which is strictly
   // incorrect. Keep compatiability.
 
   octave_value retval;
 
-  int nz = a.nnz ();
+  octave_idx_type nz = a.nnz ();
 
   if (b <= 0.0)
     {
-      int nr = a.rows ();
-      int nc = a.cols ();
+      octave_idx_type nr = a.rows ();
+      octave_idx_type nc = a.cols ();
 
       if (static_cast<int> (b) != b && a.any_element_is_negative ())
 	{
 	  ComplexMatrix result (nr, nc, Complex (pow (0.0, b)));
 
 	  // XXX FIXME XXX -- avoid apparent GNU libm bug by
 	  // converting A and B to complex instead of just A.
 	  Complex btmp (b);
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
 		OCTAVE_QUIT;
 	      
 		Complex atmp (a.data (i));
 		
 		result (a.ridx(i), j) = pow (atmp, btmp);
 	      }
 
 	  retval = octave_value (result);
 	}
       else
 	{
 	  Matrix result (nr, nc, (pow (0.0, b)));
 
-	  for (int j = 0; j < nc; j++)
-	    for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
 		OCTAVE_QUIT;
 		result (a.ridx(i), j) = pow (a.data (i), b);
 	      }
 
 	  retval = octave_value (result);
 	}
     }
   else if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       SparseComplexMatrix result (a);
 
-      for (int i = 0; i < nz; i++)
+      for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  OCTAVE_QUIT;
 
 	  // XXX FIXME XXX -- avoid apparent GNU libm bug by
 	  // converting A and B to complex instead of just A.
 
 	  Complex atmp (a.data (i));
 	  Complex btmp (b);
@@ -364,17 +364,17 @@ elem_xpow (const SparseMatrix& a, double
       result.maybe_compress (true);
 
       retval = result;
     }
   else
     {
       SparseMatrix result (a);
 
-      for (int i = 0; i < nz; i++)
+      for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  OCTAVE_QUIT;
 	  result.data (i) = pow (a.data (i), b);
 	}
 
       result.maybe_compress (true);
 
       retval = result;
@@ -384,59 +384,59 @@ elem_xpow (const SparseMatrix& a, double
 }
 
 // -*- 4 -*-
 octave_value
 elem_xpow (const SparseMatrix& a, const SparseMatrix& b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	double atmp = a (i, j);
 	double btmp = b (i, j);
 	if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	  {
 	    convert_to_complex = 1;
 	    goto done;
 	  }
       }
 
 done:
 
-  int nel = 0;
-  for (int j = 0; j < nc; j++) 
-    for (int i = 0; i < nr; i++)
+  octave_idx_type nel = 0;
+  for (octave_idx_type j = 0; j < nc; j++) 
+    for (octave_idx_type i = 0; i < nr; i++)
       if (!(a.elem (i, j) == 0. && b.elem (i, j) != 0.))
 	nel++;
 
   if (convert_to_complex)
     {
       SparseComplexMatrix complex_result (nr, nc, nel);
 
-      int ii = 0;
+      octave_idx_type ii = 0;
       complex_result.cidx(0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      Complex atmp (a (i, j));
 	      Complex btmp (b (i, j));
 	      Complex tmp =  pow (atmp, btmp);
 	      if (tmp != 0.)
 		{
 		  complex_result.data (ii) = tmp;
@@ -447,22 +447,22 @@ done:
 	}
       complex_result.maybe_compress ();
 
       retval = complex_result;
     }
   else
     {
       SparseMatrix result (nr, nc, nel);
-      int ii = 0;
+      octave_idx_type ii = 0;
 
       result.cidx (0) = 0;
-      for (int j = 0; j < nc; j++)
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      double tmp = pow (a (i, j), b (i, j));
 	      if (tmp != 0.)
 		{
 		  result.data (ii) = tmp;
 		  result.ridx (ii++) = i;
 		}
@@ -484,20 +484,20 @@ elem_xpow (const SparseMatrix& a, const 
 {
   octave_value retval;
 
   if (b == 0.0)
     // Can this case ever happen, due to automatic retyping with maybe_mutate?
     retval = octave_value (NDArray (a.dims (), 1));
   else
     {
-      int nz = a.nnz ();
+      octave_idx_type nz = a.nnz ();
       SparseComplexMatrix result (a);
       
-      for (int i = 0; i < nz; i++)
+      for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  OCTAVE_QUIT;
 	  result.data (i) = pow (Complex (a.data (i)), b);
 	}
   
       result.maybe_compress (true);
 
       retval = result;
@@ -505,41 +505,41 @@ elem_xpow (const SparseMatrix& a, const 
 
   return retval;
 }
 
 // -*- 6 -*-
 octave_value
 elem_xpow (const SparseMatrix& a, const SparseComplexMatrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  int nel = 0;
-  for (int j = 0; j < nc; j++) 
-    for (int i = 0; i < nr; i++)
+  octave_idx_type nel = 0;
+  for (octave_idx_type j = 0; j < nc; j++) 
+    for (octave_idx_type i = 0; i < nr; i++)
       if (!(a.elem (i, j) == 0. && b.elem (i, j) != 0.))
 	nel++;
 
   SparseComplexMatrix result (nr, nc, nel);
-  int ii = 0;
+  octave_idx_type ii = 0;
 
   result.cidx(0) = 0;
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  Complex tmp = pow (Complex (a (i, j)), b (i, j));
 	  if (tmp != 0.)
 	    {
 	      result.data (ii) = tmp; 
 	      result.ridx (ii++) = i; 
 	    }
@@ -551,24 +551,24 @@ elem_xpow (const SparseMatrix& a, const 
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const SparseMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  double btmp = b (i, j);
 	  if (xisint (btmp))
 	    result (i, j) = pow (a, static_cast<int> (btmp));
 	  else
 	    result (i, j) = pow (a, btmp);
 	}
@@ -576,82 +576,82 @@ elem_xpow (const Complex& a, const Spars
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const SparseComplexMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = pow (a, b (i, j));
       }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const SparseComplexMatrix& a, double b)
 {
   octave_value retval;
 
   if (b <= 0)
     {
-      int nr = a.rows ();
-      int nc = a.cols ();
+      octave_idx_type nr = a.rows ();
+      octave_idx_type nc = a.cols ();
 
       ComplexMatrix result (nr, nc, Complex (pow (0.0, b)));
 
       if (xisint (b))
 	{
-	  for (int j = 0; j < nc; j++)
-	    for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
 		OCTAVE_QUIT;
 		result (a.ridx(i), j) = 
 		  pow (a.data (i), static_cast<int> (b));
 	      }
 	}
       else
 	{
-	  for (int j = 0; j < nc; j++)
-	    for (int i = a.cidx(j); i < a.cidx(j+1); i++)
+	  for (octave_idx_type j = 0; j < nc; j++)
+	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 	      {
 		OCTAVE_QUIT;
 		result (a.ridx(i), j) = pow (a.data (i), b);
 	      }
 	}  
 
       retval = result;
     }
   else
     {
-      int nz = a.nnz ();
+      octave_idx_type nz = a.nnz ();
 
       SparseComplexMatrix result (a);
   
       if (xisint (b))
 	{
-	  for (int i = 0; i < nz; i++)
+	  for (octave_idx_type i = 0; i < nz; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result.data (i) = pow (a.data (i), static_cast<int> (b));
 	    }
 	}
       else
 	{
-	  for (int i = 0; i < nz; i++)
+	  for (octave_idx_type i = 0; i < nz; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result.data (i) = pow (a.data (i), b);
 	    }
 	}  
 
       result.maybe_compress (true);
 
@@ -660,41 +660,41 @@ elem_xpow (const SparseComplexMatrix& a,
 
   return retval;
 }
 
 // -*- 10 -*-
 octave_value
 elem_xpow (const SparseComplexMatrix& a, const SparseMatrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  int nel = 0;
-  for (int j = 0; j < nc; j++) 
-    for (int i = 0; i < nr; i++)
+  octave_idx_type nel = 0;
+  for (octave_idx_type j = 0; j < nc; j++) 
+    for (octave_idx_type i = 0; i < nr; i++)
       if (!(a.elem (i, j) == 0. && b.elem (i, j) != 0.))
 	nel++;
 
   SparseComplexMatrix result (nr, nc, nel);
-  int ii = 0;
+  octave_idx_type ii = 0;
 
   result.cidx (0) = 0;
-  for (int j = 0; j < nc; j++)
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  double btmp = b (i, j);
 	  Complex tmp;
 
 	  if (xisint (btmp))
 	    tmp = pow (a (i, j), static_cast<int> (btmp));
 	  else
@@ -720,21 +720,21 @@ elem_xpow (const SparseComplexMatrix& a,
   octave_value retval;
 
   if (b == 0.0)
     // Can this case ever happen, due to automatic retyping with maybe_mutate?
     retval = octave_value (NDArray (a.dims (), 1));
   else
     {
 
-      int nz = a.nnz ();
+      octave_idx_type nz = a.nnz ();
 
       SparseComplexMatrix result (a);
 
-      for (int i = 0; i < nz; i++)
+      for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  OCTAVE_QUIT;
 	  result.data (i) = pow (a.data (i), b);
 	}
 
       result.maybe_compress (true);
       
       retval = result;
@@ -742,41 +742,41 @@ elem_xpow (const SparseComplexMatrix& a,
 
   return retval;
 }
 
 // -*- 12 -*-
 octave_value
 elem_xpow (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  int nel = 0;
-  for (int j = 0; j < nc; j++) 
-    for (int i = 0; i < nr; i++)
+  octave_idx_type nel = 0;
+  for (octave_idx_type j = 0; j < nc; j++) 
+    for (octave_idx_type i = 0; i < nr; i++)
       if (!(a.elem (i, j) == 0. && b.elem (i, j) != 0.))
 	nel++;
 
   SparseComplexMatrix result (nr, nc, nel);
-  int ii = 0;
+  octave_idx_type ii = 0;
 
   result.cidx (0) = 0;
-  for (int j = 0; j < nc; j++) 
+  for (octave_idx_type j = 0; j < nc; j++) 
     {
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
 	  Complex tmp = pow (a (i, j), b (i, j));
 	  if (tmp != 0.)
 	    {
 	      result.data (ii) = tmp;
 	      result.ridx (ii++) = i;
 	    }
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -168,27 +168,27 @@ private:
       { return eternal; }
 
     bool is_matrix_type (void) const 
       { return definition.is_matrix_type (); }
 
     size_t byte_size (void) const
       { return definition.byte_size (); };
 
-    int numel (void) const
+    octave_idx_type numel (void) const
       { return definition.numel (); };
 
-    int capacity (void) const
+    octave_idx_type capacity (void) const
       { return definition.capacity (); };
 
     dim_vector dims (void) const 
       { return definition.dims (); }
 
-    int rows (void) const { return definition.rows (); }
-    int columns (void) const { return definition.columns (); }
+    octave_idx_type rows (void) const { return definition.rows (); }
+    octave_idx_type columns (void) const { return definition.columns (); }
 
     std::string type_name (void) const { return definition.type_name (); }
 
     std::string type_as_string (void) const;
 
     void type (std::ostream& os, const std::string& name, bool pr_type_info,
 	       bool quiet, bool pr_orig_txt);
 
@@ -375,32 +375,32 @@ public:
   void unmark_static (void) { tagged_static = false; }
 
   bool is_matrix_type (void) const 
     { return definition->is_matrix_type (); }
 
   size_t byte_size (void) const
     { return definition->byte_size (); };
 
-  int numel (void) const
+  octave_idx_type numel (void) const
     { return definition->numel (); };
 
-  int capacity (void) const
+  octave_idx_type capacity (void) const
     { return definition->capacity (); };
 
   dim_vector dims (void) const { return definition->dims (); }
 
   int dimensions_string_req_first_space (int print_dims) const;
 
   int dimensions_string_req_total_space (int print_dims) const;
 
   std::string make_dimensions_string (int print_dims) const;
 
-  int rows (void) const { return definition->rows (); }
-  int columns (void) const { return definition->columns (); }
+  octave_idx_type rows (void) const { return definition->rows (); }
+  octave_idx_type columns (void) const { return definition->columns (); }
 
   std::string type_name (void) const { return definition->type_name (); }
 
   std::string type_as_string (void) const
     { return definition->type_as_string (); }
 
   void type (std::ostream& os, bool pr_type_info, bool quiet, bool pr_orig_txt)
     { definition->type (os, name (), pr_type_info, quiet, pr_orig_txt); }
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -684,16 +684,17 @@ specified option.\n\
       "SHLEXT", OCTAVE_CONF_SHLEXT,
       "SHLEXT_VER", OCTAVE_CONF_SHLEXT_VER,
       "SH_LD", OCTAVE_CONF_SH_LD,
       "SH_LDFLAGS", OCTAVE_CONF_SH_LDFLAGS,
       "SONAME_FLAGS", OCTAVE_CONF_SONAME_FLAGS,
       "STATIC_LIBS", OCTAVE_CONF_STATIC_LIBS,
       "DEFS", OCTAVE_CONF_DEFS,
       "UGLY_DEFS", OCTAVE_CONF_UGLY_DEFS,
+      "USE_64_BIT_IDX_T", OCTAVE_CONF_USE_64_BIT_IDX_T,
       "ENABLE_DYNAMIC_LINKING", OCTAVE_CONF_ENABLE_DYNAMIC_LINKING,
       "XTRA_CFLAGS", OCTAVE_CONF_XTRA_CFLAGS,
       "XTRA_CXXFLAGS", OCTAVE_CONF_XTRA_CXXFLAGS,
       "YACC", OCTAVE_CONF_YACC,
       "YFLAGS", OCTAVE_CONF_YFLAGS,
       "archlibdir", OCTAVE_ARCHLIBDIR,
       "bindir", OCTAVE_BINDIR,
       "canonical_host_type", OCTAVE_CANONICAL_HOST_TYPE,
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -224,17 +224,17 @@ keyword_almost_match (const char * const
 
   return status;
 }
 
 // Return non-zero if either NR or NC is zero.  Return -1 if this
 // should be considered fatal; return 1 if this is ok.
 
 int
-empty_arg (const char * /* name */, int nr, int nc)
+empty_arg (const char * /* name */, octave_idx_type nr, octave_idx_type nc)
 {
   return (nr == 0 || nc == 0);
 }
 
 // See if the given file is in the path.
 
 std::string
 search_path_for_file (const std::string& path, const string_vector& names)
@@ -750,17 +750,17 @@ check_preference (const std::string& var
 	  pref = 0;
 	}
     }
 
   return pref;
 }
 
 static void
-check_dimensions (int& nr, int& nc, const char *warnfor)
+check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
       if (Vwarn_neg_dim_as_zero)
 	warning ("%s: converting negative dimension to zero", warnfor);
 
       nr = (nr < 0) ? 0 : nr;
       nc = (nc < 0) ? 0 : nc;
@@ -793,43 +793,43 @@ get_dimensions (const octave_value& a, c
   if (a.is_scalar_type ())
     {
       dim.resize (2);
       dim(0) = a.int_value ();
       dim(1) = dim(0);
     }
   else
     {
-      int nr = a.rows ();
-      int nc = a.columns ();
+      octave_idx_type nr = a.rows ();
+      octave_idx_type nc = a.columns ();
 
       if (nr == 1 || nc == 1)
         {
           Array<double> v = a.vector_value ();
 
           if (error_state)
             return;
 
-          int n = v.length ();
+          octave_idx_type n = v.length ();
           dim.resize (n);
-          for (int i = 0; i < n; i++)
+          for (octave_idx_type i = 0; i < n; i++)
             dim(i) = static_cast<int> (fix (v(i)));
         }
       else
         error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
     }
 
   if (! error_state)
     check_dimensions (dim, warn_for); // May set error_state.
 }
 
 
 void
 get_dimensions (const octave_value& a, const char *warn_for,
-		int& nr, int& nc)
+		octave_idx_type& nr, octave_idx_type& nc)
 {
   if (a.is_scalar_type ())
     {
       nr = nc = a.int_value ();
     }
   else
     {
       nr = a.rows ();
@@ -837,50 +837,50 @@ get_dimensions (const octave_value& a, c
 
       if ((nr == 1 && nc == 2) || (nr == 2 && nc == 1))
 	{
 	  Array<double> v = a.vector_value ();
 
 	  if (error_state)
 	    return;
 
-	  nr = static_cast<int> (fix (v (0)));
-	  nc = static_cast<int> (fix (v (1)));
+	  nr = static_cast<octave_idx_type> (fix (v (0)));
+	  nc = static_cast<octave_idx_type> (fix (v (1)));
 	}
       else
 	error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
     }
 
   if (! error_state)
     check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
 void
 get_dimensions (const octave_value& a, const octave_value& b,
-		const char *warn_for, int& nr, int& nc)
+		const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
 {
   nr = a.is_empty () ? 0 : a.int_value ();
   nc = b.is_empty () ? 0 : b.int_value ();
 
   if (error_state)
     error ("%s: expecting two scalar arguments", warn_for);
   else
     check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
 Matrix
-identity_matrix (int nr, int nc)
+identity_matrix (octave_idx_type nr, octave_idx_type nc)
 {
   Matrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
-      int n = std::min (nr, nc);
+      octave_idx_type n = std::min (nr, nc);
 
-      for (int i = 0; i < n; i++)
+      for (octave_idx_type i = 0; i < n; i++)
 	m (i, i) = 1.0;
     }
 
   return m;
 }
 
 extern int
 octave_format (std::ostream& os, const char *fmt, ...)
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -41,17 +41,17 @@ extern bool valid_identifier (const std:
 extern int almost_match (const std::string& std, const std::string& s,
 			 int min_match_len = 1, int case_sens = 1);
 
 extern int
 keyword_almost_match (const char * const *std, int *min_len,
 		      const std::string& s, int min_toks_to_match,
 		      int max_toks);
 
-extern int empty_arg (const char *name, int nr, int nc);
+extern int empty_arg (const char *name, octave_idx_type nr, octave_idx_type nc);
 
 extern std::string
 search_path_for_file (const std::string&, const string_vector&);
 
 extern string_vector
 search_path_for_all_files (const std::string&, const string_vector&);
 
 extern std::string file_in_path (const std::string&, const std::string&);
@@ -70,23 +70,23 @@ extern void
 check_dimensions (dim_vector& dim, const char *warnfor);
 
 extern void
 get_dimensions (const octave_value& a, const char *warn_for,
                 dim_vector& dim);
 
 extern void
 get_dimensions (const octave_value& a, const octave_value& b,
-		const char *warn_for, int& nr, int& nc);
+		const char *warn_for, octave_idx_type& nr, octave_idx_type& nc);
 
 extern void
 get_dimensions (const octave_value& a,
-		const char *warn_for, int& nr, int& nc);
+		const char *warn_for, octave_idx_type& nr, octave_idx_type& nc);
 
-extern Matrix identity_matrix (int nr, int nc);
+extern Matrix identity_matrix (octave_idx_type nr, octave_idx_type nc);
 
 extern int
 octave_format (std::ostream& os, const char *fmt, ...);
 
 extern int
 octave_vformat (std::ostream& os, const char *fmt, va_list args);
 
 extern char *octave_vsnprintf (const char *fmt, va_list args);
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "dNDArray.h"
 #include "oct-cmplx.h"
 #include "quit.h"
 
 #include "error.h"
 #include "xdiv.h"
 
 static inline bool
-result_ok (int info)
+result_ok (octave_idx_type info)
 {
   assert (info != -1);
 
   return (info != -2);
 }
 
 static void
 solve_singularity_warning (double rcond)
@@ -51,23 +51,23 @@ solve_singularity_warning (double rcond)
   warning ("matrix singular to machine precision, rcond = %g", rcond);
   warning ("attempting to find minimum norm solution");
 }
 
 template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b)
 {
-  int a_nr = a.rows ();
-  int b_nr = b.rows ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
-      int a_nc = a.cols ();
-      int b_nc = b.cols ();
+      octave_idx_type a_nc = a.cols ();
+      octave_idx_type b_nc = b.cols ();
 
       gripe_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
       return false;
     }
 
   return true;
 }
 
@@ -78,23 +78,23 @@ INSTANTIATE_MX_LEFTDIV_CONFORM (Matrix, 
 INSTANTIATE_MX_LEFTDIV_CONFORM (Matrix, ComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (ComplexMatrix, Matrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (ComplexMatrix, ComplexMatrix);
 
 template <class T1, class T2>
 bool
 mx_div_conform (const T1& a, const T2& b)
 {
-  int a_nc = a.cols ();
-  int b_nc = b.cols ();
+  octave_idx_type a_nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
-      int a_nr = a.rows ();
-      int b_nr = b.rows ();
+      octave_idx_type a_nr = a.rows ();
+      octave_idx_type b_nr = b.rows ();
 
       gripe_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
       return false;
     }
 
   return true;
 }
 
@@ -120,113 +120,113 @@ Matrix
 xdiv (const Matrix& a, const Matrix& b)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   Matrix atmp = a.transpose ();
   Matrix btmp = b.transpose ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       Matrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return Matrix (result.transpose ());
     }
 
-  int rank;
+  octave_idx_type rank;
   Matrix result = btmp.lssolve (atmp, info, rank);
 
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xdiv (const Matrix& a, const ComplexMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   Matrix atmp = a.transpose ();
   ComplexMatrix btmp = b.hermitian ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const Matrix& b)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   Matrix btmp = b.transpose ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   ComplexMatrix btmp = b.hermitian ();
 
-  int info;
+  octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result.hermitian ();
     }
 
-  int rank;
+  octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return result.hermitian ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
@@ -234,77 +234,77 @@ xdiv (const ComplexMatrix& a, const Comp
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 Matrix
 x_el_div (double a, const Matrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.columns ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.columns ();
 
   Matrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const ComplexMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.columns ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const Matrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.columns ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const ComplexMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.columns ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
@@ -317,59 +317,59 @@ x_el_div (const Complex a, const Complex
 //   complex N-d array | 2 |  4 |
 //                     +---+----+
 
 NDArray
 x_el_div (double a, const NDArray& b)
 {
   NDArray result (b.dims ());
 
-  for (int i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (double a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (int i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (const Complex a, const NDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (int i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
       result (i) = a / b (i);
     }
 
   return result;
 }
 
 ComplexNDArray
 x_el_div (const Complex a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
 
-  for (int i = 0; i < b.length (); i++)
+  for (octave_idx_type i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
       result (i) = a / b (i);
     }
 
   return result;
 }
 
@@ -384,98 +384,98 @@ x_el_div (const Complex a, const Complex
 
 // -*- 1 -*-
 Matrix
 xleftdiv (const Matrix& a, const Matrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return Matrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       Matrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xleftdiv (const Matrix& a, const ComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 3 -*-
 ComplexMatrix
 xleftdiv (const ComplexMatrix& a, const Matrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 4 -*-
 ComplexMatrix
 xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
-  int info;
+  octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
 	= a.solve (b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
-  int rank;
+  octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -38,16 +38,20 @@ Software Foundation, 59 Temple Place - S
 #include "oct-cmplx.h"
 #include "quit.h"
 
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "xpow.h"
 
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
 	  && ((x >= 0 && x < INT_MAX)
 	      || (x <= 0 && x > INT_MIN)));
 }
 
@@ -79,28 +83,28 @@ xpow (double a, double b)
 }
 
 // -*- 2 -*-
 octave_value
 xpow (double a, const Matrix& b)
 {
   octave_value retval;
 
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  Complex elt = lambda (i);
 	  if (std::imag (elt) == 0.0)
 	    lambda (i) = std::pow (a, std::real (elt));
 	  else
 	    lambda (i) = std::pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
@@ -122,28 +126,28 @@ xpow (double a, const Complex& b)
 }
 
 // -*- 4 -*-
 octave_value
 xpow (double a, const ComplexMatrix& b)
 {
   octave_value retval;
 
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  Complex elt = lambda (i);
 	  if (std::imag (elt) == 0.0)
 	    lambda (i) = std::pow (a, std::real (elt));
 	  else
 	    lambda (i) = std::pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
@@ -155,18 +159,18 @@ xpow (double a, const ComplexMatrix& b)
 }
 
 // -*- 5 -*-
 octave_value
 xpow (const Matrix& a, double b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
 	{
 	  int btmp = static_cast<int> (b);
@@ -180,17 +184,17 @@ xpow (const Matrix& a, double b)
 	      // XXX FIXME XXX -- we shouldn't do this if the exponent is
 	      // large...
 
 	      Matrix atmp;
 	      if (btmp < 0)
 		{
 		  btmp = -btmp;
 
-		  int info;
+		  octave_idx_type info;
 		  double rcond = 0.0;
 
 		  atmp = a.inverse (info, rcond, 1);
 
 		  if (info == -1)
 		    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
 		}
@@ -216,17 +220,17 @@ xpow (const Matrix& a, double b)
 	    }
 	}
       else
 	{
 	  EIG a_eig (a);
 	  ComplexColumnVector lambda (a_eig.eigenvalues ());
 	  ComplexMatrix Q (a_eig.eigenvectors ());
 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    lambda (i) = std::pow (lambda (i), b);
 
 	  ComplexDiagMatrix D (lambda);
 
 	  retval = ComplexMatrix (Q * D * Q.inverse ());
 	}
     }
 
@@ -234,28 +238,28 @@ xpow (const Matrix& a, double b)
 }
 
 // -*- 6 -*-
 octave_value
 xpow (const Matrix& a, const Complex& b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       EIG a_eig (a);
       ComplexColumnVector lambda (a_eig.eigenvalues ());
       ComplexMatrix Q (a_eig.eigenvectors ());
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	lambda (i) = std::pow (lambda (i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
@@ -276,28 +280,28 @@ xpow (const Complex& a, double b)
 }
 
 // -*- 8 -*-
 octave_value
 xpow (const Complex& a, const Matrix& b)
 {
   octave_value retval;
 
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  Complex elt = lambda (i);
 	  if (std::imag (elt) == 0.0)
 	    lambda (i) = std::pow (a, std::real (elt));
 	  else
 	    lambda (i) = std::pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
@@ -318,28 +322,28 @@ xpow (const Complex& a, const Complex& b
 }
 
 // -*- 10 -*-
 octave_value
 xpow (const Complex& a, const ComplexMatrix& b)
 {
   octave_value retval;
 
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	{
 	  Complex elt = lambda (i);
 	  if (std::imag (elt) == 0.0)
 	    lambda (i) = std::pow (a, std::real (elt));
 	  else
 	    lambda (i) = std::pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
@@ -351,18 +355,18 @@ xpow (const Complex& a, const ComplexMat
 }
 
 // -*- 11 -*-
 octave_value
 xpow (const ComplexMatrix& a, double b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
 	{
 	  int btmp = static_cast<int> (b);
@@ -376,17 +380,17 @@ xpow (const ComplexMatrix& a, double b)
 	      // XXX FIXME XXX -- we shouldn't do this if the exponent is
 	      // large...
 
 	      ComplexMatrix atmp;
 	      if (btmp < 0)
 		{
 		  btmp = -btmp;
 
-		  int info;
+		  octave_idx_type info;
 		  double rcond = 0.0;
 
 		  atmp = a.inverse (info, rcond, 1);
 
 		  if (info == -1)
 		    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
 		}
@@ -412,17 +416,17 @@ xpow (const ComplexMatrix& a, double b)
 	    }
 	}
       else
 	{
 	  EIG a_eig (a);
 	  ComplexColumnVector lambda (a_eig.eigenvalues ());
 	  ComplexMatrix Q (a_eig.eigenvectors ());
 
-	  for (int i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nr; i++)
 	    lambda (i) = std::pow (lambda (i), b);
 
 	  ComplexDiagMatrix D (lambda);
 
 	  retval = ComplexMatrix (Q * D * Q.inverse ());
 	}
     }
 
@@ -430,28 +434,28 @@ xpow (const ComplexMatrix& a, double b)
 }
 
 // -*- 12 -*-
 octave_value
 xpow (const ComplexMatrix& a, const Complex& b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       EIG a_eig (a);
       ComplexColumnVector lambda (a_eig.eigenvalues ());
       ComplexMatrix Q (a_eig.eigenvectors ());
 
-      for (int i = 0; i < nr; i++)
+      for (octave_idx_type i = 0; i < nr; i++)
 	lambda (i) = std::pow (lambda (i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
@@ -487,98 +491,103 @@ xpow (const ComplexMatrix& a, const Comp
 // library...
 
 // -*- 1 -*-
 octave_value
 elem_xpow (double a, const Matrix& b)
 {
   octave_value retval;
 
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   double d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    result (i, j) = std::pow (atmp, b (i, j));
 	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    result (i, j) = std::pow (a, b (i, j));
 	  }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
 octave_value
 elem_xpow (double a, const ComplexMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   Complex atmp (a);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = std::pow (atmp, b (i, j));
       }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const Matrix& a, double b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       ComplexMatrix result (nr, nc);
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
-	    OCTAVE_QUIT;
+	    OCTAVE_QUIT; 
       
 	    Complex atmp (a (i, j));
 
 	    result (i, j) = std::pow (atmp, b);
 	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    result (i, j) = std::pow (a (i, j), b);
 	  }
 
       retval = result;
     }
 
@@ -586,31 +595,31 @@ elem_xpow (const Matrix& a, double b)
 }
 
 // -*- 4 -*-
 octave_value
 elem_xpow (const Matrix& a, const Matrix& b)
 {
   octave_value retval;
 
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	double atmp = a (i, j);
 	double btmp = b (i, j);
 	if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	  {
 	    convert_to_complex = 1;
 	    goto done;
@@ -618,228 +627,235 @@ elem_xpow (const Matrix& a, const Matrix
       }
 
 done:
 
   if (convert_to_complex)
     {
       ComplexMatrix complex_result (nr, nc);
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    Complex atmp (a (i, j));
 	    Complex btmp (b (i, j));
 	    complex_result (i, j) = std::pow (atmp, btmp);
 	  }
 
       retval = complex_result;
     }
   else
     {
       Matrix result (nr, nc);
 
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    result (i, j) = std::pow (a (i, j), b (i, j));
 	  }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
 octave_value
 elem_xpow (const Matrix& a, const Complex& b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = std::pow (Complex (a (i, j)), b);
       }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
 elem_xpow (const Matrix& a, const ComplexMatrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = std::pow (Complex (a (i, j)), b (i, j));
       }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const Matrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	double btmp = b (i, j);
 	if (xisint (btmp))
 	  result (i, j) = std::pow (a, static_cast<int> (btmp));
 	else
 	  result (i, j) = std::pow (a, btmp);
       }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexMatrix& b)
 {
-  int nr = b.rows ();
-  int nc = b.cols ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = std::pow (a, b (i, j));
       }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, double b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    result (i, j) = std::pow (a (i, j), static_cast<int> (b));
 	  }
     }
   else
     {
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    result (i, j) = std::pow (a (i, j), b);
 	  }
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const Matrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	double btmp = b (i, j);
 	if (xisint (btmp))
 	  result (i, j) = std::pow (a (i, j), static_cast<int> (btmp));
 	else
 	  result (i, j) = std::pow (a (i, j), btmp);
       }
 
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const Complex& b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = std::pow (a (i, j), b);
       }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b)
 {
-  int nr = a.rows ();
-  int nc = a.cols ();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
 
-  int b_nr = b.rows ();
-  int b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	result (i, j) = std::pow (a (i, j), b (i, j));
       }
 
   return result;
 }
 
@@ -879,28 +895,28 @@ elem_xpow (double a, const NDArray& b)
   octave_value retval;
 
   double d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexNDArray result (b.dims ());
-      for (int i = 0; i < b.length (); i++)
+      for (octave_idx_type i = 0; i < b.length (); i++)
 	{
 	  OCTAVE_QUIT;
 	  result(i) = std::pow (atmp, b(i));
 	}
 
       retval = result;
     }
   else
     {
       NDArray result (b.dims ());
-      for (int i = 0; i < b.length (); i++)
+      for (octave_idx_type i = 0; i < b.length (); i++)
 	{
 	  OCTAVE_QUIT;
 	  result (i) = std::pow (a, b(i));
 	}
 
       retval = result;
     }
 
@@ -908,17 +924,18 @@ elem_xpow (double a, const NDArray& b)
 }
 
 // -*- 2 -*-
 octave_value
 elem_xpow (double a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
   Complex atmp (a);
-  for (int i = 0; i < b.length (); i++)
+
+  for (octave_idx_type i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
       result(i) = std::pow (atmp, b(i));
     }
 
   return result;
 }
 
@@ -927,32 +944,32 @@ octave_value
 elem_xpow (const NDArray& a, double b)
 {
   octave_value retval;
 
   if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       ComplexNDArray result (a.dims ());
 
-      for (int i = 0; i < a.length (); i++)
+      for (octave_idx_type i = 0; i < a.length (); i++)
 	{
 	  OCTAVE_QUIT;
 
 	  Complex atmp (a (i));
 
 	  result(i) = std::pow (atmp, b);
 	}
 
       retval = result;
     }
   else
     {
       NDArray result (a.dims ());
 
-      for (int i = 0; i < a.length (); i++)
+      for (octave_idx_type i = 0; i < a.length (); i++)
 	{
 	  OCTAVE_QUIT;
 	  result(i) = std::pow (a(i), b);
 	}
 
       retval = result;
     }
 
@@ -973,17 +990,17 @@ elem_xpow (const NDArray& a, const NDArr
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   int len = a.length ();
 
   bool convert_to_complex = false;
 
-  for (int i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
     {
       OCTAVE_QUIT;
       double atmp = a(i);
       double btmp = b(i);
       if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	{
 	  convert_to_complex = true;
 	  goto done;
@@ -991,31 +1008,31 @@ elem_xpow (const NDArray& a, const NDArr
     }
 
 done:
 
   if (convert_to_complex)
     {
       ComplexNDArray complex_result (a_dims);
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	{
 	  OCTAVE_QUIT;
 	  Complex atmp (a(i));
 	  Complex btmp (b(i));
 	  complex_result(i) = std::pow (atmp, btmp);
 	}
 
       retval = complex_result;
     }
   else
     {
       NDArray result (a_dims);
 
-      for (int i = 0; i < len; i++)
+      for (octave_idx_type i = 0; i < len; i++)
 	{
 	  OCTAVE_QUIT;
 	  result(i) = std::pow (a(i), b(i));
 	}
 
       retval = result;
     }
 
@@ -1023,17 +1040,17 @@ done:
 }
 
 // -*- 5 -*-
 octave_value
 elem_xpow (const NDArray& a, const Complex& b)
 {
   ComplexNDArray result (a.dims ());
 
-  for (int i = 0; i < a.length (); i++)
+  for (octave_idx_type i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
       result(i) = std::pow (Complex (a(i)), b);
     }
 
   return result;
 }
 
@@ -1046,31 +1063,33 @@ elem_xpow (const NDArray& a, const Compl
 
   if (a_dims != b_dims)
     {
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   ComplexNDArray result (a_dims);
-  for (int i = 0; i < a.length (); i++)
+
+  for (octave_idx_type i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
       result(i) = std::pow (Complex (a(i)), b(i));
     }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const NDArray& b)
 {
   ComplexNDArray result (b.dims ());
-  for (int i = 0; i < b.length (); i++)
+
+  for (octave_idx_type i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
       double btmp = b(i);
       if (xisint (btmp))
 	result(i) = std::pow (a, static_cast<int> (btmp));
       else
 	result(i) = std::pow (a, btmp);
     }
@@ -1078,42 +1097,43 @@ elem_xpow (const Complex& a, const NDArr
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
-  for (int i = 0; i < b.length (); i++)
+
+  for (octave_idx_type i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
       result(i) = std::pow (a, b(i));
     }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, double b)
 {
   ComplexNDArray result (a.dims ());
 
   if (xisint (b))
     {
-      for (int i = 0; i < a.length (); i++)
+      for (octave_idx_type i = 0; i < a.length (); i++)
 	{
 	  OCTAVE_QUIT;
 	  result(i) = std::pow (a(i), static_cast<int> (b));
 	}
     }
   else
     {
-      for (int i = 0; i < a.length (); i++)
+      for (octave_idx_type i = 0; i < a.length (); i++)
 	{
 	  OCTAVE_QUIT;
 	  result(i) = std::pow (a(i), b);
 	}
     }
 
   return result;
 }
@@ -1127,17 +1147,18 @@ elem_xpow (const ComplexNDArray& a, cons
 
   if (a_dims != b_dims)
     {
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   ComplexNDArray result (a_dims);
-  for (int i = 0; i < a.length (); i++)
+
+  for (octave_idx_type i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
       double btmp = b(i);
       if (xisint (btmp))
 	result(i) = std::pow (a(i), static_cast<int> (btmp));
       else
 	result(i) = std::pow (a(i), btmp);
     }
@@ -1145,17 +1166,18 @@ elem_xpow (const ComplexNDArray& a, cons
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, const Complex& b)
 {
   ComplexNDArray result (a.dims ());
-  for (int i = 0; i < a.length (); i++)
+
+  for (octave_idx_type i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
       result(i) = std::pow (a(i), b);
     }
 
   return result;
 }
 
@@ -1168,17 +1190,18 @@ elem_xpow (const ComplexNDArray& a, cons
 
   if (a_dims != b_dims)
     {
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   ComplexNDArray result (a_dims);
-  for (int i = 0; i < a.length (); i++)
+
+  for (octave_idx_type i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
       result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
 
