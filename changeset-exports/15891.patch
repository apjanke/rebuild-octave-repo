# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1357238215 18000
#      Thu Jan 03 13:36:55 2013 -0500
# Branch classdef
# Node ID 1ca9beb2a1943b0cfd90bdb1b6c58004d41f9e98
# Parent  2b6fe094e6156e921ffa759ccffaf48c1130399e
# Parent  44f30dcd87e0de84f357a12896cc618c8db600f2
maint: periodic merge of stdefault to classdef

diff --git a/.hgsub b/.hgsub
--- a/.hgsub
+++ b/.hgsub
@@ -1,1 +1,1 @@
-gnulib = [git]git://git.sv.gnu.org/gnulib
+gnulib-hg = gnulib-hg
diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-e657573866e8aded3b3b1461c346cf9ad02a5148 gnulib
+c960be36c9f3f690ceb43057314354e0df736416 gnulib-hg
diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -64,8 +64,9 @@ 0000000000000000000000000000000000000000
 e320928eeb3aa2370b792e83dafc3e0ddecdc871 release-3-2-4
 ba4d6343524b406b0d15aee34579f80783581c54 release-3-6-1
 704f7895eef03008dd79848eb9da4bfb40787d73 release-3-6-0
 f947d2922febf12dcd1fb6e21b356756ecb54e55 rc-3-6-2-0
 4460c4fb20e6a5d3b1972fa737d4e00eb921545a rc-3-6-2-2
 551566201318bf615b27c60ccf9368f4844008bd release-3-6-2
 a95432e7309ca6fc776c02939264bb6d443f3525 release-3-6-3
 2e8eb9ac43a5f8cfaf0423814a312ed47cb80485 rc-3-6-4-0
+df1aceb8f0bc6b5b5062907931cc663467f57d93 ss-3-7-1
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -137,20 +137,20 @@ Summary of important user-visible change
     are now available (provided that Octave is compiled with support for
     Java enabled):
 
       helpdlg    listdlg   questdlg
       inputdlg   msgbox    warndlg
 
  ** Other new functions added in 3.8.0:
 
-      betaincinv   dawson     fminsearch   rgbplot    
-      cmpermute    erfcinv    iscolormap   shrinkfaces
-      cmunique     erfi       lines        splinefit             
-      colorcube    findfigs   polyeig      tetramesh             
+      betaincinv   dawson     fminsearch  polyeig     tetramesh
+      cmpermute    erfcinv    importdata  rgbplot
+      cmunique     erfi       iscolormap  shrinkfaces
+      colorcube    findfigs   lines       splinefit
 
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.4 and have been
     removed from Octave 3.8.
                                            
       autocor    dispatch              is_global    strerror
       autocov    fstat                 krylovb      values  
diff --git a/build-aux/bootstrap_gnulib b/build-aux/bootstrap_gnulib
--- a/build-aux/bootstrap_gnulib
+++ b/build-aux/bootstrap_gnulib
@@ -200,18 +200,20 @@ copy=false
 # Or set it to 'auto' to make this script select which to use based
 # on which version control system (if any) is used in the source directory.
 vc_ignore=auto
 
 # Set this to true in bootstrap.conf to enable --bootstrap-sync by
 # default.
 bootstrap_sync=false
 
-# Use git to update gnulib sources
-use_git=true
+# Don't use git to update gnulib sources. We keep gnulib under a
+# Mercurial subrepository instead
+use_git=false
+GNULIB_SRCDIR=gnulib-hg
 
 # find_tool ENVVAR NAMES...
 # -------------------------
 # Search for a required program.  Use the value of ENVVAR, if set,
 # otherwise find the first of the NAMES that can be run (i.e.,
 # supports --version).  If found, set ENVVAR to the program name,
 # die otherwise.
 #
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -13,31 +13,24 @@ dnl Copyright (C) 1993-2012 John W. Eato
 ### ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, see
 ### <http://www.gnu.org/licenses/>.
 
-### Preserve CFLAGS and CXXFLAGS from the environment before doing
-### anything else because we don't know which macros might call
-### AC_PROG_CC or AC_PROG_CXX.
-
-EXTERN_CFLAGS="$CFLAGS"
-EXTERN_CXXFLAGS="$CXXFLAGS"
-
 AC_PREREQ([2.62])
-AC_INIT([GNU Octave], [3.7.0+], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.7.1+], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
 OCTAVE_API_VERSION_NUMBER="48"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2012-02-22"
+OCTAVE_RELEASE_DATE="2013-01-02"
 OCTAVE_COPYRIGHT="Copyright (C) 2012 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 dnl FIXME: We should auto-insert the Mercurial changeset ID into the
@@ -45,62 +38,29 @@ dnl        AC_REVISION field whenever co
 dnl AC_REVISION($Revision: 1.603 $)
 AC_CONFIG_SRCDIR([libinterp/octave.cc])
 AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_AUX_DIR([build-aux])
 AC_CONFIG_MACRO_DIR([m4])
 
 AM_INIT_AUTOMAKE([1.11 tar-ustar])
 
-OCTAVE_HOST_TYPE
+OCTAVE_CANONICAL_HOST
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define to 1 if this is Octave.])
   
 AC_USE_SYSTEM_EXTENSIONS
 
-### Path separator.
-
-sepchar=':'
-AC_ARG_WITH([sepchar],
-  [AS_HELP_STRING([--with-sepchar=<char>],
-    [use <char> as the path separation character])])
-case $with_sepchar in
-  yes | "")
-    case $canonical_host_type in
-      *-*-mingw* | *-*-msdosmsvc)
-        sepchar=';' ;;
-    esac
-    ;;
-  no)
-    AC_MSG_ERROR([You are required to define a path separation character])
-    ;;
-  *)
-    sepchar=$with_sepchar
-    ;;
-esac
-AC_SUBST(sepchar)
-AC_DEFINE_UNQUOTED(SEPCHAR, ['$sepchar'],
-  [Define this to be the path separator for your system, as a character constant.])
-AC_DEFINE_UNQUOTED(SEPCHAR_STR, ["$sepchar"],
-  [Define this to be the path separator for your system, as a string.])
+### Make configure args available for other uses.
+
+config_opts=$ac_configure_args
+AC_SUBST(config_opts)
 
 ### Set default file locations
 
-OCTAVE_SET_DEFAULT([man1dir], '$(mandir)/man1')
-OCTAVE_SET_DEFAULT([man1ext], '.1')
-OCTAVE_SET_DEFAULT([doc_cache_file], '$(octetcdir)/doc-cache')
-OCTAVE_SET_DEFAULT([texi_macros_file], '$(octetcdir)/macros.texi')
-OCTAVE_SET_DEFAULT([infofile], '$(infodir)/octave.info')
-OCTAVE_SET_DEFAULT([octincludedir], '$(includedir)/octave-$(version)/octave')
-OCTAVE_SET_DEFAULT([fcnfiledir], '$(datadir)/octave/$(version)/m')
-OCTAVE_SET_DEFAULT([localfcnfiledir], '$(datadir)/octave/site/m')
-OCTAVE_SET_DEFAULT([localapifcnfiledir],
-  '$(datadir)/octave/site/$(api_version)/m')
-OCTAVE_SET_DEFAULT([localverfcnfiledir], '$(datadir)/octave/$(version)/site/m')
-OCTAVE_SET_DEFAULT([octetcdir], '$(datadir)/octave/$(version)/etc')
 OCTAVE_SET_DEFAULT([octlibdir], '$(libdir)/octave/$(version)')
 OCTAVE_SET_DEFAULT([archlibdir],
   '$(libexecdir)/octave/$(version)/exec/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT([localarchlibdir],
   '$(libexecdir)/octave/site/exec/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT([localapiarchlibdir],
   '$(libexecdir)/octave/$(api_version)/site/exec/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT([localverarchlibdir],
@@ -108,26 +68,95 @@ OCTAVE_SET_DEFAULT([localverarchlibdir],
 OCTAVE_SET_DEFAULT([octfiledir],
   '$(libdir)/octave/$(version)/oct/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT([localoctfiledir],
   '$(libdir)/octave/site/oct/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT([localapioctfiledir],
   '$(libdir)/octave/site/oct/$(api_version)/$(canonical_host_type)')
 OCTAVE_SET_DEFAULT([localveroctfiledir],
   '$(libdir)/octave/$(version)/site/oct/$(canonical_host_type)')
+OCTAVE_SET_DEFAULT([octincludedir], '$(includedir)/octave-$(version)/octave')
+OCTAVE_SET_DEFAULT([fcnfiledir], '$(datadir)/octave/$(version)/m')
+OCTAVE_SET_DEFAULT([localfcnfiledir], '$(datadir)/octave/site/m')
+OCTAVE_SET_DEFAULT([localapifcnfiledir],
+  '$(datadir)/octave/site/$(api_version)/m')
+OCTAVE_SET_DEFAULT([localverfcnfiledir], '$(datadir)/octave/$(version)/site/m')
+OCTAVE_SET_DEFAULT([octetcdir], '$(datadir)/octave/$(version)/etc')
+OCTAVE_SET_DEFAULT([doc_cache_file], '$(octetcdir)/doc-cache')
+OCTAVE_SET_DEFAULT([texi_macros_file], '$(octetcdir)/macros.texi')
 OCTAVE_SET_DEFAULT([imagedir], '$(datadir)/octave/$(version)/imagelib')
-
-### Find pkg-config executable (sets $PKG_CONFIG)
-
+OCTAVE_SET_DEFAULT([man1dir], '$(mandir)/man1')
+OCTAVE_SET_DEFAULT([man1ext], '.1')
+OCTAVE_SET_DEFAULT([infofile], '$(infodir)/octave.info')
+
+### Check for programs used in building, installing, and running Octave.
+
+## Programs used in configuring Octave.
+## Find pkg-config executable (sets $PKG_CONFIG)
 PKG_PROG_PKG_CONFIG
 
-### Make configure args available for other uses.
-
-config_opts=$ac_configure_args
-AC_SUBST(config_opts)
+## Programs used in Makefiles.
+AC_PROG_AWK
+OCTAVE_PROG_FIND
+OCTAVE_PROG_SED
+OCTAVE_PROG_PERL
+
+## Programs used to build parts of Octave.
+OCTAVE_PROG_GPERF
+
+OCTAVE_PROG_FLEX
+AC_SUBST([LEX_OUTPUT_ROOT], [lex.octave_])
+
+OCTAVE_PROG_BISON
+
+OCTAVE_PROG_MAKEINFO
+OCTAVE_PROG_TEXI2DVI
+OCTAVE_PROG_TEXI2PDF
+
+## Programs used when installing Octave.
+AC_PROG_LN_S
+AC_PROG_MKDIR_P
+
+AC_PROG_INSTALL
+INSTALL_SCRIPT='${INSTALL}'
+AC_SUBST(INSTALL_SCRIPT)
+
+OCTAVE_PROG_DESKTOP_FILE_INSTALL
+
+## Programs used when running Octave
+OCTAVE_PROG_GHOSTSCRIPT
+OCTAVE_PROG_GNUPLOT
+OCTAVE_PROG_PAGER
+OCTAVE_PROG_PYTHON
+
+### Path separator.
+
+sepchar=':'
+AC_ARG_WITH([sepchar],
+  [AS_HELP_STRING([--with-sepchar=<char>],
+    [use <char> as the path separation character])])
+case $with_sepchar in
+  yes | "")
+    case $host_os in
+      mingw* | msdosmsvc)
+        sepchar=';' ;;
+    esac
+    ;;
+  no)
+    AC_MSG_ERROR([You are required to define a path separation character])
+    ;;
+  *)
+    sepchar=$with_sepchar
+    ;;
+esac
+AC_SUBST(sepchar)
+AC_DEFINE_UNQUOTED(SEPCHAR, ['$sepchar'],
+  [Define this to be the path separator for your system, as a character constant.])
+AC_DEFINE_UNQUOTED(SEPCHAR_STR, ["$sepchar"],
+  [Define this to be the path separator for your system, as a string.])
 
 ### Define the path to the shell on the host system.  Most systems will
 ### ensure /bin/sh is the default shell so this can be safely ignored by
 ### almost everyone.  However, when building for Android, for example,
 ### this will need to be set.
 SHELL_PATH=/bin/sh
 AC_ARG_WITH([shell],
   [AS_HELP_STRING([--with-shell=SHELL],
@@ -271,21 +300,21 @@ AC_SUBST(CXX_VERSION)
 ### Determine which C compiler to use (we expect to find gcc).
 
 AC_PROG_CC
 AC_PROG_CPP
 AC_PROG_GCC_TRADITIONAL
 
 ## Check for MSVC
 have_msvc=no
-case $canonical_host_type in
-  *-*-msdosmsvc)
+case $host_os in
+  msdosmsvc)
     have_msvc=yes
   ;;
-  *-*-mingw*)
+  mingw*)
     AC_MSG_CHECKING([for MSVC compiler])
     AC_PREPROC_IFELSE([AC_LANG_SOURCE([[
         #ifndef _MSC_VER
         #error "Not MSVC compiler"
         #endif
         ]])],
       have_msvc=yes, have_msvc=no)
     AC_MSG_RESULT([$have_msvc])
@@ -436,21 +465,21 @@ AC_SUBST(XTRA_CXXFLAGS)
 ### it by default.  Enable it with the flag --enable-openmp.
 
 USE_OPENMP=false
 AC_ARG_ENABLE([openmp],
   [AS_HELP_STRING([--enable-openmp],
     [(EXPERIMENTAL) use OpenMP SMP multi-threading])],
   [if test "$enableval" = yes; then USE_OPENMP=true; fi], [])
 if $USE_OPENMP; then
-  case $canonical_host_type in
-    *-*-mingw* | *-*-cygwin* | *-*-gnu*)
+  case $host_os in
+    mingw* | cygwin* | *-gnu*)
       OCTAVE_CHECK_OPENMP(-fopenmp)
     ;;
-    *-*-msdosmsvc)
+    msdosmsvc)
       ## FIXME: is this the right flag for MSVC?
       OCTAVE_CHECK_OPENMP(-openmp)
     ;;
     ## Add other compilers supporting OpenMP here
   esac
 fi
 
 ### Defaults for cross compiling.  BUILD_CC and BUILD_CXX are
@@ -482,30 +511,22 @@ AC_ARG_VAR([BUILD_CXX],
   [build system C++ compiler (used if cross compiling)])
 AC_ARG_VAR([BUILD_CXXFLAGS],
   [build system C++ compiler flags (used if cross compiling)])
 AC_ARG_VAR([BUILD_LDFLAGS],
   [build system C++ compiler link flags (used if cross compiling)])
 AC_ARG_VAR([BUILD_EXEEXT],
   [build system executable extension (used if cross compiling)])
 
-dnl This is bogus.  We shouldn't have to explicitly add libc too!
-dnl Keep this check before the check for the Fortran compiler,
-dnl in case -lm is needed to compile Fortran programs.
 
 ### Look for math library.  If found, this will add -lm to LIBS.
 
-case $canonical_host_type in
-  *-*-linux*)
-    AC_CHECK_LIB(m, sin, , , -lc)
-  ;;
-  *)
-    AC_CHECK_LIB(m, sin)
-  ;;
-esac
+dnl Keep this check before the check for the Fortran compiler,
+dnl in case -lm is needed to compile Fortran programs.
+AC_CHECK_LIB(m, sin)
 
 ### Determine the Fortran compiler and how to invoke it
 
 ## Default FFLAGS is -O.
 if test x"$FFLAGS" = x""; then
   FFLAGS="-O"
 fi
 
@@ -1048,18 +1069,18 @@ if test -n "$OPENGL_LIBS"; then
   if test "$FLTK_CONFIG" = no; then
     native_graphics=false
     warn_fltk_config="FLTK config script not found.  Native graphics will be disabled."
     OCTAVE_CONFIGURE_WARNING([warn_fltk_config])
   else
     FLTK_CFLAGS=`$FLTK_CONFIG $fltkconf_args --use-gl --cflags`
     FLTK_LDFLAGS=`$FLTK_CONFIG $fltkconf_args --use-gl --ldflags`
 
-    case $canonical_host_type in
-      *-*-mingw*)
+    case $host_os in
+      mingw*)
         FLTK_LDFLAGS=`echo $FLTK_LDFLAGS | sed -e 's/-mwindows//g'`
       ;;
     esac
 
     AC_CACHE_CHECK([for OpenGL support in FLTK],
       [octave_cv_fltk_opengl_support],
       [save_CFLAGS="$CFLAGS"
       CFLAGS="$CFLAGS $FLTK_CFLAGS"
@@ -1159,18 +1180,18 @@ if test $ax_blas_f77_func_ok = no; then
     FFLAGS="$save_FFLAGS"
   else
     FFLAGS="-ff2c $save_FFLAGS"
   fi
 fi
 
 ## On OSX, try again with a wrapper library (without -ff2c!)
 if test $ax_blas_f77_func_ok = no; then
-  case $canonical_host_type in
-    *-*-darwin*)
+  case $host_os in
+    darwin*)
       ## test if wrapper functions help
       octave_blaswrap_save_CFLAGS="$CFLAGS"
       CFLAGS="$CFLAGS -DUSE_BLASWRAP"
       AC_LANG_PUSH(C)
       AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
           #include "liboctave/cruft/misc/blaswrap.c"
         ]])],
         [mv conftest.$ac_objext blaswrap.$ac_objext
@@ -1394,19 +1415,17 @@ AC_ARG_ENABLE([dl],
     [disable loading of dynamically linked modules])],
   [case $enableval in
      yes) ENABLE_DYNAMIC_LINKING=true ;;
      no) ENABLE_DYNAMIC_LINKING=false ;;
      *) AC_MSG_ERROR([bad value $enableval for --enable-dl]) ;;
    esac],
   [ENABLE_DYNAMIC_LINKING=true])
 
-if $STATIC_LIBS || $SHARED_LIBS; then
-  true
-else
+if ! $STATIC_LIBS && ! $SHARED_LIBS; then
   AC_MSG_ERROR([You can't disable building static AND shared libraries!])
 fi
 
 CPICFLAG=-fPIC
 CXXPICFLAG=-fPIC
 FPICFLAG=-fPIC
 SHLEXT=so
 SHLLIB='$(SHLEXT)'
@@ -1760,17 +1779,17 @@ if $SHARED_LIBS || $ENABLE_DYNAMIC_LINKI
     ;;
   esac
 
   DL_LIBS="$lt_cv_dlopen_libs"
   AC_SUBST(DL_LIBS)
 
   ## Disable dynamic linking if capability is not present.
   if $dlopen_api || $shl_load_api || $loadlibrary_api || $dyld_api; then
-    true
+    :  # some form of dynamic linking present
   else
     ENABLE_DYNAMIC_LINKING=false
   fi
 fi
 
 if $ENABLE_DYNAMIC_LINKING; then
   AC_DEFINE(ENABLE_DYNAMIC_LINKING, 1, [Define to 1 if using dynamic linking.])
 fi
@@ -1790,27 +1809,27 @@ AC_SUBST(LD_CXX)
 AC_SUBST(RDYNAMIC_FLAG)
 AC_SUBST(ENABLE_DYNAMIC_LINKING)
 AC_SUBST(LIBOCTINTERP)
 AC_SUBST(LIBOCTAVE)
 
 ### Check for existence of various libraries
 
 ## OS-specific test for dirent, opendir.
-case $canonical_host_type in
-  *-*-mingw*)
+case $host_os in
+  mingw*)
     if test $have_msvc = yes; then
       AC_CHECK_LIB([dirent], [opendir])
       LIBS="$LIBS -ladvapi32 -lgdi32 -lws2_32 -luser32 -lkernel32"
     else
       LIBS="$LIBS -lgdi32 -lws2_32 -luser32 -lkernel32"
     fi
     LIBS="$LIBS -lgdi32 -lws2_32 -luser32 -lkernel32"
   ;;
-  *-*-msdosmsvc*)
+  msdosmsvc)
     AC_CHECK_LIB([dirent], [opendir])
     LIBS="$LIBS -ladvapi32 -lgdi32 -lws2_32 -luser32 -lkernel32"
   ;;
 esac
 
 ## Find a termlib to use.
 OCTAVE_CHECK_LIB_TERMLIB
 
@@ -1936,17 +1955,18 @@ gl_INIT
 
 dnl These checks define/undefine HAVE_FUNCNAME in config.h.
 dnl Code tests HAVE_FUNCNAME and either uses function or provides workaround.
 dnl Use multiple AC_CHECKs to avoid line continuations '\' in list
 AC_CHECK_FUNCS([canonicalize_file_name dup2])
 AC_CHECK_FUNCS([endgrent endpwent execvp expm1 expm1f fork])
 AC_CHECK_FUNCS([getegid geteuid getgid getgrent getgrgid getgrnam])
 AC_CHECK_FUNCS([getpgrp getpid getppid getpwent getpwuid getuid])
-AC_CHECK_FUNCS([kill lgamma lgammaf lgamma_r lgammaf_r])
+AC_CHECK_FUNCS([isascii kill])
+AC_CHECK_FUNCS([lgamma lgammaf lgamma_r lgammaf_r])
 AC_CHECK_FUNCS([log1p log1pf pipe])
 AC_CHECK_FUNCS([realpath resolvepath roundl])
 AC_CHECK_FUNCS([select setgrent setpwent siglongjmp strsignal])
 AC_CHECK_FUNCS([tempnam tgammaf toascii])
 AC_CHECK_FUNCS([umask uname waitpid])
 AC_CHECK_FUNCS([_kbhit])
 
 dnl There are no workarounds in the code for missing these functions.
@@ -1977,83 +1997,104 @@ double tgamma (double);
 AC_LANG_POP(C++)
 
 ## Look in <cmath> for the IEEE functions isnan, isinf, isfinite that we need.
 
 OCTAVE_CHECK_FUNC_CMATH(isnan)
 OCTAVE_CHECK_FUNC_CMATH(isinf)
 OCTAVE_CHECK_FUNC_CMATH(isfinite)
 
-dnl Would like to get rid of this crap, and just have
-dnl
-dnl   AC_CHECK_FUNCS([finite isnan isinf])
-dnl
-dnl instead, but that used to fail on some systems...
-dnl
-dnl Also just using AC_CHECK_FUNCS doesn't seem to work to find isinf
-dnl and isnan on Linux systems, so we use AC_CHECK_FUNC, and if that
-dnl fails, we try again by including math.h and invoking the function
-dnl with an argument. 
-
-### I am told that Inf and NaN don't work on m68k HP sytems.
+## Check for Inf and NaN functions
 
 case $canonical_host_type in
   m68k-hp-hpux*)
+    ## I am told that Inf and NaN don't work on m68k HP sytems.
   ;;
   *)
     AC_CHECK_FUNCS([finite isnan isinf signbit])
     AC_CHECK_FUNCS([_finite _isnan])
     AC_CHECK_DECLS([signbit], , , [#include <math.h>])
   ;;
 esac
 
 ## Check for nonstandard, but common math functions, that we need.
 
 dnl Use multiple AC_CHECKs to avoid line continuations '\' in list
 AC_CHECK_FUNCS([acosh acoshf asinh asinhf atanh atanhf cbrt cbrtf])
 AC_CHECK_FUNCS([erf erff erfc erfcf exp2f hypotf _hypotf log2 log2f])
 
+## Check for math defines such as M_LN2 in math.h
+AC_CACHE_CHECK([for MATH DEFINES in math.h],
+  [octave_cv_header_math_defines],
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+    #include <math.h>
+    ]], [[
+    double x = M_LN2;]])],
+    octave_cv_header_math_defines=yes,
+    octave_cv_header_math_defines=no)
+  ])
+
+if test $octave_cv_header_math_defines = no; then
+  ## Check again and try defining _USE_MATH_DEFINES
+  AC_CACHE_CHECK([whether _USE_MATH_DEFINES needs to be defined],
+    [octave_cv_header__use_math_defines],
+    [save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="$CPPFLAGS -D_USE_MATH_DEFINES"
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+      #include <math.h>
+      ]], [[
+      double x = M_LN2;]])],
+      octave_cv_header__use_math_defines=yes,
+      octave_cv_header__use_math_defines=no)
+    CPPFLAGS="$save_CPPFLAGS"
+    ])
+  if test $octave_cv_header__use_math_defines = yes; then
+    octave_cv_header_math_defines=yes
+    AC_DEFINE(_USE_MATH_DEFINES, 1,
+      [Define to 1 if _USE_MATH_DEFINES is required to get math constants like M_LN2.])
+    CPPFLAGS="$CPPFLAGS -D_USE_MATH_DEFINES"
+  fi
+fi 
+
+if test $octave_cv_header_math_defines = yes; then
+  AC_DEFINE(HAVE_MATH_DEFINES, 1,
+    [Define to 1 if defines such as M_PI are available in math.h])
+else
+  AC_MSG_ERROR([MATH DEFINES in math.h such as M_PI are required to build Octave])
+fi
+
 ## Windows-specific tests for extra #defines
-case $canonical_host_type in
-  *-*-msdosmsvc | *-*-mingw*)
+case $host_os in
+  msdosmsvc | mingw*)
     AC_MSG_CHECKING([for required _WIN32_WINNT])
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
         #include <windows.h>
         #if _WIN32_WINNT < 0x0403
         #error "Wrong version"
         #endif
         ]], [])],
       [AC_MSG_RESULT([none])],
       [AC_DEFINE(_WIN32_WINNT, 0x0403,
         [Define to 0x0403 to access InitializeCriticalSectionAndSpinCount.])
        AC_MSG_RESULT([0x0403])])
-    AC_MSG_CHECKING([whether _USE_MATH_DEFINES needs to be defined])
-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-        #include <math.h>
-        ]], [[
-        int x = M_LN2;]])],
-      [AC_MSG_RESULT([no])],
-      [AC_DEFINE(_USE_MATH_DEFINES, 1,
-        [Define to 1 if your system needs to define math constants like M_LN2.])
-        AC_MSG_RESULT([yes])])
   ;;
 esac
 
 ## Windows-specific use of functions
-case $canonical_host_type in
-  *-*-mingw* | *-*-msdosmsvc*)
+case $host_os in
+  msdosmsvc | mingw*)
     AC_CHECK_FUNCS([setvbuf], [],
                    [AC_MSG_ERROR([Missing function required to build Octave])])
     ;;
 esac
 
 ## Cygwin kluge for getrusage.
 AC_CHECK_FUNCS([getrusage])
-case $canonical_host_type in
-  *-*-cygwin*)
+case $host_os in
+  cygwin*)
     AC_DEFINE(RUSAGE_TIMES_ONLY, 1,
       [Define to 1 if your struct rusage only has time information.])
   ;;
 esac
 
 ## Check for CGDisplayBitsPerPixel function on Mac OSX systems with Carbon
 if test $have_framework_carbon = yes; then
   OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL
@@ -2086,48 +2127,16 @@ fi
 AC_CHECK_DECLS([sys_siglist], [], [],
 [[#include <signal.h>
 /* NetBSD declares sys_siglist in unistd.h.  */
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif
 ]])
 
-### Checks for other programs used in building, testing, installing, and
-### running Octave.
-
-AC_PROG_AWK
-OCTAVE_PROG_FIND
-OCTAVE_PROG_SED
-OCTAVE_PROG_PERL
-OCTAVE_PROG_PYTHON
-
-OCTAVE_PROG_FLEX
-AC_SUBST([LEX_OUTPUT_ROOT], [lex.octave_])
-
-OCTAVE_PROG_BISON
-
-AC_PROG_LN_S
-AC_PROG_MKDIR_P
-
-AC_PROG_INSTALL
-INSTALL_SCRIPT='${INSTALL}'
-AC_SUBST(INSTALL_SCRIPT)
-
-OCTAVE_PROG_DESKTOP_FILE_INSTALL
-
-OCTAVE_PROG_GNUPLOT
-OCTAVE_PROG_PAGER
-OCTAVE_PROG_GPERF
-
-OCTAVE_PROG_GHOSTSCRIPT
-OCTAVE_PROG_MAKEINFO
-OCTAVE_PROG_TEXI2DVI
-OCTAVE_PROG_TEXI2PDF
-
 ### Need to disable building documentation if gnuplot was not found,
 ### unless it was already disabled previously.
 
 if test -n "$DOCDIR" && test -n "$warn_gnuplot"; then
   DOCDIR=
   warn_docs="building documentation disabled because gnuplot was not found; make dist will fail"
   OCTAVE_CONFIGURE_WARNING([warn_docs])
 fi
@@ -2252,31 +2261,32 @@ do
 
   if test -z "$JAVA"; then
     AC_MSG_WARN([No Java executable found.  Octave will not be able to call Java methods.])   
     break
   fi
 
   if test -z "$JAVA_HOME"; then
     ## Find JAVA_HOME for JRE by running java and querying properties.
-    JAVA_TMP_HOME="`\"$JAVA\" -classpath ${srcdir}/build-aux OctJavaQry JAVA_HOME`"
+    JAVA_TMP_HOME=`"$JAVA" -classpath ${srcdir}/build-aux OctJavaQry JAVA_HOME`
     ## Strip directory back to top-level installation dir (JAVA_HOME for JDK).
-    JAVA_HOME="`echo $JAVA_TMP_HOME | sed -e 's|[[/\\]]bin[[/\\]]\?$||' | sed -e 's|[[/\\]]jre[[/\\]]\?$||'`"
+    JAVA_HOME=`echo $JAVA_TMP_HOME | sed -e 's|[[/\\]]bin[[/\\]]\?$||' | sed -e 's|[[/\\]]jre[[/\\]]\?$||'`
   fi
 
-  case $canonical_host_type in
-    *-mingw* | *-msdosmsvc*)
-      ## Under Win32 platform, we want JAVA_HOME to be in MSYS format, that is without
-      ## colon and backslashes, as it is also used as path separator. Use quoted paths
-      ## as Java may be installed in a path with whitespaces (e.g. C:\Program Files\Java\...).
+  case $host_os in
+    mingw* | msdosmsvc)
+      ## Under Win32 platform, we want JAVA_HOME to be in MSYS format, that is
+      ## without colon and backslashes, as it is also used as path separator.
+      ## Use quoted paths as Java may be installed in a path with whitespaces
+      ## (e.g. C:\Program Files\Java\...).
       if test -n "$JAVA_HOME"; then
-        JAVA_HOME="`cd \"$JAVA_HOME\" && pwd`"
-	## Maybe this will be useful in the future, as native Java won't probably
-	## understand MSYS paths.
-	JAVA_HOME_NATIVE="`cd \"$JAVA_HOME\" && pwd -W`"
+        JAVA_HOME=`cd "$JAVA_HOME" && pwd`
+        ## Maybe this will be useful in the future, as native Java won't
+        ## understand MSYS paths.
+        JAVA_HOME_NATIVE=`cd "$JAVA_HOME" && pwd -W`
       fi
     ;;
     *)
       JAVA_HOME_NATIVE="$JAVA_HOME"
     ;;
   esac
 
   ## Amend search path for JAVAC and JAR.
@@ -2302,44 +2312,44 @@ do
   java_minor=[`echo $java_version | sed -e 's/^\([0-9][0-9]*\)\.\([0-9][0-9]*\)\..*$/\2/'`]
   if test $java_major -ge 1 && test $java_minor -ge 5; then
     :  # Version is ok.  Do nothing.
   else
     AC_MSG_WARN([Java version is too old (< 1.5).  Octave will not be able to call Java methods.])
     break
   fi
 
-  ## At this point Win32/MSVC systems have enough configuration data. We assume
-  ## that all appropriate variables (e.g. INCLUDE and LIB) have already the required
-  ## paths to compile and link against JDK.
-  case $canonical_host_type in
-    *-msdosmsvc*)
+  ## At this point Win32/MSVC systems have enough configuration data.  We
+  ## assume that all appropriate variables (e.g. INCLUDE and LIB) already have
+  ## the required paths to compile and link against JDK.
+  case $host_os in
+    msdosmsvc)
       build_java=true
       JAVA_LIBS=-ladvapi32
       AC_DEFINE(HAVE_JAVA, 1,
         [Define to 1 if Java is available and is at least version 1.5])
       break
     ;;
-    *-mingw*)
-      if test "$have_msvc" = "yes"; then
+    mingw*)
+      if test $have_msvc = yes; then
         build_java=true
         JAVA_LIBS=-ladvapi32
         AC_DEFINE(HAVE_JAVA, 1,
           [Define to 1 if Java is available and is at least version 1.5])
         break
       fi
     ;;
   esac
 
   ## Determine which library file name to search for.
-  case $canonical_host_type in
-    *-darwin*)
+  case $host_os in
+    darwin*)
       jvmlib=libjvm.dylib
     ;;
-    *-mingw* | *-cygwin*)
+    mingw* | cygwin*)
       jvmlib=jvm.dll
     ;;
     *)
       jvmlib=libjvm.so
     ;;
   esac
 
   AC_MSG_CHECKING([for $jvmlib])
@@ -2399,31 +2409,31 @@ do
     break
   else
     AC_MSG_RESULT([$JAVA_LDPATH])
   fi
 
   AC_MSG_CHECKING([for include file <jni.h>])
 
   ## Java and JVM found.  Set up flags.
-  case $canonical_host_type in
-    *-darwin*)
+  case $host_os in
+    darwin*)
       ## Sneak the -framework flag into mkoctfile via LFLAGS
       LFLAGS="$LFLAGS -framework JavaVM"
       ## According to: http://developer.apple.com/unix/crossplatform.html
       ## one must explicitly set the include path.
       ## Unfortunately, the include path keeps moving around.
       if test -n "$JAVA_CPPFLAGS"; then
         JAVA_CPPFLAGS="-I${JAVA_CPPFLAGS}"
       else
         JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I/System/Library/Frameworks/JavaVM.framework/Home/include -I/System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Headers -I/System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers"
       fi
       JAVA_LIBS="-framework JavaVM"
     ;;
-    *-mingw* | *-cygwin*)
+    mingw* | cygwin*)
       if test -n "$JAVA_CPPFLAGS"; then
         JAVA_CPPFLAGS="-I${JAVA_CPPFLAGS}/include -I${JAVA_CPPFLAGS}/include/win32"
       else
         JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I${JAVA_HOME}/include/win32"
       fi
       JAVA_LIBS=-ladvapi32
     ;;
     *)
@@ -2431,21 +2441,21 @@ do
         JAVA_CPPFLAGS="-I${JAVA_CPPFLAGS}/include -I${JAVA_CPPFLAGS}/include/linux"
       else
         JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux"
       fi
     ;;
   esac
 
   ## Verify jni.h include file exists.
-	JNI_PATH=`echo $JAVA_CPPFLAGS | sed -e 's/-I//g'`
+  JNI_PATH=`echo $JAVA_CPPFLAGS | sed -e 's/-I//g'`
   have_jni=false
-	for dir in $JNI_PATH; do 
-	  if test -f "${dir}/jni.h"; then have_jni=true; break; fi
-	done
+  for dir in $JNI_PATH; do 
+    if test -f "${dir}/jni.h"; then have_jni=true; break; fi
+  done
   if test $have_jni = true; then
     AC_MSG_RESULT([$dir])
   else
     AC_MSG_RESULT([not found])
     AC_MSG_WARN([Include file <jni.h> not found.  Octave will not be able to call Java methods.])
     break
   fi
 
@@ -2466,103 +2476,122 @@ AC_DEFINE_UNQUOTED([JAVA_HOME], ["$JAVA_
 AC_DEFINE_UNQUOTED([JAVA_LDPATH], ["$JAVA_LDPATH"], [Java library path (libjvm)])
 
 ### GUI/Qt related tests.
 
 QT_CPPFLAGS=
 QT_LDFLAGS=
 QT_LIBS=
 win32_terminal=no
-build_gui=true
+build_gui=yes
 GUIDIR=libgui
 AC_ARG_ENABLE([gui],
   [AS_HELP_STRING([--disable-gui], [don't build the GUI])],
-  [if test "$enableval" = no; then build_gui=false; fi], [])
-
-if test $build_gui = true; then
+  [if test "$enableval" = no; then build_gui=no; fi], [])
+
+if test $build_gui = yes; then
   ## Check for Qt libraries
   PKG_CHECK_MODULES(QT, [QtCore, QtGui, QtNetwork],
     [],
-    [AC_MSG_ERROR([Qt libraries are required to build the GUI])])
-
-  ## Retrieve Qt compilation and linker flags
-  QT_CPPFLAGS="`$PKG_CONFIG --cflags-only-I QtCore QtGui QtNetwork`"
-  QT_LDFLAGS="`$PKG_CONFIG --libs-only-L QtCore QtGui QtNetwork`"
-  QT_LIBS="`$PKG_CONFIG --libs-only-l QtCore QtGui QtNetwork`"
-
-  ## Check for Qt4
-  if ! `$PKG_CONFIG --atleast-version=4.0.0 QtCore`; then
-    AC_MSG_ERROR([Qt >= 4.0.0 is required to build the GUI])
+    [AC_MSG_WARN([Qt libraries not found -- disabling GUI])
+     build_gui=no])
+
+  if test $build_gui = yes; then
+    ## Retrieve Qt compilation and linker flags
+    QT_CPPFLAGS="`$PKG_CONFIG --cflags-only-I QtCore QtGui QtNetwork`"
+    QT_LDFLAGS="`$PKG_CONFIG --libs-only-L QtCore QtGui QtNetwork`"
+    QT_LIBS="`$PKG_CONFIG --libs-only-l QtCore QtGui QtNetwork`"
+
+    ## Check for Qt4
+    if ! `$PKG_CONFIG --atleast-version=4.0.0 QtCore`; then
+      AC_MSG_WARN([Qt >= 4.0.0 not found -- disabling GUI])
+      build_gui=no
+    fi
+  fi
+
+  if test $build_gui = yes; then
+    AC_CHECK_PROGS(MOC, [moc-qt5 moc-qt4 moc])
+    AC_CHECK_PROGS(UIC, [uic-qt5 uic-qt4 uic])
+    AC_CHECK_PROGS(RCC, [rcc])
+    if test -n "$MOC" && test -n "$UIC" && test -n "$RCC"; then
+      AC_DEFINE(HAVE_QT, 1, 
+        [Define to 1 if Qt is available (libraries, developer header files, utility programs (moc, uic, and rcc))])
+    else
+      AC_MSG_WARN([Qt utility programs moc, uic, and rcc not found -- disabling GUI])
+      build_gui=no
+    fi
+  fi
+
+  if test $build_gui = yes; then
+    OCTAVE_CHECK_FUNC_SETPLACEHOLDERTEXT
   fi
 
-  AC_CHECK_PROGS(MOC, [moc-qt5 moc-qt4 moc])
-  AC_CHECK_PROGS(UIC, [uic-qt5 uic-qt4 uic])
-  AC_CHECK_PROGS(RCC, [rcc])
-  if test -z "$MOC" || test -z "$UIC" || test -z "$RCC"; then
-    AC_MSG_ERROR([Qt utility programs moc, uic, and rcc are required to build the GUI])
-  fi 
-
-  AC_DEFINE(HAVE_QT, 1, 
-    [Define to 1 if Qt is available (libraries, developer header files, utility programs (moc, uic, and rcc))])
-
-  ## Check for Qscintilla library which is used in the GUI editor. 
-  AC_CACHE_CHECK([whether Qscintilla library is installed],
-    [octave_cv_lib_qscintilla],
-    [save_CPPFLAGS="$CPPFLAGS"
-    save_LDFLAGS="$LDFLAGS"
-    save_LIBS="$LIBS"
-    CPPFLAGS="$QT_CPPFLAGS $CPPFLAGS"
-    LDFLAGS="$QT_LDFLAGS $LDFLAGS"
-    LIBS="$QT_LIBS -lqscintilla2"
-    AC_LANG_PUSH(C++)
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
-      #include <Qsci/qscilexersql.h>
-      ]], [[
-      QsciLexerSQL sqlLexer(0);
-      ]])],
-      octave_cv_lib_qscintilla=yes,
-      octave_cv_lib_qscintilla=no)
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
-    AC_LANG_POP([C++])
-  ])
-  if test $octave_cv_lib_qscintilla = no; then
-    AC_MSG_ERROR([Qscintilla library is required to build the GUI])
+  if test $build_gui = yes; then
+    ## Check for Qscintilla library which is used in the GUI editor. 
+    AC_CACHE_CHECK([whether Qscintilla library is installed],
+      [octave_cv_lib_qscintilla],
+      [save_CPPFLAGS="$CPPFLAGS"
+      save_LDFLAGS="$LDFLAGS"
+      save_LIBS="$LIBS"
+      CPPFLAGS="$QT_CPPFLAGS $CPPFLAGS"
+      LDFLAGS="$QT_LDFLAGS $LDFLAGS"
+      LIBS="$QT_LIBS -lqscintilla2"
+      AC_LANG_PUSH(C++)
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+        #include <Qsci/qscilexersql.h>
+        ]], [[
+        QsciLexerSQL sqlLexer(0);
+        ]])],
+        octave_cv_lib_qscintilla=yes,
+        octave_cv_lib_qscintilla=no)
+      CPPFLAGS="$save_CPPFLAGS"
+      LDFLAGS="$save_LDFLAGS"
+      LIBS="$save_LIBS"
+      AC_LANG_POP([C++])
+    ])
+    if test $octave_cv_lib_qscintilla = no; then
+      AC_MSG_WARN([Qscintilla library not found -- disabling built-in GUI editor])
+    else
+      ## Let's assume Qscintilla library is at the same location as
+      ## other regular Qt libraries.
+      QT_LIBS="$QT_LIBS -lqscintilla2"
+      OCTAVE_CHECK_FUNC_FINDFIRST_MODERN
+      AC_DEFINE(HAVE_QSCINTILLA, 1, 
+        [Define to 1 if the QScintilla library and header files are available])
+    fi
+
+    AC_CHECK_FUNCS([setlocale], [],
+      [AC_MSG_WARN([setlocale not found -- disabling GUI])
+       build_gui=no])
+
+    if test $build_gui = yes; then
+      case $host_os in
+        mingw* | msdosmsvc*)
+          AC_CHECK_FUNCS([setvbuf], [win32_terminal=yes],
+            [AC_MSG_WARN([setvbuf not found -- disabling GUI])
+             build_gui=no])
+          ;;
+        *)
+          AC_CHECK_HEADERS([pty.h libutil.h util.h])
+          AC_SEARCH_LIBS([openpty], [util],
+            [AC_DEFINE(HAVE_OPENPTY, [], [Define whether openpty exists])])
+          AC_CHECK_FUNCS([chmod chown ftruncate mmap munmap], [],
+            [AC_MSG_ERROR([At least one of chmod, chown, ftruncate, mmap, and munmap not found -- disabling GUI])
+             build_gui=no])
+          ;;
+      esac
+    fi
   fi
-  ## Let's assume Qscintilla library is at the same location as
-  ## other regular Qt libraries.
-  QT_LIBS="$QT_LIBS -lqscintilla2"
-
-  ## Check for Qt functions which have changed their API over time
-  OCTAVE_CHECK_FUNC_FINDFIRST_MODERN
-  OCTAVE_CHECK_FUNC_SETPLACEHOLDERTEXT
-
-  AC_CHECK_FUNCS([setlocale], [],
-                 [AC_MSG_ERROR([Missing function required to build GUI])])
-
-  case $canonical_host_type in
-    *-*-mingw* | *-*-msdosmsvc*)
-      win32_terminal=yes
-      AC_CHECK_FUNCS([setvbuf], [],
-                     [AC_MSG_ERROR([Missing function required to build GUI])])
-      ;;
-    *)
-      AC_CHECK_HEADERS([pty.h libutil.h util.h])
-      AC_SEARCH_LIBS([openpty], [util],
-        [AC_DEFINE(HAVE_OPENPTY, [], [Define whether openpty exists])])
-      AC_CHECK_FUNCS([chmod chown ftruncate mmap munmap], [],
-                     [AC_MSG_ERROR([Missing function required to build GUI])])
-      ;;
-  esac
-else
+fi
+
+if test $build_gui = no; then
   ## GUI disabled.  Eliminate building GUIDIR directory
   GUIDIR=
 fi
-AM_CONDITIONAL([AMCOND_BUILD_GUI], [test $build_gui = true])
+AM_CONDITIONAL([AMCOND_BUILD_GUI], [test $build_gui = yes])
 AM_CONDITIONAL([WIN32_TERMINAL], [test $win32_terminal = yes])
 AC_SUBST(QT_CPPFLAGS)
 AC_SUBST(QT_LDFLAGS)
 AC_SUBST(QT_LIBS)
 AC_SUBST(GUIDIR)
 
 ### Run configure in subdirectories.
 
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
@@ -21,17 +21,17 @@
 
 #include "unix/QUnixTerminalImpl.h"
 #include "unix/kpty.h"
 
 #include <termios.h>
 
 QUnixTerminalImpl::QUnixTerminalImpl(QWidget *parent)
     : QTerminalInterface(parent) {
-    setMinimumSize(600, 400);
+    setMinimumSize(300, 200);
     initialize();
 }
 
 void QUnixTerminalImpl::initialize()
 {
     m_terminalView = new TerminalView(this);
     m_terminalView->setKeyboardCursorShape(TerminalView::UnderlineCursor);
     m_terminalView->setBlinkingCursor(true);
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -22,55 +22,47 @@ along with Octave; see the file COPYING.
 
 #ifndef FILEEDITORINTERFACE_H
 #define FILEEDITORINTERFACE_H
 
 #include <QDockWidget>
 #include <QMenu>
 #include <QToolBar>
 
-class QTerminal;
-class main_window;
-
 class file_editor_interface : public QDockWidget
 {
   Q_OBJECT
 
   public:
-  file_editor_interface (QTerminal *terminal, main_window *mainWindow)
-    : QDockWidget ((QWidget*)mainWindow) // QDockWidget constructor is explicit, hence the cast.
+  file_editor_interface (QWidget *p)
+    : QDockWidget (p)
   {
     setObjectName ("FileEditor");
-    _terminal = terminal;
-    _main_window = mainWindow;
 
     connect (this, SIGNAL (visibilityChanged (bool)), this,
              SLOT (handle_visibility_changed (bool)));
   }
 
   virtual ~file_editor_interface () { }
 
   virtual QMenu *debug_menu () = 0;
   virtual QToolBar *toolbar () = 0;
 
   virtual void handle_entered_debug_mode () = 0;
   virtual void handle_quit_debug_mode () = 0;
 
 public slots:
   virtual void request_new_file () = 0;
   virtual void request_open_file () = 0;
-  virtual void request_open_file (const QString& fileName, bool silent = false) = 0;
+  virtual void request_open_file (const QString& fileName) = 0;
 
 signals:
   void active_changed (bool active);
 
 protected:
-  QTerminal* _terminal;
-  main_window* _main_window;
-
   void closeEvent (QCloseEvent *e)
   {
     emit active_changed (false);
     QDockWidget::closeEvent (e);
   }
 
 protected slots:
   void handle_visibility_changed (bool visible)
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -19,16 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#ifdef HAVE_QSCINTILLA
+
 #include <Qsci/qsciapis.h>
 // Not available in the Debian repos yet!
 // #include <Qsci/qscilexeroctave.h>
 #include "lexer-octave-gui.h"
 #include <Qsci/qscilexercpp.h>
 #include <Qsci/qscilexerbash.h>
 #include <Qsci/qscilexerperl.h>
 #include <Qsci/qscilexerbatch.h>
@@ -37,29 +39,36 @@ along with Octave; see the file COPYING.
 #include <QApplication>
 #include <QFileDialog>
 #include <QMessageBox>
 #include <QTextStream>
 #include <QVBoxLayout>
 
 #include "file-editor-tab.h"
 #include "file-editor.h"
-#include "find-dialog.h"
 #include "octave-link.h"
 
 #include "debug.h"
 #include "oct-env.h"
 
-file_editor_tab::file_editor_tab(file_editor *fileEditor)
-  : QWidget ((QWidget*)fileEditor)
+// Make parent null for the file editor tab so that warning
+// WindowModal messages don't affect grandparents.
+file_editor_tab::file_editor_tab (QString directory)
 {
-  _file_editor = fileEditor;
-  _file_name = "";
+  // Make sure there is a slash at the end of the directory name
+  // for identification when saved later.
+  if (directory.count () && directory.at (directory.count () - 1) != '/')
+    directory.append ("/");
+  _file_name = directory;
   _edit_area = new QsciScintilla (this);
 
+  // Leave the find dialog box out of memory until requested.
+  _find_dialog = 0;
+  _find_dialog_is_visible = false;
+
   // symbols
   _edit_area->setMarginType (1, QsciScintilla::SymbolMargin);
   _edit_area->setMarginSensitivity (1, true);
   _edit_area->markerDefine (QsciScintilla::RightTriangle, bookmark);
   _edit_area->markerDefine (QPixmap (":/actions/icons/redled.png"),
                             breakpoint);
   _edit_area->markerDefine (QPixmap (":/actions/icons/arrow_right.png"),
                             debugger_position);
@@ -101,67 +110,72 @@ file_editor_tab::file_editor_tab(file_ed
   // connect modified signal
   connect (_edit_area, SIGNAL (modificationChanged (bool)),
            this, SLOT (update_window_title (bool)));
   connect (_edit_area, SIGNAL (copyAvailable (bool)),
            this, SLOT (handle_copy_available (bool)));
   connect (&_file_system_watcher, SIGNAL (fileChanged (QString)),
            this, SLOT (file_has_changed (QString)));
 
-  _file_name = "";
-
   notice_settings ();
 }
 
-bool
-file_editor_tab::copy_available ()
+file_editor_tab::~file_editor_tab ()
 {
-  return _copy_available;
+  // Destroy items attached to _edit_area.
+  QsciLexer *lexer = _edit_area->lexer ();
+  if (lexer)
+    {
+      delete lexer;
+      _edit_area->setLexer(0);
+    }
+  if (_find_dialog)
+    {
+      delete _find_dialog;
+      _find_dialog = 0;
+    }
+
+  // Destroy _edit_area.
+  delete _edit_area;
 }
 
 void
 file_editor_tab::closeEvent (QCloseEvent *e)
 {
-  if (_file_editor->get_main_window ()->is_closing ())
+  // ignore close event if file is not saved and user cancels
+  // closing this window
+  if (check_file_modified ("Close File",
+                           QMessageBox::Cancel) == QMessageBox::Cancel)
     {
-      // close whole application: save file or not if modified
-      check_file_modified ("Closing Octave", 0); // no cancel possible
-      e->accept ();
+      e->ignore ();
     }
   else
     {
-      // ignore close event if file is not saved and user cancels
-      // closing this window
-      if (check_file_modified ("Close File",
-                               QMessageBox::Cancel) == QMessageBox::Cancel)
-        {
-          e->ignore ();
-        }
-      else
-        {
-          e->accept();
-        }
+      e->accept();
     }
 }
 
 void
 file_editor_tab::set_file_name (const QString& fileName)
 {
-  if (fileName != UNNAMED_FILE)
-    {
-      // update tracked file if wie really hae a file on disk
-      QStringList trackedFiles = _file_system_watcher.files ();
-      if (!trackedFiles.isEmpty ())
-        _file_system_watcher.removePath (_file_name);
-        _file_system_watcher.addPath (fileName);
-    }
+  // update tracked file if we really have a file on disk
+  QStringList trackedFiles = _file_system_watcher.files ();
+  if (!trackedFiles.isEmpty ())
+    _file_system_watcher.removePath (_file_name);
+  if (!fileName.isEmpty ())
+    _file_system_watcher.addPath (fileName);
   _file_name = fileName;
 
   // update lexer after _file_name change
   update_lexer ();
+
+  // update the file editor with current editing directory
+  emit editor_state_changed (_copy_available, QDir::cleanPath (_file_name));
+  // add the new file to the mru list
+  emit mru_add_file (QDir::cleanPath (_file_name));
 }
 
 void
 file_editor_tab::handle_margin_clicked(int margin, int line,
                                        Qt::KeyboardModifiers state)
 {
   if (margin == 1)
     {
@@ -186,17 +200,17 @@ file_editor_tab::handle_margin_clicked(i
             }
         }
     }
 }
 
 void
 file_editor_tab::update_lexer ()
 {
-  QsciLexer *lexer =  _edit_area->lexer ();
+  QsciLexer *lexer = _edit_area->lexer ();
   delete lexer;
 
   if (_file_name.endsWith (".m") || _file_name.endsWith (".M"))
     {
       lexer = new lexer_octave_gui ();
     }
   else if (_file_name.endsWith (".c")
            || _file_name.endsWith (".cc")
@@ -241,548 +255,167 @@ file_editor_tab::update_lexer ()
   lexer->setAutoIndentStyle (QsciScintilla::AiMaintain ||
                              QsciScintilla::AiOpening  ||
                              QsciScintilla::AiClosing);
 
   _edit_area->setLexer (lexer);
 }
 
 void
-file_editor_tab::request_add_breakpoint (int line)
+file_editor_tab::undo (const QWidget* ID)
 {
-  QFileInfo file_info (_file_name);
-  QString path = file_info.absolutePath ();
-  QString function_name = file_info.fileName ();
+  if (ID != this)
+    return;
+
+  _edit_area->undo ();
+}
+
+void
+file_editor_tab::redo (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->redo ();
+}
 
-  // We have to cut off the suffix, because octave appends it.
-  function_name.chop (file_info.suffix ().length () + 1);
+void
+file_editor_tab::copy (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->copy ();
+}
 
-  bp_info info (path, function_name, line);
+void
+file_editor_tab::cut (const QWidget* ID)
+{
+  if (ID != this)
+    return;
 
-  octave_link::post_event
-    (this, &file_editor_tab::add_breakpoint_callback, info);
+  _edit_area->cut ();
+}
+
+void
+file_editor_tab::paste (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  _edit_area->paste ();
 }
 
 void
-file_editor_tab::request_remove_breakpoint (int line)
+file_editor_tab::save_file (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  save_file (_file_name);
+}
+void
+
+file_editor_tab::save_file (const QWidget* ID, const QString& fileName, bool remove_on_success)
+{
+  if (ID != this)
+    return;
+
+  save_file (fileName, remove_on_success);
+}
+
+void
+file_editor_tab::save_file_as (const QWidget* ID)
 {
+  if (ID != this)
+    return;
+
+  save_file_as ();
+}
+
+void
+file_editor_tab::run_file_callback (void)
+{
+  // Maybe someday we will do something here?
+}
+
+void
+file_editor_tab::run_file (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  if (_edit_area->isModified ())
+    save_file (_file_name);
+
   QFileInfo file_info (_file_name);
   QString path = file_info.absolutePath ();
+  QString current_path
+    = QString::fromStdString (octave_link::last_working_directory ());
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
-
-  bp_info info (path, function_name, line);
-
-  octave_link::post_event
-    (this, &file_editor_tab::remove_breakpoint_callback, info);
-}
-
-void
-file_editor_tab::comment_selected_text ()
-{
-  do_comment_selected_text (true);
-}
-
-void
-file_editor_tab::uncomment_selected_text ()
-{
-  do_comment_selected_text (false);
-}
-
-void
-file_editor_tab::do_comment_selected_text (bool comment)
-{
-  if ( _edit_area->hasSelectedText() )
-    {
-      int lineFrom, lineTo, colFrom, colTo, i;
-      _edit_area->getSelection (&lineFrom,&colFrom,&lineTo,&colTo);
-      if ( colTo == 0 )  // the beginning of last line is not selected
-        lineTo--;        // stop at line above
-      _edit_area->beginUndoAction ();
-      for ( i=lineFrom; i<=lineTo; i++ )
-        {
-          if ( comment )
-            _edit_area->insertAt("%",i,0);
-          else
-            {
-              QString line(_edit_area->text(i));
-              if ( line.startsWith("%") )
-                {
-                  _edit_area->setSelection(i,0,i,1);
-                  _edit_area->removeSelectedText();
-                }
-            }
-        }
-      _edit_area->endUndoAction ();
-    }
-}
-
-void
-file_editor_tab::find ()
-{
-  find_dialog dialog (_edit_area);
-  dialog.exec ();
+  emit process_octave_code (QString ("cd \'%1\'\n%2\n")
+                    .arg(path).arg (function_name));
+ 
+  // TODO: Sending a run event crashes for long scripts. Find out why.
+  // octave_link::post_event
+  //   (this, &file_editor_tab::run_file_callback, _file_name.toStdString ()));
 }
 
 void
-file_editor_tab::update_window_title (bool modified)
-{
-  QString title(_file_name);
-  if ( !_long_title )
-    {
-      QFileInfo file(_file_name);
-      title = file.fileName();
-    }
-
-  if ( modified )
-    {
-      emit file_name_changed (title.prepend("* "));
-    }
-  else
-    emit file_name_changed (title);
-}
-
-void
-file_editor_tab::handle_copy_available(bool enableCopy)
-{
-  _copy_available = enableCopy;
-  emit editor_state_changed ();
-}
-
-int
-file_editor_tab::check_file_modified (const QString& msg, int cancelButton)
+file_editor_tab::toggle_bookmark (const QWidget* ID)
 {
-  int decision = QMessageBox::Yes;
-  if (_edit_area->isModified ())
-    {
-      // file is modified but not saved, ask user what to do
-      decision = QMessageBox::warning (this,
-                                       msg,
-                                       tr ("The file %1\n"
-                                           "has been modified. Do you want to save the changes?").
-                                       arg (_file_name),
-                                       QMessageBox::Save,
-                                       QMessageBox::Discard, cancelButton );
-      if (decision == QMessageBox::Save)
-        {
-          save_file ();
-          if (_edit_area->isModified ())
-            {
-              // If the user attempted to save the file, but it's still
-              // modified, then probably something went wrong, so return
-              // cancel for cancel this operation or try to save files
-              // as if cancel not possible
-              if ( cancelButton )
-                return (QMessageBox::Cancel);
-              else
-                save_file_as ();
-            }
-        }
-    }
-  return (decision);
-}
+  if (ID != this)
+    return;
 
-void
-file_editor_tab::remove_bookmark ()
-{
-  _edit_area->markerDeleteAll (bookmark);
-}
-
-void
-file_editor_tab::toggle_bookmark ()
-{
   int line, cur;
   _edit_area->getCursorPosition (&line,&cur);
   if ( _edit_area->markersAtLine (line) && (1 << bookmark) )
     _edit_area->markerDelete (line, bookmark);
   else
     _edit_area->markerAdd (line, bookmark);
 }
 
 void
-file_editor_tab::next_bookmark()
+file_editor_tab::next_bookmark (const QWidget* ID)
 {
+  if (ID != this)
+    return;
+
   int line, cur, nextline;
   _edit_area->getCursorPosition (&line, &cur);
   if ( _edit_area->markersAtLine (line) && (1 << bookmark) )
     line++; // we have a breakpoint here, so start search from next line
   nextline = _edit_area->markerFindNext (line, (1 << bookmark));
   _edit_area->setCursorPosition (nextline, 0);
 }
 
 void
-file_editor_tab::previous_bookmark ()
+file_editor_tab::previous_bookmark (const QWidget* ID)
 {
+  if (ID != this)
+    return;
+
   int line, cur, prevline;
   _edit_area->getCursorPosition (&line, &cur);
   if ( _edit_area->markersAtLine (line) && (1 << bookmark) )
     line--; // we have a breakpoint here, so start search from prev line
   prevline = _edit_area->markerFindPrevious (line, (1 << bookmark));
   _edit_area->setCursorPosition (prevline, 0);
 }
 
 void
-file_editor_tab::remove_all_breakpoints ()
-{
-  QFileInfo file_info (_file_name);
-  QString path = file_info.absolutePath ();
-  QString function_name = file_info.fileName ();
-
-  // We have to cut off the suffix, because octave appends it.
-  function_name.chop (file_info.suffix ().length () + 1);
-
-  bp_info info (path, function_name, 0);
-
-  octave_link::post_event
-    (this, &file_editor_tab::remove_all_breakpoints_callback, info);
-}
-
-void
-file_editor_tab::toggle_breakpoint ()
-{
-  int line, cur;
-  _edit_area->getCursorPosition (&line, &cur);
-  if ( _edit_area->markersAtLine (line) && (1 << breakpoint) )
-    request_remove_breakpoint (line);
-  else
-    request_add_breakpoint (line);
-}
-
-void
-file_editor_tab::next_breakpoint ()
-{
-  int line, cur, nextline;
-  _edit_area->getCursorPosition (&line, &cur);
-  if ( _edit_area->markersAtLine (line) && (1 << breakpoint) )
-    line++; // we have a breakpoint here, so start search from next line
-  nextline = _edit_area->markerFindNext (line, (1 << breakpoint));
-  _edit_area->setCursorPosition (nextline, 0);
-}
-
-void
-file_editor_tab::previous_breakpoint ()
-{
-  int line, cur, prevline;
-  _edit_area->getCursorPosition (&line, &cur);
-  if ( _edit_area->markersAtLine (line) && (1 << breakpoint) )
-    line--; // we have a breakpoint here, so start search from prev line
-  prevline = _edit_area->markerFindPrevious (line, (1 << breakpoint));
-  _edit_area->setCursorPosition (prevline, 0);
-}
-
-void
-file_editor_tab::cut ()
-{
-  _edit_area->cut ();
-}
-
-void
-file_editor_tab::copy ()
-{
-  _edit_area->copy ();
-}
-
-void
-file_editor_tab::paste ()
-{
-  _edit_area->paste ();
-}
-
-void
-file_editor_tab::undo ()
-{
-  _edit_area->undo ();
-}
-
-void
-file_editor_tab::redo ()
-{
-  _edit_area->redo ();
-}
-
-void
-file_editor_tab::set_debugger_position (int line)
+file_editor_tab::remove_bookmark (const QWidget* ID)
 {
-  _edit_area->markerDeleteAll (debugger_position);
-  if (line > 0)
-    {
-      _edit_area->markerAdd (line, debugger_position);
-    }
-}
-
-void
-file_editor_tab::set_modified (bool modified)
-{
-  _edit_area->setModified (modified);
-}
-
-bool
-file_editor_tab::open_file (const QString& dir)
-{
-  QString openFileName;
-  QFileDialog fileDialog(this);
-  fileDialog.setNameFilter(SAVE_FILE_FILTER);
-  fileDialog.setAcceptMode(QFileDialog::AcceptOpen);
-  fileDialog.setViewMode(QFileDialog::Detail);
-  fileDialog.setDirectory(dir);
-  if (fileDialog.exec () == QDialog::Accepted)
-    {
-      openFileName = fileDialog.selectedFiles().at(0);
-      if (openFileName.isEmpty ())
-        return false;
-
-      return load_file(openFileName);
-    }
-  else
-    {
-      return false;
-    }
-}
-
-bool
-file_editor_tab::load_file(const QString& fileName, bool silent)
-{
-  if (!_file_editor->isVisible ())
-    {
-      _file_editor->show ();
-    }
-
-  QFile file (fileName);
-  if (!file.open (QFile::ReadOnly))
-    {
-      if (silent==false)
-        QMessageBox::warning (this, tr ("Octave Editor"),
-                              tr ("Could not open file %1 for read:\n%2.").arg (fileName).
-                              arg (file.errorString ()));
-      return false;
-    }
-
-  QTextStream in (&file);
-  QApplication::setOverrideCursor (Qt::WaitCursor);
-  _edit_area->setText (in.readAll ());
-  QApplication::restoreOverrideCursor ();
-
-  set_file_name (fileName);
-  update_window_title (false); // window title (no modification)
-  _edit_area->setModified (false); // loaded file is not modified yet
-
-  return true;
-}
-
-void
-file_editor_tab::new_file ()
-{
-  if (!_file_editor->isVisible ())
-    {
-      _file_editor->show ();
-    }
-
-  set_file_name (UNNAMED_FILE);
-  update_window_title (false); // window title (no modification)
-  _edit_area->setText ("");
-  _edit_area->setModified (false); // new file is not modified yet
-}
-
-bool file_editor_tab::save_file()
-{
-  return save_file (_file_name);
-}
-
-bool
-file_editor_tab::save_file (const QString& saveFileName)
-{
-  // it is a new file with the name "<unnamed>" -> call saveFielAs
-  if (saveFileName == UNNAMED_FILE || saveFileName.isEmpty ())
-    {
-      return save_file_as();
-    }
+  if (ID != this)
+    return;
 
-  // remove the file to save from the tracker since we will change it on disk now
-  QStringList watched_files = _file_system_watcher.files();
-  if (!watched_files.isEmpty ())
-    _file_system_watcher.removePath(saveFileName);  
-    
-  // open the file for writing
-  QFile file (saveFileName);
-  if (!file.open (QFile::WriteOnly))
-    {
-      QMessageBox::warning (this, tr ("Octave Editor"),
-                            tr ("Could not open file %1 for write:\n%2.").
-                            arg (saveFileName).arg (file.errorString ()));
-      return false;
-    }
-
-  // save the contents into the file
-  QTextStream out (&file);
-  QApplication::setOverrideCursor (Qt::WaitCursor);
-  out << _edit_area->text ();
-  QApplication::restoreOverrideCursor ();
-  file.close();
-
-  // save file name after closing file otherwise tracker will notice file change
-  set_file_name (saveFileName);
-  // set the window title to actual file name (not modified)
-  update_window_title (false);
-  // files is save -> not modified
-  _edit_area->setModified (false);
-
-  return true;
-}
-
-bool
-file_editor_tab::save_file_as ()
-{
-  QString saveFileName(_file_name);
-  QFileDialog fileDialog(this);
-  if (saveFileName == UNNAMED_FILE || saveFileName.isEmpty ())
-    {
-      QString directory = QString::fromStdString
-        (octave_link::last_working_directory ());
-
-      if (directory.isEmpty ())
-        {
-          directory = QDir::homePath ();
-        }
-
-      fileDialog.setDirectory (directory);
-    }
-  else
-    {
-      fileDialog.selectFile (saveFileName);
-    }
-  fileDialog.setNameFilter (SAVE_FILE_FILTER);
-  fileDialog.setDefaultSuffix ("m");
-  fileDialog.setAcceptMode (QFileDialog::AcceptSave);
-  fileDialog.setViewMode (QFileDialog::Detail);
-
-  if (fileDialog.exec ())
-    {
-      saveFileName = fileDialog.selectedFiles ().at (0);
-      if (saveFileName.isEmpty ())
-        return false;
-
-      return save_file (saveFileName);
-    }
-
-  return false;
-}
-
-void
-file_editor_tab::run_file ()
-{
-  if (_edit_area->isModified ())
-    save_file(_file_name);
-
-  QFileInfo file_info (_file_name);
-  QString path = file_info.absolutePath ();
-  QString current_path
-    = QString::fromStdString (octave_link::last_working_directory ());
-  QString function_name = file_info.fileName ();
-
-  // We have to cut off the suffix, because octave appends it.
-  function_name.chop (file_info.suffix ().length () + 1);
-  _file_editor->terminal ()->sendText (QString ("cd \'%1\'\n%2\n")
-                                       .arg(path).arg (function_name));
-  // TODO: Sending a run event crashes for long scripts. Find out why.
-  // octave_link::post_event
-  //   (this, &file_editor_tab::run_file_callback, _file_name.toStdString ()));
-}
-
-void
-file_editor_tab::file_has_changed (const QString&)
-{
-  if (QFile::exists (_file_name))
-    {
-      // Prevent popping up multiple message boxes when the file has
-      // been changed multiple times.
-      static bool alreadyAsking = false;
-      if (!alreadyAsking)
-        {
-          alreadyAsking = true;
-
-          int decision =
-            QMessageBox::warning (this, tr ("Octave Editor"),
-                                  tr ("It seems that \'%1\' has been modified by another application. Do you want to reload it?").
-                                  arg (_file_name), QMessageBox::Yes,
-                                  QMessageBox::No);
-
-          if (decision == QMessageBox::Yes)
-            {
-              load_file (_file_name);
-            }
-
-          alreadyAsking = false;
-        }
-    }
-  else
-    {
-      int decision =
-        QMessageBox::warning (this, tr ("Octave Editor"),
-                              tr ("It seems that \'%1\' has been deleted or renamed. Do you want to save it now?").
-                              arg (_file_name), QMessageBox::Save,
-                              QMessageBox::Close);
-      if (decision == QMessageBox::Save)
-        {
-          if (!save_file_as ())
-            {
-              set_file_name (UNNAMED_FILE);
-              update_window_title (true); // window title (no modification)
-              set_modified (true);
-            }
-        }
-      else
-        {
-          emit close_request ();
-        }
-    }
-}
-
-void
-file_editor_tab::notice_settings ()
-{
-  QSettings *settings = resource_manager::get_settings ();
-
-  if (settings==NULL)
-    return; // this shouldn't happen!
-
-  _edit_area->setCaretLineVisible(settings->value ("editor/highlightCurrentLine",true).toBool ());
-
-  if (settings->value ("editor/codeCompletion",true).toBool ())
-    _edit_area->setAutoCompletionThreshold (1);
-  else
-    _edit_area->setAutoCompletionThreshold (-1);
-
-  QFont font( settings->value ("editor/fontName","Courier").toString () ,
-              settings->value ("editor/fontSize",10).toInt () );
-  if (settings->value ("editor/showLineNumbers",true).toBool ())
-    {
-      _edit_area->setMarginLineNumbers (2, true);
-      _edit_area->setMarginsFont( font );
-      QFontMetrics metrics( font );
-      _edit_area->setMarginWidth(2, metrics.width("9999"));
-    }
-  else
-    {
-      _edit_area->setMarginLineNumbers (2, false);
-      _edit_area->setMarginWidth(2, 0);
-    }
-
-  update_lexer ();
-
-  _long_title = settings->value ("editor/longWindowTitle",false).toBool ();
-
-  update_window_title (false);
-}
-
-void
-file_editor_tab::run_file_callback (void)
-{
-  // Maybe someday we will do something here?
+  _edit_area->markerDeleteAll (bookmark);
 }
 
 void
 file_editor_tab::add_breakpoint_callback (const bp_info& info)
 {
   bp_table::intmap intmap;
   intmap[0] = info.line + 1;
 
@@ -826,8 +459,644 @@ file_editor_tab::remove_all_breakpoints_
   std::string previous_directory = octave_env::get_current_directory ();
   octave_env::chdir (info.path);
   intmap = bp_table::remove_all_breakpoints_in_file (info.function_name, true);
   octave_env::chdir (previous_directory);
 
   if (intmap.size() > 0)
     _edit_area->markerDeleteAll (breakpoint);
 }
+
+void
+file_editor_tab::request_add_breakpoint (int line)
+{
+  QFileInfo file_info (_file_name);
+  QString path = file_info.absolutePath ();
+  QString function_name = file_info.fileName ();
+
+  // We have to cut off the suffix, because octave appends it.
+  function_name.chop (file_info.suffix ().length () + 1);
+
+  bp_info info (path, function_name, line);
+
+  octave_link::post_event
+    (this, &file_editor_tab::add_breakpoint_callback, info);
+}
+
+void
+file_editor_tab::request_remove_breakpoint (int line)
+{
+  QFileInfo file_info (_file_name);
+  QString path = file_info.absolutePath ();
+  QString function_name = file_info.fileName ();
+
+  // We have to cut off the suffix, because octave appends it.
+  function_name.chop (file_info.suffix ().length () + 1);
+
+  bp_info info (path, function_name, line);
+
+  octave_link::post_event
+    (this, &file_editor_tab::remove_breakpoint_callback, info);
+}
+
+void
+file_editor_tab::toggle_breakpoint (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  int line, cur;
+  _edit_area->getCursorPosition (&line, &cur);
+  if ( _edit_area->markersAtLine (line) && (1 << breakpoint) )
+    request_remove_breakpoint (line);
+  else
+    request_add_breakpoint (line);
+}
+
+void
+file_editor_tab::next_breakpoint (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  int line, cur, nextline;
+  _edit_area->getCursorPosition (&line, &cur);
+  if ( _edit_area->markersAtLine (line) && (1 << breakpoint) )
+    line++; // we have a breakpoint here, so start search from next line
+  nextline = _edit_area->markerFindNext (line, (1 << breakpoint));
+  _edit_area->setCursorPosition (nextline, 0);
+}
+
+void
+file_editor_tab::previous_breakpoint (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  int line, cur, prevline;
+  _edit_area->getCursorPosition (&line, &cur);
+  if ( _edit_area->markersAtLine (line) && (1 << breakpoint) )
+    line--; // we have a breakpoint here, so start search from prev line
+  prevline = _edit_area->markerFindPrevious (line, (1 << breakpoint));
+  _edit_area->setCursorPosition (prevline, 0);
+}
+
+void
+file_editor_tab::remove_all_breakpoints (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  QFileInfo file_info (_file_name);
+  QString path = file_info.absolutePath ();
+  QString function_name = file_info.fileName ();
+
+  // We have to cut off the suffix, because octave appends it.
+  function_name.chop (file_info.suffix ().length () + 1);
+
+  bp_info info (path, function_name, 0);
+
+  octave_link::post_event
+    (this, &file_editor_tab::remove_all_breakpoints_callback, info);
+}
+
+void
+file_editor_tab::comment_selected_text (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  do_comment_selected_text (true);
+}
+
+void
+file_editor_tab::uncomment_selected_text (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  do_comment_selected_text (false);
+}
+
+void
+file_editor_tab::handle_find_dialog_finished (int)
+{
+  // Find dialog is going to hide.  Save location of window for
+  // when it is reshown.
+  _find_dialog_geometry = _find_dialog->geometry ();
+  _find_dialog_is_visible = false;
+}
+
+void
+file_editor_tab::find (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  // The find_dialog feature doesn't need a slot for return info.
+  // Rather than Qt::DeleteOnClose, let the find feature hang about
+  // in case it contains useful information like previous searches
+  // and so on.  Perhaps one find dialog for the whole editor is
+  // better, but individual find dialogs has the nice feature of
+  // retaining position per file editor tabs, which can be undocked.
+
+  if (!_find_dialog)
+    {
+       _find_dialog = new find_dialog (_edit_area);
+      connect (_find_dialog, SIGNAL (finished (int)),
+               this, SLOT (handle_find_dialog_finished (int)));
+      _find_dialog->setWindowModality (Qt::NonModal);
+      _find_dialog_geometry = _find_dialog->geometry ();
+    }
+
+  if (!_find_dialog->isVisible ())
+    {
+      _find_dialog->setGeometry (_find_dialog_geometry);
+      _find_dialog->show ();
+      _find_dialog_is_visible = true;
+    }
+
+  _find_dialog->activateWindow ();
+}
+
+void
+file_editor_tab::do_comment_selected_text (bool comment)
+{
+  if ( _edit_area->hasSelectedText() )
+    {
+      int lineFrom, lineTo, colFrom, colTo, i;
+      _edit_area->getSelection (&lineFrom,&colFrom,&lineTo,&colTo);
+      if ( colTo == 0 )  // the beginning of last line is not selected
+        lineTo--;        // stop at line above
+      _edit_area->beginUndoAction ();
+      for ( i=lineFrom; i<=lineTo; i++ )
+        {
+          if ( comment )
+            _edit_area->insertAt("%",i,0);
+          else
+            {
+              QString line(_edit_area->text(i));
+              if ( line.startsWith("%") )
+                {
+                  _edit_area->setSelection(i,0,i,1);
+                  _edit_area->removeSelectedText();
+                }
+            }
+        }
+      _edit_area->endUndoAction ();
+    }
+}
+
+void
+file_editor_tab::update_window_title (bool modified)
+{
+  QString title ("");
+  if (_file_name.isEmpty () || _file_name.at (_file_name.count () - 1) == '/')
+    title = UNNAMED_FILE;
+  else
+    title = _file_name;
+  if ( !_long_title )
+    {
+      QFileInfo file(_file_name);
+      title = file.fileName();
+    }
+
+  if ( modified )
+    {
+      emit file_name_changed (title.prepend("* "));
+    }
+  else
+    emit file_name_changed (title);
+}
+
+void
+file_editor_tab::handle_copy_available(bool enableCopy)
+{
+  _copy_available = enableCopy;
+  emit editor_state_changed (_copy_available, QDir::cleanPath (_file_name));
+}
+
+int
+file_editor_tab::check_file_modified (const QString& msg, int cancelButton)
+{
+  int decision = QMessageBox::Yes;
+  if (_edit_area->isModified ())
+    {
+      // File is modified but not saved, ask user what to do.  The file
+      // editor tab can't be made parent because it may be deleted depending
+      // upon the response.  Instead, change the _edit_area to read only.
+      QMessageBox* msgBox = new QMessageBox (
+              QMessageBox::Warning, tr ("Octave Editor"),
+              tr ("The file \'%1\' has been modified. Do you want to save the changes?").
+              arg (_file_name), QMessageBox::Yes | QMessageBox::No, 0);
+      _edit_area->setReadOnly (true);
+      connect (msgBox, SIGNAL (finished (int)),
+               this, SLOT (handle_file_modified_answer (int)));
+      msgBox->setWindowModality (Qt::NonModal);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+      msgBox->show ();
+      return (QMessageBox::Cancel);
+    }
+  else
+    {
+      // Nothing was modified, just remove from editor.
+      emit tab_remove_request ();
+    }
+ 
+  return (decision);
+}
+
+void
+file_editor_tab::handle_file_modified_answer (int decision)
+{
+  if (decision == QMessageBox::Yes)
+    {
+      // Save file, then remove from editor.
+      save_file (_file_name, true);
+    }
+  else if (decision == QMessageBox::No)
+    {
+      // User doesn't want to save, just remove from editor.
+      emit tab_remove_request ();
+    }
+  else
+    {
+      // User canceled, allow editing again.
+      _edit_area->setReadOnly (false);
+    }
+}
+
+void
+file_editor_tab::set_modified (bool modified)
+{
+  _edit_area->setModified (modified);
+}
+
+QString
+file_editor_tab::load_file(const QString& fileName)
+{
+  QFile file (fileName);
+  if (!file.open (QFile::ReadOnly))
+    {
+      return file.errorString ();
+    }
+
+  QTextStream in (&file);
+  QApplication::setOverrideCursor (Qt::WaitCursor);
+  _edit_area->setText (in.readAll ());
+  QApplication::restoreOverrideCursor ();
+
+  set_file_name (fileName);
+  update_window_title (false); // window title (no modification)
+  _edit_area->setModified (false); // loaded file is not modified yet
+
+  return QString ();
+}
+
+void
+file_editor_tab::new_file ()
+{
+  update_window_title (false); // window title (no modification)
+  _edit_area->setText ("");
+  _edit_area->setModified (false); // new file is not modified yet
+}
+
+void
+file_editor_tab::save_file (const QString& saveFileName, bool remove_on_success)
+{
+  // If it is a new file with no name, signal that saveFileAs
+  // should be performed.
+  if (saveFileName.isEmpty () || saveFileName.at (saveFileName.count () - 1) == '/')
+     {
+      save_file_as (remove_on_success);
+      return;
+    }
+
+  // stop watching file
+  QStringList trackedFiles = _file_system_watcher.files ();
+  if (!trackedFiles.isEmpty ())
+    _file_system_watcher.removePath (saveFileName);
+
+  // open the file for writing
+  QFile file (saveFileName);
+  if (!file.open (QIODevice::WriteOnly))
+    {
+      // Unsuccessful, begin watching file again if it was being
+      // watched previously.
+      if (trackedFiles.contains (saveFileName))
+        _file_system_watcher.addPath (saveFileName);
+
+      // Create a NonModal message about error.
+      QMessageBox* msgBox = new QMessageBox (
+              QMessageBox::Critical, tr ("Octave Editor"),
+              tr ("Could not open file %1 for write:\n%2.").
+              arg (saveFileName).arg (file.errorString ()),
+              QMessageBox::Ok, 0);
+      msgBox->setWindowModality (Qt::NonModal);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+      msgBox->show ();
+      return;
+    }
+
+  // save the contents into the file
+  QTextStream out (&file);
+  QApplication::setOverrideCursor (Qt::WaitCursor);
+  out << _edit_area->text ();
+  QApplication::restoreOverrideCursor ();
+  file.close();
+
+  // save file name after closing file as set_file_name starts watching again
+  set_file_name (saveFileName);
+  // set the window title to actual file name (not modified)
+  update_window_title (false);
+  // files is save -> not modified
+  _edit_area->setModified (false);
+
+  if (remove_on_success)
+    {
+      emit tab_remove_request ();
+      return;  // Don't touch member variables after removal
+    }
+}
+
+void
+file_editor_tab::save_file_as (bool remove_on_success)
+{
+  // Simply put up the file chooser dialog box with a slot connection
+  // then return control to the system waiting for a file selection.
+
+  // If the tab is removed in response to a QFileDialog signal, the tab
+  // can't be a parent.
+  QFileDialog* fileDialog;
+  if (remove_on_success)
+    {
+      // If tab is closed, "this" cannot be parent in which case modality
+      // has no effect.  Disable editing instead.
+      _edit_area->setReadOnly (true);
+      fileDialog = new QFileDialog ();
+    }
+  else
+    fileDialog = new QFileDialog (this);
+
+  if (!_file_name.isEmpty () && _file_name.at (_file_name.count () - 1) != '/')
+    {
+      fileDialog->selectFile (_file_name);
+    }
+  else
+    {
+      fileDialog->selectFile ("");
+      if (_file_name.isEmpty ())
+        {
+          fileDialog->setDirectory (QDir::currentPath ());
+        }
+      else
+        {
+          // The file name is actually the directory name from the
+          // constructor argument.
+          fileDialog->setDirectory (_file_name);
+        }
+    }
+  fileDialog->setNameFilter (SAVE_FILE_FILTER);
+  fileDialog->setDefaultSuffix ("m");
+  fileDialog->setAcceptMode (QFileDialog::AcceptSave);
+  fileDialog->setViewMode (QFileDialog::Detail);
+  if (remove_on_success)
+    {
+      connect (fileDialog, SIGNAL (fileSelected (const QString&)),
+               this, SLOT (handle_save_file_as_answer_close (const QString&)));
+      connect (fileDialog, SIGNAL (rejected ()),
+               this, SLOT (handle_save_file_as_answer_cancel ()));
+    }
+  else
+    {
+      connect (fileDialog, SIGNAL (fileSelected (const QString&)),
+               this, SLOT (handle_save_file_as_answer (const QString&)));
+    }
+  fileDialog->setWindowModality (Qt::WindowModal);
+  fileDialog->setAttribute (Qt::WA_DeleteOnClose);
+  fileDialog->show ();
+}
+
+void
+file_editor_tab::message_duplicate_file_name (const QString& saveFileName)
+{
+  // Could overwrite the file here (and tell user the file was
+  // overwritten), but the user could have unintentionally
+  // selected the same name not intending to overwrite.
+
+  // Create a NonModal message about error.
+  QMessageBox* msgBox = new QMessageBox (
+          QMessageBox::Critical, tr ("Octave Editor"),
+          tr ("File not saved!  You've selected a file name\n\n     %1\n\nwhich is the same as the current file name.  Use ""Save"" to overwrite.  (Could allow overwriting, with message, if that is what folks want.)").
+          arg (saveFileName),
+          QMessageBox::Ok, 0);
+  msgBox->setWindowModality (Qt::NonModal);
+  msgBox->setAttribute (Qt::WA_DeleteOnClose);
+  msgBox->show ();
+}
+
+void
+file_editor_tab::handle_save_file_as_answer (const QString& saveFileName)
+{
+  if (saveFileName == _file_name)
+    {
+      message_duplicate_file_name (saveFileName);
+      // Nothing done, allow editing again.
+      _edit_area->setReadOnly (false);
+    }
+  else
+    {
+      // Have editor check for conflict, do not delete tab after save.
+      emit editor_check_conflict_save (saveFileName, false);
+    }
+}
+
+void
+file_editor_tab::handle_save_file_as_answer_close (const QString& saveFileName)
+{
+  if (saveFileName == _file_name)
+    {
+      message_duplicate_file_name (saveFileName);
+      // Nothing done, allow editing again.
+      _edit_area->setReadOnly (false);
+    }
+  else
+    {
+      // Have editor check for conflict, delete tab after save.
+      emit editor_check_conflict_save (saveFileName, true);
+    }
+}
+
+void
+file_editor_tab::handle_save_file_as_answer_cancel ()
+{
+  // User canceled, allow editing again.
+  _edit_area->setReadOnly (false);
+}
+
+void
+file_editor_tab::file_has_changed (const QString&)
+{
+  // Prevent popping up multiple message boxes when the file has
+  // been changed multiple times by temporarily removing from the
+  // file watcher.
+  QStringList trackedFiles = _file_system_watcher.files ();
+  if (!trackedFiles.isEmpty ())
+    _file_system_watcher.removePath (_file_name);
+
+  if (QFile::exists (_file_name))
+    {
+      // Create a WindowModal message that blocks the edit area
+      // by making _edit_area parent.
+      QMessageBox* msgBox = new QMessageBox (
+              QMessageBox::Warning, tr ("Octave Editor"),
+              tr ("It seems that \'%1\' has been modified by another application. Do you want to reload it?").
+              arg (_file_name), QMessageBox::Yes | QMessageBox::No, this);
+      connect (msgBox, SIGNAL (finished (int)),
+               this, SLOT (handle_file_reload_answer (int)));
+      msgBox->setWindowModality (Qt::WindowModal);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+      msgBox->show ();
+    }
+  else
+    {
+      // Create a WindowModal message that blocks the edit area
+      // by making _edit_area parent.
+      QMessageBox* msgBox = new QMessageBox (
+              QMessageBox::Warning, tr ("Octave Editor"),
+              tr ("It seems that \'%1\' has been deleted or renamed. Do you want to save it now?").
+              arg (_file_name), QMessageBox::Save | QMessageBox::Close, this);
+      connect (msgBox, SIGNAL (finished (int)),
+               this, SLOT (handle_file_resave_answer (int)));
+      msgBox->setWindowModality (Qt::WindowModal);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+      msgBox->show ();
+    }
+}
+
+void
+file_editor_tab::notice_settings ()
+{
+  QSettings *settings = resource_manager::get_settings ();
+
+  if (settings==NULL)
+    return; // this shouldn't happen!
+
+  _edit_area->setCaretLineVisible(settings->value ("editor/highlightCurrentLine",true).toBool ());
+
+  if (settings->value ("editor/codeCompletion",true).toBool ())
+    _edit_area->setAutoCompletionThreshold (1);
+  else
+    _edit_area->setAutoCompletionThreshold (-1);
+
+  QFont font( settings->value ("editor/fontName","Courier").toString () ,
+              settings->value ("editor/fontSize",10).toInt () );
+  if (settings->value ("editor/showLineNumbers",true).toBool ())
+    {
+      _edit_area->setMarginLineNumbers (2, true);
+      _edit_area->setMarginsFont( font );
+      QFontMetrics metrics( font );
+      _edit_area->setMarginWidth(2, metrics.width("9999"));
+    }
+  else
+    {
+      _edit_area->setMarginLineNumbers (2, false);
+      _edit_area->setMarginWidth(2, 0);
+    }
+
+  update_lexer ();
+
+  _long_title = settings->value ("editor/longWindowTitle",false).toBool ();
+
+  update_window_title (false);
+}
+
+void
+file_editor_tab::conditional_close (const QWidget* ID)
+{
+  if (ID != this)
+    return;
+
+  close ();
+}
+
+void
+file_editor_tab::change_editor_state (const QWidget* ID)
+{
+  if (ID != this)
+    {
+      // Widget may be going out of focus.  If so, record location.
+      if (_find_dialog)
+        {
+          if (_find_dialog->isVisible ())
+            {
+              _find_dialog_geometry = _find_dialog->geometry ();
+              _find_dialog->hide ();
+            }
+        }
+      return;
+    }
+
+  if (_find_dialog && _find_dialog_is_visible)
+    {
+      _find_dialog->setGeometry (_find_dialog_geometry);
+      _find_dialog->show ();
+    }
+  emit editor_state_changed (_copy_available, QDir::cleanPath (_file_name));
+}
+
+void
+file_editor_tab::file_name_query (const QWidget* ID)
+{
+  // A zero (null pointer) means that all file editor tabs
+  // should respond, otherwise just the desired file editor tab.
+  if (ID != this && ID != 0)
+    return;
+
+  // Unnamed files shouldn't be transmitted.
+  if (!_file_name.isEmpty ())
+    emit add_filename_to_list (_file_name);
+}
+
+void
+file_editor_tab::handle_file_reload_answer (int decision)
+{
+  if (decision == QMessageBox::Yes)
+    { // reload: file is readded to the file watcher in set_file_name ()
+      load_file (_file_name);
+    }
+  else
+    { // do not reload: readd to the file watche
+      _file_system_watcher.addPath (_file_name);
+    }
+}
+
+void
+file_editor_tab::handle_file_resave_answer (int decision)
+{
+  if (decision == QMessageBox::Save)
+    {
+      save_file (_file_name);
+    }
+  else
+    {
+      if (close ())
+        {
+          emit tab_remove_request ();
+          return;  // Don't touch member variables after removal
+        }
+    }
+
+  // Start watching file once again.
+  _file_system_watcher.addPath (_file_name);
+}
+
+void
+file_editor_tab::set_debugger_position (int line)
+{
+  _edit_area->markerDeleteAll (debugger_position);
+  if (line > 0)
+    {
+      _edit_area->markerAdd (line, debugger_position);
+    }
+}
+
+#endif
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -23,101 +23,136 @@ along with Octave; see the file COPYING.
 #ifndef FILEEDITORTAB_H
 #define FILEEDITORTAB_H
 
 #include <Qsci/qsciscintilla.h>
 #include <QWidget>
 #include <QCloseEvent>
 #include <QFileSystemWatcher>
 
+#include "find-dialog.h"
+
 class file_editor;
 class file_editor_tab : public QWidget
 {
   Q_OBJECT
   public:
-  file_editor_tab (file_editor *fileEditor);
-  bool copy_available ();
+  file_editor_tab (QString directory = "");
+  ~file_editor_tab ();
 
 public slots:
   void update_window_title(bool modified);
   void handle_copy_available(bool enableCopy);
   void handle_margin_clicked (int line, int margin, Qt::KeyboardModifiers state);
-  void comment_selected_text ();
-  void uncomment_selected_text ();
-  void find ();
-  void remove_bookmark ();
-  void toggle_bookmark ();
-  void next_bookmark ();
-  void previous_bookmark ();
-  void remove_all_breakpoints ();
-  void toggle_breakpoint ();
-  void next_breakpoint ();
-  void previous_breakpoint ();
-  void cut ();
-  void copy ();
-  void paste ();
-  void undo ();
-  void redo ();
+
+  /** Tells the editor tab to react on changed settings. */
+  void notice_settings ();
+  /** Will initiate close if associated with the identifier tag. */
+  void conditional_close (const QWidget* ID);
+  /** Change to a different editor tab by identifier tag. */
+  void change_editor_state (const QWidget* ID);
+  /** Simply transmit file name. */
+  void file_name_query (const QWidget* ID);
+
+  void undo (const QWidget* ID);
+  void redo (const QWidget* ID);
+  void copy (const QWidget* ID);
+  void cut (const QWidget* ID);
+  void paste (const QWidget* ID);
+  void save_file (const QWidget* ID);
+  void save_file (const QWidget* ID, const QString& fileName, bool remove_on_success);
+  void save_file_as (const QWidget* ID);
+  void run_file (const QWidget* ID);
+  void toggle_bookmark (const QWidget* ID);
+  void next_bookmark (const QWidget* ID);
+  void previous_bookmark (const QWidget* ID);
+  void remove_bookmark (const QWidget* ID);
+
+  void toggle_breakpoint (const QWidget* ID);
+  void next_breakpoint (const QWidget* ID);
+  void previous_breakpoint (const QWidget* ID);
+  void remove_all_breakpoints (const QWidget* ID);
+
+  void comment_selected_text (const QWidget* ID);
+  void uncomment_selected_text (const QWidget* ID);
+  void find (const QWidget* ID);
+
   void set_debugger_position (int line);
 
   void set_modified (bool modified = true);
 
-  bool open_file (const QString& dir = QString ());
-  bool load_file (const QString& fileName, bool silent = false);
+  QString load_file (const QString& fileName);
   void new_file ();
-  bool save_file ();
-  bool save_file (const QString& saveFileName);
-  bool save_file_as();
-  void run_file ();
 
   void file_has_changed (const QString& fileName);
-  QString get_file_name () const {return _file_name;}
-
-  /** Tells the editor tab to react on changed settings. */
-  void notice_settings ();
 
 signals:
   void file_name_changed (const QString& fileName);
-  void editor_state_changed ();
-  void close_request ();
+  void editor_state_changed (bool copy_available, const QString& fileName);
+  void tab_remove_request ();
+  void add_filename_to_list (const QString& fileName);
+  void mru_add_file (const QString& file_name);
+  void editor_check_conflict_save (const QString& saveFileName, bool remove_on_success);
+  void process_octave_code (const QString& command);
 
 protected:
   void closeEvent (QCloseEvent *event);
   void set_file_name (const QString& fileName);
 
+private slots:
+  /** When user closes message box for reload question. */
+  void handle_file_reload_answer (int decision);
+  /** When user closes message box for resave question. */
+  void handle_file_resave_answer (int decision);
+  /** When user closes message box for modified question. */
+  void handle_file_modified_answer (int decision);
+  /** When user closes find_dialog box. */
+  void handle_find_dialog_finished (int decision);
+  /** When user closes QFileDialog box. */
+  void handle_save_file_as_answer (const QString& fileName);
+  void handle_save_file_as_answer_close (const QString& fileName);
+  void handle_save_file_as_answer_cancel ();
+
 private:
 
   struct bp_info
   {
     bp_info (const QString& p, const QString& fn, int l)
       : path (p.toStdString ()), function_name (fn.toStdString ()), line (l)
     { }
 
     std::string path;
     std::string function_name;
     int line;
   };
 
+  void save_file (const QString& saveFileName, bool remove_on_success = false);
+  void save_file_as (bool remove_on_success = false);
+  void message_duplicate_file_name (const QString& fileName);
+
   void update_lexer ();
   void request_add_breakpoint (int line);
   void request_remove_breakpoint (int line);
 
   int check_file_modified (const QString& msg, int cancelButton);
   void do_comment_selected_text (bool comment);
 
   void run_file_callback (void);
   void add_breakpoint_callback (const bp_info& info);
   void remove_breakpoint_callback (const bp_info& info);
   void remove_all_breakpoints_callback (const bp_info& info);
 
-  file_editor *         _file_editor;
   QsciScintilla *       _edit_area;
 
   QString               _file_name;
   QString               _file_name_short;
 
   bool                  _long_title;
   bool                  _copy_available;
 
   QFileSystemWatcher    _file_system_watcher;
+
+  find_dialog *         _find_dialog;
+  bool                  _find_dialog_is_visible;
+  QRect                 _find_dialog_geometry;
 };
 
 #endif // FILEEDITORTAB_H
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -19,67 +19,56 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#ifdef HAVE_QSCINTILLA
+
 #include "file-editor.h"
 #include "resource-manager.h"
 #include <QVBoxLayout>
 #include <QApplication>
 #include <QFile>
 #include <QFont>
 #include <QFileDialog>
 #include <QMessageBox>
 #include <QStyle>
 #include <QTextStream>
 
-file_editor::file_editor (QTerminal *t, main_window *m)
-  : file_editor_interface (t, m)
+#include "octave-link.h"
+
+file_editor::file_editor (QWidget *p)
+  : file_editor_interface (p)
 {
+  // Set current editing directory before construct because loaded
+  // files will change ced accordingly.
+  ced = QDir::currentPath ();
+
   construct ();
 
-  _terminal = t;
-  _main_window = m;
   setVisible (false);
 }
 
 file_editor::~file_editor ()
 {
   QSettings *settings = resource_manager::get_settings ();
-  QStringList sessionFileNames;
+  fetFileNames.clear ();
   if (settings->value ("editor/restoreSession",true).toBool ())
     {
-      for (int n=0;n<_tab_widget->count();++n)
-        {
-          file_editor_tab* tab = dynamic_cast<file_editor_tab*> (_tab_widget->widget (n));
-          if (!tab)
-            continue;
-          sessionFileNames.append (tab->get_file_name ());
-        }
+      // Have all file editor tabs signal what their file names are.
+      emit fetab_file_name_query (0);
     }
-  settings->setValue ("editor/savedSessionTabs", sessionFileNames);
+  settings->setValue ("editor/savedSessionTabs", fetFileNames);
   settings->sync ();
 }
 
-QTerminal *
-file_editor::terminal ()
-{
-  return _terminal;
-}
-
-main_window *
-file_editor::get_main_window ()
-{
-  return _main_window;
-}
-
 QMenu *
 file_editor::debug_menu ()
 {
   return _debug_menu;
 }
 
 QToolBar *
 file_editor::toolbar ()
@@ -97,309 +86,433 @@ void
 file_editor::handle_quit_debug_mode ()
 {
   _run_action->setEnabled (true);
 }
 
 void
 file_editor::request_new_file ()
 {
-  file_editor_tab *fileEditorTab = new file_editor_tab (this);
+  // New file isn't a file_editor_tab function since the file
+  // editor tab has yet to be created and there is no object to
+  // pass a signal to.  Hence, functionality is here.
+
+  file_editor_tab *fileEditorTab = new file_editor_tab (ced);
   if (fileEditorTab)
     {
-      add_file_editor_tab (fileEditorTab);
+      add_file_editor_tab (fileEditorTab, UNNAMED_FILE);
       fileEditorTab->new_file ();
     }
 }
 
 void
 file_editor::request_open_file ()
 {
-  file_editor_tab *current_tab = active_editor_tab ();
-  int curr_tab_index = _tab_widget->currentIndex ();
-  file_editor_tab *fileEditorTab = new file_editor_tab (this);
-  if (fileEditorTab)
+  // Open file isn't a file_editor_tab function since the file
+  // editor tab has yet to be created and there is no object to
+  // pass a signal to.  Hence, functionality is here.
+
+  // Create a NonModal message.
+  QFileDialog* fileDialog = new QFileDialog (this);
+  fileDialog->setNameFilter (SAVE_FILE_FILTER);
+  fileDialog->setAcceptMode (QFileDialog::AcceptOpen);
+  fileDialog->setViewMode (QFileDialog::Detail);
+  fileDialog->setDirectory (ced);
+  connect (fileDialog, SIGNAL (fileSelected (const QString&)),
+           this, SLOT (request_open_file (const QString&)));
+  fileDialog->setWindowModality (Qt::NonModal);
+  fileDialog->setAttribute (Qt::WA_DeleteOnClose);
+  fileDialog->show ();
+}
+
+void
+file_editor::request_open_file (const QString& openFileName)
+{
+  if (openFileName.isEmpty ())
+    {
+      // ??  Not sure this will happen.  This routine isn't even called
+      // if the user hasn't selected a file.
+    }
+  else
     {
-      add_file_editor_tab (fileEditorTab);
-      QString dir = QDir::currentPath ();
-      // get the filename of the last active tab to open a new file from there
-      if (current_tab)
-        dir = QDir::cleanPath (current_tab->get_file_name ());
-      if (!fileEditorTab->open_file (dir))
+      // Have all file editor tabs signal what their file names are.
+      fetFileNames.clear ();
+      emit fetab_file_name_query (0);
+
+      // Check whether this file is already open in the editor.
+      if (fetFileNames.contains (openFileName, Qt::CaseSensitive))
         {
-          // If no file was loaded, remove the tab again.
-          _tab_widget->removeTab (_tab_widget->indexOf (fileEditorTab));
-          // restore focus to previous tab
-          if (curr_tab_index>=0)
-            _tab_widget->setCurrentIndex (curr_tab_index);
+          // Create a NonModal message so nothing is blocked and
+          // bring the existing file forward.
+          QMessageBox* msgBox = new QMessageBox (
+                  QMessageBox::Critical, tr ("Octave Editor"),
+                  tr ("File %1 is already open in the editor.").
+                  arg (openFileName), QMessageBox::Ok, 0);
+          msgBox->setWindowModality (Qt::NonModal);
+          msgBox->setAttribute (Qt::WA_DeleteOnClose);
+          msgBox->show ();
+          QFileInfo file(openFileName);
+          QString short_openFileName = file.fileName();  // get file name only
+          for(int i = 0; i < _tab_widget->count (); i++)
+            { // check whether tab title is file name (long or short)
+              if (_tab_widget->tabText (i) == openFileName ||
+                  _tab_widget->tabText (i) == short_openFileName)
+                {
+                  _tab_widget->setCurrentIndex (i);
+                  break;
+                }
+            }
+          return;
+        }
+
+      file_editor_tab *fileEditorTab = new file_editor_tab ();
+      if (fileEditorTab)
+        {
+          QString result = fileEditorTab->load_file(openFileName);
+          if (result == "")
+            {
+              // Supply empty title then have the file_editor_tab update
+              // with full or short name.
+              add_file_editor_tab (fileEditorTab, "");
+              fileEditorTab->update_window_title (false);
+              // file already loaded, add file to mru list here
+              handle_mru_add_file(QDir::cleanPath (openFileName));
+            }
+          else
+            {
+              delete fileEditorTab;
+              // Create a NonModal message about error.
+              QMessageBox* msgBox = new QMessageBox (
+                      QMessageBox::Critical, tr ("Octave Editor"),
+                      tr ("Could not open file %1 for read:\n%2.").
+                      arg (openFileName).arg (result),
+                      QMessageBox::Ok, 0);
+              msgBox->setWindowModality (Qt::NonModal);
+              msgBox->setAttribute (Qt::WA_DeleteOnClose);
+              msgBox->show ();
+            }
         }
     }
 }
 
+// open a file from the mru list
 void
-file_editor::request_open_file (const QString& fileName, bool silent)
+file_editor::request_mru_open_file ()
+{
+  QAction *action = qobject_cast<QAction *>(sender ());
+  if (action)
+    {
+      request_open_file (action->data ().toString ());
+    }
+}
+
+
+void
+file_editor::check_conflict_save (const QString& saveFileName, bool remove_on_success)
 {
-  if (!isVisible ())
+  // Have all file editor tabs signal what their file names are.
+  fetFileNames.clear ();
+  emit fetab_file_name_query (0);
+
+  // If one of those names matches the desired name, that's a conflict.
+  if (fetFileNames.contains (saveFileName, Qt::CaseSensitive))
     {
-      show ();
+      // Note: to overwrite the contents of some other file editor tab
+      // with the same name requires identifying which file editor tab
+      // that is (not too difficult) then close that tab.  Of course,
+      // that could trigger another dialog box if the file editor tab
+      // with the same name has modifications in it.  This could become
+      // somewhat confusing to the user.  For now, opt to do nothing.
+
+      // Create a NonModal message about error.
+      QMessageBox* msgBox = new QMessageBox (
+              QMessageBox::Critical, tr ("Octave Editor"),
+              tr ("File not saved!  You've selected a file name\n\n     %1\n\nwhich is the same as an already open file in the editor.  (Could allow overwriting, with message, if that is what folks want.)").
+              arg (saveFileName),
+              QMessageBox::Ok, 0);
+      msgBox->setWindowModality (Qt::NonModal);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+      msgBox->show ();
+
+      return;
     }
 
-  file_editor_tab *fileEditorTab = new file_editor_tab (this);
-  int curr_tab_index = _tab_widget->currentIndex ();
-  if (fileEditorTab)
+  QObject* saveFileObject = sender ();
+  QWidget* saveFileWidget = 0;
+  for(int i = 0; i < _tab_widget->count (); i++)
     {
-      add_file_editor_tab (fileEditorTab);
-      if (!fileEditorTab->load_file (fileName, silent))
+      if (_tab_widget->widget (i) == saveFileObject)
         {
-          // If no file was loaded, remove the tab again.
-          _tab_widget->removeTab (_tab_widget->indexOf (fileEditorTab));
-          // restore focus to previous tab
-          _tab_widget->setCurrentIndex (curr_tab_index);
+          saveFileWidget = _tab_widget->widget (i);
+          break;
         }
     }
+  if (!saveFileWidget)
+    {
+      // Create a NonModal message about error.
+      QMessageBox* msgBox = new QMessageBox (
+              QMessageBox::Critical, tr ("Octave Editor"),
+              tr ("The associated file editor tab has disappeared.  It was likely closed by some means."),
+              QMessageBox::Ok, 0);
+      msgBox->setWindowModality (Qt::NonModal);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+      msgBox->show ();
+      return;
+    }
+
+  // Can save without conflict, have the file editor tab do so.
+  emit fetab_save_file (saveFileWidget, saveFileName, remove_on_success);
 }
 
 void
 file_editor::request_undo ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->undo ();
+  emit fetab_undo (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_redo ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->redo ();
+  emit fetab_redo (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_copy ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->copy ();
+  emit fetab_copy (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_cut ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->cut ();
+  emit fetab_cut (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_paste ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->paste ();
+  emit fetab_paste (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_save_file ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->save_file ();
+  emit fetab_save_file (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_save_file_as ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->save_file_as ();
+   emit fetab_save_file_as (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_run_file ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->run_file ();
+  emit fetab_run_file (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_toggle_bookmark ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->toggle_bookmark ();
+  emit fetab_toggle_bookmark (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_next_bookmark ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->next_bookmark ();
+  emit fetab_next_bookmark (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_previous_bookmark ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->previous_bookmark ();
+  emit fetab_previous_bookmark (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_remove_bookmark ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->remove_bookmark ();
+  emit fetab_remove_bookmark (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_toggle_breakpoint ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->toggle_breakpoint ();
+  emit fetab_toggle_breakpoint (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_next_breakpoint ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->next_breakpoint ();
+  emit fetab_next_breakpoint (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_previous_breakpoint ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->previous_breakpoint ();
+  emit fetab_previous_breakpoint (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_remove_breakpoint ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->remove_all_breakpoints ();
+  emit fetab_remove_all_breakpoints (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_comment_selected_text ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->comment_selected_text ();
+  emit fetab_comment_selected_text (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_uncomment_selected_text ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->uncomment_selected_text ();
+  emit fetab_uncomment_selected_text (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_find ()
 {
-  file_editor_tab *_active_file_editor_tab = active_editor_tab ();
-  if (_active_file_editor_tab)
-    _active_file_editor_tab->find ();
+  emit fetab_find (_tab_widget->currentWidget ());
+}
+
+void
+file_editor::handle_mru_add_file (const QString& file_name)
+{
+  _mru_files.removeAll (file_name);
+  _mru_files.prepend (file_name);
+  mru_menu_update ();
+}
+
+void
+file_editor::mru_menu_update ()
+{
+  int num_files = qMin (_mru_files.size(), int (MaxMRUFiles));
+  // configure and show active actions of mru-menu
+  for (int i = 0; i < num_files; ++i)
+    {
+      QString text = tr("&%1 %2").
+          arg ((i+1) % int (MaxMRUFiles)).arg (_mru_files.at (i));
+      _mru_file_actions[i]->setText (text);
+      _mru_file_actions[i]->setData (_mru_files.at (i));
+      _mru_file_actions[i]->setVisible (true);
+    }
+    // hide unused mru-menu entries
+    for (int j = num_files; j < MaxMRUFiles; ++j)
+      _mru_file_actions[j]->setVisible (false);
+    // delete entries in string-list beyond MaxMRUFiles
+    while (_mru_files.size () > MaxMRUFiles)
+      _mru_files.removeLast ();
+    // save actual mru-list in settings
+    QSettings *settings = resource_manager::get_settings ();
+    // FIXME -- what should happen if settings is 0?
+    settings->setValue ("editor/mru_file_list",_mru_files);
 }
 
 void
 file_editor::handle_file_name_changed (const QString& fileName)
 {
-  QObject *senderObject = sender ();
-  file_editor_tab *fileEditorTab
-    = dynamic_cast<file_editor_tab*> (senderObject);
+  QObject *fileEditorTab = sender();
   if (fileEditorTab)
     {
       for(int i = 0; i < _tab_widget->count (); i++)
         {
           if (_tab_widget->widget (i) == fileEditorTab)
             {
               _tab_widget->setTabText (i, fileName);
             }
         }
     }
 }
 
 void
 file_editor::handle_tab_close_request (int index)
 {
-  file_editor_tab *fileEditorTab
-    = dynamic_cast <file_editor_tab*> (_tab_widget->widget (index));
+  // Signal to the tabs a request to close whomever matches the identifying
+  // tag (i.e., unique widget pointer).  The reason for this indirection is
+  // that it will enable a file editor widget to toss up a non-static
+  // dialog box and later signal that it wants to be removed.
+  QWidget *tabID = _tab_widget->widget (index);
+  emit fetab_close_request (tabID);
+}
+
+void
+file_editor::handle_tab_remove_request ()
+{
+  QObject *fileEditorTab = sender();
   if (fileEditorTab)
-    if (fileEditorTab->close ())
-      {
-        _tab_widget->removeTab (index);
-        delete fileEditorTab;
-      }
+    {
+      for(int i = 0; i < _tab_widget->count (); i++)
+        {
+          if (_tab_widget->widget (i) == fileEditorTab)
+            {
+              _tab_widget->removeTab (i);
+              delete fileEditorTab;
+            }
+        }
+    }
+}
+
+void
+file_editor::handle_add_filename_to_list (const QString& fileName)
+{
+  fetFileNames.append (fileName);
 }
 
 void
-file_editor::handle_tab_close_request ()
+file_editor::active_tab_changed (int index)
+{
+  emit fetab_change_request (_tab_widget->widget (index));
+}
+
+void
+file_editor::handle_editor_state_changed (bool copy_available, const QString& file_name)
 {
-  file_editor_tab *fileEditorTab = dynamic_cast <file_editor_tab*> (sender ());
-  if (fileEditorTab)
-    if (fileEditorTab->close ())
-      {
-        _tab_widget->removeTab (_tab_widget->indexOf (fileEditorTab));
-        delete fileEditorTab;
-      }
+  // In case there is some scenario where traffic could be coming from
+  // all the file editor tabs, just process info from the current active tab.
+  if (sender() == _tab_widget->currentWidget ())
+    {
+      _copy_action->setEnabled (copy_available);
+      _cut_action->setEnabled (copy_available);
+      if (!file_name.isEmpty ())
+        {
+          ced = QDir::cleanPath (file_name);
+          int lastslash = ced.lastIndexOf ('/');
+          // Test against > 0 because if somehow the directory is "/" the
+          // slash should be retained.  Otherwise, last slash is removed.
+          if (lastslash > 0 && lastslash != ced.count ())
+            {
+              ced = ced.left (lastslash);
+            }
+        }
+      setFocusProxy (_tab_widget->currentWidget ());
+    }
+}
+
+void
+file_editor::notice_settings ()
+{
+  // Relay signal to file editor tabs.
+  emit fetab_settings_changed ();
 }
 
 // slot for signal that is emitted when floating property changes
 void
 file_editor::top_level_changed (bool floating)
 {
   if(floating)
     {
       setWindowFlags(Qt::Window);  // make a window from the widget when floating
       show();                      // make it visible again since setWindowFlag hides it
     }
 }
 
 void
-file_editor::active_tab_changed (int)
-{
-  handle_editor_state_changed ();
-}
-
-void
-file_editor::handle_editor_state_changed ()
-{
-  file_editor_tab *f = active_editor_tab ();
-  if (f)
-    {
-      bool copy_available = f->copy_available ();
-      _copy_action->setEnabled (copy_available);
-      _cut_action->setEnabled (copy_available);
-      setFocusProxy (f);
-    }
-}
-
-void
-file_editor::notice_settings ()
-{
-  for(int i = 0; i < _tab_widget->count (); i++)
-    {
-      file_editor_tab *fileEditorTab
-        = dynamic_cast <file_editor_tab*> (_tab_widget->widget (i));
-      if (fileEditorTab)
-        fileEditorTab->notice_settings ();
-    }
-}
-
-void
 file_editor::construct ()
 {
   QWidget *editor_widget = new QWidget (this);
   QStyle *editor_style = QApplication::style ();
 
   _menu_bar = new QMenuBar (editor_widget);
   _tool_bar = new QToolBar (editor_widget);
   _tab_widget = new QTabWidget (editor_widget);
@@ -455,16 +568,26 @@ file_editor::construct ()
   QAction *uncomment_selection_action = new QAction (tr ("&Uncomment Selected Text"),_tool_bar);
 
   QAction *find_action = new QAction (QIcon(":/actions/icons/find.png"),
                                       tr ("&Find and Replace"), _tool_bar);
 
   _run_action = new QAction (QIcon(":/actions/icons/artsbuilderexecute.png"),
                              tr("Save File And Run"), _tool_bar);
 
+  // the mru-list and an empty array of actions
+  QSettings *settings = resource_manager::get_settings ();
+  // FIXME -- what should happen if settings is 0?
+  _mru_files = settings->value ("editor/mru_file_list").toStringList ();
+  for (int i = 0; i < MaxMRUFiles; ++i)
+    {
+       _mru_file_actions[i] = new QAction (this);
+       _mru_file_actions[i]->setVisible (false);
+    }
+
   // some actions are disabled from the beginning
   _copy_action->setEnabled(false);
   _cut_action->setEnabled(false);
   _run_action->setShortcut                      (Qt::ControlModifier+ Qt::Key_R);
   _run_action->setShortcutContext               (Qt::WindowShortcut);
   next_bookmark_action->setShortcut             (Qt::Key_F2);
   next_bookmark_action->setShortcutContext      (Qt::WindowShortcut);
   previous_bookmark_action->setShortcut         (Qt::SHIFT + Qt::Key_F2);
@@ -500,16 +623,22 @@ file_editor::construct ()
 
   // menu bar
   QMenu *fileMenu = new QMenu (tr ("&File"), _menu_bar);
   fileMenu->addAction (new_action);
   fileMenu->addAction (open_action);
   fileMenu->addAction (save_action);
   fileMenu->addAction (save_as_action);
   fileMenu->addSeparator ();
+  QMenu *mru_file_menu = new QMenu (tr ("Open &Recent"), fileMenu);
+  for (int i = 0; i < MaxMRUFiles; ++i)
+    {
+      mru_file_menu->addAction (_mru_file_actions[i]);
+    }
+  fileMenu->addMenu (mru_file_menu);
   _menu_bar->addMenu (fileMenu);
 
   QMenu *editMenu = new QMenu (tr ("&Edit"), _menu_bar);
   editMenu->addAction (undo_action);
   editMenu->addAction (redo_action);
   editMenu->addSeparator ();
   editMenu->addAction (_copy_action);
   editMenu->addAction (_cut_action);
@@ -584,48 +713,111 @@ file_editor::construct ()
   connect (remove_all_breakpoints_action,
            SIGNAL (triggered ()), this, SLOT (request_remove_breakpoint ()));
   connect (comment_selection_action,
            SIGNAL (triggered ()), this, SLOT (request_comment_selected_text ()));
   connect (uncomment_selection_action,
            SIGNAL (triggered ()), this, SLOT (request_uncomment_selected_text ()));
   connect (find_action,
            SIGNAL (triggered ()), this, SLOT (request_find ()));
+  // The actions of the mru file menu
+  for (int i = 0; i < MaxMRUFiles; ++i)
+    {
+      connect(_mru_file_actions[i], SIGNAL (triggered ()), this, SLOT (request_mru_open_file ()));
+    }
+  mru_menu_update ();
   connect (_tab_widget,
            SIGNAL (tabCloseRequested (int)), this, SLOT (handle_tab_close_request (int)));
   connect (_tab_widget,
            SIGNAL (currentChanged(int)), this, SLOT (active_tab_changed (int)));
   // topLevelChanged is emitted when floating property changes (floating = true)
   connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
 
   resize (500, 400);
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle ("Editor");
 
   //restore previous session
-  QSettings *settings = resource_manager::get_settings ();
   if (settings->value ("editor/restoreSession",true).toBool ())
     {
       QStringList sessionFileNames = settings->value("editor/savedSessionTabs", QStringList()).toStringList ();
 
       for (int n=0; n < sessionFileNames.count (); ++n)
-        request_open_file (sessionFileNames.at (n), true);
+        request_open_file (sessionFileNames.at (n));
     }
 }
 
 void
-file_editor::add_file_editor_tab (file_editor_tab *f)
+file_editor::add_file_editor_tab (file_editor_tab *f, const QString &fn)
 {
-  _tab_widget->addTab (f, "");
-  connect (f, SIGNAL (file_name_changed(QString)),
-           this, SLOT(handle_file_name_changed(QString)));
-  connect (f, SIGNAL (editor_state_changed ()),
-           this, SLOT (handle_editor_state_changed ()));
-  connect (f, SIGNAL (close_request ()),
-           this, SLOT (handle_tab_close_request ()));
+  _tab_widget->addTab (f, fn);
+
+  // Signals from the file editor_tab
+  connect (f, SIGNAL (file_name_changed (const QString&)),
+           this, SLOT (handle_file_name_changed (const QString&)));
+  connect (f, SIGNAL (editor_state_changed (bool, const QString&)),
+           this, SLOT (handle_editor_state_changed (bool, const QString&)));
+  connect (f, SIGNAL (tab_remove_request ()),
+           this, SLOT (handle_tab_remove_request ()));
+  connect (f, SIGNAL (add_filename_to_list (const QString&)),
+           this, SLOT (handle_add_filename_to_list (const QString&)));
+  connect (f, SIGNAL (editor_check_conflict_save (const QString&, bool)),
+           this, SLOT (check_conflict_save (const QString&, bool)));
+  connect (f, SIGNAL (mru_add_file (const QString&)),
+           this, SLOT (handle_mru_add_file (const QString&)));
+  connect (f, SIGNAL (process_octave_code (const QString&)),
+           parent (), SLOT (handle_command_double_clicked (const QString&)));
+  
+  // Signals from the file_editor non-trivial operations
+  connect (this, SIGNAL (fetab_settings_changed ()),
+           f, SLOT (notice_settings ()));
+  connect (this, SIGNAL (fetab_close_request (const QWidget*)),
+           f, SLOT (conditional_close (const QWidget*)));
+  connect (this, SIGNAL (fetab_change_request (const QWidget*)),
+           f, SLOT (change_editor_state (const QWidget*)));
+  connect (this, SIGNAL (fetab_file_name_query (const QWidget*)),
+           f, SLOT (file_name_query (const QWidget*)));
+  connect (this, SIGNAL (fetab_save_file (const QWidget*, const QString&, bool)),
+           f, SLOT (save_file (const QWidget*, const QString&, bool)));
+  // Signals from the file_editor trivial operations
+  connect (this, SIGNAL (fetab_undo (const QWidget*)),
+           f, SLOT (undo (const QWidget*)));
+  connect (this, SIGNAL (fetab_redo (const QWidget*)),
+           f, SLOT (redo (const QWidget*)));
+  connect (this, SIGNAL (fetab_copy (const QWidget*)),
+           f, SLOT (copy (const QWidget*)));
+  connect (this, SIGNAL (fetab_cut (const QWidget*)),
+           f, SLOT (cut (const QWidget*)));
+  connect (this, SIGNAL (fetab_paste (const QWidget*)),
+           f, SLOT (paste (const QWidget*)));
+  connect (this, SIGNAL (fetab_save_file (const QWidget*)),
+           f, SLOT (save_file (const QWidget*)));
+  connect (this, SIGNAL (fetab_save_file_as (const QWidget*)),
+           f, SLOT (save_file_as (const QWidget*)));
+  connect (this, SIGNAL (fetab_run_file (const QWidget*)),
+           f, SLOT (run_file (const QWidget*)));
+  connect (this, SIGNAL (fetab_toggle_bookmark (const QWidget*)),
+           f, SLOT (toggle_bookmark (const QWidget*)));
+  connect (this, SIGNAL (fetab_next_bookmark (const QWidget*)),
+           f, SLOT (next_bookmark (const QWidget*)));
+  connect (this, SIGNAL (fetab_previous_bookmark (const QWidget*)),
+           f, SLOT (previous_bookmark (const QWidget*)));
+  connect (this, SIGNAL (fetab_remove_bookmark (const QWidget*)),
+           f, SLOT (remove_bookmark (const QWidget*)));
+  connect (this, SIGNAL (fetab_toggle_breakpoint (const QWidget*)),
+           f, SLOT (toggle_breakpoint (const QWidget*)));
+  connect (this, SIGNAL (fetab_next_breakpoint (const QWidget*)),
+           f, SLOT (next_breakpoint (const QWidget*)));
+  connect (this, SIGNAL (fetab_previous_breakpoint (const QWidget*)),
+           f, SLOT (previous_breakpoint (const QWidget*)));
+  connect (this, SIGNAL (fetab_remove_all_breakpoints (const QWidget*)),
+           f, SLOT (remove_all_breakpoints (const QWidget*)));
+  connect (this, SIGNAL (fetab_comment_selected_text (const QWidget*)),
+           f, SLOT (comment_selected_text (const QWidget*)));
+  connect (this, SIGNAL (fetab_uncomment_selected_text (const QWidget*)),
+           f, SLOT (uncomment_selected_text (const QWidget*)));
+  connect (this, SIGNAL (fetab_find (const QWidget*)),
+           f, SLOT (find (const QWidget*)));
+
   _tab_widget->setCurrentWidget (f);
 }
 
-file_editor_tab *
-file_editor::active_editor_tab ()
-{
-  return dynamic_cast<file_editor_tab*> (_tab_widget->currentWidget ());
-}
+#endif
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -25,17 +25,16 @@ along with Octave; see the file COPYING.
 
 #include <QToolBar>
 #include <QAction>
 #include <QMenuBar>
 #include <QStatusBar>
 #include <QCloseEvent>
 #include <QTabWidget>
 
-#include "main-window.h"
 #include "file-editor-interface.h"
 #include "file-editor-tab.h"
 
 const char UNNAMED_FILE[]     = "<unnamed>";
 const char SAVE_FILE_FILTER[] = "Octave Files (*.m);;All Files (*.*)";
 enum editor_markers
   {
     bookmark,
@@ -43,33 +42,59 @@ enum editor_markers
     debugger_position
   };
 
 class file_editor : public file_editor_interface
 {
   Q_OBJECT
 
   public:
-  file_editor (QTerminal *terminal, main_window *m);
+  file_editor (QWidget *p);
   ~file_editor ();
   void loadFile (const QString& fileName);
 
-  QTerminal *       terminal ();
-  main_window *     get_main_window ();
-
   QMenu *           debug_menu ();
   QToolBar *        toolbar ();
 
   void handle_entered_debug_mode ();
   void handle_quit_debug_mode ();
 
+signals:
+  void fetab_settings_changed ();
+  void fetab_close_request (const QWidget* ID);
+  void fetab_change_request (const QWidget* ID);
+  void fetab_file_name_query (const QWidget* ID);
+  // Save is a ping-pong type of communication
+  void fetab_save_file (const QWidget* ID, const QString& fileName, bool remove_on_success);
+  // No fetab_open, functionality in editor
+  // No fetab_new, functionality in editor
+  void fetab_undo (const QWidget* ID);
+  void fetab_redo (const QWidget* ID);
+  void fetab_copy (const QWidget* ID);
+  void fetab_cut (const QWidget* ID);
+  void fetab_paste (const QWidget* ID);
+  void fetab_save_file (const QWidget* ID);
+  void fetab_save_file_as (const QWidget* ID);
+  void fetab_run_file (const QWidget* ID);
+  void fetab_toggle_bookmark (const QWidget* ID);
+  void fetab_next_bookmark (const QWidget* ID);
+  void fetab_previous_bookmark (const QWidget* ID);
+  void fetab_remove_bookmark (const QWidget* ID);
+  void fetab_toggle_breakpoint (const QWidget* ID);
+  void fetab_next_breakpoint (const QWidget* ID);
+  void fetab_previous_breakpoint (const QWidget* ID);
+  void fetab_remove_all_breakpoints (const QWidget* ID);
+  void fetab_comment_selected_text (const QWidget* ID);
+  void fetab_uncomment_selected_text (const QWidget* ID);
+  void fetab_find (const QWidget* ID);
+
 public slots:
   void request_new_file ();
   void request_open_file ();
-  void request_open_file (const QString& fileName, bool silent = false);
+  void request_mru_open_file ();
 
   void request_undo ();
   void request_redo ();
   void request_copy ();
   void request_cut ();
   void request_paste ();
   void request_save_file ();
   void request_save_file_as ();
@@ -85,33 +110,49 @@ public slots:
   void request_remove_breakpoint ();
 
   void request_comment_selected_text ();
   void request_uncomment_selected_text ();
   void request_find ();
 
   void handle_file_name_changed (const QString& fileName);
   void handle_tab_close_request (int index);
-  void handle_tab_close_request ();
+  void handle_tab_remove_request ();
+  void handle_add_filename_to_list (const QString& fileName);
   void active_tab_changed (int index);
-  void handle_editor_state_changed ();
+  void handle_editor_state_changed (bool enableCopy, const QString& fileName);
+  void handle_mru_add_file (const QString& file_name);
+  void check_conflict_save (const QString& fileName, bool remove_on_success);
+
   /** Slot when floating property changes */
   void top_level_changed (bool floating);
 
   /** Tells the editor to react on changed settings. */
   void notice_settings ();
 
+private slots:
+  void request_open_file (const QString& fileName);
+
 private:
   void construct ();
-  void add_file_editor_tab(file_editor_tab *f);
-  file_editor_tab *active_editor_tab();
+  void add_file_editor_tab(file_editor_tab *f, const QString &fn);
+  void save_file_as (QWidget *fetabID = 0);
+  void mru_menu_update ();
+
+  QStringList fetFileNames;
+  QString ced;
 
   QMenuBar *        _menu_bar;
   QToolBar *        _tool_bar;
   QMenu *           _debug_menu;
   QAction *         _copy_action;
   QAction *         _cut_action;
   QAction *         _run_action;
   QTabWidget *      _tab_widget;
   int               _marker_breakpoint;
+
+  enum { MaxMRUFiles = 10 };
+  QAction *_mru_file_actions[MaxMRUFiles];
+  QStringList _mru_files;
+
 };
 
 #endif // FILEEDITORMDISUBWINDOW_H
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -38,16 +38,18 @@
 ** $QT_END_LICENSE$
 **
 ****************************************************************************/
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#ifdef HAVE_QSCINTILLA
+
 #include <QtGui>
 #include <QIcon>
 #include "find-dialog.h"
 
 find_dialog::find_dialog (QsciScintilla* edit_area, QWidget *p)
   : QDialog (p)
 {
   setWindowTitle ("Find and Replace");
@@ -194,8 +196,10 @@ find_dialog::replace_all ()
         {
           _edit_area->replace (_replace_line_edit->text ());   // replace
           count++;                                             // inc counter
           _find_result_available = _edit_area->findNext();                     // and find next
         }
     }
   // TODO: Show number of replaced strings
 }
+
+#endif
diff --git a/libgui/src/m-editor/lexer-octave-gui.cc b/libgui/src/m-editor/lexer-octave-gui.cc
--- a/libgui/src/m-editor/lexer-octave-gui.cc
+++ b/libgui/src/m-editor/lexer-octave-gui.cc
@@ -19,16 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#ifdef HAVE_QSCINTILLA
+
 #include "lexer-octave-gui.h"
 #include <qcolor.h>
 #include <qfont.h>
 
 // -----------------------------------------------------
 // Some basic functions
 // -----------------------------------------------------
 lexer_octave_gui::lexer_octave_gui (QObject *p)
@@ -170,8 +172,9 @@ const char *lexer_octave_gui::keywords(i
 {
   if (set == 1)
     {
       return resource_manager::octave_keywords ();
     }
   return 0;
 }
 
+#endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -63,18 +63,20 @@ main_window::~main_window ()
 {
   // Clean up all dynamically created objects to ensure they are
   // deleted before this main_window is.  Otherwise, some will be
   // attached to a non-existent parent.
 
   if (_octave_qt_event_listener)
     delete _octave_qt_event_listener;
 
+#ifdef HAVE_QSCINTILLA
   if (_file_editor)
     delete _file_editor;
+#endif
 
   if (_terminal_dock_widget)
     delete _terminal_dock_widget;
 
   if (_terminal)
     delete _terminal;
 
   if (_status_bar)
@@ -91,32 +93,38 @@ main_window::~main_window ()
 
   if (_workspace_view)
     delete _workspace_view;
 }
 
 void
 main_window::new_file ()
 {
+#ifdef HAVE_QSCINTILLA
   _file_editor->request_new_file ();
   focus_editor ();
+#endif
 }
 
 void
 main_window::open_file ()
 {
+#ifdef HAVE_QSCINTILLA
   _file_editor->request_open_file ();
   focus_editor ();
+#endif
 }
 
 void
 main_window::open_file (const QString& file_name)
 {
+#ifdef HAVE_QSCINTILLA
   _file_editor->request_open_file (file_name);
   focus_editor ();
+#endif
 }
 
 void
 main_window::report_status_message (const QString& statusMessage)
 {
   _status_bar->showMessage (statusMessage, 1000);
 }
 
@@ -357,24 +365,26 @@ main_window::focus_workspace ()
   _workspace_view->setFocus ();
   _workspace_view->activateWindow ();
   _workspace_view->raise ();
 }
 
 void
 main_window::focus_editor ()
 {
+#ifdef HAVE_QSCINTILLA
   if (!_file_editor->isVisible ())
     {
       _file_editor->setVisible (true);
     }
 
   _file_editor->setFocus ();
   _file_editor->activateWindow ();
   _file_editor->raise ();
+#endif
 }
 
 void
 main_window::focus_documentation ()
 {
   if (!_documentation_dock_widget->isVisible ())
     {
       _documentation_dock_widget->setVisible (true);
@@ -389,29 +399,33 @@ void
 main_window::handle_entered_debug_mode ()
 {
   setWindowTitle ("Octave (Debugging)");
   _debug_continue->setEnabled (true);
   _debug_step_into->setEnabled (true);
   _debug_step_over->setEnabled (true);
   _debug_step_out->setEnabled (true);
   _debug_quit->setEnabled (true);
+#ifdef HAVE_QSCINTILLA
   _file_editor->handle_entered_debug_mode ();
+#endif
 }
 
 void
 main_window::handle_quit_debug_mode ()
 {
   setWindowTitle ("Octave");
   _debug_continue->setEnabled (false);
   _debug_step_into->setEnabled (false);
   _debug_step_over->setEnabled (false);
   _debug_step_out->setEnabled (false);
   _debug_quit->setEnabled (false);
+#ifdef HAVE_QSCINTILLA
   _file_editor->handle_quit_debug_mode ();
+#endif
 }
 
 void
 main_window::debug_continue ()
 {
   octave_link::post_event (this, &main_window::debug_continue_callback);
 }
 
@@ -571,17 +585,19 @@ main_window::construct ()
   // destroying this main_window.
   QWidget *dummyWidget = new QWidget ();
   dummyWidget->setObjectName ("CentralDummyWidget");
   dummyWidget->resize (10, 10);
   dummyWidget->setSizePolicy (QSizePolicy::Minimum, QSizePolicy::Minimum);
   dummyWidget->hide ();
   setCentralWidget (dummyWidget);
 
-  _file_editor = new file_editor (_terminal, this);
+#ifdef HAVE_QSCINTILLA
+  _file_editor = new file_editor (this);
+#endif
 
   QMenu *file_menu = menuBar ()->addMenu (tr ("&File"));
 
   QMenu *new_menu = file_menu->addMenu(tr ("New"));
 
   QAction *new_script_action
     = new_menu->addAction (QIcon(":/actions/icons/filenew.png"), tr ("Script"));
   new_script_action->setShortcut (Qt::ControlModifier + Qt::Key_N);
@@ -693,45 +709,57 @@ main_window::construct ()
     = edit_menu->addAction(tr ("Clear Command History"));
   QAction * clear_workspace_action
     = edit_menu->addAction (tr ("Clear Workspace"));
 
   _debug_menu = menuBar ()->addMenu (tr ("De&bug"));
 
   _debug_step_over = _debug_menu->addAction (QIcon (":/actions/icons/db_step.png"), tr ("Step"));
   _debug_step_over->setEnabled (false);
+#ifdef HAVE_QSCINTILLA
   _file_editor->debug_menu ()->addAction (_debug_step_over);
   _file_editor->toolbar ()->addAction (_debug_step_over);
+#endif
   _debug_step_over->setShortcut (Qt::Key_F10);
 
   _debug_step_into = _debug_menu->addAction (QIcon (":/actions/icons/db_step_in.png"), tr ("Step in"));
   _debug_step_into->setEnabled (false);
+#ifdef HAVE_QSCINTILLA
   _file_editor->debug_menu ()->addAction (_debug_step_into);
   _file_editor->toolbar ()->addAction (_debug_step_into);
+#endif
   _debug_step_into->setShortcut (Qt::Key_F11);
 
   _debug_step_out = _debug_menu->addAction (QIcon (":/actions/icons/db_step_out.png"), tr ("Step out"));
   _debug_step_out->setEnabled (false);
+#ifdef HAVE_QSCINTILLA
   _file_editor->debug_menu ()->addAction (_debug_step_out);
   _file_editor->toolbar ()->addAction (_debug_step_out);
+#endif
   _debug_step_out->setShortcut (Qt::ShiftModifier + Qt::Key_F11);
 
   _debug_continue = _debug_menu->addAction (QIcon (":/actions/icons/db_cont.png"), tr ("Continue"));
   _debug_continue->setEnabled (false);
+#ifdef HAVE_QSCINTILLA
   _file_editor->debug_menu ()->addAction (_debug_continue);
   _file_editor->toolbar ()->addAction (_debug_continue);
+#endif
   _debug_continue->setShortcut (Qt::Key_F5);
 
   _debug_menu->addSeparator ();
+#ifdef HAVE_QSCINTILLA
   _file_editor->debug_menu ()->addSeparator ();
+#endif
 
   _debug_quit = _debug_menu->addAction (QIcon (":/actions/icons/db_stop.png"), tr ("Exit Debug Mode"));
   _debug_quit->setEnabled (false);
+#ifdef HAVE_QSCINTILLA
   _file_editor->debug_menu ()->addAction (_debug_quit);
   _file_editor->toolbar ()->addAction (_debug_quit);
+#endif
   _debug_quit->setShortcut (Qt::ShiftModifier + Qt::Key_F5);
 
   //QMenu *parallelMenu = menuBar ()->addMenu (tr ("&Parallel"));
 
   QMenu *   desktop_menu = menuBar ()->addMenu (tr ("&Desktop"));
   QAction * load_workspace_action       = desktop_menu->addAction (tr ("Load workspace"));
 
 
@@ -861,20 +889,22 @@ main_window::construct ()
   connect (show_history_action,         SIGNAL (toggled (bool)),
            _history_dock_widget,        SLOT   (setVisible (bool)));
   connect (_history_dock_widget,        SIGNAL (active_changed (bool)),
            show_history_action,         SLOT   (setChecked (bool)));
   connect (show_file_browser_action,    SIGNAL (toggled (bool)),
            _files_dock_widget,          SLOT   (setVisible (bool)));
   connect (_files_dock_widget,          SIGNAL (active_changed (bool)),
            show_file_browser_action,    SLOT   (setChecked (bool)));
+#ifdef HAVE_QSCINTILLA
   connect (show_editor_action,          SIGNAL (toggled (bool)),
            _file_editor,                SLOT   (setVisible (bool)));
   connect (_file_editor,                SIGNAL (active_changed (bool)),
            show_editor_action,          SLOT   (setChecked (bool)));
+#endif
   connect (show_documentation_action,   SIGNAL (toggled (bool)),
            _documentation_dock_widget,  SLOT   (setVisible (bool)));
   connect (_documentation_dock_widget,  SIGNAL (active_changed (bool)),
            show_documentation_action,   SLOT   (setChecked (bool)));
 
   connect (command_window_action,       SIGNAL (triggered ()),
            this,                        SLOT (focus_command_window ()));
   connect (workspace_action,            SIGNAL (triggered ()),
@@ -885,18 +915,20 @@ main_window::construct ()
            this,                        SLOT (focus_current_directory ()));
   connect (editor_action,               SIGNAL (triggered ()),
            this,                        SLOT (focus_editor ()));
   connect (documentation_action,        SIGNAL (triggered ()),
            this,                        SLOT (focus_documentation ()));
 
   connect (reset_windows_action,        SIGNAL (triggered ()),
            this,                        SLOT   (reset_windows ()));
+#ifdef HAVE_QSCINTILLA
   connect (this,                        SIGNAL (settings_changed ()),
            _file_editor,                SLOT   (notice_settings ()));
+#endif
   connect (this,                        SIGNAL (settings_changed ()),
            _files_dock_widget,          SLOT   (notice_settings ()));
   connect (this,                        SIGNAL (settings_changed ()),
            this,                        SLOT   (notice_settings ()));
   connect (_files_dock_widget,          SIGNAL (open_file (QString)),
            this,                        SLOT   (open_file (QString)));
   connect (_files_dock_widget,          SIGNAL (displayed_directory_changed(QString)),
            this,                        SLOT   (set_current_working_directory(QString)));
@@ -936,17 +968,19 @@ main_window::construct ()
   connect (clear_command_history,       SIGNAL (triggered ()),
            this,                        SLOT (handle_clear_history_request ()));
 
   setWindowTitle ("Octave");
   setDockOptions(QMainWindow::AnimatedDocks | QMainWindow::AllowNestedDocks | QMainWindow::AllowTabbedDocks);
   addDockWidget (Qt::LeftDockWidgetArea, _workspace_view);
   addDockWidget (Qt::LeftDockWidgetArea, _history_dock_widget);
   addDockWidget (Qt::RightDockWidgetArea, _files_dock_widget);
+#ifdef HAVE_QSCINTILLA
   addDockWidget (Qt::RightDockWidgetArea, _file_editor);
+#endif
   addDockWidget (Qt::BottomDockWidgetArea, _terminal_dock_widget);
   addDockWidget (Qt::RightDockWidgetArea, _documentation_dock_widget);
   setStatusBar (_status_bar);
 
   _octave_qt_event_listener = new octave_qt_event_listener ();
   octave_link::register_event_listener (_octave_qt_event_listener);
 
   connect (_octave_qt_event_listener,
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -143,17 +143,19 @@ private:
 
   void debug_step_out_callback (void);
 
   void debug_quit_callback (void);
 
   void exit_callback (void);
 
   QTerminal *               _terminal;
+#ifdef HAVE_QSCINTILLA
   file_editor_interface *   _file_editor;
+#endif
   QMenu *                   _debug_menu;
 
   QAction *                 _debug_continue;
   QAction *                 _debug_step_into;
   QAction *                 _debug_step_over;
   QAction *                 _debug_step_out;
   QAction *                 _debug_quit;
 
diff --git a/libgui/src/symbol-information.cc b/libgui/src/symbol-information.cc
--- a/libgui/src/symbol-information.cc
+++ b/libgui/src/symbol-information.cc
@@ -46,47 +46,56 @@ symbol_information::symbol_information (
   _class_name = QString (sr.varval ().class_name ().c_str ());
   octave_value ov = sr.varval ();
   dim_vector dv = ov.dims ();
 
   // In case we have really large matrices or strings, cut them down
   // for performance reasons.
   QString short_value_string;
   bool use_short_value_string = false;
+
   if (ov.is_range ())
     {
       use_short_value_string = true;
 
       Range r = ov.range_value ();
 
       double base = r.base ();
-      double increment = r.base ();
-      double limit = r.base ();
+      double increment = r.inc ();
+      double limit = r.limit ();
 
       std::stringstream buffer;
 
       buffer << base << ":";
       if (increment != 1 )
         buffer << increment << ":";
       buffer << limit;
 
       short_value_string = QString::fromStdString (buffer.str ());
     }
   else if (ov.is_matrix_type () || ov.is_cell ())
     {
-      if (ov.numel () > 10)
-        use_short_value_string = true;
-    }
-  else if (ov.is_string ())
-    {
-      if (ov.string_value ().length () > 40)
+      if (ov.is_string ())  // a string?
         {
-          use_short_value_string = true;
-          short_value_string
-            = QString::fromStdString (ov.string_value ().substr (0, 40));
+          if (ov.string_value ().length () > 30)
+            {
+              use_short_value_string = true;
+              short_value_string = QString ("\"")
+                  + QString::fromStdString (ov.string_value ().substr (0, 30))
+                  + QString (" ... \"");
+            }
+        }
+      else  // arrays and cell arrays
+        {
+          if (ov.numel () > 10)
+            {
+              use_short_value_string = true;
+              short_value_string = QString("...");
+              // TODO: what kind of short version can be printed for arrays?
+            }
         }
     }
 
   if (use_short_value_string)
     {
       _value = short_value_string;
     }
   else
diff --git a/libinterp/corefcn/__contourc__.cc b/libinterp/corefcn/__contourc__.cc
--- a/libinterp/corefcn/__contourc__.cc
+++ b/libinterp/corefcn/__contourc__.cc
@@ -92,128 +92,126 @@ start_contour (double lvl, double x, dou
 }
 
 static void
 drawcn (const RowVector& X, const RowVector& Y, const Matrix& Z,
         double lvl, int r, int c, double ct_x, double ct_y,
         unsigned int start_edge, bool first, charMatrix& mark)
 {
   double px[4], py[4], pz[4], tmp;
-  unsigned int stop_edge, next_edge, pt[2];
-  int next_r, next_c;
+  unsigned int stop_edge, pt[2];
+
+  // Continue while next facet is not done yet.
+  while (r >= 0 && c >= 0 && r < mark.rows () && c < mark.cols ()
+         && mark(r, c) > 0)
+    {
 
-  //get x, y, and z - lvl for current facet
-  px[0] = px[3] = X(c);
-  px[1] = px[2] = X(c+1);
+      //get x, y, and z - lvl for current facet
+      px[0] = px[3] = X(c);
+      px[1] = px[2] = X(c+1);
 
-  py[0] = py[1] = Y(r);
-  py[2] = py[3] = Y(r+1);
+      py[0] = py[1] = Y(r);
+      py[2] = py[3] = Y(r+1);
+
+      pz[3] = Z(r+1, c) - lvl;
+      pz[2] = Z(r+1, c + 1) - lvl;
+      pz[1] = Z(r, c+1) - lvl;
+      pz[0] = Z(r, c) - lvl;
 
-  pz[3] = Z(r+1, c) - lvl;
-  pz[2] = Z(r+1, c + 1) - lvl;
-  pz[1] = Z(r, c+1) - lvl;
-  pz[0] = Z(r, c) - lvl;
+      // Facet edge and point naming assignment.
+      //
+      //  0-----1   .-0-.
+      //  |     |   |   |
+      //  |     |   3   1
+      //  |     |   |   |
+      //  3-----2   .-2-.
 
-  // Facet edge and point naming assignment.
-  //
-  //  0-----1   .-0-.
-  //  |     |   |   |
-  //  |     |   3   1
-  //  |     |   |   |
-  //  3-----2   .-2-.
+      // Get mark value of current facet.
+      char id = static_cast<char> (mark(r, c));
+
+      // Check startedge s.
+      if (start_edge == 255)
+        {
+          // Find start edge.
+          for (unsigned int k = 0; k < 4; k++)
+            if (static_cast<char> (1 << k) & id)
+              start_edge = k;
+        }
 
-  // Get mark value of current facet.
-  char id = static_cast<char> (mark(r, c));
+      if (start_edge == 255)
+        break;
+
+      // Decrease mark value of current facet for start edge.
+      mark(r, c) -= static_cast<char> (1 << start_edge);
 
-  // Check startedge s.
-  if (start_edge == 255)
-    {
-      // Find start edge.
-      for (unsigned int k = 0; k < 4; k++)
-        if (static_cast<char> (1 << k) & id)
-          start_edge = k;
-    }
+      // Next point (clockwise).
+      pt[0] = start_edge;
+      pt[1] = (pt[0] + 1) % 4;
+
+      // Calculate contour segment start if first of contour.
+      if (first)
+        {
+          tmp = fabs (pz[pt[1]]) / fabs (pz[pt[0]]);
 
-  if (start_edge == 255)
-    return;
+          if (xisnan (tmp))
+            ct_x = ct_y = 0.5;
+          else
+            {
+              ct_x = px[pt[0]] + (px[pt[1]] - px[pt[0]])/(1 + tmp);
+              ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
+            }
 
-  // Decrease mark value of current facet for start edge.
-  mark(r, c) -= static_cast<char> (1 << start_edge);
+          start_contour (lvl, ct_x, ct_y);
+          first = false;
+        }
 
-  // Next point (clockwise).
-  pt[0] = start_edge;
-  pt[1] = (pt[0] + 1) % 4;
+      // Find stop edge.
+      // FIXME -- perhaps this should use a while loop?
+      for (unsigned int k = 1; k <= 4; k++)
+        {
+          if (start_edge == 0 || start_edge == 2)
+            stop_edge = (start_edge + k) % 4;
+          else
+            stop_edge = (start_edge - k) % 4;
 
-  // Calculate contour segment start if first of contour.
-  if (first)
-    {
+          if (static_cast<char> (1 << stop_edge) & id)
+            break;
+        }
+
+      pt[0] = stop_edge;
+      pt[1] = (pt[0] + 1) % 4;
       tmp = fabs (pz[pt[1]]) / fabs (pz[pt[0]]);
 
       if (xisnan (tmp))
         ct_x = ct_y = 0.5;
       else
         {
           ct_x = px[pt[0]] + (px[pt[1]] - px[pt[0]])/(1 + tmp);
           ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
         }
 
-      start_contour (lvl, ct_x, ct_y);
-    }
+      // Add point to contour.
+      add_point (ct_x, ct_y);
 
-  // Find stop edge.
-  // FIXME -- perhaps this should use a while loop?
-  for (unsigned int k = 1; k <= 4; k++)
-    {
-      if (start_edge == 0 || start_edge == 2)
-        stop_edge = (start_edge + k) % 4;
-      else
-        stop_edge = (start_edge - k) % 4;
-
-      if (static_cast<char> (1 << stop_edge) & id)
-        break;
-    }
-
-  pt[0] = stop_edge;
-  pt[1] = (pt[0] + 1) % 4;
-  tmp = fabs (pz[pt[1]]) / fabs (pz[pt[0]]);
+      // Decrease id value of current facet for start edge.
+      mark(r, c) -= static_cast<char> (1 << stop_edge);
 
-  if (xisnan (tmp))
-    ct_x = ct_y = 0.5;
-  else
-    {
-      ct_x = px[pt[0]] + (px[pt[1]] - px[pt[0]])/(1 + tmp);
-      ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
-    }
-
-  // Add point to contour.
-  add_point (ct_x, ct_y);
-
-  // Decrease id value of current facet for start edge.
-  mark(r, c) -= static_cast<char> (1 << stop_edge);
+      // Find next facet.
+      if (stop_edge == 0)
+        r--;
+      else if (stop_edge == 1)
+        c++;
+      else if (stop_edge == 2)
+        r++;
+      else if (stop_edge == 3)
+        c--;
 
-  // Find next facet.
-  next_c = c;
-  next_r = r;
+      // Go to next facet.
+      start_edge = (stop_edge + 2) % 4;
 
-  if (stop_edge == 0)
-    next_r--;
-  else if (stop_edge == 1)
-    next_c++;
-  else if (stop_edge == 2)
-    next_r++;
-  else if (stop_edge == 3)
-    next_c--;
-
-  // Check if next facet is not done yet.
-  // Go to next facet.
-  if (next_r >= 0 && next_c >= 0 && next_r < mark.rows ()
-      && next_c < mark.cols () && mark(next_r, next_c) > 0)
-    {
-      next_edge = (stop_edge + 2) % 4;
-      drawcn (X, Y, Z, lvl, next_r, next_c, ct_x, ct_y, next_edge, false, mark);
     }
 }
 
 static void
 mark_facets (const Matrix& Z, charMatrix& mark, double lvl)
 {
   unsigned int nr = mark.rows ();
   unsigned int nc = mark.cols ();
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -416,8 +416,21 @@ changed locally for the function and any
 variable value is restored when exiting the function.\n\
 @seealso{svd}\n\
 @end deftypefn")
 {
   static const char *driver_names[] = { "gesvd", "gesdd", 0 };
 
   return SET_INTERNAL_VARIABLE_CHOICES (svd_driver, driver_names);
 }
+
+/*
+%!test
+%! A = [1+1i, 1-1i, 0; 0, 2, 0; 1i, 1i, 1+2i];
+%! old_driver = svd_driver ("gesvd");
+%! [U1, S1, V1] = svd (A);
+%! svd_driver ("gesdd");
+%! [U2, S2, V2] = svd (A);
+%! assert (U1, U2, 5*eps);
+%! assert (S1, S2, 5*eps);
+%! assert (V1, V2, 5*eps);
+%! svd_driver (old_driver);
+*/
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -174,17 +174,17 @@ convex hull is calculated.\n\n\
       facetT *facet;
 
       octave_idx_type i = 0;
 
       FORALLfacets
         {
           octave_idx_type j = 0;
 
-          if (! nonsimp_seen && ! facet->simplicial)
+          if (! (nonsimp_seen || facet->simplicial || qh hull_dim == 2))
             {
               nonsimp_seen = true;
 
               if (cmd.find ("QJ") != std::string::npos)
                 {
                   // Should never happen with QJ.
                   error ("convhulln: qhull failed: option 'QJ' returned non-simplicial facet");
                   return retval;
@@ -308,9 +308,14 @@ convex hull is calculated.\n\n\
 %! assert (v, 1.0, 1e6*eps);
 
 %!testif HAVE_QHULL
 %! tetrahedron = [1 1 1;-1 -1 1;-1 1 -1;1 -1 -1];
 %! [h, v] = convhulln (tetrahedron);
 %! h = sortrows (sort (h, 2), [1 2 3]);
 %! assert (h, [1 2 3;1 2 4; 1 3 4; 2 3 4]);
 %! assert (v, 8/3, 10*eps);
+
+%!testif HAVE_QHULL
+%! triangle=[0 0; 1 1; 1 0; 1 2];
+%! h = convhulln (triangle);
+%! assert (size (h), [3 2]);
 */
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1394,17 +1394,17 @@ If @var{f} is the number of fields in th
 cell array will have a dimension vector corresponding to\n\
 @code{[@var{F} size(@var{S})]}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 s = struct (\"name\", @{\"Peter\", \"Hannah\", \"Robert\"@},\n\
            \"age\", @{23, 16, 3@});\n\
 c = struct2cell (s)\n\
-   @result{} c = @{1x1x3 Cell Array@}\n\
+   @result{} c = @{2x1x3 Cell Array@}\n\
 c(1,1,:)(:)\n\
    @result{}\n\
       @{\n\
         [1,1] = Peter\n\
         [2,1] = Hannah\n\
         [3,1] = Robert\n\
       @}\n\
 c(2,1,:)(:)\n\
diff --git a/libinterp/octave-value/ov-ch-mat.cc b/libinterp/octave-value/ov-ch-mat.cc
--- a/libinterp/octave-value/ov-ch-mat.cc
+++ b/libinterp/octave-value/ov-ch-mat.cc
@@ -149,21 +149,27 @@ octave_char_matrix::as_mxArray (void) co
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 // The C++ standard guarantees cctype defines functions, not macros (and
 // hence macros *CAN'T* be defined if only cctype is included) so
-// there's no need to fuck around. The exceptions are isascii and
-// toascii, which are not C++. Oddly enough, all those character
-// functions are int (*) (int), even in C++. Wicked!
+// there's no need to fuck around.  The exceptions are isascii and
+// toascii, which are not C++.  Oddly enough, all those character
+// functions are int (*) (int), even in C++.  Wicked!
 static inline int xisascii (int c)
-{ return isascii (c); }
+{
+#ifdef HAVE_ISASCII
+  return isascii (c);
+#else
+  return (c >= 0x00 && c <= 0x7f);
+#endif
+}
 
 static inline int xtoascii (int c)
 {
 #ifdef HAVE_TOASCII
   return toascii (c);
 #else
   return (c & 0x7F);
 #endif
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -173,18 +173,16 @@ private:
 
 private:
 
   JavaVMInitArgs vm_args;
 
   std::list<std::string> java_opts;
 };
 
-static dim_vector compute_array_dimensions (JNIEnv* jni_env, jobject obj);
-
 #ifdef __WIN32__
 static std::string
 read_registry_string (const std::string& key, const std::string& value)
 {
   HKEY hkey;
   DWORD len;
 
   std::string retval;
@@ -721,18 +719,18 @@ find_octave_class (JNIEnv *jni_env, cons
 }
 
 static dim_vector
 compute_array_dimensions (JNIEnv* jni_env, jobject obj)
 {
   jobjectArray_ref jobj (jni_env, reinterpret_cast<jobjectArray> (obj));
   jclass_ref jcls (jni_env, jni_env->GetObjectClass (obj));
   jclass_ref ccls (jni_env, jni_env->GetObjectClass (jcls));
-  jmethodID isArray_ID = jni_env->GetMethodID (ccls, "isArray", "()Z"),
-            getComponentType_ID = jni_env->GetMethodID (ccls, "getComponentType", "()Ljava/lang/Class;");
+  jmethodID isArray_ID = jni_env->GetMethodID (ccls, "isArray", "()Z");
+  jmethodID getComponentType_ID = jni_env->GetMethodID (ccls, "getComponentType", "()Ljava/lang/Class;");
 
   dim_vector dv (1, 1);
   int idx = 0;
 
   jobj.detach ();
   while (jcls && jni_env->CallBooleanMethod (jcls, isArray_ID))
     {
       int len = (jobj ? jni_env->GetArrayLength (jobj) : 0);
@@ -805,17 +803,18 @@ get_array_elements (JNIEnv* jni_env, job
 
 static octave_value
 set_array_elements (JNIEnv* jni_env, jobject jobj,
                     const octave_value_list& idx, const octave_value& rhs)
 {
   octave_value retval;
 
   jclass_ref rhsCls (jni_env);
-  jobject_ref resObj (jni_env), rhsObj (jni_env);
+  jobject_ref resObj (jni_env);
+  jobject_ref rhsObj (jni_env);
   jobject_ref java_idx (jni_env, make_java_index (jni_env, idx));
 
   if (! error_state && unbox (jni_env, rhs, rhsObj, rhsCls))
     {
       jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
       jmethodID mID = jni_env->GetStaticMethodID (helperClass, "arraySubsasgn",
           "(Ljava/lang/Object;[[ILjava/lang/Object;)Ljava/lang/Object;");
       resObj = jni_env->CallStaticObjectMethod (helperClass, mID,
@@ -834,25 +833,26 @@ static string_vector
 get_invoke_list (JNIEnv* jni_env, jobject jobj)
 {
   std::list<std::string> name_list;
 
   if (jni_env)
     {
       jclass_ref cls (jni_env, jni_env->GetObjectClass (jobj));
       jclass_ref ccls (jni_env, jni_env->GetObjectClass (cls));
-      jmethodID getMethods_ID = jni_env->GetMethodID (ccls, "getMethods", "()[Ljava/lang/reflect/Method;"),
-        getFields_ID = jni_env->GetMethodID (ccls, "getFields", "()[Ljava/lang/reflect/Field;");
-      jobjectArray_ref mList (jni_env, reinterpret_cast<jobjectArray> (jni_env->CallObjectMethod (cls, getMethods_ID))),
-        fList (jni_env, reinterpret_cast<jobjectArray> (jni_env->CallObjectMethod (cls, getFields_ID)));
-      int mLen = jni_env->GetArrayLength (mList), fLen = jni_env->GetArrayLength (fList);
-      jclass_ref mCls (jni_env, jni_env->FindClass ("java/lang/reflect/Method")),
-        fCls (jni_env, jni_env->FindClass ("java/lang/reflect/Field"));
-      jmethodID m_getName_ID = jni_env->GetMethodID (mCls, "getName", "()Ljava/lang/String;"),
-        f_getName_ID = jni_env->GetMethodID (fCls, "getName", "()Ljava/lang/String;");
+      jmethodID getMethods_ID = jni_env->GetMethodID (ccls, "getMethods", "()[Ljava/lang/reflect/Method;");
+      jmethodID getFields_ID = jni_env->GetMethodID (ccls, "getFields", "()[Ljava/lang/reflect/Field;");
+      jobjectArray_ref mList (jni_env, reinterpret_cast<jobjectArray> (jni_env->CallObjectMethod (cls, getMethods_ID)));
+      jobjectArray_ref fList (jni_env, reinterpret_cast<jobjectArray> (jni_env->CallObjectMethod (cls, getFields_ID)));
+      int mLen = jni_env->GetArrayLength (mList);
+      int fLen = jni_env->GetArrayLength (fList);
+      jclass_ref mCls (jni_env, jni_env->FindClass ("java/lang/reflect/Method"));
+      jclass_ref fCls (jni_env, jni_env->FindClass ("java/lang/reflect/Field"));
+      jmethodID m_getName_ID = jni_env->GetMethodID (mCls, "getName", "()Ljava/lang/String;");
+      jmethodID f_getName_ID = jni_env->GetMethodID (fCls, "getName", "()Ljava/lang/String;");
 
       for (int i = 0; i < mLen; i++)
         {
           jobject_ref meth (jni_env, jni_env->GetObjectArrayElement (mList, i));
           jstring_ref methName (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (meth, m_getName_ID)));
           name_list.push_back (jstring_to_string (jni_env, methName));
         }
 
@@ -1225,18 +1225,17 @@ unbox (JNIEnv* jni_env, const octave_val
     }
   else if (!Vjava_matrix_autoconversion
            && ((val.is_real_matrix ()
                 && (val.rows () == 1 || val.columns () == 1))
                || val.is_range ()))
     {
       Matrix m = val.matrix_value ();
       jdoubleArray dv = jni_env->NewDoubleArray (m.length ());
-      //for (int i = 0; i < m.length (); i++)
-        jni_env->SetDoubleArrayRegion (dv, 0, m.length (), m.fortran_vec ());
+      jni_env->SetDoubleArrayRegion (dv, 0, m.length (), m.fortran_vec ());
       jobj = dv;
       jcls = jni_env->GetObjectClass (jobj);
     }
   else if (Vjava_matrix_autoconversion
            && (val.is_matrix_type () || val.is_range ()) && val.is_real_type ())
     {
       jclass_ref mcls (jni_env, find_octave_class (jni_env, "org/octave/Matrix"));
       dim_vector dims = val.dims ();
@@ -1405,48 +1404,16 @@ initialize_java (void)
         }
       catch (std::string msg)
         {
           error (msg.c_str ());
         }
     }
 }
 
-DEFUN (__java_init__, , ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} java_init ()\n\
-Internal function used @strong{only} when debugging Java interface.\n\
-Function will directly call initialize_java() to create an instance of a JVM.\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  retval = 0;
-  initialize_java ();
-  if (! error_state)
-    retval = 1;
-
-  return retval;
-}
-
-DEFUN (__java_exit__, , ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} java_exit ()\n\
-Internal function used @strong{only} when debugging Java interface.\n\
-Function will directly call terminate_jvm() to destroy the current JVM\n\
-instance.\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  terminate_jvm ();
-
-  return retval;
-}
-
 JNIEXPORT jboolean JNICALL
 Java_org_octave_Octave_call (JNIEnv *env, jclass, jstring funcName,
                              jobjectArray argin, jobjectArray argout)
 {
   std::string fname = jstring_to_string (env, funcName);
 
   int nargout = env->GetArrayLength (argout);
   int nargin = env->GetArrayLength (argin);
@@ -1731,16 +1698,29 @@ octave_java::convert_to_str_internal (bo
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env)
     return convert_to_string (current_env, to_java (), force, type);
   else
     return octave_value ("");
 }
 
+void
+octave_java::print (std::ostream& os, bool) const
+{
+  print_raw (os);
+  newline (os);
+}
+
+void
+octave_java::print_raw (std::ostream& os, bool) const
+{
+  os << "<Java object: " << java_classname << ">";
+}
+
 octave_value
 octave_java::do_javaMethod (JNIEnv* jni_env, const std::string& name,
                              const octave_value_list& args)
 {
   octave_value retval;
 
   if (jni_env)
     {
@@ -1920,16 +1900,58 @@ octave_java::do_java_set (JNIEnv* jni_en
   return retval;
 }
 
 #endif  // endif on HAVE_JAVA
 
 // DEFUN blocks below must be outside of HAVE_JAVA block so that
 // documentation strings are always available, even when functions are not.
 
+DEFUN (__java_init__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} java_init ()\n\
+Internal function used @strong{only} when debugging Java interface.\n\
+Function will directly call initialize_java() to create an instance of a JVM.\n\
+@end deftypefn")
+{
+
+#ifdef HAVE_JAVA
+  octave_value retval;
+
+  retval = 0;
+
+  initialize_java ();
+
+  if (! error_state)
+    retval = 1;
+
+  return retval;
+#else
+  error ("__java_init__: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+DEFUN (__java_exit__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} java_exit ()\n\
+Internal function used @strong{only} when debugging Java interface.\n\
+Function will directly call terminate_jvm() to destroy the current JVM\n\
+instance.\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  terminate_jvm ();
+#else
+  error ("__java_init__: Octave was not compiled with Java interface");
+#endif
+
+  return octave_value ();
+}
+
 DEFUN (javaObject, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{jobj} =} javaObject (@var{classname})\n\
 @deftypefnx {Built-in Function} {@var{jobj} =} javaObject (@var{classname}, @var{arg1}, @dots{})\n\
 Create a Java object of class @var{classsname}, by calling the class\n\
 constructor with the arguments @var{arg1}, @dots{}\n\
 \n\
 The first example below creates an uninitialized object,\n\
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -144,26 +144,19 @@ public:
   bool is_map (void) const { return false; }
 
   bool is_java (void) const { return true; }
 
   string_vector map_keys (void) const;
 
   dim_vector dims (void) const;
 
-  void print (std::ostream& os, bool pr_as_read_syntax = false) const
-  {
-    os << "<Java object: " << java_classname << ">";
-    newline(os);
-  }
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const
-  {
-    print(os, pr_as_read_syntax);
-  }
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   octave_value_list
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx, int nargout);
 
   octave_value
   subsref (const std::string& type, const std::list<octave_value_list>& idx)
   {
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -652,16 +652,18 @@ maximum_braindamage (void)
 // EMBEDDED is declared int instead of bool because this function is
 // declared extern "C".
 
 int
 octave_main (int argc, char **argv, int embedded)
 {
   octave_process_command_line (argc, argv);
 
+  sysdep_init ();
+
   install_defaults ();
 
   octave_initialize_interpreter (argc, argv, embedded);
 
   return octave_execute_interpreter ();
 }
 
 void
@@ -857,18 +859,16 @@ octave_initialize_interpreter (int argc,
 
   octave_program_invocation_name = octave_env::get_program_invocation_name ();
   octave_program_name = octave_env::get_program_name ();
 
   octave_thread::init ();
 
   init_signals ();
 
-  sysdep_init ();
-
   octave_ieee_init ();
 
   // The idea here is to force xerbla to be referenced so that we will
   // link to our own version instead of the one provided by the BLAS
   // library.  But octave_NaN should never be -1, so we should never
   // actually call xerbla.
 
   if (octave_NaN == -1)
diff --git a/libinterp/template-inst/Array-jit.cc b/libinterp/template-inst/Array-jit.cc
--- a/libinterp/template-inst/Array-jit.cc
+++ b/libinterp/template-inst/Array-jit.cc
@@ -26,15 +26,20 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_LLVM
 
 #include "Array.h"
 #include "Array.cc"
 
 extern template class OCTAVE_API Array<octave_idx_type>;
 
-#include "pt-jit.h"
+#include "jit-ir.h"
 
 NO_INSTANTIATE_ARRAY_SORT (jit_function);
 
 INSTANTIATE_ARRAY (jit_function, OCTINTERP_API);
 
+#ifdef Cell_h
+#error Must not include Cell.h in Array-jit.h
+#error This causes problems on MSVC
 #endif
+
+#endif
diff --git a/liboctave/numeric/CmplxSVD.cc b/liboctave/numeric/CmplxSVD.cc
--- a/liboctave/numeric/CmplxSVD.cc
+++ b/liboctave/numeric/CmplxSVD.cc
@@ -113,18 +113,17 @@ ComplexSVD::init (const ComplexMatrix& a
       // Note:  for this case, both jobu and jobv should be 'N', but
       // there seems to be a bug in dgesvd from Lapack V2.0.  To
       // demonstrate the bug, set both jobu and jobv to 'N' and find
       // the singular values of [eye(3), eye(3)].  The result is
       // [-sqrt(2), -sqrt(2), -sqrt(2)].
       //
       // For Lapack 3.0, this problem seems to be fixed.
 
-      jobu = 'N';
-      jobv = 'N';
+      jobu = jobv = 'N';
       ncol_u = nrow_vt = 1;
       break;
 
     default:
       break;
     }
 
   type_computed = svd_type;
@@ -137,31 +136,31 @@ ComplexSVD::init (const ComplexMatrix& a
   sigma.resize (nrow_s, ncol_s);
   double *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   Complex *vt = right_sm.fortran_vec ();
 
-  octave_idx_type lrwork = 5*max_mn;
-
-  Array<double> rwork (dim_vector (lrwork, 1));
-
-  // Ask ZGESVD what the dimension of WORK should be.
+  // Query ZGESVD for the correct dimension of WORK.
 
   octave_idx_type lwork = -1;
 
   Array<Complex> work (dim_vector (1, 1));
 
   octave_idx_type one = 1;
-  octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
+  octave_idx_type m1 = std::max (m, one);
+  octave_idx_type nrow_vt1 = std::max (nrow_vt, one);
 
   if (svd_driver == SVD::GESVD)
     {
+      octave_idx_type lrwork = 5*max_mn;
+      Array<double> rwork (dim_vector (lrwork, 1));
+
       F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -175,16 +174,24 @@ ComplexSVD::init (const ComplexMatrix& a
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
     }
   else if (svd_driver == SVD::GESDD)
     {
       assert (jobu == jobv);
       char jobz = jobu;
+
+      octave_idx_type lrwork;
+      if (jobz == 'N')
+        lrwork = 7*min_mn;
+      else
+        lrwork = 5*min_mn*min_mn + 5*min_mn;
+      Array<double> rwork (dim_vector (lrwork, 1));
+
       OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, 8*min_mn);
 
       F77_XFCN (zgesdd, ZGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/numeric/dbleSVD.cc b/liboctave/numeric/dbleSVD.cc
--- a/liboctave/numeric/dbleSVD.cc
+++ b/liboctave/numeric/dbleSVD.cc
@@ -113,18 +113,17 @@ SVD::init (const Matrix& a, SVD::type sv
       // Note:  for this case, both jobu and jobv should be 'N', but
       // there seems to be a bug in dgesvd from Lapack V2.0.  To
       // demonstrate the bug, set both jobu and jobv to 'N' and find
       // the singular values of [eye(3), eye(3)].  The result is
       // [-sqrt(2), -sqrt(2), -sqrt(2)].
       //
       // For Lapack 3.0, this problem seems to be fixed.
 
-      jobu = 'N';
-      jobv = 'N';
+      jobu = jobv = 'N';
       ncol_u = nrow_vt = 1;
       break;
 
     default:
       break;
     }
 
   type_computed = svd_type;
@@ -137,24 +136,25 @@ SVD::init (const Matrix& a, SVD::type sv
   sigma.resize (nrow_s, ncol_s);
   double *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   double *vt = right_sm.fortran_vec ();
 
-  // Ask DGESVD what the dimension of WORK should be.
+  // Query DGESVD for the correct dimension of WORK.
 
   octave_idx_type lwork = -1;
 
   Array<double> work (dim_vector (1, 1));
 
   octave_idx_type one = 1;
-  octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
+  octave_idx_type m1 = std::max (m, one);
+  octave_idx_type nrow_vt1 = std::max (nrow_vt, one);
 
   if (svd_driver == SVD::GESVD)
     {
       F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, info
                                  F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/numeric/fCmplxSVD.cc b/liboctave/numeric/fCmplxSVD.cc
--- a/liboctave/numeric/fCmplxSVD.cc
+++ b/liboctave/numeric/fCmplxSVD.cc
@@ -115,18 +115,17 @@ FloatComplexSVD::init (const FloatComple
       // Note:  for this case, both jobu and jobv should be 'N', but
       // there seems to be a bug in dgesvd from Lapack V2.0.  To
       // demonstrate the bug, set both jobu and jobv to 'N' and find
       // the singular values of [eye(3), eye(3)].  The result is
       // [-sqrt(2), -sqrt(2), -sqrt(2)].
       //
       // For Lapack 3.0, this problem seems to be fixed.
 
-      jobu = 'N';
-      jobv = 'N';
+      jobu = jobv = 'N';
       ncol_u = nrow_vt = 1;
       break;
 
     default:
       break;
     }
 
   type_computed = svd_type;
@@ -139,31 +138,31 @@ FloatComplexSVD::init (const FloatComple
   sigma.resize (nrow_s, ncol_s);
   float *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   FloatComplex *vt = right_sm.fortran_vec ();
 
-  octave_idx_type lrwork = 5*max_mn;
-
-  Array<float> rwork (dim_vector (lrwork, 1));
-
-  // Ask ZGESVD what the dimension of WORK should be.
+  // Query CGESVD for the correct dimension of WORK.
 
   octave_idx_type lwork = -1;
 
   Array<FloatComplex> work (dim_vector (1, 1));
 
   octave_idx_type one = 1;
-  octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
+  octave_idx_type m1 = std::max (m, one);
+  octave_idx_type nrow_vt1 = std::max (nrow_vt, one);
 
   if (svd_driver == SVD::GESVD)
     {
+      octave_idx_type lrwork = 5*max_mn;
+      Array<float> rwork (dim_vector (lrwork, 1));
+
       F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -177,16 +176,24 @@ FloatComplexSVD::init (const FloatComple
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
     }
   else if (svd_driver == SVD::GESDD)
     {
       assert (jobu == jobv);
       char jobz = jobu;
+
+      octave_idx_type lrwork;
+      if (jobz == 'N')
+        lrwork = 5*min_mn;
+      else
+        lrwork = min_mn * std::max (5*min_mn+7, 2*max_mn+2*min_mn+1);
+      Array<float> rwork (dim_vector (lrwork, 1));
+
       OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, 8*min_mn);
 
       F77_XFCN (cgesdd, CGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/numeric/floatSVD.cc b/liboctave/numeric/floatSVD.cc
--- a/liboctave/numeric/floatSVD.cc
+++ b/liboctave/numeric/floatSVD.cc
@@ -113,18 +113,17 @@ FloatSVD::init (const FloatMatrix& a, SV
       // Note:  for this case, both jobu and jobv should be 'N', but
       // there seems to be a bug in dgesvd from Lapack V2.0.  To
       // demonstrate the bug, set both jobu and jobv to 'N' and find
       // the singular values of [eye(3), eye(3)].  The result is
       // [-sqrt(2), -sqrt(2), -sqrt(2)].
       //
       // For Lapack 3.0, this problem seems to be fixed.
 
-      jobu = 'N';
-      jobv = 'N';
+      jobu = jobv = 'N';
       ncol_u = nrow_vt = 1;
       break;
 
     default:
       break;
     }
 
   type_computed = svd_type;
@@ -137,24 +136,25 @@ FloatSVD::init (const FloatMatrix& a, SV
   sigma.resize (nrow_s, ncol_s);
   float *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   float *vt = right_sm.fortran_vec ();
 
-  // Ask DGESVD what the dimension of WORK should be.
+  // Query SGESVD for the correct dimension of WORK.
 
   octave_idx_type lwork = -1;
 
   Array<float> work (dim_vector (1, 1));
 
   octave_idx_type one = 1;
-  octave_idx_type m1 = std::max (m, one), nrow_vt1 = std::max (nrow_vt, one);
+  octave_idx_type m1 = std::max (m, one);
+  octave_idx_type nrow_vt1 = std::max (nrow_vt, one);
 
   if (svd_driver == SVD::GESVD)
     {
       F77_XFCN (sgesvd, SGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
                                  m, n, tmp_data, m1, s_vec, u, m1, vt,
                                  nrow_vt1, work.fortran_vec (), lwork, info
                                  F77_CHAR_ARG_LEN (1)
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -41,20 +41,16 @@ along with Octave; see the file COPYING.
 #include "fCNDArray.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "mx-inlines.cc"
 #include "lo-mappers.h"
 
-#ifndef M_PI
-#define M_PI 3.14159265358979323846
-#endif
-
 #include "Faddeeva.hh"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zbesj, ZBESJ) (const double&, const double&, const double&,
                            const octave_idx_type&, const octave_idx_type&,
                            double*, double*, octave_idx_type&,
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -422,17 +422,17 @@ octave_rand::do_scalar (double a)
 float
 octave_rand::do_float_scalar (float a)
 {
   float retval = 0.0;
 
   if (use_old_generators)
     {
       double da = a;
-      double dretval;
+      double dretval = 0.0;
       switch (current_distribution)
         {
         case uniform_dist:
           F77_FUNC (dgenunf, DGENUNF) (0.0, 1.0, dretval);
           break;
 
         case normal_dist:
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, dretval);
diff --git a/liboctave/numeric/randpoisson.c b/liboctave/numeric/randpoisson.c
--- a/liboctave/numeric/randpoisson.c
+++ b/liboctave/numeric/randpoisson.c
@@ -417,17 +417,17 @@ poisson_rejection (double lambda, double
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
       do {
         do {
-          y = tan(M_PI*RUNI);
+          y = tan (M_PI*RUNI);
           em = sq * y + lambda;
         } while (em < 0.0);
         em = floor (em);
         t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
       } while (RUNI > t);
       p[i] = em;
     }
 }
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1271,29 +1271,33 @@ AC_DEFUN([OCTAVE_HAVE_FRAMEWORK], [
   else
     AC_MSG_RESULT([no])
     [$5]
   fi
 ])
 dnl
 dnl Figure out the hardware-vendor-os info.
 dnl
-dnl Hanging '])' in AC_MSG_WARN is for adding newline to output
-dnl
-AC_DEFUN([OCTAVE_HOST_TYPE], [
+AC_DEFUN([OCTAVE_CANONICAL_HOST], [
   AC_CANONICAL_HOST
   if test -z "$host"; then
-    host=unknown
+    host=unknown-unknown-unknown
+    AC_MSG_WARN([configuring Octave for unknown system type])
   fi
   canonical_host_type=$host
-  if test "$host" = unknown; then
-    AC_MSG_WARN([configuring Octave for unknown system type
-])
+  AC_SUBST(canonical_host_type)
+  if test -z "$host_cpu"; then
+    host_cpu=unknown
   fi
-  AC_SUBST(canonical_host_type)
+  if test -z "$host_vendor"; then
+    host_vendor=unknown
+  fi
+  if test -z "$host_os"; then
+    host_os=unknown
+  fi
 ])
 dnl
 dnl Check for IEEE 754 data format.
 dnl
 AC_DEFUN([OCTAVE_IEEE754_DATA_FORMAT], [
   AC_MSG_CHECKING([for IEEE 754 data format])
   AC_CACHE_VAL([octave_cv_ieee754_data_format],
     [AC_RUN_IFELSE([AC_LANG_SOURCE([[
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -14,19 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{A} =} importdata (@var{fname})
 ## @deftypefnx {Function File} {@var{A} =} importdata (@var{fname}, @var{delimiter})
-## @deftypefnx {Function File} {@var{A} =} importdata (@var{fname}, @var{delimiter},  @var{header_rows})
-## @deftypefnx {Function File} {[@var{A}, @var{delimiter}] =} importdata (...)
-## @deftypefnx {Function File} {[@var{A}, @var{delimiter}, @var{header_rows}] =} importdata (...)
+## @deftypefnx {Function File} {@var{A} =} importdata (@var{fname}, @var{delimiter}, @var{header_rows})
+## @deftypefnx {Function File} {[@var{A}, @var{delimiter}] =} importdata (@dots{})
+## @deftypefnx {Function File} {[@var{A}, @var{delimiter}, @var{header_rows}] =} importdata (@dots{})
 ## Importing data from file.
 ##
 ## Importing the contents of file @var{fname} into workspace.
 ##
 ## Input parameters:
 ## @itemize
 ## @item @var{fname}
 ## The file name for the file to import.
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -592,17 +592,18 @@ function varargout = strread (str, forma
                 (@(x) substr (x, e(1)+1, length (x) - e(1)), words(icol, jptr), ...
                 "UniformOutput", false);
               words(icol, jptr) = fmt_words{ii};
               fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
 
             else
               if (! idg(ii) && ! isempty (strfind (fmt_words{ii-1}, "%s")))
                 ## Trailing literal.  If preceding format == '%s' this is an error
-                warning ("Ambiguous '%s' specifier next to literal in column %d", icol);
+                warning ...
+                 ("strread: ambiguous '%s' specifier next to literal in column %d", icol);
               elseif (idg(ii))
                 ## Current field = fixed width. Strip into icol, rest in icol+1
                 sw = regexp (fmt_words{ii}, '\d', "once");
                 ew = regexp (fmt_words{ii}, '[nfuds]') - 1;
                 wdth = floor (str2double (fmt_words{ii}(sw:ew)));
                 words(icol+1, jptr) = cellfun (@(x) x(wdth+1:end),
                      words(icol,jptr), "UniformOutput", false);
                 if (isempty ([words(icol+1, :){:}]))
@@ -792,28 +793,28 @@ endfunction
 %!test
 %! str = "";
 %! a = rand (10, 1);
 %! b = char (randi ([65, 85], 10, 1));
 %! for k = 1:10
 %!   str = sprintf ("%s %.6f %s\n", str, a(k), b(k));
 %! endfor
 %! [aa, bb] = strread (str, "%f %s");
-%! assert (a, aa, 1e-6);
-%! assert (cellstr (b), bb);
+%! assert (aa, a, 1e-6);
+%! assert (bb, cellstr (b));
 
 %!test
 %! str = "";
 %! a = rand (10, 1);
 %! b = char (randi ([65, 85], 10, 1));
 %! for k = 1:10
 %!   str = sprintf ("%s %.6f %s\n", str, a(k), b(k));
 %! endfor
 %! aa = strread (str, "%f %*s");
-%! assert (a, aa, 1e-6);
+%! assert (aa, a, 1e-6);
 
 %!test
 %! str = sprintf ("/* this is\nacomment*/ 1 2 3");
 %! a = strread (str, "%f", "commentstyle", "c");
 %! assert (a, [1; 2; 3]);
 
 %!test
 %! str = "# comment\n# comment\n1 2 3";
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -190,28 +190,32 @@ function [C, position] = textscan (fid, 
       eol_char = args{endofline + 1};
       if (! any (strcmp (eol_char, {"", "\n", "\r", "\r\n"})))
         error ("textscan: illegal EndOfLine character value specified");
       endif
     else
       error ("textscan: character value required for EndOfLine");
     endif
   else
+    if (! ischar (fid))
     ## Determine EOL from file.  Search for EOL candidates in first BUFLENGTH chars
     eol_srch_len = min (length (str), BUFLENGTH);
     ## First try DOS (CRLF)
     if (! isempty (strfind ("\r\n", str(1 : eol_srch_len))))
       eol_char = "\r\n";
     ## Perhaps old Macintosh? (CR)
     elseif (! isempty (strfind ("\r", str(1 : eol_srch_len))))
       eol_char = "\r";
     ## Otherwise, use plain UNIX (LF)
     else
       eol_char = "\n";
     endif
+    else
+      eol_char = "\n";
+    endif
     ## Set up the default endofline param value
     args(end+1:end+2) = {"endofline", eol_char};
   endif
 
   if (!ischar (fid))
     ## Now that we know what EOL looks like, we can process format_repeat_count.
     ## FIXME The below isn't ML-compatible: counts lines, not format string uses
     if (isfinite (nlines) && (nlines >= 0))
@@ -403,8 +407,93 @@ endfunction
 %! assert (R{1}, int32 (1));
 %! assert (isempty (R{2}), true);
 
 %% bug #37023 (actually a strread test)
 %!test
 %! data = textscan("   1. 1 \n 2 3\n", '%f %f');
 %! assert (data{1}, [1; 2], 1e-15);
 %! assert (data{2}, [1; 3], 1e-15);
+
+%%  Whitespace test (bug #37333) using delimiter ";"
+%!test
+%! tc = [];
+%! tc{1, 1} = "C:/code;";
+%! tc{1, end+1} = "C:/code/meas;";
+%! tc{1, end+1} = " C:/code/sim;";
+%! tc{1, end+1} = "C:/code/utils;";
+%! string = [tc{:}];
+%! c = textscan (string, "%s", "delimiter", ";");
+%! for k = 1:numel (c{1})
+%!   lh = c{1}{k};
+%!   rh = tc{k};
+%!   rh(rh == ";") = "";
+%!   rh = strtrim (rh);
+%!   assert (strcmp (lh, rh));
+%! end
+
+%%  Whitespace test (bug #37333), adding multipleDelimsAsOne true arg
+%!test
+%! tc = [];
+%! tc{1, 1} = "C:/code;";
+%! tc{1, end+1} = " C:/code/meas;";
+%! tc{1, end+1} = "C:/code/sim;;";
+%! tc{1, end+1} = "C:/code/utils;";
+%! string = [tc{:}];
+%! c = textscan (string, "%s", "delimiter", ";", "multipleDelimsAsOne", 1);
+%! for k = 1:numel (c{1})
+%!   lh = c{1}{k};
+%!   rh = tc{k};
+%!   rh(rh == ";") = "";
+%!   rh = strtrim (rh);
+%!   assert (strcmp (lh, rh));
+%! end
+
+%%  Whitespace test (bug #37333), adding multipleDelimsAsOne false arg
+%!test
+%! tc = [];
+%! tc{1, 1} = "C:/code;";
+%! tc{1, end+1} = " C:/code/meas;";
+%! tc{1, end+1} = "C:/code/sim;;";
+%! tc{1, end+1} = "";
+%! tc{1, end+1} = "C:/code/utils;";
+%! string = [tc{:}];
+%! c = textscan (string, "%s", "delimiter", ";", "multipleDelimsAsOne", 0);
+%! for k = 1:numel (c{1})
+%!   lh = c{1}{k};
+%!   rh = tc{k};
+%!   rh(rh == ";") = "";
+%!   rh = strtrim (rh);
+%!   assert (strcmp (lh, rh));
+%! end
+
+%%  Whitespace test (bug #37333) whitespace "" arg
+%!test
+%! tc = [];
+%! tc{1, 1} = "C:/code;";
+%! tc{1, end+1} = " C:/code/meas;";
+%! tc{1, end+1} = "C:/code/sim;";
+%! tc{1, end+1} = "C:/code/utils;";
+%! string = [tc{:}];
+%! c = textscan (string, "%s", "delimiter", ";", "whitespace", "");
+%! for k = 1:numel (c{1})
+%!   lh = c{1}{k};
+%!   rh = tc{k};
+%!   rh(rh == ";") = "";
+%!   assert (strcmp (lh, rh));
+%! end
+
+%%  Whitespace test (bug #37333), whitespace " " arg
+%!test
+%! tc = [];
+%! tc{1, 1} = "C:/code;";
+%! tc{1, end+1} = " C:/code/meas;";
+%! tc{1, end+1} = "C:/code/sim;";
+%! tc{1, end+1} = "C:/code/utils;";
+%! string = [tc{:}];
+%! c = textscan (string, "%s", "delimiter", ";", "whitespace", " ");
+%! for k = 1:numel (c{1})
+%!   lh = c{1}{k};
+%!   rh = tc{k};
+%!   rh(rh == ";") = "";
+%!   rh = strtrim (rh);
+%!   assert (strcmp (lh, rh));
+%! end
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -43,28 +43,28 @@
 ##         @{
 ##           a =  1
 ##           b =  2
 ##           c =  3
 ##           d =  4
 ##         @}
 ## @end group
 ## @group
-## t = struct ("d", @{@}, "c", @{@}, "b", "a", @{@});
+## t = struct ("d", @{@}, "c", @{@}, "b", @{@}, "a", @{@});
 ## t2 = orderfields (s, t)
 ##      @result{} t2 =
 ##         @{
 ##           d =  4
 ##           c =  3
 ##           b =  2
 ##           a =  1
 ##         @}
 ## @end group
 ## @group
-## t3 = orderfields (s, [3, 2, 4, 1]);
+## t3 = orderfields (s, [3, 2, 4, 1])
 ##      @result{} t3 =
 ##         @{
 ##           a =  1
 ##           b =  2
 ##           c =  3
 ##           d =  4
 ##         @}
 ## @end group
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -316,16 +316,17 @@ function enhanced = gnuplot_set_term (pl
     elseif (any (strcmp (term, flickering_terms)))
       fprintf (plot_stream, "%s\n", term_str);
       if (nargin == 5)
         if (! isempty (file))
           fprintf (plot_stream, "set output '%s';\n", file);
         endif
       endif
     endif
+    fprintf (plot_stream, "set termoption dashed\n")
   else
     ## gnuplot will pick up the GNUTERM environment variable itself
     ## so no need to set the terminal type if not also setting the
     ## figure title, enhanced mode, or position.
   endif
 
 endfunction
 
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -20,19 +20,20 @@
 
 include $(top_srcdir)/build-aux/common.mk
 
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
   -I$(top_srcdir)/liboctave/array \
   -I$(top_srcdir)/liboctave/cruft/misc \
   -I$(top_srcdir)/liboctave/numeric \
+  -I$(top_srcdir)/liboctave/system \
   -I$(top_srcdir)/liboctave/util \
   -I$(top_srcdir)/libinterp \
-  -I$(top_builddir)/libinterp/interpfcn \
+  -I$(top_builddir)/libinterp/interpfcn -I$(top_srcdir)/libinterp/interpfcn \
   -I$(top_builddir)/libgnu -I$(top_srcdir)/libgnu
 
 AM_CFLAGS += $(WARN_CFLAGS)
 
 AM_CXXFLAGS += $(WARN_CXXFLAGS)
 
 EXTRA_DIST = \
   mkoctfile.in.cc \
diff --git a/src/main-cli.cc b/src/main-cli.cc
--- a/src/main-cli.cc
+++ b/src/main-cli.cc
@@ -21,20 +21,23 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defaults.h"
 #include "octave.h"
+#include "sysdep.h"
 
 int
 main (int argc, char **argv)
 {
   octave_process_command_line (argc, argv);
 
+  sysdep_init ();
+
   install_defaults ();
 
   octave_initialize_interpreter (argc, argv, 0);
 
   return octave_execute_interpreter ();
 }
diff --git a/src/main.cc b/src/main.cc
--- a/src/main.cc
+++ b/src/main.cc
@@ -22,24 +22,27 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defaults.h"
 #include "octave.h"
 #include "octave-gui.h"
+#include "sysdep.h"
 
 int
 main (int argc, char **argv)
 {
   int retval = 0;
 
   octave_process_command_line (argc, argv);
 
+  sysdep_init ();
+
   install_defaults ();
 
   if (octave_starting_gui ())
     retval = octave_start_gui (argc, argv);
   else
     {
       octave_initialize_interpreter (argc, argv, 0);
 
