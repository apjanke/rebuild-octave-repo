# HG changeset patch
# User Rik <rik@octave.org>
# Date 1542903123 28800
#      Thu Nov 22 08:12:03 2018 -0800
# Node ID 4d1c6c60f6b3c002d7835d48c72bbdf0ea54038d
# Parent  80d284ab86b680a9b42dd031fc55604934ad4735
Clean up implementation of uitable in 36e0e5b428e7.

* genpropdoc.m: Re-order primary list of graphics objects.
Correct spelling in comments.  Indent and document uitable properties.
Correct generation of Texinfo string to handle a default value of a cell '{}'.

* gui.txi: Re-order list of uiXXX functions in to sensible groups.

* Table.cc, Table.h: Use Octave standard copyright on file.
Use Octave coding conventions for placement of parentheses,
line length, position of '*' in pointers,

* graphics.cc: Use Octave coding conventions for placement of parentheses,
space after '!' operator, line length,

* graphics.in.h (uitable): Change default of "columnformat" to "Cell ()" to match
Matlab.  Change "enable" to a bool_property.
* graphics.in.h (uitable::update_fontweight): Add warning when "demi" or
"light" fontweight is used.

* uitable.m: Use Octave standard copyright on file.  Rewrite documentation to
match other uiXXX functions.  Use Octave coding conventions in documentation,
in code, and in demonstration code in %!demo blocks.  Only provide an output
if one is requested.  Use rows() or columns() rather than size (x, [1|2]).

* NEWS: Move note about Unicode characters to be above changes to libraries.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -92,26 +92,26 @@ Summary of important user-visible change
     option will expand the plot to take up as much room as possible on
     the page without distorting the original aspect ratio of the plot.
 
  ** Printing using the -dtiff output device will now create compressed
     images using LZW compression.  This change was made for Matlab
     compatibility.  To produce uncompressed images use the -dtiffn
     device.
 
+ ** It is now possible to use files and folders containing Unicode
+    characters in Windows.
+
  ** The FFTW library is now required to perform FFT calculations.
     The FFTPACK sources have been removed from Octave.
 
  ** The OSMesa library is no longer used.  To print invisible figures
     when using OpenGL graphics, the Qt QOFFSCREENSURFACE feature must be
     available and you must use the qt graphics toolkit.
 
- ** It is now possible to use files and folders containing Unicode
-    characters in Windows.
-
  ** The str2func function no longer accepts a second "global" argument.
     This argument was typically used to allow functions that accept
     function names as arguments to avoid conflicts with subfunctions or
     nested functions.  Instead, it's best to avoid this situation
     entirely and require users to pass function handles rather than
     function names.
 
  ** New functions added in 5.0:
diff --git a/doc/interpreter/genpropdoc.m b/doc/interpreter/genpropdoc.m
--- a/doc/interpreter/genpropdoc.m
+++ b/doc/interpreter/genpropdoc.m
@@ -26,21 +26,21 @@
 ## All the hard coded documentation is written in getdoc function.  See the
 ## comments in getdoc bellow for instruction on how to document a graphics
 ## property.
 ##
 ## @seealso{}
 ## @end deftypefn
 
 function genpropdoc (objname, fname)
-  objnames = {"root", "figure", "axes", "line", ...
-              "text", "image", "patch", "surface", "light", ...
-              "uimenu", "uibuttongroup", "uicontextmenu", "uipanel", ...
-              "uicontrol", "uitable", "uitoolbar", "uipushtool", ...
-              "uitoggletool"};
+  objnames = {"root", "figure", "axes", ...
+              "image", "light", "line", "patch", "surface", "text", ...
+              "uibuttongroup", "uicontextmenu", "uicontrol", "uipanel", ...
+              "uimenu", "uipushtool", "uitable", "uitoggletool" "uitoolbar"
+             };
 
   ## Base properties
   base = getstructure ("base");
 
   ## Object properties
   if (any (strcmp (objname, objnames)))
     obj = getstructure (objname, base);
   else
@@ -85,17 +85,17 @@ function s = getdoc (objname, field, bas
   ##   If not provided, valid values for radio properties are automatically
   ##   retrieved using set function.
   ##
   ## -"default": string.  If not provided the default value is automatically
   ##   retrieved using get function.
   ##
   ## -"printdefault": a boolean (def. true) that specifies whether the
   ##   default value should be printed.  It is useful for properties
-  ##   like root "screendepth" that default to screen dependant values.
+  ##   like root "screendepth" that default to screen dependent values.
 
   packopt = @(c) strjoin (c, " | ");
   markdef = @(s) ["@{" s "@}"];
 
   ## Some generic templates:
   valid_color = "colorspec";
   valid_handle = "graphics handle";
   valid_string = "string";
@@ -1655,48 +1655,61 @@ point source (@qcode{\"local\"}).";
       case "units"
       case "value"
       case "verticalalignment"
 
     endswitch
 
   ## uitable Properties
   elseif (strcmp (objname, "uitable"))
-      switch (field)
-        ## Overridden shared properties
+    switch (field)
+      ## Overridden shared properties
+
+      ## Specific properties
+      case "backgroundcolor"
+      case "celleditcallback"
+      case "cellselectioncallback"
+      case "columneditable"
+      case "columnformat"
+      case "columnname"
+      case "columnwidth"
+      case "data"
+      case "enable"
+      case "extent"
+        s.valid = valid_4elvec;
+        s.printdefault = false;
+
+      case "fontangle"
+        s.doc = doc_fontangle;
 
-        ## Specific properties
-        case "backgroundcolor"
-        case "celleditcallback"
-        case "cellselectioncallback"
-        case "columneditable"
-        case "columnformat"
-        case "columnname"
-        case "columnwidth"
-        case "createfcn"
-        case "data"
-        case "deletefcn"
-        case "enable"
-        case "extent"
-        case "fontangle"
-        case "fontname"
-        case "fontsize"
-        case "fontunits"
-        case "fontweight"
-        case "foregroundcolor"
-        case "keypressfcn"
-        case "keyreleasefcn"
-        case "position"
-        case "rearrangeablecolumns"
-        case "rowname"
-        case "rowstriping"
-        case "tooltipstring"
-        case "units"
+      case "fontname"
+        s.doc = doc_fontname;
+        s.valid = valid_string;
+
+      case "fontsize"
+        s.doc = doc_fontsize;
+        s.valid = "scalar";
+
+      case "fontunits"
+        s.doc = doc_fontunits;
 
-      endswitch
+      case "fontweight"
+        s.doc = doc_fontweight;
+
+      case "foregroundcolor"
+      case "keypressfcn"
+      case "keyreleasefcn"
+      case "position"
+      case "rearrangeablecolumns"
+      case "rowname"
+      case "rowstriping"
+      case "tooltipstring"
+      case "units"
+
+    endswitch
 
   ## uitoolbar properties
   elseif (strcmp (objname, "uitoolbar"))
     switch (field)
       ## Overridden shared properties
       case "buttondownfcn"
         s.doc = doc_unused;
 
@@ -1849,19 +1862,19 @@ function def = getdefault (h, objname, f
           str = ["[" str "]"];
           ## Add ";" between columns vector values
           if (rows (def) != 1)
             str = strrep (str, "\n", "; ");
           endif
         endif
 
         ## Replace texinfo reserved characters
-        def = strrep (str, "{", "@{");
+        def = strrep (str, "@", "@@");  # must occur first
+        def = strrep (def, "{", "@{");
         def = strrep (def, "}", "@}");
-        def = strrep (def, "@", "@@");
 
         def = ["@code{" def "}"];
       else
         args = arrayfun (@(x) num2str (x), size (def), "uniformoutput", false);
         def = [strjoin(args, "-by-") " " class(def)];
       endif
     endif
   endif
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -23,17 +23,18 @@ Octave is principally a batch or command
 offer some features for constructing graphical interfaces that interact with
 users.
 
 The GUI elements available are I/O dialogs, a progress bar, and UI elements
 for plot windows.  For example, rather than hardcoding a filename for output
 results a script can open a dialog box and allow the user to choose a file.
 Similarly, if a calculation is expected to take a long time a script can
 display a progress bar.  The various UI elements can be used to fully customize
-the plot window with menubars, context menus,
+the plot window with menubars, toolbars, context menus, pushbuttons, sliders,
+etc.
 
 Several utility functions make it possible to store private data for use with
 a GUI which will not pollute the user's variable space.
 
 Finally, a program written in Octave might want to have long term storage of
 preferences or state variables.  This can be done with user-defined
 preferences.
 
@@ -56,18 +57,18 @@ a filename.
 @DOCSTRING(uigetdir)
 
 @cindex dialog, displaying a dialog for selecting files
 @DOCSTRING(uigetfile)
 
 @cindex dialog, displaying a dialog for storing files
 @DOCSTRING(uiputfile)
 
-Additionally, there are dialog boxes for printing further help, warnings or
-errors and to get textual input from the user.
+Additionally, there are dialog boxes for displaying help messages, warnings, or
+errors, and for getting text input from the user.
 
 @cindex dialog, displaying an error dialog
 @DOCSTRING(errordlg)
 
 @cindex dialog, displaying a help dialog
 @DOCSTRING(helpdlg)
 
 @cindex dialog, displaying an input dialog
@@ -98,34 +99,34 @@ For creating new dialog types, there is 
 
 @node UI Elements
 @section UI Elements
 
 The @nospell{ui*} series of functions work best with the @code{qt} graphics
 toolkit, although some functionality is available with the @code{fltk} toolkit.
 There is no support for the @code{gnuplot} toolkit.
 
-@DOCSTRING(uimenu)
+@DOCSTRING(uipanel)
 
 @DOCSTRING(uibuttongroup)
 
+@DOCSTRING(uicontrol)
+
+@DOCSTRING(uitable)
+
+@DOCSTRING(uimenu)
+
 @DOCSTRING(uicontextmenu)
 
-@DOCSTRING(uicontrol)
-
-@DOCSTRING(uipanel)
-
-@DOCSTRING(uitable)
+@DOCSTRING(uitoolbar)
 
 @DOCSTRING(uipushtool)
 
 @DOCSTRING(uitoggletool)
 
-@DOCSTRING(uitoolbar)
-
 @node GUI Utility Functions
 @section GUI Utility Functions
 
 These functions do not implement a GUI element but are useful when developing
 programs that do.  The functions @code{uiwait}, @code{uiresume}, and
 @code{waitfor} are only available with the @code{qt} or @code{fltk} toolkits.
 
 @DOCSTRING(guidata)
diff --git a/libgui/graphics/Table.cc b/libgui/graphics/Table.cc
--- a/libgui/graphics/Table.cc
+++ b/libgui/graphics/Table.cc
@@ -1,27 +1,27 @@
 /*
 
 Copyright (C) 2016 Andrew Thornton
 
 This file is part of Octave.
 
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
+Octave is free software: you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
 
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
+<https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <QEvent>
@@ -51,195 +51,194 @@ along with Octave; see the file COPYING.
 #include "oct-strstrm.h"
 #include "ov-struct.h"
 
 namespace QtHandles
 {
 
   static const int AUTO_WIDTH = 75;
 
-#define AUTO_HEIGHT \
-  tp.get_fontsize () * 2 - 1
+#define AUTO_HEIGHT tp.get_fontsize () * 2 - 1
 
-  static QSize realQSizeForTable(QTableWidget *t)
+  static QSize realQSizeForTable (QTableWidget *t)
   {
     int w = t->verticalHeader ()->width () + 4;
     for (int i = 0; i < t->columnCount (); i++)
       w += t->columnWidth (i);
     int h = t->horizontalHeader ()->height () + 4;
     for (int i = 0; i < t->rowCount (); i++)
       h += t->rowHeight (i);
-    return QSize(w, h);
+    return QSize (w, h);
   }
 
 #define FORMATNUMBER(type)                                                    \
   static QString formatNumber (type d,                                        \
                                char format = 'f',                             \
                                int precision = 4)                             \
   {                                                                           \
     if (format == 'n')                                                        \
       {                                                                       \
         if (d == floor (d))                                                   \
-          return QString::number(d, 'g', precision);                          \
+          return QString::number (d, 'g', precision);                         \
         else if (d <= pow (10, precision - 1) && d > pow (10, 1 - precision)) \
-          return QString::number(d, 'f', precision);                          \
+          return QString::number (d, 'f', precision);                         \
         else                                                                  \
-          return QString::number(d, 'e', precision);                          \
+          return QString::number (d, 'e', precision);                         \
       }                                                                       \
     else if (format == 'F')                                                   \
       {                                                                       \
         int exponent = floor (log10 (d) / 3) * 3;                             \
-        d *=  pow (10, -exponent);                                            \
-        return QString::number(d, 'f', precision) + "e" +                     \
+        d *= pow (10, -exponent);                                             \
+        return QString::number (d, 'f', precision) + "e" +                    \
           (exponent < 0 ? "-" : "+") +                                        \
-          QString("%1").arg(abs (exponent), 3, 10, QChar('0'));               \
+          QString ("%1").arg (abs (exponent), 3, 10, QChar ('0'));            \
       }                                                                       \
     else if (format == 'E')                                                   \
       {                                                                       \
         int exponent = floor (log10 (d) / 3) * 3;                             \
         d *=  pow (10, -exponent);                                            \
-        return QString::number(d,                                             \
-                               'f',                                           \
-                               precision - floor (log10 (d)) - 1) +           \
+        return QString::number (d,                                            \
+                                'f',                                          \
+                                precision - floor (log10 (d)) - 1) +          \
                "e" + (exponent < 0 ? "-" : "+") +                             \
-               QString("%1").arg(abs (exponent), 3, 10, QChar('0'));          \
+               QString ("%1").arg (abs (exponent), 3, 10, QChar ('0'));       \
       }                                                                       \
     else                                                                      \
-      return QString::number(d, format, precision);                           \
+      return QString::number (d, format, precision);                          \
   }
 
   FORMATNUMBER(double)
   FORMATNUMBER(float)
 
 #undef FORMATNUMBER
 
   static QString formatComplex (Complex c, char format = 'f', int precision = 4)
   {
-    return formatNumber(c.real(), format, precision) +
-      " + " + formatNumber(c.imag (), format, precision) + "i";
+    return formatNumber (c.real (), format, precision) + " + "
+           + formatNumber (c.imag (), format, precision) + "i";
   }
 
 #define FORMAT_VALUE_EXCEPT_RAT(f,l)                      \
   if (format == "numeric" || format == "short")           \
-    text = formatNumber(value, 'n', f);                   \
+    text = formatNumber (value, 'n', f);                  \
   else if (format == "short f" || format == "shortf")     \
-    text = formatNumber(value, 'f', f);                   \
+    text = formatNumber (value, 'f', f);                  \
   else if (format == "short e" || format == "shorte")     \
-    text = formatNumber(value, 'e', f);                   \
+    text = formatNumber (value, 'e', f);                  \
   else if (format == "short eng" || format == "shorteng") \
-    text = formatNumber(value, 'F', f);                   \
+    text = formatNumber (value, 'F', f);                  \
   else if (format == "short g" || format == "shortg")     \
-    text = formatNumber(value, 'g', f + 1);               \
+    text = formatNumber (value, 'g', f + 1);              \
   else if (format == "long")                              \
-    text = formatNumber(value, 'n', l);                   \
+    text = formatNumber (value, 'n', l);                  \
   else if (format == "long f" || format == "longf")       \
-    text = formatNumber(value, 'f', l);                   \
+    text = formatNumber (value, 'f', l);                  \
   else if (format == "long e" || format == "longe")       \
-    text = formatNumber(value, 'e', l);                   \
+    text = formatNumber (value, 'e', l);                  \
   else if (format == "long eng" || format == "longeng")   \
-    text = formatNumber(value, 'E', l);                   \
+    text = formatNumber (value, 'E', l);                  \
   else if (format == "long g" || format == "longg")       \
-    text = formatNumber(value, 'g', l + 1);               \
+    text = formatNumber (value, 'g', l + 1);              \
   else if (format == "bank")                              \
-    text = QString::number(value, 'f', 2);                \
+    text = QString::number (value, 'f', 2);               \
   else if (format == "+")                                 \
     if (value > 0)                                        \
-      text = Utils::fromStdString("+");                   \
+      text = Utils::fromStdString ("+");                  \
     else if (value < 0)                                   \
-      text = Utils::fromStdString("-");                   \
+      text = Utils::fromStdString ("-");                  \
     else                                                  \
-      text = Utils::fromStdString("");
+      text = Utils::fromStdString ("");
 
-#define FORMAT_VALUE(f,l)                                            \
-  FORMAT_VALUE_EXCEPT_RAT(f,l)                                       \
-  else if (format == "rat")                                          \
-    text = Utils::fromStdString(rational_approx(double (value), 0)); \
-  else                                                               \
-    {                                                                \
-      text = formatNumber (value, 'n', f);                           \
-      flag = Qt::AlignLeft ;                                         \
+#define FORMAT_VALUE(f,l)                                               \
+  FORMAT_VALUE_EXCEPT_RAT(f,l)                                          \
+  else if (format == "rat")                                             \
+    text = Utils::fromStdString (rational_approx (double (value), 0));  \
+  else                                                                  \
+    {                                                                   \
+      text = formatNumber (value, 'n', f);                              \
+      flag = Qt::AlignLeft ;                                            \
     }
 
-#define FORMAT_UINT_VALUE()                   \
-  text = QString::number(value);              \
-  if (format == "char"  || format == "popup") \
-    flag = Qt::AlignLeft;                     \
-  else if (format == "+")                     \
-    {                                         \
-      if (value > 0)                          \
-        text = Utils::fromStdString("+");     \
-      else                                    \
-        text = Utils::fromStdString("");      \
+#define FORMAT_UINT_VALUE()                    \
+  text = QString::number (value);              \
+  if (format == "char"  || format == "popup")  \
+    flag = Qt::AlignLeft;                      \
+  else if (format == "+")                      \
+    {                                          \
+      if (value > 0)                           \
+        text = Utils::fromStdString ("+");     \
+      else                                     \
+        text = Utils::fromStdString ("");      \
     }
 
-#define FORMAT_INT_VALUE()                    \
-  text = QString::number(value);              \
-  if (format == "char" || format == "popup")  \
-    flag = Qt::AlignLeft ;                    \
-  else if (format == "+")                     \
-    {                                         \
-      if (value > 0)                          \
-        text = Utils::fromStdString("+");     \
-      else if (value < 0)                     \
-        text = Utils::fromStdString("-");     \
-      else                                    \
-        text = Utils::fromStdString("");      \
+#define FORMAT_INT_VALUE()                     \
+  text = QString::number (value);              \
+  if (format == "char" || format == "popup")   \
+    flag = Qt::AlignLeft ;                     \
+  else if (format == "+")                      \
+    {                                          \
+      if (value > 0)                           \
+        text = Utils::fromStdString ("+");     \
+      else if (value < 0)                      \
+        text = Utils::fromStdString ("-");     \
+      else                                     \
+        text = Utils::fromStdString ("");      \
     }
 
-  static std::pair <Qt::AlignmentFlag, QString> qStringValueFor (
+  static std::pair<Qt::AlignmentFlag, QString> qStringValueFor (
     octave_value val, std::string format = "")
   {
     Qt::AlignmentFlag flag = Qt::AlignRight;
     QString text;
     if (val.is_string ())
       {
         text = QtHandles::Utils::fromStdString (val.string_value ());
         flag = Qt::AlignLeft ;
       }
     else if (val.iscomplex ())
       {
-        // Matlab has mulitple complex types we only have double.
+        // Matlab has multiple complex types, we only have double.
         Complex c = val.complex_value ();
         if (format == "short")
-          text = formatComplex(c, 'f', 4);
+          text = formatComplex (c, 'f', 4);
         else if (format == "short e" || format == "shorte")
-          text = formatComplex(c, 'e', 4);
+          text = formatComplex (c, 'e', 4);
         else if (format == "short eng" || format == "shorteng")
-          text = formatComplex(c, 'E', 4);
+          text = formatComplex (c, 'E', 4);
         else if (format == "short g" || format == "shortg")
-          text = formatComplex(c, 'g', 5);
+          text = formatComplex (c, 'g', 5);
         else if (format == "long")
-          text = formatComplex(c, 'f', 15);
+          text = formatComplex (c, 'f', 15);
         else if (format == "long e" || format == "longe")
-          text = formatComplex(c, 'e', 15);
+          text = formatComplex (c, 'e', 15);
         else if (format == "long eng" || format == "longeng")
-          text = formatComplex(c, 'E', 15);
+          text = formatComplex (c, 'E', 15);
         else if (format == "long g" || format == "longg")
-          text = formatComplex(c, 'g', 16);
+          text = formatComplex (c, 'g', 16);
         else if (format == "bank")
-          text = QString::number(c.real (), 'f', 2);
+          text = QString::number (c.real (), 'f', 2);
         else if (format == "+")
           {
             if (c.real () > 0)
-              text = Utils::fromStdString("+");
+              text = Utils::fromStdString ("+");
             else if (c.real () < 0)
-              text = Utils::fromStdString("-");
+              text = Utils::fromStdString ("-");
             else
-              text = Utils::fromStdString("");
+              text = Utils::fromStdString ("");
           }
         else if (format == "rat")
-          text = Utils::fromStdString(rational_approx(c.real (), 0)) + " + " +
-            Utils::fromStdString(rational_approx(c.imag (), 0)) + "i";
+          text = Utils::fromStdString (rational_approx (c.real (), 0)) + " + "
+                 + Utils::fromStdString (rational_approx (c.imag (), 0)) + "i";
         else if (format == "numeric")
           text = QString::number (c.real (), 'g', 5) + " + "
-            + QString::number (c.imag (), 'g', 5) + "i";
+                 + QString::number (c.imag (), 'g', 5) + "i";
         else
           {
             text = QString::number (c.real (), 'g', 5) + " + "
-              + QString::number (c.imag (), 'g', 5) + "i";
+                   + QString::number (c.imag (), 'g', 5) + "i";
             flag = Qt::AlignLeft ;
           }
       }
     else if (val.is_double_type () )
       {
         double value = val.double_value ();
         FORMAT_VALUE(4, 15)
       }
@@ -288,75 +287,78 @@ namespace QtHandles
         uint64_t value = val.uint64_value ();
         FORMAT_UINT_VALUE()
       }
     else if (val.islogical ())
       {
         bool b = val.bool_value ();
         if (format == "char" || format == "popup" || format == "")
           {
-            text = Utils::fromStdString(b ? "true" : "false");
+            text = Utils::fromStdString (b ? "true" : "false");
             flag = Qt::AlignLeft ;
           }
         else if (format == "+")
           {
-            text = Utils::fromStdString(b ? "+" : "");
+            text = Utils::fromStdString (b ? "+" : "");
             flag = Qt::AlignLeft ;
           }
         else
-          text = Utils::fromStdString(b ? "1" : "0");
+          text = Utils::fromStdString (b ? "1" : "0");
       }
     else
       {
         std::stringstream warn_string;
         warn_string << "Unknown conversion for datatype " << val.class_name ()
-          << " to " << format << " for value " << val.string_value (true);
-        warning (warn_string.str().c_str());
+                    << " to " << format
+                    << " for value " << val.string_value (true);
+        warning (warn_string.str ().c_str ());
 
-        text = Utils::fromStdString(val.string_value (true));
+        text = Utils::fromStdString (val.string_value (true));
       }
 
-    return std::make_pair(flag, text);
+    return std::make_pair (flag, text);
   }
 
 #undef FORMAT_VALUE
 #undef FORMAT_VALUE_EXCEPT_RAT
 #undef FORMAT_UINT_VALUE
 #undef FORMAT_INT_VALUE
 
-  static QTableWidgetItem * itemFor(octave_value val, std::string format = "",
-                                    bool enabled = false)
+  static QTableWidgetItem * itemFor (octave_value val, std::string format = "",
+                                     bool enabled = false)
   {
-    QTableWidgetItem* retval  = new QTableWidgetItem ();
-    std::pair <Qt::AlignmentFlag, QString> flag_and_text = qStringValueFor(val, format);
+    QTableWidgetItem *retval = new QTableWidgetItem ();
+    std::pair<Qt::AlignmentFlag, QString> flag_and_text =
+      qStringValueFor (val, format);
     retval->setTextAlignment (flag_and_text.first);
     retval->setText (flag_and_text.second);
 
     if (enabled)
-      retval->setFlags (retval->flags ()  | Qt::ItemIsEditable);
+      retval->setFlags (retval->flags () | Qt::ItemIsEditable);
     else
-      retval->setFlags (retval->flags ()  & ~Qt::ItemIsEditable);
+      retval->setFlags (retval->flags () & ~Qt::ItemIsEditable);
 
     return retval;
   }
 
   static octave_value
-  attempt_type_conversion (const octave_value& ov, const octave_value& old_value)
+  attempt_type_conversion (const octave_value& ov,
+                           const octave_value& old_value)
   {
     octave_value retval;
 
     // Define a macro to help with the conversion of strings to integers
     // FIXME: these will happily integer overflow in the (u)int64 case
     // - this probably doesn't matter.
 #define SCANF_AND_CONVERT(name,ctype,format)           \
   else if (old_value.is_ ## name ## _type ())          \
     {                                                  \
       ctype val;                                       \
       int n;                                           \
-      const char* c_str = ov.string_value ().c_str (); \
+      const char *c_str = ov.string_value ().c_str (); \
       int error = sscanf (c_str, format, &val, &n);    \
       if (error != 1 || c_str[n])                      \
         {                                              \
           val = 0;                                     \
         }                                              \
       retval = octave_value ( octave_ ## name (val));  \
     }
 
@@ -368,17 +370,17 @@ namespace QtHandles
     SCANF_AND_CONVERT(uint16, uint64_t, "%ju %n")
     SCANF_AND_CONVERT(int32, int64_t, "%jd %n")
     SCANF_AND_CONVERT(uint32, uint64_t, "%ju %n")
     SCANF_AND_CONVERT(int64, int64_t, "%jd %n")
     SCANF_AND_CONVERT(uint64, uint64_t, "%ju %n")
 
   #undef SCANF_AND_CONVERT
 
-    else if (old_value.isnumeric () && !old_value.isinteger ())
+    else if (old_value.isnumeric () && ! old_value.isinteger ())
       {
         // Basically need to do str2double
         Complex complex = octave_str2double (ov.string_value ());
         if (old_value.is_single_type ())
           retval = octave_value (FloatComplex (complex));
         else
           retval = octave_value (complex);
       }
@@ -394,19 +396,19 @@ namespace QtHandles
     else
       retval = octave_value (octave_str2double (ov.string_value ()));
     return retval;
   }
 
   QWidget *
   Table::checkBoxForLogical (octave_value val, bool enabled = false)
   {
-    QWidget *retval = new QWidget(m_tableWidget);
-    QCheckBox *checkBox = new QCheckBox();
-    QHBoxLayout *layout = new QHBoxLayout(retval);
+    QWidget *retval = new QWidget (m_tableWidget);
+    QCheckBox *checkBox = new QCheckBox ();
+    QHBoxLayout *layout = new QHBoxLayout (retval);
     layout->addWidget (checkBox);
     layout->setAlignment (Qt::AlignCenter);
     layout->setContentsMargins (0, 0, 0, 0);
     retval->setLayout (layout);
 
     if ((val.islogical () || val.is_bool_scalar ()) && val.bool_value ())
       checkBox->setCheckState (Qt::Checked);
     else
@@ -417,126 +419,127 @@ namespace QtHandles
     checkBox->setProperty ("Enabled", QVariant (enabled));
 
     return retval;
   }
 
   Table*
   Table::create (const graphics_object& go)
   {
-    Object* parent = Object::parentObject (go);
+    Object *parent = Object::parentObject (go);
 
     if (parent)
       {
-        Container* container = parent->innerContainer ();
+        Container *container = parent->innerContainer ();
 
         if (container)
           return new Table (go, new QTableWidget (container));
       }
 
-      return 0;
+    return 0;
   }
 
-  Table::Table (const graphics_object& go, QTableWidget* tableWidget)
-    : Object (go, tableWidget), m_tableWidget(tableWidget), m_curData(),
-      m_blockUpdates(false)
+  Table::Table (const graphics_object& go, QTableWidget *tableWidget)
+    : Object (go, tableWidget), m_tableWidget (tableWidget), m_curData (),
+      m_blockUpdates (false)
   {
     uitable::properties& tp = properties<uitable> ();
 
-    m_curData = octave_value(tp.get_data ());
+    m_curData = octave_value (tp.get_data ());
     Matrix bb = tp.get_boundingbox (false);
     m_tableWidget->setObjectName ("UITable");
     m_tableWidget->setAutoFillBackground (true);
-    m_tableWidget->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                    octave::math::round (bb(2)), octave::math::round (bb(3)));
+    m_tableWidget->setGeometry (octave::math::round (bb(0)),
+                                octave::math::round (bb(1)),
+                                octave::math::round (bb(2)),
+                                octave::math::round (bb(3)));
     m_tableWidget->setFont (Utils::computeFont<uitable> (tp)) ;
     m_tableWidget->setSelectionBehavior (QAbstractItemView::SelectItems);
     updatePalette ();
     m_keyPressHandlerDefined = ! tp.get_keypressfcn ().isempty ();
     m_keyReleaseHandlerDefined = ! tp.get_keyreleasefcn ().isempty ();
     updateData ();
     updateRowname ();
     updateColumnname ();
-    updateColumnwidth();
-    updateEnable(); // Also does rearrangeableColumns
+    updateColumnwidth ();
+    updateEnable ();  // Also does rearrangeableColumns
     m_tableWidget->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
     m_tableWidget->setVisible (tp.is_visible ());
     updateExtent ();
     m_tableWidget->installEventFilter (this);
 
 
     connect (m_tableWidget, SIGNAL (itemChanged (QTableWidgetItem*)),
              SLOT (itemChanged (QTableWidgetItem*)));
     connect (m_tableWidget, SIGNAL (cellClicked (int, int)),
              SLOT (cellClicked (int, int)));
     connect (m_tableWidget, SIGNAL (itemSelectionChanged (void)),
              SLOT (itemSelectionChanged (void)));
   }
 
-  Table::~Table (void)
-  {
-  }
+  Table::~Table (void) { }
 
   void
   Table::itemSelectionChanged ()
   {
-    if (!(properties<uitable> ().get_cellselectioncallback ().isempty ()))
+    if (! (properties<uitable> ().get_cellselectioncallback ().isempty ()))
       {
-        QModelIndexList modelIndexList = m_tableWidget->selectionModel()->selectedIndexes ();
-        int length = modelIndexList.size();
+        QModelIndexList modelIndexList =
+          m_tableWidget->selectionModel ()->selectedIndexes ();
+        int length = modelIndexList.size ();
         Matrix indices = Matrix (length, 2);
         for (int i = 0; i < length; i++)
           {
-            indices (i, 0) = modelIndexList.value (i).row () + 1;
-            indices (i, 1) = modelIndexList.value (i).column () + 1;
+            indices(i, 0) = modelIndexList.value (i).row () + 1;
+            indices(i, 1) = modelIndexList.value (i).column () + 1;
           }
         octave_scalar_map eventData;
         eventData.setfield ("Indices", indices);
         octave_value cellSelectionCallbackEventObject =
           octave_value (new octave_struct (eventData));
-        gh_manager::post_callback(m_handle,
-                                  "cellselectioncallback",
-                                  cellSelectionCallbackEventObject);
+        gh_manager::post_callback (m_handle,
+                                   "cellselectioncallback",
+                                   cellSelectionCallbackEventObject);
       }
   }
 
   void
   Table::cellClicked (int row, int col)
   {
-    QCheckBox* checkBox = NULL;
-    QWidget* widget = qobject_cast<QWidget*> (
-      m_tableWidget->cellWidget (row, col));
-    if (widget && !widget->children ().isEmpty ())
+    QCheckBox *checkBox = nullptr;
+    QWidget *widget = qobject_cast<QWidget *> (
+                        m_tableWidget->cellWidget (row, col));
+    if (widget && ! widget->children ().isEmpty ())
       {
-        QHBoxLayout* layout = qobject_cast<QHBoxLayout*> (
-          widget->children ().first ());
+        QHBoxLayout *layout = qobject_cast<QHBoxLayout *> (
+                                widget->children ().first ());
         if (layout && layout->count () > 0)
           {
-            checkBox = qobject_cast<QCheckBox*> (
-              layout->itemAt (0)-> widget ());
+            checkBox = qobject_cast<QCheckBox *> (
+                         layout->itemAt (0)-> widget ());
           }
       }
-    if (checkBox && checkBox->property ("Enabled").toBool())
-      checkBoxClicked(row, col, checkBox);
+    if (checkBox && checkBox->property ("Enabled").toBool ())
+      checkBoxClicked (row, col, checkBox);
   }
 
   void
   Table::sendCellEditCallback (int row,
-    int col,
-    octave_value old_value,
-    octave_value new_value,
-    octave_value edit_data,
-    octave_value error)
+                               int col,
+                               octave_value old_value,
+                               octave_value new_value,
+                               octave_value edit_data,
+                               octave_value error)
   {
 
     if (!(properties<uitable> ().get_celleditcallback ().isempty ()))
       {
         Matrix indices = Matrix (1, 2);
-        indices (0, 0) = row + 1;
-        indices (0, 1) = col + 1;
+        indices(0, 0) = row + 1;
+        indices(0, 1) = col + 1;
 
         octave_scalar_map eventData;
         eventData.setfield ("Indices", indices);
         eventData.setfield ("PreviousData", old_value);
         eventData.setfield ("NewData", new_value);
         eventData.setfield ("EditData", edit_data);
         eventData.setfield ("Error", error);
 
@@ -551,250 +554,253 @@ namespace QtHandles
       warning (error.string_value ().c_str ());
   }
 
   void
   Table::comboBoxCurrentIndexChanged (const QString& value)
   {
     if (m_blockUpdates)
       return;
+
     m_blockUpdates = true;
     gh_manager::auto_lock lock;
-    octave_value data = octave_value(m_curData);
+    octave_value data = octave_value (m_curData);
     bool ok = false;
 
-    QComboBox* comboBox = qobject_cast<QComboBox*> (sender());
+    QComboBox *comboBox = qobject_cast<QComboBox *> (sender ());
     int row = comboBox->property ("row").toInt ();
     int col = comboBox->property ("col").toInt ();
 
-    octave_value edit_data = octave_value(Utils::toStdString(value));
+    octave_value edit_data = octave_value (Utils::toStdString (value));
 
     if (row < data.rows () && col < data.columns ())
       {
         if (data.iscell ())
           {
             Cell cell = data.cell_value ();
-            octave_value old_data = cell (row, col);
-            if (cell (row, col).is_string ())
+            octave_value old_data = cell(row, col);
+            if (cell(row, col).is_string ())
               {
-                cell (row, col) = edit_data;
+                cell(row, col) = edit_data;
                 if (edit_data.string_value () != old_data.string_value ())
                   {
-                    m_curData = octave_value(cell);
+                    m_curData = octave_value (cell);
                     gh_manager::post_set (m_handle,
                                           "data",
                                           octave_value (cell),
                                           false);
                   }
 
-                octave_value error = octave_value("");
-                sendCellEditCallback(row,
-                  col,
-                  old_data,
-                  edit_data,
-                  edit_data,
-                  error);
+                octave_value error = octave_value ("");
+                sendCellEditCallback (row, col,
+                                      old_data,
+                                      edit_data,
+                                      edit_data,
+                                      error);
                 ok = true;
               }
             else
               {
-                cell (row, col) = attempt_type_conversion(edit_data, old_data);
+                cell(row, col) = attempt_type_conversion (edit_data, old_data);
 
                 // Inform the QTableWidget of our change
-                updateData(row, col, cell (row, col), columnformat (col), columneditable (col));
+                updateData (row, col, cell(row, col),
+                            columnformat (col), columneditable (col));
 
-                m_curData = octave_value(cell);
+                m_curData = octave_value (cell);
                 gh_manager::post_set (m_handle, "data", octave_value (cell), false);
 
-                octave_value error = octave_value("");
-                sendCellEditCallback(row,
-                  col,
-                  old_data,
-                  cell (row, col),
-                  edit_data,
-                  error);
+                octave_value error = octave_value ("");
+                sendCellEditCallback (row,
+                                      col,
+                                      old_data,
+                                      cell(row, col),
+                                      edit_data,
+                                      error);
                 ok = true;
               }
           }
         else
           {
             octave_value old_data = data.is_matrix_type ()
-              ? data.fast_elem_extract(row + col * data.rows())
-              : octave_value ();
-            data.fast_elem_insert (row + col * data.rows(),
-                                   attempt_type_conversion(edit_data, old_data));
+                                    ? data.fast_elem_extract (row + col * data.rows ())
+                                    : octave_value ();
+            data.fast_elem_insert (row + col * data.rows (),
+                                   attempt_type_conversion (edit_data, old_data));
 
             // Inform the QTableWidget of our change
-            updateData(row,
-                       col,
-                       data.fast_elem_extract (row + col * data.rows ()),
-                       columnformat (col),
-                       columneditable (col));
+            updateData (row,
+                        col,
+                        data.fast_elem_extract (row + col * data.rows ()),
+                        columnformat (col),
+                        columneditable (col));
 
-            m_curData = octave_value(data);
+            m_curData = octave_value (data);
             gh_manager::post_set (m_handle, "data", data, false);
 
-            octave_value error = octave_value("");
-            sendCellEditCallback(row,
-              col,
-              old_data,
-              data.fast_elem_extract(row + col * data.rows()),
-              edit_data,
-              error);
+            octave_value error = octave_value ("");
+            sendCellEditCallback (row,
+                                  col,
+                                  old_data,
+                                  data.fast_elem_extract (row + col * data.rows ()),
+                                  edit_data,
+                                  error);
             ok = true;
           }
       }
     else
       {
         // Reset the QTableWidgetItem
-        updateData(row, col, octave_value (""), columnformat (col), columneditable (col));
+        updateData (row, col, octave_value (""), columnformat (col),
+                    columneditable (col));
 
-        octave_value error = octave_value("Table data is not editable at this location.");
-        sendCellEditCallback(row,
-          col,
-          octave_value(),
-          octave_value(),
-          edit_data,
-          error);
+        octave_value error =
+          octave_value ("Table data is not editable at this location.");
+        sendCellEditCallback (row,
+                              col,
+                              octave_value (),
+                              octave_value (),
+                              edit_data,
+                              error);
       }
 
-    if (!ok)
+    if (! ok)
       {
         comboBox->setCurrentIndex (-1);
         comboBox->setEditable (true);
         comboBox->setEditText (comboBox->property ("original_value").toString ());
         comboBox->lineEdit ()->setReadOnly (true);
       }
-      m_blockUpdates = false;
+    m_blockUpdates = false;
   }
 
   void
-  Table::checkBoxClicked (int row, int col, QCheckBox* checkBox)
+  Table::checkBoxClicked (int row, int col, QCheckBox *checkBox)
   {
     if (m_blockUpdates)
       return;
     m_blockUpdates = true;
     gh_manager::auto_lock lock;
 
-    bool new_value = !checkBox->isChecked ();
+    bool new_value = ! checkBox->isChecked ();
 
-    octave_value data = octave_value(m_curData);
+    octave_value data = octave_value (m_curData);
     if (data.islogical ())
       {
         // EASY WE JUST CONVERT
         boolMatrix matrix = data.bool_matrix_value ();
         if (row < matrix.rows () && col < matrix.columns ())
           {
-            bool old_value = matrix (row, col);
-            matrix (row, col) = new_value;
-            checkBox->setChecked(new_value);
+            bool old_value = matrix(row, col);
+            matrix(row, col) = new_value;
+            checkBox->setChecked (new_value);
             if (new_value != old_value)
               {
-                m_curData = octave_value(matrix);
-                gh_manager::post_set (m_handle, "data", octave_value(matrix), false);
+                m_curData = octave_value (matrix);
+                gh_manager::post_set (m_handle, "data",
+                                      octave_value (matrix), false);
               }
 
-            sendCellEditCallback(row,
-              col,
-              octave_value(old_value),
-              octave_value(new_value),
-              octave_value(new_value),
-              octave_value(""));
+            sendCellEditCallback (row, col,
+                                  octave_value (old_value),
+                                  octave_value (new_value),
+                                  octave_value (new_value),
+                                  octave_value (""));
 
           }
         else
           {
-            sendCellEditCallback(row,
-              col,
-              octave_value(),
-              octave_value(),
-              octave_value(new_value),
-              octave_value("Table data is not editable at this location."));
+            sendCellEditCallback (row,
+                                  col,
+                                  octave_value (),
+                                  octave_value (),
+                                  octave_value (new_value),
+                                  octave_value ("Table data is not editable at this location."));
           }
       }
     else if (data.iscell ())
       {
         Cell cell = data.cell_value ();
         if (row < cell.rows () && col < cell.columns ())
           {
-              if (cell (row, col).islogical ())
-                {
-                  bool old_value = cell (row, col).bool_value ();
-                  cell (row, col) = octave_value(new_value);
-                  checkBox->setChecked(new_value);
-                  if (new_value != old_value)
-                    {
-                      m_curData = octave_value(cell);
-                      gh_manager::post_set (m_handle, "data", octave_value (cell), false);
-                    }
+            if (cell(row, col).islogical ())
+              {
+                bool old_value = cell(row, col).bool_value ();
+                cell(row, col) = octave_value (new_value);
+                checkBox->setChecked (new_value);
+                if (new_value != old_value)
+                  {
+                    m_curData = octave_value (cell);
+                    gh_manager::post_set (m_handle, "data", octave_value (cell), false);
+                  }
 
-                  sendCellEditCallback(row,
-                    col,
-                    octave_value(old_value),
-                    octave_value(new_value),
-                    octave_value(new_value),
-                    octave_value(""));
-                }
-              else
-                {
-                  sendCellEditCallback(row,
-                    col,
-                    cell (row, col),
-                    octave_value(),
-                    octave_value(new_value),
-                    octave_value("Cannot convert logical edit to other type."));
-                }
+                sendCellEditCallback (row,
+                                      col,
+                                      octave_value (old_value),
+                                      octave_value (new_value),
+                                      octave_value (new_value),
+                                      octave_value (""));
+              }
+            else
+              {
+                sendCellEditCallback (row,
+                                      col,
+                                      cell(row, col),
+                                      octave_value (),
+                                      octave_value (new_value),
+                                      octave_value ("Cannot convert logical edit to other type."));
+              }
           }
         else
           {
-            sendCellEditCallback(row,
-              col,
-              cell (row, col),
-              octave_value(),
-              octave_value(new_value),
-              octave_value("Table data is not editable at this location."));
+            sendCellEditCallback (row,
+                                  col,
+                                  cell(row, col),
+                                  octave_value (),
+                                  octave_value (new_value),
+                                  octave_value ("Table data is not editable at this location."));
           }
       }
     else if (data.is_matrix_type ())
       {
         if (row < data.rows () && col < data.columns ())
           {
-            sendCellEditCallback(row,
-              col,
-              data.fast_elem_extract (row + col * data.rows()),
-              octave_value(),
-              octave_value(new_value),
-              octave_value("Cannot convert logical edit to other type."));
+            sendCellEditCallback (row,
+                                  col,
+                                  data.fast_elem_extract (row + col * data.rows ()),
+                                  octave_value (),
+                                  octave_value (new_value),
+                                  octave_value ("Cannot convert logical edit to other type."));
           }
         else
           {
-            sendCellEditCallback(row,
-              col,
-              data.fast_elem_extract (row + col * data.rows()),
-              octave_value(),
-              octave_value(new_value),
-              octave_value("Table data is not editable at this location."));
+            sendCellEditCallback (row,
+                                  col,
+                                  data.fast_elem_extract (row + col * data.rows ()),
+                                  octave_value (),
+                                  octave_value (new_value),
+                                  octave_value ("Table data is not editable at this location."));
           }
       }
-      m_blockUpdates = false;
+    m_blockUpdates = false;
   }
 
 
   void
-  Table::itemChanged (QTableWidgetItem* item)
+  Table::itemChanged (QTableWidgetItem *item)
   {
     if (m_blockUpdates)
       return;
     m_blockUpdates = true;
     gh_manager::auto_lock lock;
-    octave_value data = octave_value(m_curData);
+    octave_value data = octave_value (m_curData);
 
     int row = item->row ();
     int col = item->column ();
-    octave_value edit_data = octave_value (Utils::toStdString(item->text ()));
+    octave_value edit_data = octave_value (Utils::toStdString (item->text ()));
     octave_value new_value;
     octave_value old_value;
     octave_value new_data;
 
     if (row < data.rows () && col < data.columns ())
       {
         if (data.iscell ())
           {
@@ -805,58 +811,59 @@ namespace QtHandles
             old_value = data.fast_elem_extract (row + col * data.rows ());
           }
 
         // Now we need to coerce the new_value in to the type of the old_value
         if (old_value.is_string ())
           new_value = edit_data;
         else
           {
-            new_value = attempt_type_conversion(edit_data, old_value);
-            std::pair <Qt::AlignmentFlag, QString> flag_and_text =
-              qStringValueFor(new_value, columnformat (col));
+            new_value = attempt_type_conversion (edit_data, old_value);
+            std::pair<Qt::AlignmentFlag, QString> flag_and_text =
+              qStringValueFor (new_value, columnformat (col));
             item->setTextAlignment (flag_and_text.first);
             item->setText (flag_and_text.second);
           }
 
         if (data.iscell ())
           {
-            Cell cell = data.cell_value();
-            cell (row, col) = new_value;
+            Cell cell = data.cell_value ();
+            cell(row, col) = new_value;
             new_data = octave_value (cell);
           }
         else
           {
             data.fast_elem_insert (row + col * data.rows (), new_value);
             new_data = data;
           }
-          m_curData = octave_value(new_data);
-          gh_manager::post_set (m_handle, "data", new_data, false);
+        m_curData = octave_value (new_data);
+        gh_manager::post_set (m_handle, "data", new_data, false);
 
-          sendCellEditCallback(row,
-            col,
-            octave_value(old_value),
-            octave_value(new_value),
-            octave_value(new_value),
-            octave_value(""));
+        sendCellEditCallback (row,
+                              col,
+                              octave_value (old_value),
+                              octave_value (new_value),
+                              octave_value (new_value),
+                              octave_value (""));
       }
     else
       {
         item->setText ("");
 
-        octave_value error = octave_value("Table data is not editable at this location.");
-        sendCellEditCallback(row,
-          col,
-          octave_value(),
-          octave_value(),
-          edit_data,
-          error);
+        octave_value error =
+          octave_value ("Table data is not editable at this location.");
+        sendCellEditCallback (row,
+                              col,
+                              octave_value (),
+                              octave_value (),
+                              edit_data,
+                              error);
       }
 
-      m_blockUpdates = false;
+    m_blockUpdates = false;
   }
 
   void
   Table::update (int pId)
   {
     uitable::properties& tp = properties<uitable> ();
 
     switch (pId)
@@ -874,70 +881,72 @@ namespace QtHandles
       case uitable::properties::ID_COLUMNWIDTH:
         updateColumnwidth ();
         break;
 
       case uitable::properties::ID_COLUMNEDITABLE:
       case uitable::properties::ID_COLUMNFORMAT:
       case uitable::properties::ID_DATA:
         m_blockUpdates = true;
-        m_curData = octave_value(tp.get_data ());
+        m_curData = octave_value (tp.get_data ());
         updateData ();
         updateRowname ();
         updateColumnname ();
         updateColumnwidth ();
-        updateEnable();
+        updateEnable ();
         m_blockUpdates = false;
         break;
 
       case uitable::properties::ID_ENABLE:
-        updateEnable();
+        updateEnable ();
         break;
 
       case uitable::properties::ID_KEYPRESSFCN:
         m_keyPressHandlerDefined = ! tp.get_keypressfcn ().isempty ();
         break;
 
       case uitable::properties::ID_KEYRELEASEFCN:
         m_keyReleaseHandlerDefined = ! tp.get_keyreleasefcn ().isempty ();
         break;
 
-        case uitable::properties::ID_FONTNAME:
-        case uitable::properties::ID_FONTSIZE:
-        case uitable::properties::ID_FONTWEIGHT:
-        case uitable::properties::ID_FONTANGLE:
-          if (m_tableWidget)
-            {
-              m_tableWidget->setFont (Utils::computeFont<uitable> (tp));
-              for (int row = 0; row < m_tableWidget->rowCount (); row++)
-                {
-                  m_tableWidget->setRowHeight (row, AUTO_HEIGHT);
-                }
-            }
-          break;
+      case uitable::properties::ID_FONTNAME:
+      case uitable::properties::ID_FONTSIZE:
+      case uitable::properties::ID_FONTWEIGHT:
+      case uitable::properties::ID_FONTANGLE:
+        if (m_tableWidget)
+          {
+            m_tableWidget->setFont (Utils::computeFont<uitable> (tp));
+            for (int row = 0; row < m_tableWidget->rowCount (); row++)
+              {
+                m_tableWidget->setRowHeight (row, AUTO_HEIGHT);
+              }
+          }
+        break;
 
       case uitable::properties::ID_POSITION:
-          {
-            Matrix bb = tp.get_boundingbox (false);
-            m_tableWidget->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
-                                        octave::math::round (bb(2)), octave::math::round (bb(3)));
-            updateExtent();
-          }
+        {
+          Matrix bb = tp.get_boundingbox (false);
+          m_tableWidget->setGeometry (octave::math::round (bb(0)),
+                                      octave::math::round (bb(1)),
+                                      octave::math::round (bb(2)),
+                                      octave::math::round (bb(3)));
+          updateExtent ();
+        }
         break;
 
       case uitable::properties::ID_REARRANGEABLECOLUMNS:
         updateRearrangeableColumns ();
         break;
 
       case uitable::properties::ID_ROWNAME:
         updateRowname ();
         break;
 
       case uitable::properties::ID_ROWSTRIPING:
-        updatePalette();
+        updatePalette ();
         break;
 
       case uitable::properties::ID_TOOLTIPSTRING:
         m_tableWidget->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
         break;
 
       case base_properties::ID_VISIBLE:
         m_tableWidget->setVisible (tp.is_visible ());
@@ -957,113 +966,115 @@ namespace QtHandles
     // Reset the Column Count
     m_tableWidget->setColumnCount (tp.get_data ().columns ());
 
     octave_value columnname = tp.get_columnname ();
     QStringList l;
     bool visible = true;
 
     if (columnname.is_string () && columnname.string_value (false) == "numbered")
-        for (int i = 0; i < m_tableWidget->columnCount (); i++)
-          l << QString::number(i + 1);
+      for (int i = 0; i < m_tableWidget->columnCount (); i++)
+        l << QString::number (i + 1);
     else if (columnname.is_string ())
       {
         if (m_tableWidget->columnCount () > 0)
-          l << Utils::fromStdString(columnname.string_value ());
+          l << Utils::fromStdString (columnname.string_value ());
         for (int i = 1; i < m_tableWidget->columnCount (); i++)
           l << "";
       }
     else if (columnname.isempty ())
       {
         for (int i = 0; i < m_tableWidget->columnCount (); i++)
           l << "";
 
         visible = false;
       }
     else if (columnname.iscell ())
       {
-        octave_idx_type n = columnname.numel();
-        Cell cell_value = columnname.cell_value();
+        octave_idx_type n = columnname.numel ();
+        Cell cell_value = columnname.cell_value ();
 
         for (octave_idx_type i = 0; i < n; i++)
           {
             octave_value v = cell_value (i);
             if (v.is_string ())
-              l << Utils::fromStdString(v.string_value (true));
+              l << Utils::fromStdString (v.string_value (true));
             else if (v.is_matrix_type ())
               {
                 Matrix data = v.matrix_value ();
 
                 /* Now Matlab does something very strange here:
-                 * If data is a row or column matrix, then each datapoint is added
-                 * Otherwise nothing is set.
+                 * If data is a row or column matrix,
+                 * then each datapoint is added.
+                 * Otherwise, nothing is set.
                  */
                 if (data.rows () > 1 && data.cols () > 1)
                   l << "";
                 else
                   for (octave_idx_type j = 0; j < data.numel (); j++)
-                    l << QString::number(data (j));
+                    l << QString::number (data(j));
               }
             else if (v.isnumeric ())
-              l << QString::number(v.double_value ());
+              l << QString::number (v.double_value ());
             else
-              l << QString::number(v.double_value ());
+              l << QString::number (v.double_value ());
           }
       }
     else if (columnname.is_matrix_type ())
       {
         octave_idx_type n = columnname.numel ();
         Matrix matrix_value = columnname.matrix_value ();
 
         for (octave_idx_type i = 0; i < n; i++)
-          l << QString::number(matrix_value (i));
+          l << QString::number (matrix_value(i));
       }
     else
       {
         for (int i = 0; i < m_tableWidget->columnCount (); i++)
           l << "";
         visible = false;
       }
 
-    l.replaceInStrings("|", "\n");
+    l.replaceInStrings ("|", "\n");
 
     // Now add the columns as required
-    if (m_tableWidget->columnCount () < l.length())
+    if (m_tableWidget->columnCount () < l.length ())
       {
         int oldColumnCount = m_tableWidget->columnCount ();
-        m_tableWidget->setColumnCount (l.length());
+        m_tableWidget->setColumnCount (l.length ());
         for (int col = oldColumnCount; col < l.length (); col++)
           {
             std::string format = columnformat (col);
             bool enabled = columneditable (col);
 
             for (int row = 0; row < m_tableWidget->rowCount (); row++)
               updateData (row, col, octave_value (""), format, enabled);
           }
       }
 
-      m_tableWidget->setHorizontalHeaderLabels (l);
-      m_tableWidget->horizontalHeader ()->setVisible (visible);
+    m_tableWidget->setHorizontalHeaderLabels (l);
+    m_tableWidget->horizontalHeader ()->setVisible (visible);
   }
 
   void
   Table::updateColumnwidth (void)
   {
     uitable::properties& tp = properties<uitable> ();
 
     octave_value columnwidth = tp.get_columnwidth ();
     if (columnwidth.isempty () ||
-      (columnwidth.is_string () && columnwidth.string_value (false) == "auto"))
+        (columnwidth.is_string () && columnwidth.string_value (false) == "auto"))
       for (int i = 0; i < m_tableWidget->columnCount (); i++)
         m_tableWidget->setColumnWidth (i, AUTO_WIDTH);
-    else if (columnwidth.is_string () && columnwidth.string_value (false) == "preferred")
+    else if (columnwidth.is_string ()
+             && columnwidth.string_value (false) == "preferred")
       for (int i = 0; i < m_tableWidget->columnCount (); i++)
         {
           int column_size =
-            (qobject_cast<QAbstractItemView*> (m_tableWidget))->sizeHintForColumn (i);
+            (qobject_cast<QAbstractItemView *> (m_tableWidget))->sizeHintForColumn (i);
           int header_size = m_tableWidget->horizontalHeader ()->sectionSizeHint (i);
 
           if (column_size > header_size)
             header_size = column_size;
           m_tableWidget->setColumnWidth (i, header_size);
         }
     else if (columnwidth.iscell ())
       {
@@ -1072,87 +1083,87 @@ namespace QtHandles
         for (; i < m_tableWidget->columnCount () && i < cell_value.numel (); i++)
           {
             octave_value v = cell_value (i);
             if (v.is_string ()  && v.string_value (false) == "auto")
               m_tableWidget->setColumnWidth (i, AUTO_WIDTH);
             else if (v.is_string () && v.string_value (false) == "preferred")
               {
                 int column_size =
-                  (qobject_cast<QAbstractItemView*> (m_tableWidget))->sizeHintForColumn (i);
+                  (qobject_cast<QAbstractItemView *> (m_tableWidget))->sizeHintForColumn (i);
                 int header_size = m_tableWidget->horizontalHeader ()->sectionSizeHint (i);
 
                 if (column_size > header_size)
                   header_size = column_size;
                 m_tableWidget->setColumnWidth (i, header_size);
               }
             else
               {
-                int w = int (v.double_value());
+                int w = int (v.double_value ());
                 m_tableWidget->setColumnWidth (i, w);
               }
           }
-        for (;i < m_tableWidget->columnCount (); i++)
+        for (; i < m_tableWidget->columnCount (); i++)
           {
             int column_size =
-              (qobject_cast<QAbstractItemView*> (m_tableWidget))->sizeHintForColumn (i);
+              (qobject_cast<QAbstractItemView *> (m_tableWidget))->sizeHintForColumn (i);
             int header_size = m_tableWidget->horizontalHeader ()->sectionSizeHint (i);
 
             if (column_size > header_size)
               header_size = column_size;
             m_tableWidget->setColumnWidth (i, header_size);
           }
       }
     else if (columnwidth.is_matrix_type ())
       {
         Matrix matrix_value = columnwidth.matrix_value ();
         int i = 0;
         for (; i < m_tableWidget->columnCount () && i < matrix_value.numel (); i++)
           {
-            octave_value v = matrix_value (i);
-            int w = int (v.double_value());
+            octave_value v = matrix_value(i);
+            int w = int (v.double_value ());
             m_tableWidget->setColumnWidth (i, w);
           }
-        for (;i < m_tableWidget->columnCount (); i++)
+        for (; i < m_tableWidget->columnCount (); i++)
           m_tableWidget->setColumnWidth (i, AUTO_WIDTH);
       }
   }
 
   bool inline
   Table::columneditable (int col)
   {
     uitable::properties& tp = properties<uitable> ();
     boolNDArray columneditable = tp.get_columneditable ().bool_array_value ();
     bool editable = false;
 
-    if (!columneditable.isempty () && col < columneditable.numel ())
+    if (! columneditable.isempty () && col < columneditable.numel ())
       editable = columneditable.xelem (col);
-    else if (!columneditable.isempty () && columneditable.numel () == 1)
+    else if (! columneditable.isempty () && columneditable.numel () == 1)
       editable = columneditable.xelem (0);
 
     return editable;
   }
 
   std::string inline
   Table::columnformat (int col)
   {
     uitable::properties& tp = properties<uitable> ();
     std::string format = "";
     octave_value ov_columnformat = tp.get_columnformat ();
 
     if (ov_columnformat.iscell ())
       {
         Cell columnformat = ov_columnformat.cell_value ();
-        if (!columnformat.isempty () && col < columnformat.numel ())
+        if (! columnformat.isempty () && col < columnformat.numel ())
           {
             octave_value format_value = columnformat.xelem (col);
 
-            if (!format_value.isempty () && format_value.is_string())
+            if (! format_value.isempty () && format_value.is_string ())
               format = format_value.string_value ();
-            else if (!format_value.isempty () && format_value.iscell ())
+            else if (! format_value.isempty () && format_value.iscell ())
               format = "popup";
           }
       }
     else if (ov_columnformat.is_string ())
       {
         format = ov_columnformat.string_value ();
       }
     return format;
@@ -1162,69 +1173,69 @@ namespace QtHandles
   Table::updateDataColumn (int col)
   {
     octave_value data = properties<uitable> ().get_data ();
 
     std::string format = columnformat (col);
     bool is_editable = columneditable (col);
 
     for (octave_idx_type row = 0; row < data.rows (); row++)
-      updateData(row,
-        col,
-        data.iscell ()
-          ? data.cell_value () (row, col)
-          : data.fast_elem_extract (row + col * data.rows ()),
-        format,
-        is_editable);
+      updateData (row,
+                  col,
+                  data.iscell ()
+                  ? data.cell_value () (row, col)
+                  : data.fast_elem_extract (row + col * data.rows ()),
+                  format,
+                  is_editable);
   }
 
   void inline
   Table::updateData (int row, int col)
   {
     octave_value data = properties<uitable> ().get_data ();
     updateData (row,
-      col,
-      data.iscell ()
-        ? data.cell_value () (row, col)
-        : data.fast_elem_extract (row + col * data.rows ()),
-      columnformat (col),
-      columneditable (col));
+                col,
+                data.iscell ()
+                ? data.cell_value () (row, col)
+                : data.fast_elem_extract (row + col * data.rows ()),
+                columnformat (col),
+                columneditable (col));
   }
 
   void inline
   Table::updateData (int row, int col, octave_value value,
                      std::string format = "", bool enabled = false)
   {
     if (format == "logical" || (format == "" && value.islogical ()))
       {
         if (m_tableWidget->item (row, col))
           delete m_tableWidget->item (row, col);
 
-        m_tableWidget->setCellWidget (row, col, checkBoxForLogical(value, enabled));
-        m_tableWidget->cellWidget (row, col)->setProperty ("row", QVariant(row));
-        m_tableWidget->cellWidget (row, col)->setProperty ("col", QVariant(col));
+        m_tableWidget->setCellWidget (row, col, checkBoxForLogical (value, enabled));
+        m_tableWidget->cellWidget (row, col)->setProperty ("row", QVariant (row));
+        m_tableWidget->cellWidget (row, col)->setProperty ("col", QVariant (col));
       }
     else if (format == "popup" && enabled)
       {
         if (m_tableWidget->item (row, col))
           delete m_tableWidget->item (row, col);
 
-        QString string_value = qStringValueFor(value, format).second;
+        QString string_value = qStringValueFor (value, format).second;
         uitable::properties& tp = properties<uitable> ();
         octave_value format_value = tp.get_columnformat ().cell_value ().xelem (col);
 
-        QComboBox* comboBox = new QComboBox ();
-        comboBox->setProperty("row", QVariant (row));
-        comboBox->setProperty("col", QVariant (col));
+        QComboBox *comboBox = new QComboBox ();
+        comboBox->setProperty ("row", QVariant (row));
+        comboBox->setProperty ("col", QVariant (col));
 
         int index = -1;
         for (int k = 0; k < format_value.numel (); k++)
           {
-            QString popup_item = Utils::fromStdString(
-              format_value.fast_elem_extract (k).string_value ());
+            QString popup_item = Utils::fromStdString (
+                                   format_value.fast_elem_extract (k).string_value ());
 
             comboBox->addItem (popup_item);
 
             if (popup_item == string_value)
               index = k;
           }
         comboBox->setCurrentIndex (index);
 
@@ -1233,34 +1244,34 @@ namespace QtHandles
             comboBox->setEditable (true);
             comboBox->setEditText (string_value);
             comboBox->lineEdit ()->setReadOnly (true);
           }
 
         comboBox->setProperty ("original_value", QVariant (string_value));
 
         comboBox->installEventFilter (this);
-        m_tableWidget->setCellWidget(row, col, comboBox);
-        connect(comboBox, SIGNAL(currentIndexChanged(const QString&)),
-                this, SLOT(comboBoxCurrentIndexChanged(const QString&)));
+        m_tableWidget->setCellWidget (row, col, comboBox);
+        connect (comboBox, SIGNAL(currentIndexChanged (const QString&)),
+                 this, SLOT(comboBoxCurrentIndexChanged (const QString&)));
       }
     else
       {
         if (m_tableWidget->cellWidget (row, col))
           delete m_tableWidget->cellWidget (row, col);
-        m_tableWidget->setItem (row, col, itemFor(value, format, enabled));
+        m_tableWidget->setItem (row, col, itemFor (value, format, enabled));
       }
   }
 
   void
   Table::updateData ()
   {
     uitable::properties& tp = properties<uitable> ();
 
-    octave_value data = tp.get_data();
+    octave_value data = tp.get_data ();
 
     if (data.iscell () || data.is_matrix_type ())
       {
         m_tableWidget->setRowCount (data.rows ());
         m_tableWidget->setColumnCount (data.columns ());
 
         for (octave_idx_type col = 0; col < data.columns (); col++)
           updateDataColumn (col);
@@ -1269,70 +1280,70 @@ namespace QtHandles
     for (octave_idx_type row = 0; row < m_tableWidget->rowCount (); row++)
       m_tableWidget->setRowHeight (row, AUTO_HEIGHT);
   }
 
   void
   Table::updateEnable (void)
   {
     uitable::properties& tp = properties<uitable> ();
-    m_tableWidget->setEnabled (!tp.enable_is ("off"));
+    bool enabled = tp.is_enable ();
+    m_tableWidget->setEnabled (! enabled);
 
-    bool enabled = tp.enable_is ("on");
     bool rearrangeableColumns = tp.is_rearrangeablecolumns ();
 
     // Set selection mode
     m_tableWidget->setSelectionMode (enabled
-      ? QAbstractItemView::ExtendedSelection
-      : QAbstractItemView::NoSelection);
+                                     ? QAbstractItemView::ExtendedSelection
+                                     : QAbstractItemView::NoSelection);
 
     // Set rearrangeablecolumns
     #if defined (HAVE_QT4)
       m_tableWidget->horizontalHeader ()->setMovable (enabled && rearrangeableColumns);
     #elif defined (HAVE_QT5)
       m_tableWidget->horizontalHeader ()->setSectionsMovable (enabled && rearrangeableColumns);
     #endif
     m_tableWidget->horizontalHeader ()->setDragEnabled (enabled && rearrangeableColumns);
     m_tableWidget->horizontalHeader ()->setDragDropMode (QAbstractItemView::InternalMove);
 
     // Turn off column editable
     for (int col = 0; col < m_tableWidget->columnCount (); col++)
       {
         bool editable = columneditable (col);
 
         for (int row = 0; row < m_tableWidget->rowCount (); row++)
-          if (QTableWidgetItem* item = m_tableWidget->item (row, col))
+          if (QTableWidgetItem *item = m_tableWidget->item (row, col))
             {
               Qt::ItemFlags flags = item->flags ();
               if (enabled && editable)
                 item->setFlags (flags | Qt::ItemIsEditable);
               else
                 item->setFlags (flags & ~Qt::ItemIsEditable);
             }
-          else if (QWidget* widget = m_tableWidget->cellWidget (row, col))
+          else if (QWidget *widget = m_tableWidget->cellWidget (row, col))
             {
-              QCheckBox* checkBox = NULL;
-              if (widget && !widget->children ().isEmpty ())
+              QCheckBox *checkBox = nullptr;
+              if (widget && ! widget->children ().isEmpty ())
                 {
-                  QHBoxLayout* layout = qobject_cast<QHBoxLayout*> (
-                    widget->children ().first ());
+                  QHBoxLayout *layout = qobject_cast<QHBoxLayout *> (
+                                          widget->children ().first ());
                   if (layout && layout->count () > 0)
                     {
-                      checkBox = qobject_cast<QCheckBox*> (
-                        layout->itemAt (0)-> widget ());
+                      checkBox = qobject_cast<QCheckBox *> (
+                                   layout->itemAt (0)-> widget ());
                     }
                 }
               if (checkBox)
                 {
                   widget->setProperty ("Enabled", QVariant (enabled & editable));
                 }
               else
                 {
-                  widget->setAttribute(Qt::WA_TransparentForMouseEvents, !(editable & enabled));
-                  widget->setFocusPolicy(Qt::NoFocus);
+                  widget->setAttribute (Qt::WA_TransparentForMouseEvents, !(editable & enabled));
+                  widget->setFocusPolicy (Qt::NoFocus);
                 }
             }
       }
   }
 
   void
   Table::updateExtent (void)
   {
@@ -1350,19 +1361,19 @@ namespace QtHandles
   Table::updatePalette (void)
   {
     uitable::properties& tp = properties<uitable> ();
 
     QPalette p = m_tableWidget->palette ();
     p.setColor (QPalette::Text,
                 Utils::fromRgb (tp.get_foregroundcolor_rgb ()));
     p.setColor (QPalette::Base,
-              Utils::fromRgb (tp.get_backgroundcolor_rgb ()));
+                Utils::fromRgb (tp.get_backgroundcolor_rgb ()));
     p.setColor (QPalette::AlternateBase,
-              Utils::fromRgb (tp.get_alternatebackgroundcolor_rgb ()));
+                Utils::fromRgb (tp.get_alternatebackgroundcolor_rgb ()));
     m_tableWidget->setPalette (p);
     m_tableWidget->setAlternatingRowColors (tp.is_rowstriping ());
     // FIXME: Handle multiple alternating background colors
   }
 
   void
   Table::updateRowname (void)
   {
@@ -1372,80 +1383,81 @@ namespace QtHandles
     m_tableWidget->setRowCount (tp.get_data ().rows ());
 
     octave_value rowname = tp.get_rowname ();
     QStringList l;
     bool visible = true;
 
     if (rowname.is_string () && rowname.string_value (false) == "numbered")
       for (int i = 0; i < m_tableWidget->rowCount (); i++)
-        l << QString::number(i + 1);
+        l << QString::number (i + 1);
     else if (rowname.is_string ())
       {
         if (m_tableWidget->rowCount () > 0)
-          l << Utils::fromStdString(rowname.string_value ());
+          l << Utils::fromStdString (rowname.string_value ());
         for (int i = 1; i < m_tableWidget->rowCount (); i++)
           l << "";
       }
     else if (rowname.isempty ())
       {
         for (int i = 0; i < m_tableWidget->rowCount (); i++)
           l << "";
         visible = false;
       }
     else if (rowname.iscell ())
       {
-        octave_idx_type n = rowname.numel();
-        Cell cell_value = rowname.cell_value();
+        octave_idx_type n = rowname.numel ();
+        Cell cell_value = rowname.cell_value ();
 
         for (octave_idx_type i = 0; i < n; i++)
           {
             octave_value v = cell_value (i);
             if (v.is_string ())
-              l << Utils::fromStdString(v.string_value (true));
+              l << Utils::fromStdString (v.string_value (true));
             else if (v.is_matrix_type ())
               {
                 Matrix data = v.matrix_value ();
 
                 /* Now Matlab does something very strange here:
-                 * If data is a row or column matrix, then each datapoint is added
-                 * Otherwise nothing is set.
+                 * If data is a row or column matrix,
+                 * then each datapoint is added.
+                 * Otherwise, nothing is set.
                  */
                 if (data.rows () > 1 && data.cols () > 1)
                   l << "";
                 else
                   for (octave_idx_type j = 0; j < data.numel (); j++)
-                    l << QString::number(data (j));
+                    l << QString::number (data(j));
               }
             else if (v.isnumeric ())
-              l << QString::number(v.double_value (true));
+              l << QString::number (v.double_value (true));
             else
-              l << QString::number(v.double_value (true));
+              l << QString::number (v.double_value (true));
           }
       }
     else if (rowname.is_matrix_type ())
       {
-        octave_idx_type n = rowname.numel();
-        Matrix matrix_value = rowname.matrix_value();
+        octave_idx_type n = rowname.numel ();
+        Matrix matrix_value = rowname.matrix_value ();
 
         for (octave_idx_type i = 0; i < n; i++)
-          l << QString::number(matrix_value (i));
+          l << QString::number (matrix_value(i));
       }
     else
       {
         for (int i = 0; i < m_tableWidget->columnCount (); i++)
           l << "";
         visible = false;
       }
 
     // Add dummy rows as required
-    if (m_tableWidget->rowCount () < l.length())
+    if (m_tableWidget->rowCount () < l.length ())
       {
         int oldRowCount = m_tableWidget->rowCount ();
-        m_tableWidget->setRowCount (l.length());
+        m_tableWidget->setRowCount (l.length ());
 
         for (int col = 0; col < m_tableWidget->columnCount (); col++)
           {
             std::string format = columnformat (col);
             bool enabled = columneditable (col);
 
             for (int row = oldRowCount; row < l.length (); row++)
               {
@@ -1461,32 +1473,32 @@ namespace QtHandles
   }
 
   void
   Table::updateRearrangeableColumns (void)
   {
     uitable::properties& tp = properties<uitable> ();
 
     bool rearrangeableColumns = tp.is_rearrangeablecolumns ();
-    bool enabled = tp.enable_is ("on");
+    bool enabled = tp.is_enable ();
 
   #if defined (HAVE_QT4)
     m_tableWidget->horizontalHeader ()->setMovable (enabled && rearrangeableColumns);
   #elif defined (HAVE_QT5)
     m_tableWidget->horizontalHeader ()->setSectionsMovable (enabled && rearrangeableColumns);
   #endif
     m_tableWidget->horizontalHeader ()->setDragEnabled (enabled && rearrangeableColumns);
     m_tableWidget->horizontalHeader ()->setDragDropMode (QAbstractItemView::InternalMove);
   }
 
   bool
-  Table::eventFilter (QObject* watched, QEvent* xevent)
+  Table::eventFilter (QObject *watched, QEvent *xevent)
   {
     //uitable::properties& tp = properties<uitable> ();
-    if (qobject_cast<QTableWidget*> (watched))
+    if (qobject_cast<QTableWidget *> (watched))
       {
         switch (xevent->type ())
           {
           case QEvent::Resize:
             {
               gh_manager::auto_lock lock;
               graphics_object go = object ();
               if (go.valid_object ())
@@ -1497,187 +1509,188 @@ namespace QtHandles
                     m_tableWidget->setFont (Utils::computeFont<uitable> (tp));
                 }
             }
             break;
 
           case QEvent::MouseButtonPress:
             {
               gh_manager::auto_lock lock;
-              QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+              QMouseEvent *m = dynamic_cast<QMouseEvent *> (xevent);
               graphics_object go = object ();
               const uitable::properties& tp =
                 Utils::properties<uitable> (go);
               graphics_object fig = go.get_ancestor ("figure");
 
-              if (m->button () != Qt::LeftButton || !tp.enable_is ("on"))
+              if (m->button () != Qt::LeftButton || ! tp.is_enable ())
                 {
                   gh_manager::post_set (fig.get_handle (), "selectiontype",
                                         Utils::figureSelectionType (m), false);
                   gh_manager::post_set (fig.get_handle (), "currentpoint",
                                         Utils::figureCurrentPoint (fig, m),
                                         false);
                   gh_manager::post_callback (fig.get_handle (),
                                              "windowbuttondownfcn");
                   gh_manager::post_callback (m_handle, "buttondownfcn");
 
                   if (m->button () == Qt::RightButton)
                     ContextMenu::executeAt (properties (), m->globalPos ());
                 }
               else
                 {
                   gh_manager::post_set (fig.get_handle (), "selectiontype",
-                                       octave_value ("normal"), false);
+                                        octave_value ("normal"), false);
                 }
             }
             break;
 
           case QEvent::KeyPress:
             {
-              QKeyEvent* k = dynamic_cast<QKeyEvent*> (xevent);
+              QKeyEvent *k = dynamic_cast<QKeyEvent *> (xevent);
               if (m_keyPressHandlerDefined)
                 {
                   gh_manager::auto_lock lock;
 
                   octave_scalar_map keyData = Utils::makeKeyEventStruct (k);
                   graphics_object fig = object ().get_ancestor ("figure");
 
                   gh_manager::post_set (fig.get_handle (), "currentcharacter",
                                         keyData.getfield ("Character"), false);
                   gh_manager::post_callback (m_handle, "keypressfcn", keyData);
                 }
               int row = m_tableWidget->currentRow ();
               int col = m_tableWidget->currentColumn ();
-              switch (k->key())
+              switch (k->key ())
                 {
                 case Qt::Key_Space:
                   {
-                    QCheckBox* checkBox = NULL;
-                    QWidget* widget = qobject_cast<QWidget*> (
-                      m_tableWidget->cellWidget (row, col));
-                    if (widget && !widget->children ().isEmpty ())
+                    QCheckBox *checkBox = nullptr;
+                    QWidget *widget = qobject_cast<QWidget *> (
+                                        m_tableWidget->cellWidget (row, col));
+                    if (widget && ! widget->children ().isEmpty ())
                       {
-                        QHBoxLayout* layout = qobject_cast<QHBoxLayout*> (
-                          widget->children ().first ());
+                        QHBoxLayout *layout = qobject_cast<QHBoxLayout *> (
+                                                widget->children ().first ());
                         if (layout && layout->count () > 0)
                           {
-                            checkBox = qobject_cast<QCheckBox*> (
-                              layout->itemAt (0)-> widget ());
+                            checkBox = qobject_cast<QCheckBox *> (
+                                         layout->itemAt (0)-> widget ());
                           }
                       }
-                    if (checkBox && checkBox->property ("Enabled").toBool())
-                      checkBoxClicked(row, col, checkBox);
-  
-                    QComboBox* comboBox = qobject_cast<QComboBox*> (
-                      m_tableWidget->cellWidget (row, col));
+                    if (checkBox && checkBox->property ("Enabled").toBool ())
+                      checkBoxClicked (row, col, checkBox);
+
+                    QComboBox *comboBox = qobject_cast<QComboBox *> (
+                                            m_tableWidget->cellWidget (row,
+                                                                       col));
                     if (comboBox)
                       comboBox->showPopup ();
                   }
                   break;
 
                 case Qt::Key_Return:
                 case Qt::Key_Enter:
                   {
-                    if (k->modifiers() == Qt::NoModifier)
+                    if (k->modifiers () == Qt::NoModifier)
                       {
-                        if (row + 1 < m_tableWidget->rowCount())
+                        if (row + 1 < m_tableWidget->rowCount ())
                           m_tableWidget->setCurrentCell (row + 1, col);
                         else
                           {
-                            if (col + 1 < m_tableWidget->columnCount())
+                            if (col + 1 < m_tableWidget->columnCount ())
                               m_tableWidget->setCurrentCell (0, col + 1);
                             else
                               m_tableWidget->setCurrentCell (0, 0);
                           }
                       }
-                    else if (k->modifiers() == Qt::ShiftModifier)
+                    else if (k->modifiers () == Qt::ShiftModifier)
                       {
                         if (row - 1 >= 0)
                           m_tableWidget->setCurrentCell (row - 1, col);
                         else
                           {
                             if (col - 1 >= 0)
                               m_tableWidget->setCurrentCell
-                                  (m_tableWidget->rowCount() - 1,
-                                   col - 1);
+                              (m_tableWidget->rowCount () - 1,
+                               col - 1);
                             else
                               m_tableWidget->setCurrentCell
-                                  (m_tableWidget->rowCount() - 1,
-                                   m_tableWidget->columnCount() - 1);
+                              (m_tableWidget->rowCount () - 1,
+                               m_tableWidget->columnCount () - 1);
                           }
                       }
                   }
                   break;
 
                 default:
                   break;
                 }
             }
             break;
 
           case QEvent::KeyRelease:
             {
               if (m_keyReleaseHandlerDefined)
                 {
                   gh_manager::auto_lock lock;
-                  QKeyEvent* k = dynamic_cast<QKeyEvent*> (xevent);
+                  QKeyEvent *k = dynamic_cast<QKeyEvent *> (xevent);
 
                   octave_scalar_map keyData = Utils::makeKeyEventStruct (k);
                   graphics_object fig = object ().get_ancestor ("figure");
 
                   gh_manager::post_set (fig.get_handle (), "currentcharacter",
                                         keyData.getfield ("Character"), false);
-                  gh_manager::post_callback (m_handle, "keyreleasefcn", keyData);
+                  gh_manager::post_callback (m_handle, "keyreleasefcn",
+                                             keyData);
                 }
             }
             break;
 
           default:
             break;
           }
       }
-    else if (qobject_cast<QComboBox*> (watched))
+    else if (qobject_cast<QComboBox *> (watched))
       {
         switch (xevent->type ())
           {
           case QEvent::MouseButtonPress:
             {
               gh_manager::auto_lock lock;
-              QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+              QMouseEvent *m = dynamic_cast<QMouseEvent *> (xevent);
               graphics_object go = object ();
-              const uitable::properties& tp =
-                Utils::properties<uitable> (go);
+              const uitable::properties& tp = Utils::properties<uitable> (go);
               graphics_object fig = go.get_ancestor ("figure");
 
-              if (m->button () != Qt::LeftButton || !tp.enable_is ("on"))
+              if (m->button () != Qt::LeftButton || ! tp.is_enable ())
                 {
                   gh_manager::post_set (fig.get_handle (), "selectiontype",
                                         Utils::figureSelectionType (m), false);
                   gh_manager::post_set (fig.get_handle (), "currentpoint",
                                         Utils::figureCurrentPoint (fig, m),
                                         false);
                   gh_manager::post_callback (fig.get_handle (),
                                              "windowbuttondownfcn");
                   gh_manager::post_callback (m_handle, "buttondownfcn");
 
                   if (m->button () == Qt::RightButton)
                     ContextMenu::executeAt (tp, m->globalPos ());
                 }
               else
                 {
                   gh_manager::post_set (fig.get_handle (), "selectiontype",
-                                       Utils::figureSelectionType (m), false);
+                                        Utils::figureSelectionType (m), false);
 
-                  QComboBox* comboBox_0 = qobject_cast<QComboBox*> (watched);
+                  QComboBox *comboBox_0 = qobject_cast<QComboBox *> (watched);
                   for (int row = 0; row < m_tableWidget->rowCount (); row++)
                     {
                       for (int col = 0; col < m_tableWidget->columnCount (); col++)
                         {
-                          QComboBox* comboBox_1 = qobject_cast<QComboBox*> (
-                            m_tableWidget->cellWidget (row, col));
+                          QComboBox *comboBox_1 = qobject_cast<QComboBox *> (
+                                                    m_tableWidget->cellWidget (row, col));
                           if (comboBox_0 == comboBox_1)
                             m_tableWidget->setCurrentCell (row, col);
                         }
                     }
                 }
             }
             break;
 
diff --git a/libgui/graphics/Table.h b/libgui/graphics/Table.h
--- a/libgui/graphics/Table.h
+++ b/libgui/graphics/Table.h
@@ -1,27 +1,27 @@
 /*
 
 Copyright (C) 2016 Andrew Thornton
 
 This file is part of Octave.
 
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
+Octave is free software: you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
 
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
+<https://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (octave_Table_h)
 #define octave_Table_h 1
 
 #include "Object.h"
 
@@ -69,23 +69,25 @@ namespace QtHandles
   private:
     Container* m_container;
     QTableWidget* m_tableWidget;
     octave_value m_curData;
     bool m_blockUpdates;
     bool m_keyPressHandlerDefined;
     bool m_keyReleaseHandlerDefined;
     QWidget * checkBoxForLogical(octave_value cal, bool enabled);
-    void updateData (int row, int col, octave_value value, std::string format, bool enabled);
+    void updateData (int row, int col, octave_value value, std::string format,
+                     bool enabled);
     void updateData (int row, int col);
     void updateDataColumn (int col);
     std::string columnformat (int column);
     bool columneditable (int column);
-    void sendCellEditCallback (int row, int col, octave_value old_value, octave_value new_value, octave_value edit_data, octave_value error);
+    void sendCellEditCallback (int row, int col, octave_value old_value,
+                               octave_value new_value, octave_value edit_data, octave_value error);
     void checkBoxClicked (int row, int col, QCheckBox* checkBox);
 
 
 
   };
 
-}; // namespace QtHandles
+}
 
 #endif
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -2728,17 +2728,17 @@ gh_manager::do_free (const graphics_hand
 
       auto p = handle_map.find (h);
 
       if (p == handle_map.end ())
         error ("graphics_handle::free: invalid object %g", h.value ());
 
       base_properties& bp = p->second.get_properties ();
 
-      if (!p->second.valid_object () || bp.is_beingdeleted ())
+      if (! p->second.valid_object () || bp.is_beingdeleted ())
         return;
 
       graphics_handle parent_h = p->second.get_parent ();
       graphics_object parent_go = gh_manager::get_object (parent_h);
 
       bp.set_beingdeleted (true);
 
       // delete listeners before invalidating object
@@ -10880,124 +10880,110 @@ uitable::properties::get_boundingbox (bo
         go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
 
   pos(0)--;
   pos(1)--;
   pos(1) = parent_size(1) - pos(1) - pos(3);
+
   return pos;
 }
 
 void
 uitable::properties::set_columnformat (const octave_value& val)
 {
-  /* Matlab only allows certain values for columnformat - here we will only
-     check the structure of the argument. Values will be checked in Table.cc */
+  /* Matlab only allows certain values for ColumnFormat. Here we only check the
+   * structure of the argument.  Values will be checked in Table.cc */
 
   if (val.iscellstr ())
     {
       if (columnformat.set (val, true))
-        {
-          mark_modified ();
-        }
+        mark_modified ();
     }
   else if (val.iscell ())
     {
       Cell cell_value = val.cell_value ();
 
       for (int i = 0; i < cell_value.numel (); i++)
         {
-          octave_value v = cell_value (i);
+          octave_value v = cell_value(i);
           if (v.iscell ())
             {
-              /* We are in a pop-up menu selection
-               * Matlab only allows non-empty strings here */
+              /* We are in a pop-up menu selection.
+               * Matlab only allows non-empty strings here. */
               Cell popup = v.cell_value ();
               for (int j = 0; j < popup.numel (); j++)
                 {
-                  octave_value p = popup (j);
-                  if (!p.is_string () || p.string_value ().length () == 0)
-                    {
-                      error ("set: pop-up menu definitions must be non-empty strings.");
-                    }
+                  octave_value p = popup(j);
+                  if (! p.is_string () || p.isempty ())
+                    error ("set: pop-up menu definitions must be non-empty strings.");
                 }
             }
-          else if (!(v.is_string () || v.isempty ()))
+          else if (! (v.is_string () || v.isempty ()))
             {
               error ("set: columnformat definintions must be a cellstr of "
-                "either 'char', 'short [e|g|eng]?', 'long [e|g|eng]?', "
-                "'numeric', 'bank', '+', 'rat', 'logical', or a cellstr of non-empty "
-                "pop-up menu definitions.");
+                     "either 'char', 'short [e|g|eng]?', 'long [e|g|eng]?', "
+                     "'numeric', 'bank', '+', 'rat', 'logical', "
+                     "or a cellstr of non-empty pop-up menu definitions.");
             }
         }
 
       if (columnformat.set (val, true))
-        {
-          mark_modified ();
-        }
+        mark_modified ();
     }
   else if (val.isempty ())
     {
       if (columnformat.set (Cell (), true))
-        {
-          mark_modified ();
-        }
+        mark_modified ();
     }
   else
     {
       error ("set: expecting cell of strings.");
     }
 }
 
 void
 uitable::properties::set_columnwidth (const octave_value& val)
 {
   bool error_exists = false;
-  if (val.is_string ()  && val.string_value (false) == "auto")
-    {
-      error_exists = false;
-    }
+
+  if (val.is_string () && val.string_value (false) == "auto")
+    error_exists = false;
   else if (val.iscell ())
     {
       Cell cell_value = val.cell_value ();
       for (int i = 0; i < cell_value.numel (); i++)
         {
-          octave_value v = cell_value (i);
+          octave_value v = cell_value(i);
           if (v.is_string ())
             {
               if (v.string_value (false) != "auto")
                 error_exists = true;
             }
           else if (v.iscell ())
             {
               error_exists = true;
             }
-          else if (!(v.is_scalar_type ()))
+          else if (! v.is_scalar_type ())
             {
               error_exists = true;
             }
         }
     }
   else
-    {
-      error_exists = true;
-    }
+    error_exists = true;
 
   if (error_exists)
-    {
-      error ("set: expecting either 'auto' or a cell of pixel values or auto.");
-    }
+    error ("set: expecting either 'auto' or a cell of pixel values or auto.");
   else
     {
       if (columnwidth.set (val, true))
-        {
-          mark_modified ();
-        }
+        mark_modified ();
     }
 }
 
 void
 uitable::properties::set_units (const octave_value& val)
 {
   caseless_str old_units = get_units ();
 
@@ -11078,16 +11064,17 @@ uitable::properties::get_backgroundcolor
 
 Matrix
 uitable::properties::get_alternatebackgroundcolor_rgb (void)
 {
   int i = 0;
   Matrix bg = backgroundcolor.get ().matrix_value ();
   if (bg.rows () > 1)
     i = 1;
+
   return bg.row (i);
 }
 
 Matrix
 uitable::properties::get_extent_matrix (void) const
 {
   return extent.get ().matrix_value ();
 }
@@ -11100,16 +11087,17 @@ uitable::properties::get_extent (void) c
   graphics_object parent_go = gh_manager::get_object (get_parent ());
   if (parent_go)
     {
       Matrix parent_bbox = parent_go.get_properties ().get_boundingbox (true);
       Matrix parent_size = parent_bbox.extract_n (0, 2, 1, 2);
 
       return convert_position (m, "pixels", get_units (), parent_size);
     }
+
   return m;
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 uitoolbar::get_default (const caseless_str& pname) const
 {
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -2319,17 +2319,17 @@ public:
 
   void renumber_parent (graphics_handle new_gh)
   {
     parent = new_gh;
   }
 
   static property_list::pval_map_type factory_defaults (void);
 
-  // FIXME: these functions should be generated automatically by the
+  // FIXME: These functions should be generated automatically by the
   //        genprops.awk script.
   //
   // EMIT_BASE_PROPERTIES_GET_FUNCTIONS
 
   virtual octave_value get_alim (void) const { return octave_value (); }
   virtual octave_value get_clim (void) const { return octave_value (); }
   virtual octave_value get_xlim (void) const { return octave_value (); }
   virtual octave_value get_ylim (void) const { return octave_value (); }
@@ -2810,17 +2810,17 @@ public:
   }
 
   bool valid_object (void) const { return rep->valid_object (); }
 
   std::string type (void) const { return rep->type (); }
 
   operator bool (void) const { return rep->valid_object (); }
 
-  // FIXME: these functions should be generated automatically by the
+  // FIXME: These functions should be generated automatically by the
   //        genprops.awk script.
   //
   // EMIT_GRAPHICS_OBJECT_GET_FUNCTIONS
 
   octave_value get_alim (void) const
   { return get_properties ().get_alim (); }
 
   octave_value get_clim (void) const
@@ -3105,17 +3105,16 @@ public:
     void update_units (const caseless_str& old_units);
 
     void update_paperunits (const caseless_str& old_paperunits);
 
     std::string get_title (void) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
-
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (figure)
       array_property alphamap , Matrix (64, 1, 1)
       callback_property buttondownfcn , Matrix ()
       callback_property closerequestfcn , "closereq"
       color_property color , color_property (color_values (1, 1, 1), radio_values ("none"))
       array_property colormap , viridis_colormap ()
@@ -3605,17 +3604,16 @@ public:
 
     void set_text_child (handle_property& h, const std::string& who,
                          const octave_value& v);
 
     void delete_text_child (handle_property& h);
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
-
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (axes)
       radio_property activepositionproperty , "{outerposition}|position"
       row_vector_property alim m , default_lim ()
       radio_property alimmode , "{auto}|manual"
       color_property ambientlightcolor , color_values (1, 1, 1)
       bool_property box u , "off"
@@ -4347,16 +4345,17 @@ public:
           mark_modified ();
         }
       else
         set_positionmode ("manual");
     }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (text)
       color_property backgroundcolor , color_property (radio_values ("{none}"), color_values (1, 1, 1))
       color_property color u , color_values (0, 0, 0)
       color_property edgecolor , color_property (radio_values ("{none}"), color_values (0, 0, 0))
       bool_property editing , "off"
       radio_property erasemode h , "{normal}|none|xor|background"
       array_property extent rG , Matrix (1, 4, 0.0)
@@ -4449,18 +4448,17 @@ public:
     void update_fontname (void) { update_font (); update_text_extent (); }
     void update_fontsize (void) { update_font (); update_text_extent (); }
     void update_fontangle (void) { update_font (); update_text_extent (); }
 
     void update_fontweight (void)
     {
       update_font ();
       update_text_extent ();
-      // FIXME: DEPRECATED: Remove warning with demi and light in
-      // version 6.
+      // FIXME: DEPRECATED: Remove warning with demi and light in version 6.
       if (fontweight.is ("demi") || fontweight.is ("light"))
         warning_with_id ("Octave:deprecated-property",
                          "Setting 'fontweight' to '%s' is deprecated, \
 use 'normal' or 'bold'.", fontweight.current_value ().c_str ());
     }
 
     void update_interpreter (void) { update_text_extent (); }
     void update_horizontalalignment (void) { update_text_extent (); }
@@ -5512,18 +5510,17 @@ public:
     void update_string (void) { update_text_extent (); }
     void update_fontname (void) { update_text_extent (); }
     void update_fontsize (void) { update_text_extent (); }
     void update_fontangle (void) { update_text_extent (); }
 
     void update_fontweight (void)
     {
       update_text_extent ();
-      // FIXME: DEPRECATED: Remove warning with demi and light in
-      // version 6.
+      // FIXME: DEPRECATED: Remove warning with demi and light in version 6.
       if (fontweight.is ("demi") || fontweight.is ("light"))
         warning_with_id ("Octave:deprecated-property",
                          "Setting 'fontweight' to '%s' is deprecated, \
 use 'normal' or 'bold'.", fontweight.current_value ().c_str ());
     }
 
     void update_fontunits (const caseless_str& old_units);
 
@@ -5610,17 +5607,17 @@ public:
     // void update_text_extent (void);
     // void update_string (void) { update_text_extent (); }
     // void update_fontname (void) { update_text_extent (); }
     // void update_fontsize (void) { update_text_extent (); }
     // void update_fontangle (void) { update_text_extent (); }
 
     void update_fontweight (void)
     {
-      // FIXME: DEPRECATED: Remove this warning in version 6.
+      // FIXME: DEPRECATED: Remove warning with demi and light in version 6.
       if (fontweight.is ("demi") || fontweight.is ("light"))
         warning_with_id ("Octave:deprecated-property",
                          "Setting 'fontweight' to '%s' is deprecated, \
 use 'normal' or 'bold'.", fontweight.current_value ().c_str ());
     }
 
     void update_units (const caseless_str& old_units);
     void update_fontunits (const caseless_str& old_units);
@@ -5699,17 +5696,17 @@ public:
       position.add_constraint (dim_vector (1, 4));
     }
 
     void update_units (const caseless_str& old_units);
     void update_fontunits (const caseless_str& old_units);
 
     void update_fontweight (void)
     {
-      // FIXME: DEPRECATED: Remove this warning in version 6.
+      // FIXME: DEPRECATED: Remove warning with demi and light in version 6.
       if (fontweight.is ("demi") || fontweight.is ("light"))
         warning_with_id ("Octave:deprecated-property",
                          "Setting 'fontweight' to '%s' is deprecated, \
 use 'normal' or 'bold'.", fontweight.current_value ().c_str ());
     }
   };
 
 private:
@@ -5751,27 +5748,30 @@ public:
     double get___fontsize_points__ (double box_pix_height = 0) const;
 
     double get_fontsize_pixels (double box_pix_height = 0) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
     // Programming note: Keep property list sorted if new ones are added.
 
+    // FIXME: keypressfcn, keyreleasefcn, rearrangeablecolumns properties
+    //        seem to have been removed from Matlab.
+
     BEGIN_PROPERTIES (uitable)
       any_property __object__ h , Matrix ()
       array_property backgroundcolor , default_table_backgroundcolor ()
       callback_property celleditcallback , Matrix ()
       callback_property cellselectioncallback , Matrix ()
       row_vector_property columneditable , Matrix ()
-      any_property columnformat S , Matrix ()
+      any_property columnformat S , Cell ()
       any_property columnname , "numbered"
       any_property columnwidth S , "auto"
       any_property data u , Matrix ()
-      radio_property enable , "{on}|inactive|off"
+      bool_property enable , "on"
       array_property extent rG , Matrix (1, 4, 0.0)
       radio_property fontangle u , "{normal}|italic|oblique"
       string_property fontname u , OCTAVE_DEFAULT_FONTNAME
       double_property fontsize u , 10
       radio_property fontunits S , "inches|centimeters|normalized|{points}|pixels"
       radio_property fontweight u , "light|{normal}|demi|bold"
       color_property foregroundcolor , color_values (0, 0, 0)
       callback_property keypressfcn , Matrix ()
@@ -5790,30 +5790,39 @@ public:
 
     Matrix get_alternatebackgroundcolor_rgb (void);
 
   protected:
     void init (void)
     {
       position.add_constraint (dim_vector (1, 4));
       extent.add_constraint (dim_vector (1, 4));
+      backgroundcolor.add_constraint ("double");
       backgroundcolor.add_constraint (dim_vector (-1, 3));
-      backgroundcolor.add_constraint ("double");
       columneditable.add_constraint ("logical");
     }
 
     void update_units (const caseless_str& old_units);
     void update_fontunits (const caseless_str& old_units);
     void update_table_extent (void) { };
     void update_data (void) { update_table_extent (); }
     void update_fontname (void) { update_table_extent (); }
     void update_fontsize (void) { update_table_extent (); }
     void update_fontangle (void) { update_table_extent (); }
-    void update_fontweight (void) { update_table_extent (); }
-
+
+    void update_fontweight (void)
+    {
+      // FIXME: DEPRECATED: Remove warning with demi and light in version 6.
+      if (fontweight.is ("demi") || fontweight.is ("light"))
+        warning_with_id ("Octave:deprecated-property",
+                         "Setting 'fontweight' to '%s' is deprecated, \
+use 'normal' or 'bold'.", fontweight.current_value ().c_str ());
+
+      update_table_extent ();
+    }
   };
 
 private:
   properties xproperties;
 
 public:
   uitable (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
diff --git a/scripts/gui/uitable.m b/scripts/gui/uitable.m
--- a/scripts/gui/uitable.m
+++ b/scripts/gui/uitable.m
@@ -1,226 +1,228 @@
 ## Copyright (C) 2016-2018 Andrew Thornton
 ##
 ## This file is part of Octave.
 ##
-## Octave is free software; you can redistribute it and/or modify it
+## Octave is free software: you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
+## the Free Software Foundation, either version 3 of the License, or
+## (at your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
+## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{hui} =} uitable (@var{property}, @var{value}, @dots{})
-## @deftypefnx {} {@var{hui} =} uitable (@var{parent}, "@var{property}", @var{value}, @dots{})
+## @deftypefnx {} {@var{hui} =} uitable (@var{parent}, @var{property}, @var{value}, @dots{})
 ## Create a uitable object and return a handle to it.
 ##
-## uitables are used to show tables of data in a figure.
+## A uitable object is used to show tables of data in a figure window.
 ##
-## If @var{parent} is omitted, a uitable for the current figure is created.  If
-## no figure is available, a new figure is created first.
+## If @var{parent} is omitted then a uitable for the current figure is
+## created.  If no figure is available, a new figure is created first.
 ##
-## If @var{parent} is given, a uitable relative to @var{parent} is created.
+## If @var{parent} is given then a uitable relative to @var{parent} is
+## created.
 ##
 ## Any provided property value pairs will override the default values of the
 ## created uitable object.
 ##
-## Uitable properties are documented at @ref{Uitable Properties}.
+## Properties of uitable objects are documented at
+## @ref{Uitable Properties}.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## % create figure and table on it
-## f = figure;
-## m = magic(8);
-## t = uitable(f, 'Data', m, 'ColumnWidth', @{ 40 @});
-## @end group
-##
-## @group
-## % Create a named table
-## f = figure();
-## d = reshape(1:9, 3, []);
-## column_names = @{ 'Col1', 'Col2', 'Col3' @};
-## row_names = @{ 'Row1', 'Row2', 'Row3' @};
-## t = uitable(f, 'Data', d, ...
-##             'ColumnName', column_names, ...
-##             'RowName', row_names);
-##
-## p = get(t, 'Position');
-## e = get(t, 'Extent');
-## p(3:4) = e(3:4);
-## set(t, 'Position', p);
+## ## Create figure and place a table on it
+## f = figure ();
+## m = magic (8);
+## t = uitable (f, "Data", m, "ColumnWidth", @{ 40 @});
 ## @end group
 ##
 ## @group
-## function uitable_demo ()
-##     f = figure ('Name', 'uitable Demo', 'Menu', 'none', 'Position', [10 10 1000 680]);
+## ## Create a table with labeled rows and columns
+## f = figure ();
+## d = reshape (1:9, [3, 3]);
+## row_names = @{ "Row1", "Row2", "Row3" @};
+## col_names = @{ "Col1", "Col2", "Col3" @};
+## t = uitable (f, "Data", d, ...
+##              "RowName", row_names, "ColumnName", col_names);
 ##
-##     % A basic example
-##     d = @{ 'char', 'A string';
-##         'double', 12.3456789;
-##         'complex', 1+2i;
-##         'bool', true;
-##         'single', single(12.3456789);
-##         'int8', int8(-128);
-##         'uint8', uint8(128);
-##         'int16', int16(-32768);
-##         'uint16', uint16(32768);
-##         'int32', int32(-2147483648);
-##         'uint32', uint32(2147483648);
-##         'int64', int64(-2147483649);
-##         'uint64', uint64(2147843649)@};
+## p = get (t, "Position");
+## e = get (t, "Extent");
+## p(3:4) = e(3:4);
+## set (t, "Position", p);
+## @end group
 ##
-##     popup_options = @{'A', 'B', 'C', 'D', 'E'@};
+## ## Long demo with callbacks
+## function uitable_demo ()
+##   f = figure ("Name", "uitable Demo", "Menu", "none", ...
+##               "Position", [10 10 1000 680]);
 ##
-##     columnformat_options = @{ '[]', 'char', 'pop-up', 'numeric', 'short', 'short e', ...
-##                     'short eng', 'short g', 'long', 'long e', 'long eng', ...
-##                     'long g', 'bank', '+', 'rat', 'logical'@};
-##     columnformat_values = columnformat_options;
-##     columnformat_values@{1@} = '';
-##     columnformat_values@{3@} = popup_options;
+##   ## A basic example
+##   d = @{ "char"   , "A string";
+##         "double" , 12.3456789;
+##         "complex", 1+2i;
+##         "bool"   , true;
+##         "single" , single (12.3456789);
+##         "int8"   , int8 (-128);
+##         "uint8"  , uint8 (128);
+##         "int16"  , int16 (-32768);
+##         "uint16" , uint16 (32768);
+##         "int32"  , int32 (-2147483648);
+##         "uint32" , uint32 (2147483648);
+##         "int64"  , int64 (-2147483649);
+##         "uint64" , uint64 (2147843649)@};
 ##
-##     %default_data = cell(size(d, 1), 10);
-##     default_data = repmat(d(:,2), 1, size(columnformat_options, 2));
-##     b_add = uicontrol(f, 'Position', [ 285 630 600 50], ...
-##               'UserData', [size(d,1) 1], ...
-##               'Style', 'pushbutton', ...
-##               'String', 'Set data at selected point to selected datatype');
+##   popup_options = @{"A", "B", "C", "D", "E"@};
 ##
-##     l_type_table = uicontrol(f, 'Position', [ 0 603 120 25 ], ...
-##         'String', 'Datatype Table:', ...
-##         'Style', 'text');
-##     t_type_table = uitable(f, 'Position', [ 0 530 1000 70 ], ...
-##         'Data', transpose(d(:, 2)), ...
-##         'ColumnName', transpose(d(:, 1)), ...
-##         'RowName', 'Value', ...
-##         'CellSelectionCallback', @@(x, y) ...
-##             set(b_add, 'UserData', y.Indices ));
+##   columnformat_options = @{ "[]", "char", "pop-up", "numeric", "short", "short e", ...
+##                   "short eng", "short g", "long", "long e", "long eng", ...
+##                   "long g", "bank", "+", "rat", "logical"@};
+##   columnformat_values = columnformat_options;
+##   columnformat_values@{1@} = "";
+##   columnformat_values@{3@} = popup_options;
 ##
-##     l_point_table = uicontrol(f, 'Position', [ 0 640 60 25 ], ...
-##         'String', 'Point:', ...
-##         'Style', 'text');
-##     t_point_table = uitable(f, 'Position', [ 80 630 160 42 ], ...
-##                            'RowName', [], ...
-##                            'ColumnName', @{'x', 'y'@}, ...
-##                            'Data', [ 1 1 ], ...
-##                            'ColumnEditable', true);
+##   default_data = repmat (d(:,2), 1, columns (columnformat_options));
+##   b_add = uicontrol (f, "Position", [285 630 600 50], ...
+##             "UserData", [rows(d), 1], ...
+##             "Style", "pushbutton", ...
+##             "String", "Set data at selected point to selected datatype");
+##
+##   l_type_table = uicontrol (f, "Position", [ 0 603 120 25 ], ...
+##       "String", "Datatype Table:", ...
+##       "Style", "text");
+##   t_type_table = uitable (f, "Position", [ 0 530 1000 70 ], ...
+##       "Data", transpose (d(:, 2)), ...
+##       "ColumnName", transpose (d(:, 1)), ...
+##       "RowName", "Value", ...
+##       "CellSelectionCallback", ...
+##            @@(x, y) set (b_add, "UserData", y.Indices ));
 ##
-##     l_editable_table = uicontrol(f, 'Position', [ 0 502 200 25 ], ...
-##         'Style', 'text', ...
-##         'String', 'Set Data Columns Editable:');
-##     t_editable_table = uitable(f, 'Position', [ 0 434 1000 65 ], ...
-##                                'Data', repmat(false, 1, size(default_data, 2)), ...
-##                                'ColumnEditable', true);
+##   l_point_table = uicontrol (f, "Position", [ 0 640 60 25 ], ...
+##       "String", "Point:", ...
+##       "Style", "text");
+##   t_point_table = uitable (f, "Position", [ 80 630 160 42 ], ...
+##       "RowName", [], ...
+##       "ColumnName", @{"x", "y"@}, ...
+##       "Data", [ 1, 1 ], ...
+##       "ColumnEditable", true);
 ##
-##     l_format_table = uicontrol(f, 'Position', [ 0 406 200 25 ], ...
-##         'Style', 'text', ...
-##         'String', 'Set Data Column Format:');
-##     t_format_table = uitable(f, 'Position', [ 0 338 1000 65 ], ...
-##         'Data', columnformat_options, ...
-##         'ColumnEditable', true, ...
-##         'ColumnFormat', arrayfun(@@(x) @{columnformat_options@}, 1:size(columnformat_options, 2)));
+##   l_editable_table = uicontrol (f, "Position", [ 0 502 200 25 ], ...
+##       "Style", "text", ...
+##       "String", "Set Data Columns Editable:");
+##   t_editable_table = uitable (f, "Position", [ 0 434 1000 65 ], ...
+##                              "Data", repmat (false, 1, columns (default_data)), ...
+##                              "ColumnEditable", true);
 ##
-##     l_data_table = uicontrol(f, 'Style', 'text', 'String', 'Data:', 'Position', [ 0 310 60 25]);
-##     t_data_table = uitable(f, 'Position', [ 0 15 1000 290 ], ...
-##         'Data', default_data, ...
-##         'ColumnFormat', columnformat_values);
+##   l_format_table = uicontrol (f, "Position", [ 0 406 200 25 ], ...
+##       "Style", "text", ...
+##       "String", "Set Data Column Format:");
+##   t_format_table = uitable (f, "Position", [ 0 338 1000 65 ], ...
+##       "Data", columnformat_options, ...
+##       "ColumnEditable", true, ...
+##       "ColumnFormat", arrayfun (@@(x) @{columnformat_options@}, 1:columns (columnformat_options)));
+##
+##   l_data_table = uicontrol (f, "Style", "text", "String", "Data:", "Position", [ 0 310 60 25 ]);
+##   t_data_table = uitable (f, "Position", [ 0 15 1000 290 ], ...
+##       "Data", default_data, ...
+##       "ColumnFormat", columnformat_values);
 ##
-##     set(t_format_table, 'CellEditCallback', ...
-##         @@(x, y) update_column_format(y.NewData, y.Indices, t_data_table, popup_options));
-##     set(t_point_table, 'CellEditCallback', ...
-##        @@(x, y) validate_point_table(x, y, t_data_table));
-##     set(t_editable_table, 'CellEditCallback', @@(x,y) set(t_data_table, ...
-##             'ColumnEditable', get(t_editable_table, 'Data')));
-##     set(b_add, 'Callback', @@(x, y) ...
-##             update_data(b_add, t_point_table, t_type_table, t_data_table));
-##     set(t_data_table, 'cellselectioncallback', @@(x, y) update_point_table(y.Indices, t_point_table));
-## end
+##   set (t_format_table, "CellEditCallback", ...
+##       @@(x, y) update_column_format (y.NewData, y.Indices, t_data_table, popup_options));
+##   set (t_point_table, "CellEditCallback", ...
+##      @@(x, y) validate_point_table (x, y, t_data_table));
+##   set (t_editable_table, "CellEditCallback", @@(x,y) set (t_data_table, ...
+##           "ColumnEditable", get (t_editable_table, "Data")));
+##   set (b_add, "Callback", @@(x, y) ...
+##           update_data (b_add, t_point_table, t_type_table, t_data_table));
+##   set (t_data_table, "cellselectioncallback", @@(x, y) update_point_table (y.Indices, t_point_table));
+## endfunction
 ##
-## function validate_point_table(h, dat, t_data_table)
-##     if (~(dat.NewData > 0 && ...
-##         dat.NewData < size(get(t_data_table, 'Data'), dat.Indices(1, 1)) + 1))
+## function validate_point_table (h, dat, t_data_table)
+##   if (! (dat.NewData > 0 && ...
+##     dat.NewData < size (get (t_data_table, "Data"), dat.Indices(1, 1)) + 1))
 ##
-##         d = get(h, 'Data');
-##         d(dat.Indices) = 1;
-##         set(h, 'Data', d);
-##     end
-## end
+##     d = get (h, "Data");
+##     d(dat.Indices) = 1;
+##     set (h, "Data", d);
+##   endif
+## endfunction
 ##
-## function update_column_format(format, indices, t_data_table, popup_options)
-##     cf = get(t_data_table, 'ColumnFormat');
-##     if (strcmp(format, '[]'))
-##         format = '';
-##     elseif (strcmp(format, 'pop-up'))
-##         format = popup_options;
-##     end
-##     cf@{indices(1,2)@} = format;
-##     set(t_data_table, 'ColumnFormat', cf);
-## end
+## function update_column_format (format, indices, t_data_table, popup_options)
+##   cf = get (t_data_table, "ColumnFormat");
+##   if (strcmp (format, "[]"))
+##     format = "";
+##   elseif (strcmp (format, "pop-up"))
+##     format = popup_options;
+##   endif
+##   cf@{indices(1,2)@} = format;
+##   set (t_data_table, "ColumnFormat", cf);
+## endfunction
 ##
-## function update_point_table(indices, t_point_table)
-##     if (size(indices, 1) == 0)
-##         indices = [1 1];
-##     end
-##     set(t_point_table, 'Data', indices(1,:));
-## end  % function
+## function update_point_table (indices, t_point_table)
+##   if (isempty (indices))
+##     indices = [1, 1];
+##   endif
+##   set (t_point_table, "Data", indices(1,:));
+## endfunction
 ##
 ## function update_data (b_add, t_point_table, t_type_table, t_data_table)
-##     indices = get(b_add, 'UserData');
-##     if (size(indices, 1) == 0)
-##         indices = [1 1];
-##     end
-##     d = get(t_data_table, 'Data');
-##     t_type_table_data = get(t_type_table, 'Data');
-##     p = get(t_point_table, 'Data');
-##     d(p(1,2), p(1,1)) = t_type_table_data(indices(1,2));
-##     set(t_data_table, 'Data', d);
-## end
-## @end group
+##   indices = get (b_add, "UserData");
+##   if (isempty (indices))
+##     indices = [1, 1];
+##   endif
+##   d = get (t_data_table, "Data");
+##   t_type_table_data = get (t_type_table, "Data");
+##   p = get (t_point_table, "Data");
+##   d(p(1,2), p(1,1)) = t_type_table_data(indices(1,2));
+##   set (t_data_table, "Data", d);
+## endfunction
 ## @end example
 ##
 ## @seealso{figure, uicontrol}
 ## @end deftypefn
 
-## Author: Andrew Thornton
+function hui = uitable (varargin)
 
-function hui = uitable (varargin)
-    [h, args] = __uiobject_split_args__ ("uitable", varargin, ...
-                                         {"figure", "uipanel", "uibuttongroup"});
-    hui = __go_uitable__ (h, args{:});
+  [h, args] = __uiobject_split_args__ ("uitable", varargin, ...
+                                       {"figure", "uipanel", "uibuttongroup"});
+  htmp = __go_uitable__ (h, args{:});
+
+  if (nargout > 0)
+    hui = htmp;
+  endif
 
 endfunction
 
 
 %!demo
-%!
-%! % create figure and table on it
+%! ## Create figure and place a table on it
 %! f = clf ();
 %! m = magic (8);
 %! t = uitable (f, "Data", m, "ColumnWidth", {50}, ...
 %!              "Units", "normalized", "Position", [0.1 0.1 0.8 0.8]);
 
 %!demo
-%! % create figure and table with editable
+%! ## Create figure and place an editable table on it
 %! f = clf ();
 %! m = magic (8);
 %! t = uitable (f, "Data", m, "ColumnWidth", {50}, "ColumnEditable", true, ...
 %!              "Units", "normalized", "Position", [0.1 0.1 0.8 0.8]);
 
 %!demo
-%! % create figure and table but change the format to rational_approx
+%! ## Create figure and table, but change the format to rational_approx
 %! f = clf ();
 %! m = magic (8) / 64;
 %! t = uitable (f, "Data", m, "ColumnWidth", {50}, ...
 %!              "ColumnFormat", repmat ({"rat"}, 1, 8), ...
 %!              "Units", "normalized", "Position", [0.1 0.1 0.8 0.8]);
 
 %!demo
 %! cf = {"char", "char", {"A", "B", "C"}, "numeric", "short", "short e", ...
@@ -276,25 +278,25 @@ endfunction
 %!      "uint32", uint32(0);
 %!      "uint32", uint32(4294967295);
 %!      "uint64", uint64(9223372036854775807);
 %!      "uint64", uint64(0);
 %!      "uint64", uint64(18446744073709551615);
 %!      "char", "a string"};
 %!
 %! ws = {"auto", 140};
-%! widths = cell (1, size (cf, 2));
+%! widths = cell (1, columns (cf));
 %! widths(1,1) = ws(1,1);
-%! widths(1,2:end) = repmat (ws(:, 2), 1, size (cf, 2) - 1);
+%! widths(1,2:end) = repmat (ws(:,2), [1, columns(cf) - 1]);
 %!
-%! data = cell (size (d, 1), size (cf, 2));
+%! data = cell (rows (d), columns (cf));
 %!
 %! data(:,1) = d(:,1);
 %!
-%! data(:,2:end) = repmat(d(:,2), 1, size(cf, 2) - 1);
+%! data(:, 2:end) = repmat (d(:,2), [1, columns(cf) - 1]);
 %!
-%! t = uitable ("Data", data, ...
-%!              "ColumnFormat", cf, ...
-%!              "ColumnWidth", widths, ...
-%!              "Units", "Normalized", ...
-%!              "Position", [0 0 1 1], ...
-%!              "ColumnName", cn, ...
-%!              "ColumnEditable", true);
+%! t = uitable ("Data", data,
+%!              "ColumnFormat", cf,
+%!              "ColumnWidth", widths,
+%!              "ColumnName", cn,
+%!              "ColumnEditable", true,
+%!              "Units", "Normalized",
+%!              "Position", [0 0 1 1]);
