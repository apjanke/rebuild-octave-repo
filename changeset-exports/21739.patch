# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463637575 14400
#      Thu May 19 01:59:35 2016 -0400
# Node ID c4ab2e54f1008efa03ef63ecf6213d65d62f8d69
# Parent  a99c2407f930f669d67a5f44cd863fb180f2eb68
use namespace for oct_mach_info class

* mach-info.h, mach-info.cc: Put oct_mach_info in octave namespace and
rename to mach_info.  Change all uses.

diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -442,18 +442,18 @@ do_stream_open (const std::string& name,
   fid = -1;
 
   std::string mode = mode_arg;
   bool use_zlib = false;
   normalize_fopen_mode (mode, use_zlib);
 
   std::ios::openmode md = fopen_mode_to_ios_mode (mode);
 
-  oct_mach_info::float_format flt_fmt =
-    oct_mach_info::string_to_float_format (arch);
+  octave::mach_info::float_format flt_fmt =
+    octave::mach_info::string_to_float_format (arch);
 
   std::string fname = octave::sys::file_ops::tilde_expand (name);
 
   octave::sys::file_stat fs (fname);
 
   if (! (md & std::ios::out))
     fname = find_data_file_in_load_path ("fopen", fname);
 
@@ -2274,18 +2274,18 @@ do_fread (octave_stream& os, const octav
     }
   catch (octave_execution_exception& e)
     {
       error (e, "fread: SKIP must be an integer");
     }
 
   std::string arch = arch_arg.xstring_value ("fread: ARCH architecture type must be a string");
 
-  oct_mach_info::float_format flt_fmt
-    = oct_mach_info::string_to_float_format (arch);
+  octave::mach_info::float_format flt_fmt
+    = octave::mach_info::string_to_float_format (arch);
 
   return os.read (size, block_size, input_type, output_type, skip,
                   flt_fmt, count);
 }
 
 DEFUN (fread, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} fread (@var{fid})\n\
@@ -2522,18 +2522,18 @@ do_fwrite (octave_stream& os, const octa
     }
   catch (octave_execution_exception& e)
     {
       error (e, "fwrite: SKIP must be an integer");
     }
 
   std::string arch = arch_arg.xstring_value ("fwrite: ARCH architecture type must be a string");
 
-  oct_mach_info::float_format flt_fmt
-    = oct_mach_info::string_to_float_format (arch);
+  octave::mach_info::float_format flt_fmt
+    = octave::mach_info::string_to_float_format (arch);
 
   return os.write (data, block_size, output_type, skip, flt_fmt);
 }
 
 DEFUN (fwrite, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} fwrite (@var{fid}, @var{data})\n\
 @deftypefnx {} {} fwrite (@var{fid}, @var{data}, @var{precision})\n\
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -170,41 +170,41 @@ matches_patterns (const string_vector& p
         return true;
     }
 
   return false;
 }
 
 int
 read_binary_file_header (std::istream& is, bool& swap,
-                         oct_mach_info::float_format& flt_fmt, bool quiet)
+                         octave::mach_info::float_format& flt_fmt, bool quiet)
 {
   const int magic_len = 10;
   char magic[magic_len+1];
   is.read (magic, magic_len);
   magic[magic_len] = '\0';
 
   if (strncmp (magic, "Octave-1-L", magic_len) == 0)
-    swap = oct_mach_info::words_big_endian ();
+    swap = octave::mach_info::words_big_endian ();
   else if (strncmp (magic, "Octave-1-B", magic_len) == 0)
-    swap = ! oct_mach_info::words_big_endian ();
+    swap = ! octave::mach_info::words_big_endian ();
   else
     {
       if (! quiet)
         error ("load: unable to read read binary file");
 
       return -1;
     }
 
   char tmp = 0;
   is.read (&tmp, 1);
 
   flt_fmt = mopt_digit_to_float_format (tmp);
 
-  if (flt_fmt == oct_mach_info::flt_fmt_unknown)
+  if (flt_fmt == octave::mach_info::flt_fmt_unknown)
     {
       if (! quiet)
         error ("load: unrecognized binary format!");
 
       return -1;
     }
 
   return 0;
@@ -227,17 +227,17 @@ check_gzip_magic (const std::string& fna
 }
 #endif
 
 static load_save_format
 get_file_format (std::istream& file, const std::string& filename)
 {
   load_save_format retval = LS_UNKNOWN;
 
-  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
+  octave::mach_info::float_format flt_fmt = octave::mach_info::flt_fmt_unknown;
 
   bool swap = false;
 
   if (read_binary_file_header (file, swap, flt_fmt, true) == 0)
     retval = LS_BINARY;
   else
     {
       file.clear ();
@@ -337,17 +337,17 @@ get_file_format (const std::string& fnam
     }
 #endif
 
   return retval;
 }
 
 octave_value
 do_load (std::istream& stream, const std::string& orig_fname,
-         load_save_format format, oct_mach_info::float_format flt_fmt,
+         load_save_format format, octave::mach_info::float_format flt_fmt,
          bool list_only, bool swap, bool verbose,
          const string_vector& argv, int argv_idx, int argc, int nargout)
 {
   octave_value retval;
 
   octave_scalar_map retstruct;
 
   std::ostringstream output_buf;
@@ -715,17 +715,17 @@ Force Octave to assume the file is in Oc
       if (i == argc)
         print_usage ();
 
       orig_fname = argv[i];
     }
   else
     i--;
 
-  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
+  octave::mach_info::float_format flt_fmt = octave::mach_info::flt_fmt_unknown;
 
   bool swap = false;
 
   if (orig_fname == "-")
     {
       i++;
 
 #if defined (HAVE_HDF5)
@@ -1155,21 +1155,21 @@ parse_save_options (const std::string &a
 
 void
 write_header (std::ostream& os, load_save_format format)
 {
   switch (format.type)
     {
     case LS_BINARY:
       {
-        os << (oct_mach_info::words_big_endian ()
+        os << (octave::mach_info::words_big_endian ()
                ? "Octave-1-B" : "Octave-1-L");
 
-        oct_mach_info::float_format flt_fmt =
-          oct_mach_info::native_float_format ();
+        octave::mach_info::float_format flt_fmt =
+          octave::mach_info::native_float_format ();
 
         char tmp = static_cast<char> (float_format_to_mopt_digit (flt_fmt));
 
         os.write (&tmp, 1);
       }
       break;
 
     case LS_MAT5_BINARY:
diff --git a/libinterp/corefcn/load-save.h b/libinterp/corefcn/load-save.h
--- a/libinterp/corefcn/load-save.h
+++ b/libinterp/corefcn/load-save.h
@@ -69,22 +69,22 @@ public:
   { return type; }
   int type, opts;
 };
 
 extern void dump_octave_core (void);
 
 extern int
 read_binary_file_header (std::istream& is, bool& swap,
-                         oct_mach_info::float_format& flt_fmt,
+                         octave::mach_info::float_format& flt_fmt,
                          bool quiet = false);
 
 extern octave_value
 do_load (std::istream& stream, const std::string& orig_fname,
-         load_save_format format, oct_mach_info::float_format flt_fmt,
+         load_save_format format, octave::mach_info::float_format flt_fmt,
          bool list_only, bool swap, bool verbose,
          const string_vector& argv, int argv_idx, int argc, int nargout);
 
 extern OCTINTERP_API bool is_octave_data_file (const std::string& file);
 
 extern void
 do_save (std::ostream& os, const symbol_table::symbol_record& sr,
          load_save_format fmt, bool save_as_floats);
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -70,17 +70,17 @@ along with Octave; see the file COPYING.
 // PRECISION, placing the result in DATA.  If SWAP is TRUE, swap
 // the bytes of each element before copying to DATA.  FLT_FMT
 // specifies the format of the data if we are reading floating point
 // numbers.
 
 static void
 read_mat_binary_data (std::istream& is, double *data, int precision,
                       int len, bool swap,
-                      oct_mach_info::float_format flt_fmt)
+                      octave::mach_info::float_format flt_fmt)
 {
   switch (precision)
     {
     case 0:
       read_doubles (is, data, LS_DOUBLE, len, swap, flt_fmt);
       break;
 
     case 1:
@@ -140,17 +140,17 @@ read_mat_file_header (std::istream& is, 
 // bigger than we expect, so we swap bytes.
 //
 // If mopt is zero, it means the file was written on a little endian
 // machine, and we only need to swap if we are running on a big endian
 // machine.
 //
 // Gag me.
 
-  if (oct_mach_info::words_big_endian () && mopt == 0)
+  if (octave::mach_info::words_big_endian () && mopt == 0)
     swap = true;
 
   // mopt is signed, therefore byte swap may result in negative value.
 
   if (mopt > 9999 || mopt < 0)
     swap = true;
 
   if (swap)
@@ -171,54 +171,54 @@ read_mat_file_header (std::istream& is, 
     }
 
   return 0;
 }
 
 // We don't just use a cast here, because we need to be able to detect
 // possible errors.
 
-oct_mach_info::float_format
+octave::mach_info::float_format
 mopt_digit_to_float_format (int mach)
 {
-  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
+  octave::mach_info::float_format flt_fmt = octave::mach_info::flt_fmt_unknown;
 
   switch (mach)
     {
     case 0:
-      flt_fmt = oct_mach_info::flt_fmt_ieee_little_endian;
+      flt_fmt = octave::mach_info::flt_fmt_ieee_little_endian;
       break;
 
     case 1:
-      flt_fmt = oct_mach_info::flt_fmt_ieee_big_endian;
+      flt_fmt = octave::mach_info::flt_fmt_ieee_big_endian;
       break;
 
     case 2:
     case 3:
     case 4:
     default:
-      flt_fmt = oct_mach_info::flt_fmt_unknown;
+      flt_fmt = octave::mach_info::flt_fmt_unknown;
       break;
     }
 
   return flt_fmt;
 }
 
 int
-float_format_to_mopt_digit (oct_mach_info::float_format flt_fmt)
+float_format_to_mopt_digit (octave::mach_info::float_format flt_fmt)
 {
   int retval = -1;
 
   switch (flt_fmt)
     {
-    case oct_mach_info::flt_fmt_ieee_little_endian:
+    case octave::mach_info::flt_fmt_ieee_little_endian:
       retval = 0;
       break;
 
-    case oct_mach_info::flt_fmt_ieee_big_endian:
+    case octave::mach_info::flt_fmt_ieee_big_endian:
       retval = 1;
       break;
 
     default:
       break;
     }
 
   return retval;
@@ -260,20 +260,20 @@ read_mat_binary_data (std::istream& is, 
   type = mopt % 10;  // Full, sparse, etc.
   mopt /= 10;        // Eliminate first digit.
   prec = mopt % 10;  // double, float, int, etc.
   mopt /= 10;        // Eliminate second digit.
   order = mopt % 10; // Row or column major ordering.
   mopt /= 10;        // Eliminate third digit.
   mach = mopt % 10;  // IEEE, VAX, etc.
 
-  oct_mach_info::float_format flt_fmt;
+  octave::mach_info::float_format flt_fmt;
   flt_fmt = mopt_digit_to_float_format (mach);
 
-  if (flt_fmt == oct_mach_info::flt_fmt_unknown)
+  if (flt_fmt == octave::mach_info::flt_fmt_unknown)
     error ("load: unrecognized binary format!");
 
   if (imag && type == 1)
     error ("load: encountered complex matrix with string flag set!");
 
   int dlen = 0;
 
   // LEN includes the terminating character, and the file is also
@@ -399,18 +399,18 @@ read_mat_binary_data (std::istream& is, 
 bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
                       const std::string& name)
 {
   int32_t mopt = 0;
 
   mopt += tc.is_sparse_type () ? 2 : tc.is_string () ? 1 : 0;
 
-  oct_mach_info::float_format flt_fmt =
-    oct_mach_info::native_float_format ();;
+  octave::mach_info::float_format flt_fmt =
+    octave::mach_info::native_float_format ();;
 
   mopt += 1000 * float_format_to_mopt_digit (flt_fmt);
 
   os.write (reinterpret_cast<char *> (&mopt), 4);
 
   octave_idx_type len;
   int32_t nr = tc.rows ();
 
diff --git a/libinterp/corefcn/ls-mat4.h b/libinterp/corefcn/ls-mat4.h
--- a/libinterp/corefcn/ls-mat4.h
+++ b/libinterp/corefcn/ls-mat4.h
@@ -20,21 +20,21 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_ls_mat4_h)
 #define octave_ls_mat4_h 1
 
 #include "octave-config.h"
 
-extern oct_mach_info::float_format
+extern octave::mach_info::float_format
 mopt_digit_to_float_format (int mach);
 
 extern int
-float_format_to_mopt_digit (oct_mach_info::float_format flt_fmt);
+float_format_to_mopt_digit (octave::mach_info::float_format flt_fmt);
 
 extern int
 read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt,
                       int32_t& nr, int32_t& nc, int32_t& imag,
                       int32_t& len, int quiet = 0);
 
 extern std::string
 read_mat_binary_data (std::istream& is, const std::string& filename,
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -120,17 +120,17 @@ enum arrayclasstype
 // Read COUNT elements of data from IS in the format specified by TYPE,
 // placing the result in DATA.  If SWAP is TRUE, swap the bytes of
 // each element before copying to DATA.  FLT_FMT specifies the format
 // of the data if we are reading floating point numbers.
 
 static void
 read_mat5_binary_data (std::istream& is, double *data,
                        octave_idx_type  count, bool swap, mat5_data_type type,
-                       oct_mach_info::float_format flt_fmt)
+                       octave::mach_info::float_format flt_fmt)
 {
 
   switch (type)
     {
     case miINT8:
       read_doubles (is, data, LS_CHAR, count, swap, flt_fmt);
       break;
 
@@ -185,17 +185,17 @@ read_mat5_binary_data (std::istream& is,
     default:
       break;
     }
 }
 
 static void
 read_mat5_binary_data (std::istream& is, float *data,
                        octave_idx_type  count, bool swap, mat5_data_type type,
-                       oct_mach_info::float_format flt_fmt)
+                       octave::mach_info::float_format flt_fmt)
 {
 
   switch (type)
     {
     case miINT8:
       read_floats (is, data, LS_CHAR, count, swap, flt_fmt);
       break;
 
@@ -490,21 +490,21 @@ read_mat5_binary_element (std::istream& 
   bool logicalvar;
   dim_vector dims;
   enum arrayclasstype arrayclass;
   int16_t number = *(reinterpret_cast<const int16_t *>("\x00\x01"));
   octave_idx_type nzmax;
   std::string classname;
 
   // MAT files always use IEEE floating point
-  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
+  octave::mach_info::float_format flt_fmt = octave::mach_info::flt_fmt_unknown;
   if ((number == 1) ^ swap)
-    flt_fmt = oct_mach_info::flt_fmt_ieee_big_endian;
+    flt_fmt = octave::mach_info::flt_fmt_ieee_big_endian;
   else
-    flt_fmt = oct_mach_info::flt_fmt_ieee_little_endian;
+    flt_fmt = octave::mach_info::flt_fmt_ieee_little_endian;
 
   // element type, length and small data element flag
   int32_t type = 0;
   int32_t element_length;
   bool is_small_data_element;
   if (read_mat5_tag (is, swap, type, element_length, is_small_data_element))
     return retval;                      // EOF
 
diff --git a/libinterp/corefcn/ls-oct-binary.cc b/libinterp/corefcn/ls-oct-binary.cc
--- a/libinterp/corefcn/ls-oct-binary.cc
+++ b/libinterp/corefcn/ls-oct-binary.cc
@@ -127,17 +127,17 @@ along with Octave; see the file COPYING.
 //   7                          string
 //
 // Except for "data type" equal 5 that requires special treatment, these
 // old style "data type" value also cause the specific load/save functions
 // to be called. FILENAME is used for error messages.
 
 std::string
 read_binary_data (std::istream& is, bool swap,
-                  oct_mach_info::float_format fmt,
+                  octave::mach_info::float_format fmt,
                   const std::string& filename, bool& global,
                   octave_value& tc, std::string& doc)
 {
   std::string retval;
 
   unsigned char tmp = 0;
 
   int32_t name_len = 0;
diff --git a/libinterp/corefcn/ls-oct-binary.h b/libinterp/corefcn/ls-oct-binary.h
--- a/libinterp/corefcn/ls-oct-binary.h
+++ b/libinterp/corefcn/ls-oct-binary.h
@@ -27,13 +27,13 @@ along with Octave; see the file COPYING.
 
 extern OCTINTERP_API bool
 save_binary_data (std::ostream& os, const octave_value& tc,
                   const std::string& name, const std::string& doc,
                   bool mark_as_global, bool save_as_floats);
 
 extern OCTINTERP_API std::string
 read_binary_data (std::istream& is, bool swap,
-                  oct_mach_info::float_format fmt,
+                  octave::mach_info::float_format fmt,
                   const std::string& filename, bool& global,
                   octave_value& tc, std::string& doc);
 
 #endif
diff --git a/libinterp/corefcn/oct-fstrm.cc b/libinterp/corefcn/oct-fstrm.cc
--- a/libinterp/corefcn/oct-fstrm.cc
+++ b/libinterp/corefcn/oct-fstrm.cc
@@ -27,24 +27,24 @@ along with Octave; see the file COPYING.
 #include <cerrno>
 #include <cstring>
 
 #include "error.h"
 #include "oct-fstrm.h"
 
 octave_stream
 octave_fstream::create (const std::string& nm_arg, std::ios::openmode arg_md,
-                        oct_mach_info::float_format ff)
+                        octave::mach_info::float_format ff)
 {
   return octave_stream (new octave_fstream (nm_arg, arg_md, ff));
 }
 
 octave_fstream::octave_fstream (const std::string& nm_arg,
                                 std::ios::openmode arg_md,
-                                oct_mach_info::float_format ff)
+                                octave::mach_info::float_format ff)
   : octave_base_stream (arg_md, ff), nm (nm_arg)
 {
   fs.open (nm.c_str (), arg_md);
 
   if (! fs)
     // Note: error is inherited from octave_base_stream, not ::error.
     error (gnulib::strerror (errno));
 }
diff --git a/libinterp/corefcn/oct-fstrm.h b/libinterp/corefcn/oct-fstrm.h
--- a/libinterp/corefcn/oct-fstrm.h
+++ b/libinterp/corefcn/oct-fstrm.h
@@ -32,24 +32,24 @@ along with Octave; see the file COPYING.
 
 class
 octave_fstream : public octave_base_stream
 {
 public:
 
   octave_fstream (const std::string& nm_arg,
                   std::ios::openmode arg_md = std::ios::in | std::ios::out,
-                  oct_mach_info::float_format flt_fmt
-                    = oct_mach_info::native_float_format ());
+                  octave::mach_info::float_format flt_fmt
+                    = octave::mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& nm_arg,
           std::ios::openmode arg_md = std::ios::in | std::ios::out,
-          oct_mach_info::float_format flt_fmt
-            = oct_mach_info::native_float_format ());
+          octave::mach_info::float_format flt_fmt
+            = octave::mach_info::native_float_format ());
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin);
 
   // Return current stream position.
 
   off_t tell (void);
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -31,18 +31,18 @@ along with Octave; see the file COPYING.
 
 class
 octave_base_iostream : public octave_base_stream
 {
 public:
 
   octave_base_iostream (const std::string& n = "",
                         std::ios::openmode m = std::ios::in | std::ios::out,
-                        oct_mach_info::float_format ff
-                          = oct_mach_info::native_float_format ())
+                        octave::mach_info::float_format ff
+                          = octave::mach_info::native_float_format ())
     : octave_base_stream (m, ff), nm (n) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin);
 
   // Return current stream position.
 
@@ -77,17 +77,17 @@ private:
 
 class
 octave_istream : public octave_base_iostream
 {
 public:
 
   octave_istream (std::istream *arg = 0, const std::string& n = "")
     : octave_base_iostream (n, std::ios::in,
-                            oct_mach_info::native_float_format ()),
+                            octave::mach_info::native_float_format ()),
       is (arg)
   { }
 
   static octave_stream
   create (std::istream *arg = 0, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
@@ -116,17 +116,17 @@ private:
 
 class
 octave_ostream : public octave_base_iostream
 {
 public:
 
   octave_ostream (std::ostream *arg, const std::string& n = "")
     : octave_base_iostream (n, std::ios::out,
-                            oct_mach_info::native_float_format ()),
+                            octave::mach_info::native_float_format ()),
       os (arg)
   { }
 
   static octave_stream
   create (std::ostream *arg, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
diff --git a/libinterp/corefcn/oct-prcstrm.cc b/libinterp/corefcn/oct-prcstrm.cc
--- a/libinterp/corefcn/oct-prcstrm.cc
+++ b/libinterp/corefcn/oct-prcstrm.cc
@@ -26,44 +26,44 @@ along with Octave; see the file COPYING.
 
 #include <cstdio>
 
 #include "oct-prcstrm.h"
 #include "sysdep.h"
 
 octave_stream
 octave_iprocstream::create (const std::string& n, std::ios::openmode arg_md,
-                            oct_mach_info::float_format ff)
+                            octave::mach_info::float_format ff)
 {
   return octave_stream (new octave_iprocstream (n, arg_md, ff));
 }
 
 octave_iprocstream::octave_iprocstream (const std::string& n,
                                         std::ios::openmode arg_md,
-                                        oct_mach_info::float_format ff)
+                                        octave::mach_info::float_format ff)
   : octave_stdiostream (n, octave_popen (n.c_str (), "r"),
                         arg_md, ff, octave_pclose)
 {
 }
 
 octave_iprocstream::~octave_iprocstream (void)
 {
   do_close ();
 }
 
 octave_stream
 octave_oprocstream::create (const std::string& n, std::ios::openmode arg_md,
-                            oct_mach_info::float_format ff)
+                            octave::mach_info::float_format ff)
 {
   return octave_stream (new octave_oprocstream (n, arg_md, ff));
 }
 
 octave_oprocstream::octave_oprocstream (const std::string& n,
                                         std::ios::openmode arg_md,
-                                        oct_mach_info::float_format ff)
+                                        octave::mach_info::float_format ff)
   : octave_stdiostream (n, octave_popen (n.c_str (), "w"),
                         arg_md, ff, octave_pclose)
 {
 }
 
 octave_oprocstream::~octave_oprocstream (void)
 {
   do_close ();
diff --git a/libinterp/corefcn/oct-prcstrm.h b/libinterp/corefcn/oct-prcstrm.h
--- a/libinterp/corefcn/oct-prcstrm.h
+++ b/libinterp/corefcn/oct-prcstrm.h
@@ -32,23 +32,23 @@ along with Octave; see the file COPYING.
 
 class
 octave_iprocstream : public octave_stdiostream
 {
 public:
 
   octave_iprocstream (const std::string& n,
                       std::ios::openmode arg_md = std::ios::in,
-                      oct_mach_info::float_format flt_fmt
-                        = oct_mach_info::native_float_format ());
+                      octave::mach_info::float_format flt_fmt
+                        = octave::mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& n, std::ios::openmode arg_md = std::ios::in,
-          oct_mach_info::float_format flt_fmt
-            = oct_mach_info::native_float_format ());
+          octave::mach_info::float_format flt_fmt
+            = octave::mach_info::native_float_format ());
 
 protected:
 
   ~octave_iprocstream (void);
 
 private:
 
   // No copying!
@@ -60,23 +60,23 @@ private:
 
 class
 octave_oprocstream : public octave_stdiostream
 {
 public:
 
   octave_oprocstream (const std::string& n,
                       std::ios::openmode arg_md = std::ios::out,
-                      oct_mach_info::float_format flt_fmt
-                        = oct_mach_info::native_float_format ());
+                      octave::mach_info::float_format flt_fmt
+                        = octave::mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& n, std::ios::openmode arg_md = std::ios::out,
-          oct_mach_info::float_format flt_fmt
-            = oct_mach_info::native_float_format ());
+          octave::mach_info::float_format flt_fmt
+            = octave::mach_info::native_float_format ());
 
 protected:
 
   ~octave_oprocstream (void);
 
 private:
 
   // No copying!
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -31,18 +31,18 @@ along with Octave; see the file COPYING.
 template <typename BUF_T, typename STREAM_T, typename FILE_T>
 class
 octave_tstdiostream : public octave_base_stream
 {
 public:
 
   octave_tstdiostream (const std::string& n, FILE_T f = 0, int fid = 0,
                        std::ios::openmode m = std::ios::in | std::ios::out,
-                       oct_mach_info::float_format ff
-                         = oct_mach_info::native_float_format (),
+                       octave::mach_info::float_format ff
+                         = octave::mach_info::native_float_format (),
                        typename BUF_T::close_fcn cf = BUF_T::file_close)
     : octave_base_stream (m, ff), nm (n), md (m),
       s (f ? new STREAM_T (f, cf) : 0), fnum (fid)
   { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin)
@@ -101,27 +101,27 @@ private:
 class
 octave_stdiostream
   : public octave_tstdiostream<c_file_ptr_buf, io_c_file_ptr_stream, FILE *>
 {
 public:
 
   octave_stdiostream (const std::string& n, FILE *f = 0,
                       std::ios::openmode m = std::ios::in | std::ios::out,
-                      oct_mach_info::float_format ff
-                        = oct_mach_info::native_float_format (),
+                      octave::mach_info::float_format ff
+                        = octave::mach_info::native_float_format (),
                       c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
     : octave_tstdiostream<c_file_ptr_buf, io_c_file_ptr_stream, FILE *>
        (n, f, f ? fileno (f) : -1, m, ff, cf) { }
 
   static octave_stream
   create (const std::string& n, FILE *f = 0,
           std::ios::openmode m = std::ios::in | std::ios::out,
-          oct_mach_info::float_format ff
-            = oct_mach_info::native_float_format (),
+          octave::mach_info::float_format ff
+            = octave::mach_info::native_float_format (),
           c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
   {
     return octave_stream (new octave_stdiostream (n, f, m, ff, cf));
   }
 
 protected:
 
   ~octave_stdiostream (void) { }
@@ -140,28 +140,28 @@ private:
 class
 octave_zstdiostream
   : public octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile>
 {
 public:
 
   octave_zstdiostream (const std::string& n, gzFile f = 0, int fid = 0,
                        std::ios::openmode m = std::ios::in | std::ios::out,
-                       oct_mach_info::float_format ff
-                         = oct_mach_info::native_float_format (),
+                       octave::mach_info::float_format ff
+                         = octave::mach_info::native_float_format (),
                        c_zfile_ptr_buf::close_fcn cf
                          = c_zfile_ptr_buf::file_close)
     : octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile>
        (n, f, fid, m, ff, cf) { }
 
   static octave_stream
   create (const std::string& n, gzFile f = 0, int fid = 0,
           std::ios::openmode m = std::ios::in | std::ios::out,
-          oct_mach_info::float_format ff
-            = oct_mach_info::native_float_format (),
+          octave::mach_info::float_format ff
+            = octave::mach_info::native_float_format (),
           c_zfile_ptr_buf::close_fcn cf = c_zfile_ptr_buf::file_close)
   {
     return octave_stream (new octave_zstdiostream (n, f, fid, m, ff, cf));
   }
 
 protected:
 
   ~octave_zstdiostream (void) { }
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -6220,17 +6220,17 @@ replace_old_NA<double> (double val)
 
 template <typename SRC_T, typename DST_T>
 static octave_value
 convert_and_copy (std::list<void *>& input_buf_list,
                   octave_idx_type input_buf_elts,
                   octave_idx_type elts_read,
                   octave_idx_type nr, octave_idx_type nc, bool swap,
                   bool do_float_fmt_conv, bool do_NA_conv,
-                  oct_mach_info::float_format from_flt_fmt)
+                  octave::mach_info::float_format from_flt_fmt)
 {
   typedef typename DST_T::element_type dst_elt_type;
 
   DST_T conv (dim_vector (nr, nc));
 
   dst_elt_type *conv_data = conv.fortran_vec ();
 
   octave_idx_type j = 0;
@@ -6247,17 +6247,17 @@ convert_and_copy (std::list<void *>& inp
               for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
                    i++, j++)
                 {
                   if (swap)
                     swap_bytes<sizeof (SRC_T)> (&data[i]);
                   else if (do_float_fmt_conv)
                     do_float_format_conversion (&data[i], sizeof (SRC_T),
                                                 1, from_flt_fmt,
-                                                oct_mach_info::native_float_format ());
+                                                octave::mach_info::native_float_format ());
 
                   dst_elt_type tmp (data[i]);
 
                   if (is_old_NA (tmp))
                     tmp = replace_old_NA (tmp);
 
                   conv_data[j] = tmp;
                 }
@@ -6267,17 +6267,17 @@ convert_and_copy (std::list<void *>& inp
               for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
                    i++, j++)
                 {
                   if (swap)
                     swap_bytes<sizeof (SRC_T)> (&data[i]);
                   else if (do_float_fmt_conv)
                     do_float_format_conversion (&data[i], sizeof (SRC_T),
                                                 1, from_flt_fmt,
-                                                oct_mach_info::native_float_format ());
+                                                octave::mach_info::native_float_format ());
 
                   conv_data[j] = data[i];
                 }
             }
         }
       else
         {
           if (do_NA_conv)
@@ -6311,17 +6311,17 @@ convert_and_copy (std::list<void *>& inp
 
   return conv;
 }
 
 typedef octave_value (*conv_fptr)
   (std::list<void *>& input_buf_list, octave_idx_type input_buf_elts,
    octave_idx_type elts_read, octave_idx_type nr, octave_idx_type nc,
    bool swap, bool do_float_fmt_conv, bool do_NA_conv,
-   oct_mach_info::float_format from_flt_fmt);
+   octave::mach_info::float_format from_flt_fmt);
 
 #define TABLE_ELT(T, U, V, W) \
   conv_fptr_table[oct_data_conv::T][oct_data_conv::U] = convert_and_copy<V, W>
 
 #define FILL_TABLE_ROW(T, V) \
   TABLE_ELT (T, dt_int8, V, int8NDArray); \
   TABLE_ELT (T, dt_uint8, V, uint8NDArray); \
   TABLE_ELT (T, dt_int16, V, int16NDArray); \
@@ -6339,17 +6339,17 @@ typedef octave_value (*conv_fptr)
 
 octave_value
 octave_stream::finalize_read (std::list<void *>& input_buf_list,
                               octave_idx_type input_buf_elts,
                               octave_idx_type elts_read,
                               octave_idx_type nr, octave_idx_type nc,
                               oct_data_conv::data_type input_type,
                               oct_data_conv::data_type output_type,
-                              oct_mach_info::float_format ffmt)
+                              octave::mach_info::float_format ffmt)
 {
   octave_value retval;
 
   static bool initialized = false;
 
   // Table function pointers for return types x read types.
 
   static conv_fptr conv_fptr_table[oct_data_conv::dt_unknown][14];
@@ -6375,23 +6375,23 @@ octave_stream::finalize_read (std::list<
       FILL_TABLE_ROW (dt_uchar, unsigned char);
       FILL_TABLE_ROW (dt_logical, bool);
 
       initialized = true;
     }
 
   bool swap = false;
 
-  if (ffmt == oct_mach_info::flt_fmt_unknown)
+  if (ffmt == octave::mach_info::flt_fmt_unknown)
     ffmt = float_format ();
 
-  if (oct_mach_info::words_big_endian ())
-    swap = (ffmt == oct_mach_info::flt_fmt_ieee_little_endian);
+  if (octave::mach_info::words_big_endian ())
+    swap = (ffmt == octave::mach_info::flt_fmt_ieee_little_endian);
   else
-    swap = (ffmt == oct_mach_info::flt_fmt_ieee_big_endian);
+    swap = (ffmt == octave::mach_info::flt_fmt_ieee_big_endian);
 
   bool do_float_fmt_conv = ((input_type == oct_data_conv::dt_double
                              || input_type == oct_data_conv::dt_single)
                             && ffmt != float_format ());
 
   bool do_NA_conv = (output_type == oct_data_conv::dt_double);
 
   switch (output_type)
@@ -6424,17 +6424,17 @@ octave_stream::finalize_read (std::list<
 
   return retval;
 }
 
 octave_value
 octave_stream::read (const Array<double>& size, octave_idx_type block_size,
                      oct_data_conv::data_type input_type,
                      oct_data_conv::data_type output_type,
-                     octave_idx_type skip, oct_mach_info::float_format ffmt,
+                     octave_idx_type skip, octave::mach_info::float_format ffmt,
                      octave_idx_type& count)
 {
   octave_value retval;
 
   octave_idx_type nr = -1;
   octave_idx_type nc = -1;
 
   bool one_elt_size_spec = false;
@@ -6614,25 +6614,25 @@ octave_stream::read (const Array<double>
     }
 
   return retval;
 }
 
 octave_idx_type
 octave_stream::write (const octave_value& data, octave_idx_type block_size,
                       oct_data_conv::data_type output_type,
-                      octave_idx_type skip, oct_mach_info::float_format flt_fmt)
+                      octave_idx_type skip, octave::mach_info::float_format flt_fmt)
 {
   octave_idx_type retval = -1;
 
   if (! stream_ok ())
     invalid_operation ("fwrite", "writing");
   else
     {
-      if (flt_fmt == oct_mach_info::flt_fmt_unknown)
+      if (flt_fmt == octave::mach_info::flt_fmt_unknown)
         flt_fmt = float_format ();
 
       octave_idx_type status = data.write (*this, block_size, output_type,
                                            skip, flt_fmt);
 
       if (status < 0)
         error ("fwrite: write error");
       else
@@ -6688,26 +6688,26 @@ class ultimate_element_type<octave_int<T
 public:
   typedef T type;
 };
 
 template <typename T>
 static bool
 convert_data (const T *data, void *conv_data, octave_idx_type n_elts,
               oct_data_conv::data_type output_type,
-              oct_mach_info::float_format flt_fmt)
+              octave::mach_info::float_format flt_fmt)
 {
   bool retval = true;
 
   bool swap
-    = ((oct_mach_info::words_big_endian ()
-        && flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian)
-       || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
-
-  bool do_float_conversion = flt_fmt != oct_mach_info::float_format ();
+    = ((octave::mach_info::words_big_endian ()
+        && flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian)
+       || flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
+
+  bool do_float_conversion = flt_fmt != octave::mach_info::float_format ();
 
   typedef typename ultimate_element_type<T>::type ult_elt_type;
 
   switch (output_type)
     {
     case oct_data_conv::dt_char:
       convert_chars<ult_elt_type, char> (data, conv_data, n_elts);
       break;
@@ -6853,24 +6853,24 @@ octave_stream::skip_bytes (size_t skip)
   return status;
 }
 
 template <typename T>
 octave_idx_type
 octave_stream::write (const Array<T>& data, octave_idx_type block_size,
                       oct_data_conv::data_type output_type,
                       octave_idx_type skip,
-                      oct_mach_info::float_format flt_fmt)
-{
-  bool swap = ((oct_mach_info::words_big_endian ()
-                && flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian)
-               || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
+                      octave::mach_info::float_format flt_fmt)
+{
+  bool swap = ((octave::mach_info::words_big_endian ()
+                && flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian)
+               || flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
 
   bool do_data_conversion = (swap || ! is_equivalent_type<T> (output_type)
-                             || flt_fmt != oct_mach_info::float_format ());
+                             || flt_fmt != octave::mach_info::float_format ());
 
   octave_idx_type nel = data.numel ();
 
   octave_idx_type chunk_size;
 
   if (skip != 0)
     chunk_size = block_size;
   else if (do_data_conversion)
@@ -6923,17 +6923,17 @@ octave_stream::write (const Array<T>& da
 }
 
 #define INSTANTIATE_WRITE(T) \
   template \
   octave_idx_type \
   octave_stream::write (const Array<T>& data, octave_idx_type block_size, \
                         oct_data_conv::data_type output_type, \
                         octave_idx_type skip, \
-                        oct_mach_info::float_format flt_fmt)
+                        octave::mach_info::float_format flt_fmt)
 
 INSTANTIATE_WRITE (octave_int8);
 INSTANTIATE_WRITE (octave_uint8);
 INSTANTIATE_WRITE (octave_int16);
 INSTANTIATE_WRITE (octave_uint16);
 INSTANTIATE_WRITE (octave_int32);
 INSTANTIATE_WRITE (octave_uint32);
 INSTANTIATE_WRITE (octave_int64);
@@ -7140,20 +7140,20 @@ octave_stream::mode (void) const
   int retval = 0;
 
   if (stream_ok ())
     retval = rep->mode ();
 
   return retval;
 }
 
-oct_mach_info::float_format
+octave::mach_info::float_format
 octave_stream::float_format (void) const
 {
-  oct_mach_info::float_format retval = oct_mach_info::flt_fmt_unknown;
+  octave::mach_info::float_format retval = octave::mach_info::flt_fmt_unknown;
 
   if (stream_ok ())
     retval = rep->float_format ();
 
   return retval;
 }
 
 std::string
@@ -7452,17 +7452,17 @@ octave_stream_list::do_get_info (int fid
 
   if (! os.is_valid ())
     ::error ("invalid file id = %d", fid);
 
   string_vector retval (3);
 
   retval(0) = os.name ();
   retval(1) = octave_stream::mode_as_string (os.mode ());
-  retval(2) = oct_mach_info::float_format_as_string (os.float_format ());
+  retval(2) = octave::mach_info::float_format_as_string (os.float_format ());
 
   return retval;
 }
 
 string_vector
 octave_stream_list::do_get_info (const octave_value& fid) const
 {
   int conv_err = 0;
@@ -7493,17 +7493,17 @@ octave_stream_list::do_list_open_files (
           << std::setw (4) << p->first << "     "
           // reset necessary in addition to setiosflags since this is one stmt.
           << std::resetiosflags (std::ios::adjustfield)
           << std::setiosflags (std::ios::left)
           << std::setw (3)
           << octave_stream::mode_as_string (os.mode ())
           << "  "
           << std::setw (9)
-          << oct_mach_info::float_format_as_string (os.float_format ())
+          << octave::mach_info::float_format_as_string (os.float_format ())
           << "  "
           << os.name () << "\n";
     }
 
   buf << "\n";
 
   return buf.str ();
 }
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -58,18 +58,18 @@ class
 OCTINTERP_API
 octave_base_stream
 {
   friend class octave_stream;
 
 public:
 
   octave_base_stream (std::ios::openmode arg_md = std::ios::in | std::ios::out,
-                      oct_mach_info::float_format ff
-                        = oct_mach_info::native_float_format ())
+                      octave::mach_info::float_format ff
+                        = octave::mach_info::native_float_format ())
     : count (0), md (arg_md), flt_fmt (ff), fail (false), open_state (true),
       errmsg ()
   { }
 
   virtual ~octave_base_stream (void) { }
 
   // The remaining functions are not specific to input or output only,
   // and must be provided by the derived classes.
@@ -136,17 +136,17 @@ public:
   // Return current error message for this stream.
 
   std::string error (bool clear, int& err_num);
 
 protected:
 
   int mode (void) const { return md; }
 
-  oct_mach_info::float_format float_format (void) const { return flt_fmt; }
+  octave::mach_info::float_format float_format (void) const { return flt_fmt; }
 
   // Set current error state and set fail to TRUE.
 
   void error (const std::string& msg);
   void error (const std::string& who, const std::string& msg);
 
   // Clear any error message and set fail to FALSE.
 
@@ -161,17 +161,17 @@ private:
   // A reference count.
   octave_refcount<octave_idx_type> count;
 
   // The permission bits for the file.  Should be some combination of
   // std::ios::open_mode bits.
   int md;
 
   // Data format.
-  oct_mach_info::float_format flt_fmt;
+  octave::mach_info::float_format flt_fmt;
 
   // TRUE if an error has occurred.
   bool fail;
 
   // TRUE if this stream is open.
   bool open_state;
 
   // Should contain error message if fail is TRUE.
@@ -276,33 +276,33 @@ public:
 
   bool is_open (void) const;
 
   void close (void);
 
   octave_value read (const Array<double>& size, octave_idx_type block_size,
                      oct_data_conv::data_type input_type,
                      oct_data_conv::data_type output_type,
-                     octave_idx_type skip, oct_mach_info::float_format flt_fmt,
+                     octave_idx_type skip, octave::mach_info::float_format flt_fmt,
                      octave_idx_type& count);
 
   octave_idx_type write (const octave_value& data, octave_idx_type block_size,
                          oct_data_conv::data_type output_type,
                          octave_idx_type skip,
-                         oct_mach_info::float_format flt_fmt);
+                         octave::mach_info::float_format flt_fmt);
 
   bool write_bytes (const void *data, size_t n_elts);
 
   bool skip_bytes (size_t n_elts);
 
   template <typename T>
   octave_idx_type write (const Array<T>& data, octave_idx_type block_size,
                          oct_data_conv::data_type output_type,
                          octave_idx_type skip,
-                         oct_mach_info::float_format flt_fmt);
+                         octave::mach_info::float_format flt_fmt);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
                       octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   octave_value scanf (const octave_value& fmt, const Array<double>& size,
                       octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   octave_value_list oscanf (const std::string& fmt,
@@ -351,17 +351,17 @@ public:
   bool ok (void) const { return rep && rep->ok (); }
 
   operator bool () const { return ok (); }
 
   std::string name (void) const;
 
   int mode (void) const;
 
-  oct_mach_info::float_format float_format (void) const;
+  octave::mach_info::float_format float_format (void) const;
 
   static std::string mode_as_string (int mode);
 
   std::istream *input_stream (void)
   {
     return rep ? rep->input_stream () : 0;
   }
 
@@ -400,17 +400,17 @@ private:
 
   octave_value
   finalize_read (std::list<void *>& input_buf_list,
                  octave_idx_type input_buf_elts,
                  octave_idx_type elts_read,
                  octave_idx_type nr, octave_idx_type nc,
                  oct_data_conv::data_type input_type,
                  oct_data_conv::data_type output_type,
-                 oct_mach_info::float_format ffmt);
+                 octave::mach_info::float_format ffmt);
 };
 
 class
 OCTINTERP_API
 octave_stream_list
 {
 protected:
 
diff --git a/libinterp/corefcn/oct-strstrm.cc b/libinterp/corefcn/oct-strstrm.cc
--- a/libinterp/corefcn/oct-strstrm.cc
+++ b/libinterp/corefcn/oct-strstrm.cc
@@ -45,26 +45,26 @@ octave_base_strstream::tell (void)
   // Note: error is inherited from octave_base_stream, not ::error.
   // This error function does not halt execution so "return ..." must exist.
   error ("ftell: invalid operation");
   return -1;
 }
 
 octave_stream
 octave_istrstream::create (const char *data, std::ios::openmode arg_md,
-                           oct_mach_info::float_format flt_fmt)
+                           octave::mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
 
 octave_stream
 octave_istrstream::create (const std::string& data, std::ios::openmode arg_md,
-                           oct_mach_info::float_format flt_fmt)
+                           octave::mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
 
 octave_stream
 octave_ostrstream::create (std::ios::openmode arg_md,
-                           oct_mach_info::float_format flt_fmt)
+                           octave::mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_ostrstream (arg_md, flt_fmt));
 }
diff --git a/libinterp/corefcn/oct-strstrm.h b/libinterp/corefcn/oct-strstrm.h
--- a/libinterp/corefcn/oct-strstrm.h
+++ b/libinterp/corefcn/oct-strstrm.h
@@ -31,18 +31,18 @@ along with Octave; see the file COPYING.
 #include "oct-stream.h"
 
 class
 octave_base_strstream : public octave_base_stream
 {
 public:
 
   octave_base_strstream (std::ios::openmode m = std::ios::out,
-                         oct_mach_info::float_format ff
-                           = oct_mach_info::native_float_format ())
+                         octave::mach_info::float_format ff
+                           = octave::mach_info::native_float_format ())
     : octave_base_stream (m, ff) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t, int);
 
   // Return current stream position.
 
@@ -73,35 +73,35 @@ private:
 
 class
 octave_istrstream : public octave_base_strstream
 {
 public:
 
   octave_istrstream (const char *data,
                      std::ios::openmode arg_md = std::ios::out,
-                     oct_mach_info::float_format ff
-                       = oct_mach_info::native_float_format ())
+                     octave::mach_info::float_format ff
+                       = octave::mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff), is (data) { }
 
   octave_istrstream (const std::string& data,
                      std::ios::openmode arg_md = std::ios::out,
-                     oct_mach_info::float_format ff
-                       = oct_mach_info::native_float_format ())
+                     octave::mach_info::float_format ff
+                       = octave::mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff), is (data.c_str ()) { }
 
   static octave_stream
   create (const char *data, std::ios::openmode arg_md = std::ios::out,
-          oct_mach_info::float_format ff
-            = oct_mach_info::native_float_format ());
+          octave::mach_info::float_format ff
+            = octave::mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& data, std::ios::openmode arg_md = std::ios::out,
-          oct_mach_info::float_format ff
-            = oct_mach_info::native_float_format ());
+          octave::mach_info::float_format ff
+            = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
   std::istream *input_stream (void) { return &is; }
 
   std::ostream *output_stream (void) { return 0; }
@@ -130,24 +130,24 @@ private:
 };
 
 class
 octave_ostrstream : public octave_base_strstream
 {
 public:
 
   octave_ostrstream (std::ios::openmode arg_md = std::ios::out,
-                     oct_mach_info::float_format ff
-                       = oct_mach_info::native_float_format ())
+                     octave::mach_info::float_format ff
+                       = octave::mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff), os () { }
 
   static octave_stream
   create (std::ios::openmode arg_md = std::ios::out,
-          oct_mach_info::float_format ff
-            = oct_mach_info::native_float_format ());
+          octave::mach_info::float_format ff
+            = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
 
   std::istream *input_stream (void) { return 0; }
 
   std::ostream *output_stream (void) { return &os; }
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -1472,43 +1472,43 @@ pr_any_float (const float_format *fmt, s
           tmp.d = d;
 
           // Unless explicitly asked for, always print in big-endian format.
 
           // FIXME: will bad things happen if we are
           // interrupted before resetting the format flags and fill
           // character?
 
-          oct_mach_info::float_format flt_fmt =
-            oct_mach_info::native_float_format ();
+          octave::mach_info::float_format flt_fmt =
+            octave::mach_info::native_float_format ();
 
           os.fill ('0');
           os.flags (std::ios::right | std::ios::hex);
 
           if (hex_format > 1
-              || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian)
+              || flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian)
             {
               for (size_t i = 0; i < sizeof (double); i++)
                 os << std::setw (2) << static_cast<int> (tmp.i[i]);
             }
           else
             {
               for (int i = sizeof (double) - 1; i >= 0; i--)
                 os << std::setw (2) << static_cast<int> (tmp.i[i]);
             }
         }
       else if (bit_format)
         {
           equiv tmp;
           tmp.d = d;
 
-          oct_mach_info::float_format flt_fmt =
-            oct_mach_info::native_float_format ();
-
-          if (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian)
+          octave::mach_info::float_format flt_fmt =
+            octave::mach_info::native_float_format ();
+
+          if (flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian)
             {
               for (size_t i = 0; i < sizeof (double); i++)
                 PRINT_CHAR_BITS (os, tmp.i[i]);
             }
           else
             {
               if (bit_format > 1)
                 {
@@ -3006,30 +3006,30 @@ pr_int (std::ostream& os, const T& d, in
   //   {bit,hex}_format == 2: print native
 
   if (hex_format)
     {
       octave_preserve_stream_state stream_state (os);
 
       os.flags (std::ios::right | std::ios::hex);
 
-      if (hex_format > 1 || oct_mach_info::words_big_endian ())
+      if (hex_format > 1 || octave::mach_info::words_big_endian ())
         {
           for (size_t i = 0; i < sz; i++)
             os << std::setw (2) << static_cast<int> (tmpi[i]);
         }
       else
         {
           for (int i = sz - 1; i >= 0; i--)
             os << std::setw (2) << static_cast<int> (tmpi[i]);
         }
     }
   else if (bit_format)
     {
-      if (oct_mach_info::words_big_endian ())
+      if (octave::mach_info::words_big_endian ())
         {
           for (size_t i = 0; i < sz; i++)
             PRINT_CHAR_BITS (os, tmpi[i]);
         }
       else
         {
           if (bit_format > 1)
             {
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -834,35 +834,35 @@ DEFUN (isieee, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isieee ()\n\
 Return true if your computer @emph{claims} to conform to the IEEE standard\n\
 for floating point calculations.\n\
 \n\
 No actual tests are performed.\n\
 @end deftypefn")
 {
-  oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
+  octave::mach_info::float_format flt_fmt = octave::mach_info::native_float_format ();
 
-  return ovl (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
-              || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
+  return ovl (flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian
+              || flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
 }
 
 /*
 %!assert (islogical (isieee ()))
 */
 
 DEFUN (native_float_format, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} native_float_format ()\n\
 Return the native floating point format as a string.\n\
 @end deftypefn")
 {
-  oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
+  octave::mach_info::float_format flt_fmt = octave::mach_info::native_float_format ();
 
-  return ovl (oct_mach_info::float_format_as_string (flt_fmt));
+  return ovl (octave::mach_info::float_format_as_string (flt_fmt));
 }
 
 /*
 %!assert (ischar (native_float_format ()))
 */
 
 DEFUN (tilde_expand, args, ,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1664,25 +1664,25 @@ specified option.\n\
 #endif
 
       config.assign ("unix", octave_value (unix_system));
       config.assign ("mac", octave_value (mac_system));
       config.assign ("windows", octave_value (windows_system));
 
       config.assign ("dld", octave_value (octave_supports_dynamic_linking));
 
-      oct_mach_info::float_format ff = oct_mach_info::native_float_format ();
+      octave::mach_info::float_format ff = octave::mach_info::native_float_format ();
       config.assign ("float_format",
-                     octave_value (oct_mach_info::float_format_as_string (ff)));
+                     octave_value (octave::mach_info::float_format_as_string (ff)));
 
       config.assign ("words_big_endian",
-                     octave_value (oct_mach_info::words_big_endian ()));
+                     octave_value (octave::mach_info::words_big_endian ()));
 
       config.assign ("words_little_endian",
-                     octave_value (oct_mach_info::words_little_endian ()));
+                     octave_value (octave::mach_info::words_little_endian ()));
 
       config.assign ("build_environment", octave_value (build_env));
 
       config.assign ("build_features", octave_value (build_features));
 
       initialized = true;
     }
 
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -592,17 +592,17 @@ octave_play_callback (const void *, void
           }
       }
       break;
 
     case 24:
       {
         static double scale_factor = std::pow (2.0, 23) - 1.0;
 
-        static int big_endian = oct_mach_info::words_big_endian ();
+        static int big_endian = octave::mach_info::words_big_endian ();
 
         uint8_t *buffer = static_cast<uint8_t *> (output);
 
         for (unsigned long i = 0; i < frames; i++)
           {
             int32_t sample_l = p_l[i];
             int32_t sample_r = p_r[i];
 
@@ -704,17 +704,17 @@ portaudio_play_callback (const void *, v
               }
           }
           break;
 
         case 24:
           {
             static double scale_factor = std::pow (2.0, 23) - 1.0;
 
-            static int big_endian = oct_mach_info::words_big_endian ();
+            static int big_endian = octave::mach_info::words_big_endian ();
 
             uint8_t *buffer = static_cast<uint8_t *> (output);
 
             for (unsigned long j = 0; j < frames; j++)
               {
                 unsigned int sample_number = player->get_sample_number ();
 
                 if (sample_number >= player->get_end_sample ())
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -547,17 +547,17 @@ octave_base_diag<DMT, MT>::print (std::o
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 template <typename DMT, typename MT>
 int
 octave_base_diag<DMT, MT>::write (octave_stream& os, int block_size,
                                   oct_data_conv::data_type output_type,
                                   int skip,
-                                  oct_mach_info::float_format flt_fmt) const
+                                  octave::mach_info::float_format flt_fmt) const
 {
   return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
 template <typename DMT, typename MT>
 void
 octave_base_diag<DMT, MT>::print_info (std::ostream& os,
                                        const std::string& prefix) const
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -201,17 +201,17 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const;
+             octave::mach_info::float_format flt_fmt) const;
 
   mxArray *as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_info (std::ostream& os, const std::string& prefix) const;
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -251,17 +251,17 @@ octave_base_int_matrix<T>::save_binary (
             this->byte_size ());
 
   return true;
 }
 
 template <typename T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
-                                        oct_mach_info::float_format)
+                                        octave::mach_info::float_format)
 {
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
@@ -515,17 +515,17 @@ octave_base_int_scalar<T>::save_binary (
 {
   os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size ());
   return true;
 }
 
 template <typename T>
 bool
 octave_base_int_scalar<T>::load_binary (std::istream& is, bool swap,
-                                        oct_mach_info::float_format)
+                                        octave::mach_info::float_format)
 {
   T tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size ()))
     return false;
 
   if (swap)
     switch (this->byte_size ())
       {
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -73,17 +73,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool&);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format);
+                    octave::mach_info::float_format);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 };
 
 // base int scalar values.
 
@@ -118,16 +118,16 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool&);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format);
+                    octave::mach_info::float_format);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -934,17 +934,17 @@ octave_base_value::load_ascii (std::istr
 bool
 octave_base_value::save_binary (std::ostream&, bool&)
 {
   err_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
 }
 
 bool
 octave_base_value::load_binary (std::istream&, bool,
-                                oct_mach_info::float_format)
+                                octave::mach_info::float_format)
 {
   err_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
 }
 
 bool
 octave_base_value::save_hdf5 (octave_hdf5_id, const char *, bool)
 {
   err_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
@@ -953,17 +953,17 @@ octave_base_value::save_hdf5 (octave_hdf
 bool
 octave_base_value::load_hdf5 (octave_hdf5_id, const char *)
 {
   err_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
 }
 
 int
 octave_base_value::write (octave_stream&, int, oct_data_conv::data_type,
-                          int, oct_mach_info::float_format) const
+                          int, octave::mach_info::float_format) const
 {
   err_wrong_type_arg ("octave_base_value::write()", type_name ());
 }
 
 mxArray *
 octave_base_value::as_mxArray (void) const
 {
   return 0;
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -640,28 +640,28 @@ public:
 
   virtual bool save_ascii (std::ostream& os);
 
   virtual bool load_ascii (std::istream& is);
 
   virtual bool save_binary (std::ostream& os, bool& save_as_floats);
 
   virtual bool load_binary (std::istream& is, bool swap,
-                            oct_mach_info::float_format fmt);
+                            octave::mach_info::float_format fmt);
 
   virtual bool
   save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   virtual bool
   load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   virtual int
   write (octave_stream& os, int block_size,
          oct_data_conv::data_type output_type, int skip,
-         oct_mach_info::float_format flt_fmt) const;
+         octave::mach_info::float_format flt_fmt) const;
 
   virtual void *mex_get_data (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_ir (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_jc (void) const { return 0; }
 
   virtual mxArray *as_mxArray (void) const;
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -312,17 +312,17 @@ octave_bool_matrix::save_binary (std::os
 
   os.write (htmp, nel);
 
   return true;
 }
 
 bool
 octave_bool_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format /* fmt */)
+                                 octave::mach_info::float_format /* fmt */)
 {
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -200,25 +200,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -257,17 +257,17 @@ octave_sparse_bool_matrix::save_binary (
 
   os.write (htmp, nz);
 
   return true;
 }
 
 bool
 octave_sparse_bool_matrix::load_binary (std::istream& is, bool swap,
-                                        oct_mach_info::float_format /* fmt */)
+                                        octave::mach_info::float_format /* fmt */)
 {
   int32_t nz, nc, nr, tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -130,17 +130,17 @@ public:
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
   { return matrix; }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -147,17 +147,17 @@ octave_bool::save_binary (std::ostream& 
   char tmp = (scalar ? 1 : 0);
   os.write (reinterpret_cast<char *> (&tmp), 1);
 
   return true;
 }
 
 bool
 octave_bool::load_binary (std::istream& is, bool /* swap */,
-                          oct_mach_info::float_format /* fmt */)
+                          octave::mach_info::float_format /* fmt */)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   scalar = (tmp ? 1 : 0);
   return true;
 }
 
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -213,25 +213,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     return os.write (bool_array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -884,17 +884,17 @@ octave_cell::save_binary (std::ostream& 
         return false;
     }
 
   return true;
 }
 
 bool
 octave_cell::load_binary (std::istream& is, bool swap,
-                          oct_mach_info::float_format fmt)
+                          octave::mach_info::float_format fmt)
 {
   clear_cellstr_cache ();
 
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -158,17 +158,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   octave_value map (unary_mapper_t umap) const;
 
   mxArray *as_mxArray (void) const;
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1307,17 +1307,17 @@ octave_class::save_binary (std::ostream&
       i++;
     }
 
   return true;
 }
 
 bool
 octave_class::load_binary (std::istream& is, bool swap,
-                           oct_mach_info::float_format fmt)
+                           octave::mach_info::float_format fmt)
 {
   bool success = true;
 
   int32_t classname_len;
 
   is.read (reinterpret_cast<char *> (&classname_len), 4);
   if (! is)
     return false;
diff --git a/libinterp/octave-value/ov-class.h b/libinterp/octave-value/ov-class.h
--- a/libinterp/octave-value/ov-class.h
+++ b/libinterp/octave-value/ov-class.h
@@ -191,17 +191,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
 private:
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -326,17 +326,17 @@ octave_complex::save_binary (std::ostrea
   Complex ctmp = complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 16);
 
   return true;
 }
 
 bool
 octave_complex::load_binary (std::istream& is, bool swap,
-                             oct_mach_info::float_format fmt)
+                             octave::mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   Complex ctmp;
   read_doubles (is, reinterpret_cast<double *> (&ctmp),
                 static_cast<save_type> (tmp), 2, swap, fmt);
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -166,25 +166,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (array_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
 
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -194,17 +194,17 @@ octave_complex_diag_matrix::save_binary 
   write_doubles (os, reinterpret_cast<const double *> (mtmp), st,
                  2 * m.numel ());
 
   return true;
 }
 
 bool
 octave_complex_diag_matrix::load_binary (std::istream& is, bool swap,
-                                         oct_mach_info::float_format fmt)
+                                         octave::mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/libinterp/octave-value/ov-cx-diag.h b/libinterp/octave-value/ov-cx-diag.h
--- a/libinterp/octave-value/ov-cx-diag.h
+++ b/libinterp/octave-value/ov-cx-diag.h
@@ -77,17 +77,17 @@ public:
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&,
                          Complex&) const;
 
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -447,17 +447,17 @@ octave_complex_matrix::save_binary (std:
   write_doubles (os, reinterpret_cast<const double *> (mtmp), st,
                  2 * dv.numel ());
 
   return true;
 }
 
 bool
 octave_complex_matrix::load_binary (std::istream& is, bool swap,
-                                    oct_mach_info::float_format fmt)
+                                    octave::mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -150,25 +150,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -287,17 +287,17 @@ octave_sparse_complex_matrix::save_binar
   write_doubles (os, reinterpret_cast<const double *> (matrix.data ()), st,
                  2 * nz);
 
   return true;
 }
 
 bool
 octave_sparse_complex_matrix::load_binary (std::istream& is, bool swap,
-                                           oct_mach_info::float_format fmt)
+                                           octave::mach_info::float_format fmt)
 {
   int32_t nz, nc, nr, tmp;
   char ctmp;
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -125,28 +125,28 @@ public:
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
   { return matrix; }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const;
 
 #if 0
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -559,17 +559,17 @@ octave_fcn_handle::save_binary (std::ost
       os.write (buf_str.c_str (), buf_str.length ());
     }
 
   return true;
 }
 
 bool
 octave_fcn_handle::load_binary (std::istream& is, bool swap,
-                                oct_mach_info::float_format fmt)
+                                octave::mach_info::float_format fmt)
 {
   bool success = true;
 
   int32_t tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
   if (swap)
     swap_bytes<4> (&tmp);
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -141,17 +141,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -209,17 +209,17 @@ octave_fcn_inline::save_binary (std::ost
   tmp = iftext.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   os.write (iftext.c_str (), iftext.length ());
   return true;
 }
 
 bool
 octave_fcn_inline::load_binary (std::istream& is, bool swap,
-                                oct_mach_info::float_format)
+                                octave::mach_info::float_format)
 {
   int32_t nargs;
   if (! is.read (reinterpret_cast<char *> (&nargs), 4))
     return false;
   if (swap)
     swap_bytes<4> (&nargs);
 
   if (nargs < 1)
diff --git a/libinterp/octave-value/ov-fcn-inline.h b/libinterp/octave-value/ov-fcn-inline.h
--- a/libinterp/octave-value/ov-fcn-inline.h
+++ b/libinterp/octave-value/ov-fcn-inline.h
@@ -74,17 +74,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -159,17 +159,17 @@ octave_float_scalar::save_binary (std::o
   float dtmp = float_value ();
   os.write (reinterpret_cast<char *> (&dtmp), 4);
 
   return true;
 }
 
 bool
 octave_float_scalar::load_binary (std::istream& is, bool swap,
-                                  oct_mach_info::float_format fmt)
+                                  octave::mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   float dtmp;
   read_floats (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
 
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -226,25 +226,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     return os.write (array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -276,17 +276,17 @@ octave_float_complex::save_binary (std::
   FloatComplex ctmp = float_complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 8);
 
   return true;
 }
 
 bool
 octave_float_complex::load_binary (std::istream& is, bool swap,
-                                   oct_mach_info::float_format fmt)
+                                   octave::mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   FloatComplex ctmp;
   read_floats (is, reinterpret_cast<float *> (&ctmp),
                static_cast<save_type> (tmp), 2, swap, fmt);
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -162,25 +162,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (array_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
 
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -166,17 +166,17 @@ octave_float_complex_diag_matrix::save_b
   const FloatComplex *mtmp = m.data ();
   write_floats (os, reinterpret_cast<const float *> (mtmp), st, 2 * m.numel ());
 
   return true;
 }
 
 bool
 octave_float_complex_diag_matrix::load_binary (std::istream& is, bool swap,
-                                               oct_mach_info::float_format fmt)
+                                               octave::mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/libinterp/octave-value/ov-flt-cx-diag.h b/libinterp/octave-value/ov-flt-cx-diag.h
--- a/libinterp/octave-value/ov-flt-cx-diag.h
+++ b/libinterp/octave-value/ov-flt-cx-diag.h
@@ -75,17 +75,17 @@ public:
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&,
                          FloatComplex&) const;
 
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -410,17 +410,17 @@ octave_float_complex_matrix::save_binary
   write_floats (os, reinterpret_cast<const float *> (mtmp), st,
                 2 * dv.numel ());
 
   return true;
 }
 
 bool
 octave_float_complex_matrix::load_binary (std::istream& is, bool swap,
-                                          oct_mach_info::float_format fmt)
+                                          octave::mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -146,25 +146,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -135,17 +135,17 @@ octave_float_diag_matrix::save_binary (s
   const float *mtmp = m.data ();
   write_floats (os, mtmp, st, m.numel ());
 
   return true;
 }
 
 bool
 octave_float_diag_matrix::load_binary (std::istream& is, bool swap,
-                                       oct_mach_info::float_format fmt)
+                                       octave::mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/libinterp/octave-value/ov-flt-re-diag.h b/libinterp/octave-value/ov-flt-re-diag.h
--- a/libinterp/octave-value/ov-flt-re-diag.h
+++ b/libinterp/octave-value/ov-flt-re-diag.h
@@ -75,17 +75,17 @@ public:
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&,
                          float&) const;
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -431,17 +431,17 @@ octave_float_matrix::save_binary (std::o
   const float *mtmp = m.data ();
   write_floats (os, mtmp, st, dv.numel ());
 
   return true;
 }
 
 bool
 octave_float_matrix::load_binary (std::istream& is, bool swap,
-                                  oct_mach_info::float_format fmt)
+                                  octave::mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
diff --git a/libinterp/octave-value/ov-flt-re-mat.h b/libinterp/octave-value/ov-flt-re-mat.h
--- a/libinterp/octave-value/ov-flt-re-mat.h
+++ b/libinterp/octave-value/ov-flt-re-mat.h
@@ -184,25 +184,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -301,17 +301,17 @@ public:
 
   idx_vector index_vector (bool /* require_integers */ = false) const
   {
     return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix));
   }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const
   {
@@ -609,17 +609,17 @@ public:
   {
     scalar -= OCTAVE_INT_T (1);
   }
 
   idx_vector index_vector (bool /* require_integers */ = false) const { return idx_vector (scalar); }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, octave_idx_type skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     return os.write (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (),
                      block_size, output_type, skip, flt_fmt);
   }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return scalar.mex_get_data (); }
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2105,17 +2105,17 @@ octave_java::save_binary (std::ostream& 
 {
   warning ("save: unable to save java objects, skipping");
 
   return true;
 }
 
 bool
 octave_java::load_binary (std::istream& /* is */, bool /* swap*/,
-                          oct_mach_info::float_format /* fmt */)
+                          octave::mach_info::float_format /* fmt */)
 {
   // Silently skip over java object that was not saved
   return true;
 }
 
 bool
 octave_java::save_hdf5 (octave_hdf5_id /* loc_id */, const char * /* name */,
                         bool /* save_as_floats */)
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -74,17 +74,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name,
                   bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   octave_value_list
   subsref (const std::string& type,
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -180,17 +180,17 @@ bool octave_lazy_index::load_ascii (std:
 
 bool octave_lazy_index::save_binary (std::ostream& os, bool& save_as_floats)
 {
   return save_binary_data (os, make_value (), value_save_tag,
                            "", false, save_as_floats);
 }
 
 bool octave_lazy_index::load_binary (std::istream& is, bool swap,
-                                     oct_mach_info::float_format fmt)
+                                     octave::mach_info::float_format fmt)
 {
   bool dummy;
   std::string doc;
 
   std::string nm = read_binary_data (is, swap, fmt, "", dummy, value, doc);
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
 
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -200,22 +200,22 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   { return make_value ().write (os, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const
   { return make_value ().mex_get_data (); }
 
   mxArray *as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -127,17 +127,17 @@ octave_oncleanup::save_binary (std::ostr
 {
   warning ("save: unable to save onCleanup variables, skipping");
 
   return true;
 }
 
 bool
 octave_oncleanup::load_binary (std::istream& /* is */, bool /* swap */,
-                               oct_mach_info::float_format /* fmt */)
+                               octave::mach_info::float_format /* fmt */)
 {
   // Silently skip object that was not saved
   return true;
 }
 
 bool
 octave_oncleanup::save_hdf5 (octave_hdf5_id /* loc_id */,
                              const char * /* name */,
diff --git a/libinterp/octave-value/ov-oncleanup.h b/libinterp/octave-value/ov-oncleanup.h
--- a/libinterp/octave-value/ov-oncleanup.h
+++ b/libinterp/octave-value/ov-oncleanup.h
@@ -70,17 +70,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -309,17 +309,17 @@ octave_perm_matrix::save_binary (std::os
   os.write (reinterpret_cast<const char *> (col_perm.data ()),
                                             col_perm.byte_size ());
 
   return true;
 }
 
 bool
 octave_perm_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format)
+                                 octave::mach_info::float_format)
 {
   int32_t sz;
   bool colp;
   if (! (is.read (reinterpret_cast<char *> (&sz), 4)
          && is.read (reinterpret_cast<char *> (&colp), 1)))
     return false;
 
   MArray<octave_idx_type> m (dim_vector (sz, 1));
@@ -379,17 +379,17 @@ octave_perm_matrix::print (std::ostream&
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 int
 octave_perm_matrix::write (octave_stream& os, int block_size,
                            oct_data_conv::data_type output_type, int skip,
-                           oct_mach_info::float_format flt_fmt) const
+                           octave::mach_info::float_format flt_fmt) const
 {
   return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
 void
 octave_perm_matrix::print_info (std::ostream& os,
                                 const std::string& prefix) const
 {
diff --git a/libinterp/octave-value/ov-perm.h b/libinterp/octave-value/ov-perm.h
--- a/libinterp/octave-value/ov-perm.h
+++ b/libinterp/octave-value/ov-perm.h
@@ -198,21 +198,21 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const;
+             octave::mach_info::float_format flt_fmt) const;
 
   mxArray *as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_info (std::ostream& os, const std::string& prefix) const;
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -491,17 +491,17 @@ octave_range::save_binary (std::ostream&
   os.write (reinterpret_cast<char *> (&lim), 8);
   os.write (reinterpret_cast<char *> (&inc), 8);
 
   return true;
 }
 
 bool
 octave_range::load_binary (std::istream& is, bool swap,
-                           oct_mach_info::float_format /* fmt */)
+                           octave::mach_info::float_format /* fmt */)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   double bas, lim, inc;
   if (! is.read (reinterpret_cast<char *> (&bas), 8))
     return false;
   if (swap)
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -260,25 +260,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     // FIXME: could be more memory efficient by having a
     // special case of the octave_stream::write method for ranges.
 
     return os.write (matrix_value (), block_size, output_type, skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -212,17 +212,17 @@ octave_diag_matrix::save_binary (std::os
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, m.numel ());
 
   return true;
 }
 
 bool
 octave_diag_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format fmt)
+                                 octave::mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/libinterp/octave-value/ov-re-diag.h b/libinterp/octave-value/ov-re-diag.h
--- a/libinterp/octave-value/ov-re-diag.h
+++ b/libinterp/octave-value/ov-re-diag.h
@@ -80,17 +80,17 @@ public:
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&,
                          double&) const;
 
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -544,17 +544,17 @@ octave_matrix::save_binary (std::ostream
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, dv.numel ());
 
   return true;
 }
 
 bool
 octave_matrix::load_binary (std::istream& is, bool swap,
-                            oct_mach_info::float_format fmt)
+                            octave::mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
diff --git a/libinterp/octave-value/ov-re-mat.h b/libinterp/octave-value/ov-re-mat.h
--- a/libinterp/octave-value/ov-re-mat.h
+++ b/libinterp/octave-value/ov-re-mat.h
@@ -208,25 +208,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -310,17 +310,17 @@ octave_sparse_matrix::save_binary (std::
 
   write_doubles (os, matrix.data (), st, nz);
 
   return true;
 }
 
 bool
 octave_sparse_matrix::load_binary (std::istream& is, bool swap,
-                                   oct_mach_info::float_format fmt)
+                                   octave::mach_info::float_format fmt)
 {
   int32_t nz, nc, nr, tmp;
   char ctmp;
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -132,24 +132,24 @@ public:
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
 #if 0
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -181,17 +181,17 @@ octave_scalar::save_binary (std::ostream
   double dtmp = double_value ();
   os.write (reinterpret_cast<char *> (&dtmp), 8);
 
   return true;
 }
 
 bool
 octave_scalar::load_binary (std::istream& is, bool swap,
-                            oct_mach_info::float_format fmt)
+                            octave::mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   double dtmp;
   read_doubles (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
 
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -225,25 +225,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   {
     return os.write (array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -450,17 +450,17 @@ octave_char_matrix_str::save_binary (std
 
   charNDArray m = char_array_value ();
   os.write (m.fortran_vec (), dv.numel ());
   return true;
 }
 
 bool
 octave_char_matrix_str::load_binary (std::istream& is, bool swap,
-                                     oct_mach_info::float_format /* fmt */)
+                                     octave::mach_info::float_format /* fmt */)
 {
   int32_t elements;
   if (! is.read (reinterpret_cast<char *> (&elements), 4))
     return false;
   if (swap)
     swap_bytes<4> (&elements);
 
   if (elements < 0)
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -150,25 +150,25 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const
+             octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
 protected:
 
   octave_value do_index_op_internal (const octave_value_list& idx,
                                      bool resize_ok, char type = '"');
 
 private:
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -796,17 +796,17 @@ octave_struct::save_binary (std::ostream
         return ! os.fail ();
     }
 
   return true;
 }
 
 bool
 octave_struct::load_binary (std::istream& is, bool swap,
-                            oct_mach_info::float_format fmt)
+                            octave::mach_info::float_format fmt)
 {
   bool success = true;
   int32_t len;
   if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
@@ -1427,17 +1427,17 @@ octave_scalar_struct::save_binary (std::
         return ! os.fail ();
     }
 
   return true;
 }
 
 bool
 octave_scalar_struct::load_binary (std::istream& is, bool swap,
-                                   oct_mach_info::float_format fmt)
+                                   octave::mach_info::float_format fmt)
 {
   bool success = true;
   int32_t len;
   if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
diff --git a/libinterp/octave-value/ov-struct.h b/libinterp/octave-value/ov-struct.h
--- a/libinterp/octave-value/ov-struct.h
+++ b/libinterp/octave-value/ov-struct.h
@@ -135,17 +135,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   octave_value
@@ -255,17 +255,17 @@ public:
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
+                    octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1933,17 +1933,17 @@ octave_value::make_storable_value (void)
     }
   else
     maybe_economize ();
 }
 
 int
 octave_value::write (octave_stream& os, int block_size,
                      oct_data_conv::data_type output_type, int skip,
-                     oct_mach_info::float_format flt_fmt) const
+                     octave::mach_info::float_format flt_fmt) const
 {
   return rep->write (os, block_size, output_type, skip, flt_fmt);
 }
 
 OCTAVE_NORETURN static void
 err_binary_op (const std::string& on, const std::string& tn1,
                const std::string& tn2)
 {
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1266,29 +1266,29 @@ public:
   bool save_ascii (std::ostream& os) { return rep->save_ascii (os); }
 
   bool load_ascii (std::istream& is) { return rep->load_ascii (is); }
 
   bool save_binary (std::ostream& os, bool& save_as_floats)
   { return rep->save_binary (os, save_as_floats); }
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt)
+                    octave::mach_info::float_format fmt)
   { return rep->load_binary (is, swap, fmt); }
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name,
                   bool save_as_floats)
   { return rep->save_hdf5 (loc_id, name, save_as_floats); }
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name)
   { return rep->load_hdf5 (loc_id, name); }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
-             oct_mach_info::float_format flt_fmt) const;
+             octave::mach_info::float_format flt_fmt) const;
 
   octave_base_value *internal_rep (void) const { return rep; }
 
   // Unsafe.  These functions exist to support the MEX interface.
   // You should not use them anywhere else.
   void *mex_get_data (void) const { return rep->mex_get_data (); }
 
   octave_idx_type *mex_get_ir (void) const { return rep->mex_get_ir (); }
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -105,21 +105,21 @@ octave_rand::instance_ok (void)
 }
 
 double
 octave_rand::do_seed (void)
 {
   union d2i { double d; int32_t i[2]; };
   union d2i u;
 
-  oct_mach_info::float_format ff = oct_mach_info::native_float_format ();
+  octave::mach_info::float_format ff = octave::mach_info::native_float_format ();
 
   switch (ff)
     {
-    case oct_mach_info::flt_fmt_ieee_big_endian:
+    case octave::mach_info::flt_fmt_ieee_big_endian:
       F77_FUNC (getsd, GETSD) (u.i[1], u.i[0]);
       break;
     default:
       F77_FUNC (getsd, GETSD) (u.i[0], u.i[1]);
       break;
     }
 
   return u.d;
@@ -145,21 +145,21 @@ octave_rand::do_seed (double s)
 {
   use_old_generators = true;
 
   int i0, i1;
   union d2i { double d; int32_t i[2]; };
   union d2i u;
   u.d = s;
 
-  oct_mach_info::float_format ff = oct_mach_info::native_float_format ();
+  octave::mach_info::float_format ff = octave::mach_info::native_float_format ();
 
   switch (ff)
     {
-    case oct_mach_info::flt_fmt_ieee_big_endian:
+    case octave::mach_info::flt_fmt_ieee_big_endian:
       i1 = force_to_fit_range (u.i[0], 1, 2147483563);
       i0 = force_to_fit_range (u.i[1], 1, 2147483399);
       break;
     default:
       i0 = force_to_fit_range (u.i[0], 1, 2147483563);
       i1 = force_to_fit_range (u.i[1], 1, 2147483399);
       break;
     }
diff --git a/liboctave/system/mach-info.cc b/liboctave/system/mach-info.cc
--- a/liboctave/system/mach-info.cc
+++ b/liboctave/system/mach-info.cc
@@ -29,191 +29,194 @@ along with Octave; see the file COPYING.
 #include "mach-info.h"
 #include "singleton-cleanup.h"
 
 extern "C"
 {
   double F77_FUNC (d1mach, D1MACH) (const octave_idx_type&);
 }
 
-oct_mach_info *oct_mach_info::instance = 0;
-
-union equiv
+namespace octave
 {
-  double d;
-  int i[2];
-};
+  mach_info *mach_info::instance = 0;
 
-struct
-float_params
-{
-  oct_mach_info::float_format fp_fmt;
-  equiv fp_par[4];
-};
+  union equiv
+  {
+    double d;
+    int i[2];
+  };
+
+  struct
+  float_params
+  {
+    mach_info::float_format fp_fmt;
+    equiv fp_par[4];
+  };
 
-#define INIT_FLT_PAR(fp, fmt, sm1, sm2, lrg1, lrg2, rt1, rt2, dv1, dv2) \
-  do \
-    { \
-      fp.fp_fmt = (fmt); \
-      fp.fp_par[0].i[0] = (sm1);  fp.fp_par[0].i[1] = (sm2); \
-      fp.fp_par[1].i[0] = (lrg1); fp.fp_par[1].i[1] = (lrg2); \
-      fp.fp_par[2].i[0] = (rt1);  fp.fp_par[2].i[1] = (rt2); \
-      fp.fp_par[3].i[0] = (dv1);  fp.fp_par[3].i[1] = (dv2); \
-    } \
-  while (0)
+  #define INIT_FLT_PAR(fp, fmt, sm1, sm2, lrg1, lrg2, rt1, rt2, dv1, dv2) \
+    do \
+      { \
+        fp.fp_fmt = (fmt); \
+        fp.fp_par[0].i[0] = (sm1);  fp.fp_par[0].i[1] = (sm2); \
+        fp.fp_par[1].i[0] = (lrg1); fp.fp_par[1].i[1] = (lrg2); \
+        fp.fp_par[2].i[0] = (rt1);  fp.fp_par[2].i[1] = (rt2); \
+        fp.fp_par[3].i[0] = (dv1);  fp.fp_par[3].i[1] = (dv2); \
+      } \
+    while (0)
 
-static int
-equiv_compare (const equiv *std, const equiv *v, int len)
-{
-  int i;
-  for (i = 0; i < len; i++)
-    if (v[i].i[0] != std[i].i[0] || v[i].i[1] != std[i].i[1])
-      return 0;
-  return 1;
-}
+  static int
+  equiv_compare (const equiv *std, const equiv *v, int len)
+  {
+    int i;
+    for (i = 0; i < len; i++)
+      if (v[i].i[0] != std[i].i[0] || v[i].i[1] != std[i].i[1])
+        return 0;
+    return 1;
+  }
 
-static oct_mach_info::float_format
-get_float_format (void)
-{
-  oct_mach_info::float_format retval = oct_mach_info::flt_fmt_unknown;
-
-  float_params fp[5];
+  static mach_info::float_format
+  get_float_format (void)
+  {
+    mach_info::float_format retval = mach_info::flt_fmt_unknown;
 
-  INIT_FLT_PAR (fp[0], oct_mach_info::flt_fmt_ieee_big_endian,
-                   1048576,  0,
-                2146435071, -1,
-                1017118720,  0,
-                1018167296,  0);
+    float_params fp[5];
+
+    INIT_FLT_PAR (fp[0], mach_info::flt_fmt_ieee_big_endian,
+                     1048576,  0,
+                  2146435071, -1,
+                  1017118720,  0,
+                  1018167296,  0);
 
-  INIT_FLT_PAR (fp[1], oct_mach_info::flt_fmt_ieee_little_endian,
-                 0,    1048576,
-                -1, 2146435071,
-                 0, 1017118720,
-                 0, 1018167296);
+    INIT_FLT_PAR (fp[1], mach_info::flt_fmt_ieee_little_endian,
+                   0,    1048576,
+                  -1, 2146435071,
+                   0, 1017118720,
+                   0, 1018167296);
 
-  INIT_FLT_PAR (fp[4], oct_mach_info::flt_fmt_unknown,
-                0, 0,
-                0, 0,
-                0, 0,
-                0, 0);
+    INIT_FLT_PAR (fp[4], mach_info::flt_fmt_unknown,
+                  0, 0,
+                  0, 0,
+                  0, 0,
+                  0, 0);
 
-  equiv mach_fp_par[4];
+    equiv mach_fp_par[4];
 
-  mach_fp_par[0].d = F77_FUNC (d1mach, D1MACH) (1);
-  mach_fp_par[1].d = F77_FUNC (d1mach, D1MACH) (2);
-  mach_fp_par[2].d = F77_FUNC (d1mach, D1MACH) (3);
-  mach_fp_par[3].d = F77_FUNC (d1mach, D1MACH) (4);
+    mach_fp_par[0].d = F77_FUNC (d1mach, D1MACH) (1);
+    mach_fp_par[1].d = F77_FUNC (d1mach, D1MACH) (2);
+    mach_fp_par[2].d = F77_FUNC (d1mach, D1MACH) (3);
+    mach_fp_par[3].d = F77_FUNC (d1mach, D1MACH) (4);
 
-  int i = 0;
-  do
-    {
-      if (equiv_compare (fp[i].fp_par, mach_fp_par, 4))
-        {
-          retval = fp[i].fp_fmt;
-          break;
-        }
-    }
-  while (fp[++i].fp_fmt != oct_mach_info::flt_fmt_unknown);
+    int i = 0;
+    do
+      {
+        if (equiv_compare (fp[i].fp_par, mach_fp_par, 4))
+          {
+            retval = fp[i].fp_fmt;
+            break;
+          }
+      }
+    while (fp[++i].fp_fmt != mach_info::flt_fmt_unknown);
 
-  return retval;
-}
+    return retval;
+  }
 
-static bool
-ten_little_endians (void)
-{
-  // Are we little or big endian?  From Harbison & Steele.
-
-  union
+  static bool
+  ten_little_endians (void)
   {
-    long l;
-    char c[sizeof (long)];
-  } u;
+    // Are we little or big endian?  From Harbison & Steele.
 
-  u.l = 1;
+    union
+    {
+      long l;
+      char c[sizeof (long)];
+    } u;
 
-  return (u.c[sizeof (long) - 1] == 1);
-}
+    u.l = 1;
 
-oct_mach_info::oct_mach_info (void)
-  : native_float_fmt (get_float_format ()),
-    big_chief (ten_little_endians ()) { }
+    return (u.c[sizeof (long) - 1] == 1);
+  }
 
-bool
-oct_mach_info::instance_ok (void)
-{
-  bool retval = true;
+  mach_info::mach_info (void)
+    : native_float_fmt (get_float_format ()),
+      big_chief (ten_little_endians ()) { }
 
-  if (! instance)
-    {
-      instance = new oct_mach_info ();
+  bool
+  mach_info::instance_ok (void)
+  {
+    bool retval = true;
 
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
-    }
+    if (! instance)
+      {
+        instance = new mach_info ();
 
-  if (! instance)
-    (*current_liboctave_error_handler)
-      ("unable to create command history object!");
-
-  return retval;
-}
+        if (instance)
+          singleton_cleanup_list::add (cleanup_instance);
+      }
 
-oct_mach_info::float_format
-oct_mach_info::native_float_format (void)
-{
-  return (instance_ok ())
-         ? instance->native_float_fmt : oct_mach_info::flt_fmt_unknown;
-}
+    if (! instance)
+      (*current_liboctave_error_handler)
+        ("unable to create command history object!");
+
+    return retval;
+  }
 
-bool
-oct_mach_info::words_big_endian (void)
-{
-  return (instance_ok ())
-         ? instance->big_chief : false;
-}
+  mach_info::float_format
+  mach_info::native_float_format (void)
+  {
+    return (instance_ok ())
+           ? instance->native_float_fmt : mach_info::flt_fmt_unknown;
+  }
 
-bool
-oct_mach_info::words_little_endian (void)
-{
-  return (instance_ok ())
-         ? (! instance->big_chief) : false;
-}
+  bool
+  mach_info::words_big_endian (void)
+  {
+    return (instance_ok ())
+           ? instance->big_chief : false;
+  }
 
-oct_mach_info::float_format
-oct_mach_info::string_to_float_format (const std::string& s)
-{
-  oct_mach_info::float_format retval = oct_mach_info::flt_fmt_unknown;
+  bool
+  mach_info::words_little_endian (void)
+  {
+    return (instance_ok ())
+           ? (! instance->big_chief) : false;
+  }
 
-  if (s == "native" || s == "n")
-    retval = oct_mach_info::native_float_format ();
-  else if (s == "ieee-be" || s == "b")
-    retval = oct_mach_info::flt_fmt_ieee_big_endian;
-  else if (s == "ieee-le" || s == "l")
-    retval = oct_mach_info::flt_fmt_ieee_little_endian;
-  else if (s == "unknown")
-    retval = oct_mach_info::flt_fmt_unknown;
-  else
-    (*current_liboctave_error_handler) ("invalid architecture type specified");
+  mach_info::float_format
+  mach_info::string_to_float_format (const std::string& s)
+  {
+    mach_info::float_format retval = mach_info::flt_fmt_unknown;
 
-  return retval;
-}
+    if (s == "native" || s == "n")
+      retval = mach_info::native_float_format ();
+    else if (s == "ieee-be" || s == "b")
+      retval = mach_info::flt_fmt_ieee_big_endian;
+    else if (s == "ieee-le" || s == "l")
+      retval = mach_info::flt_fmt_ieee_little_endian;
+    else if (s == "unknown")
+      retval = mach_info::flt_fmt_unknown;
+    else
+      (*current_liboctave_error_handler) ("invalid architecture type specified");
 
-std::string
-oct_mach_info::float_format_as_string (float_format flt_fmt)
-{
-  std::string retval = "unknown";
+    return retval;
+  }
 
-  switch (flt_fmt)
-    {
-    case flt_fmt_ieee_big_endian:
-      retval = "ieee-be";
-      break;
+  std::string
+  mach_info::float_format_as_string (float_format flt_fmt)
+  {
+    std::string retval = "unknown";
+
+    switch (flt_fmt)
+      {
+      case flt_fmt_ieee_big_endian:
+        retval = "ieee-be";
+        break;
 
-    case flt_fmt_ieee_little_endian:
-      retval = "ieee-le";
-      break;
+      case flt_fmt_ieee_little_endian:
+        retval = "ieee-le";
+        break;
 
-    default:
-      break;
-    }
+      default:
+        break;
+      }
 
-  return retval;
+    return retval;
+  }
 }
diff --git a/liboctave/system/mach-info.h b/liboctave/system/mach-info.h
--- a/liboctave/system/mach-info.h
+++ b/liboctave/system/mach-info.h
@@ -22,57 +22,67 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_mach_info_h)
 #define octave_mach_info_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-class
-OCTAVE_API
-oct_mach_info
+namespace octave
 {
-protected:
+  class
+  OCTAVE_API
+  mach_info
+  {
+  protected:
 
-  oct_mach_info (void);
+    mach_info (void);
 
-public:
+  public:
 
-  enum float_format
-  {
-    flt_fmt_unknown,
-    flt_fmt_ieee_little_endian,
-    flt_fmt_ieee_big_endian,
-  };
+    enum float_format
+    {
+      flt_fmt_unknown,
+      flt_fmt_ieee_little_endian,
+      flt_fmt_ieee_big_endian,
+    };
 
-  static bool instance_ok (void);
+    static bool instance_ok (void);
+
+    static float_format native_float_format (void);
 
-  static float_format native_float_format (void);
+    static bool words_big_endian (void);
 
-  static bool words_big_endian (void);
+    static bool words_little_endian (void);
 
-  static bool words_little_endian (void);
+    static float_format string_to_float_format (const std::string&);
 
-  static float_format string_to_float_format (const std::string&);
+    static std::string float_format_as_string (float_format);
 
-  static std::string float_format_as_string (float_format);
+  private:
 
-private:
+    static mach_info *instance;
 
-  static oct_mach_info *instance;
+    static void cleanup_instance (void) { delete instance; instance = 0; }
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+    // The floating point format for the current machine.
+    mutable float_format native_float_fmt;
 
-  // The floating point format for the current machine.
-  mutable float_format native_float_fmt;
+    // TRUE if the byte order on this system is big endian.
+    mutable bool big_chief;
 
-  // TRUE if the byte order on this system is big endian.
-  mutable bool big_chief;
+    // No copying!
+
+    mach_info (const mach_info&);
 
-  // No copying!
+    mach_info& operator = (const mach_info&);
+  };
+}
 
-  oct_mach_info (const oct_mach_info&);
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  oct_mach_info& operator = (const oct_mach_info&);
-};
+OCTAVE_DEPRECATED ("use octave::mach_info instead")
+typedef octave::mach_info oct_mach_info;
 
 #endif
+
+#endif
diff --git a/liboctave/util/data-conv.cc b/liboctave/util/data-conv.cc
--- a/liboctave/util/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -647,45 +647,45 @@ IEEE_little_double_to_IEEE_big_double (v
 static void
 IEEE_little_float_to_IEEE_big_float (void *d, octave_idx_type len)
 {
   swap_bytes<4> (d, len);
 }
 
 void
 do_double_format_conversion (void *data, octave_idx_type len,
-                             oct_mach_info::float_format from_fmt,
-                             oct_mach_info::float_format to_fmt)
+                             octave::mach_info::float_format from_fmt,
+                             octave::mach_info::float_format to_fmt)
 {
   switch (to_fmt)
     {
-    case oct_mach_info::flt_fmt_ieee_little_endian:
+    case octave::mach_info::flt_fmt_ieee_little_endian:
       switch (from_fmt)
         {
-        case oct_mach_info::flt_fmt_ieee_little_endian:
+        case octave::mach_info::flt_fmt_ieee_little_endian:
           break;
 
-        case oct_mach_info::flt_fmt_ieee_big_endian:
+        case octave::mach_info::flt_fmt_ieee_big_endian:
           IEEE_big_double_to_IEEE_little_double (data, len);
           break;
 
         default:
           err_unrecognized_float_fmt ();
           break;
         }
       break;
 
-    case oct_mach_info::flt_fmt_ieee_big_endian:
+    case octave::mach_info::flt_fmt_ieee_big_endian:
       switch (from_fmt)
         {
-        case oct_mach_info::flt_fmt_ieee_little_endian:
+        case octave::mach_info::flt_fmt_ieee_little_endian:
           IEEE_little_double_to_IEEE_big_double (data, len);
           break;
 
-        case oct_mach_info::flt_fmt_ieee_big_endian:
+        case octave::mach_info::flt_fmt_ieee_big_endian:
           break;
 
         default:
           err_unrecognized_float_fmt ();
           break;
         }
       break;
 
@@ -694,45 +694,45 @@ do_double_format_conversion (void *data,
         ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
 do_float_format_conversion (void *data, octave_idx_type len,
-                            oct_mach_info::float_format from_fmt,
-                            oct_mach_info::float_format to_fmt)
+                            octave::mach_info::float_format from_fmt,
+                            octave::mach_info::float_format to_fmt)
 {
   switch (to_fmt)
     {
-    case oct_mach_info::flt_fmt_ieee_little_endian:
+    case octave::mach_info::flt_fmt_ieee_little_endian:
       switch (from_fmt)
         {
-        case oct_mach_info::flt_fmt_ieee_little_endian:
+        case octave::mach_info::flt_fmt_ieee_little_endian:
           break;
 
-        case oct_mach_info::flt_fmt_ieee_big_endian:
+        case octave::mach_info::flt_fmt_ieee_big_endian:
           IEEE_big_float_to_IEEE_little_float (data, len);
           break;
 
         default:
           err_unrecognized_float_fmt ();
           break;
         }
       break;
 
-    case oct_mach_info::flt_fmt_ieee_big_endian:
+    case octave::mach_info::flt_fmt_ieee_big_endian:
       switch (from_fmt)
         {
-        case oct_mach_info::flt_fmt_ieee_little_endian:
+        case octave::mach_info::flt_fmt_ieee_little_endian:
           IEEE_little_float_to_IEEE_big_float (data, len);
           break;
 
-        case oct_mach_info::flt_fmt_ieee_big_endian:
+        case octave::mach_info::flt_fmt_ieee_big_endian:
           break;
 
         default:
           err_unrecognized_float_fmt ();
           break;
         }
       break;
 
@@ -741,18 +741,18 @@ do_float_format_conversion (void *data, 
         ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
 do_float_format_conversion (void *data, size_t sz, octave_idx_type len,
-                            oct_mach_info::float_format from_fmt,
-                            oct_mach_info::float_format to_fmt)
+                            octave::mach_info::float_format from_fmt,
+                            octave::mach_info::float_format to_fmt)
 {
   switch (sz)
     {
     case sizeof (float):
       do_float_format_conversion (data, len, from_fmt, to_fmt);
       break;
 
     case sizeof (double):
@@ -765,17 +765,17 @@ do_float_format_conversion (void *data, 
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
 read_doubles (std::istream& is, double *data, save_type type,
               octave_idx_type len, bool swap,
-              oct_mach_info::float_format fmt)
+              octave::mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_READ (uint8_t, swap, data, 1, len, is);
       break;
 
     case LS_U_SHORT:
@@ -824,17 +824,17 @@ read_doubles (std::istream& is, double *
       is.clear (std::ios::failbit | is.rdstate ());
       break;
     }
 }
 
 void
 read_floats (std::istream& is, float *data, save_type type,
              octave_idx_type len, bool swap,
-             oct_mach_info::float_format fmt)
+             octave::mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_READ (uint8_t, swap, data, 1, len, is);
       break;
 
     case LS_U_SHORT:
diff --git a/liboctave/util/data-conv.h b/liboctave/util/data-conv.h
--- a/liboctave/util/data-conv.h
+++ b/liboctave/util/data-conv.h
@@ -93,43 +93,43 @@ enum save_type
   LS_FLOAT   = 6,
   LS_DOUBLE  = 7,
   LS_U_LONG  = 8,
   LS_LONG    = 9
 };
 
 extern OCTAVE_API void
 do_double_format_conversion (void *data, octave_idx_type len,
-                             oct_mach_info::float_format from_fmt,
-                             oct_mach_info::float_format to_fmt
-                             = oct_mach_info::native_float_format ());
+                             octave::mach_info::float_format from_fmt,
+                             octave::mach_info::float_format to_fmt
+                             = octave::mach_info::native_float_format ());
 
 extern OCTAVE_API void
 do_float_format_conversion (void *data, octave_idx_type len,
-                            oct_mach_info::float_format from_fmt,
-                            oct_mach_info::float_format to_fmt
-                            = oct_mach_info::native_float_format ());
+                            octave::mach_info::float_format from_fmt,
+                            octave::mach_info::float_format to_fmt
+                            = octave::mach_info::native_float_format ());
 
 extern OCTAVE_API void
 do_float_format_conversion (void *data, size_t sz, octave_idx_type len,
-                            oct_mach_info::float_format from_fmt,
-                            oct_mach_info::float_format to_fmt
-                            = oct_mach_info::native_float_format ());
+                            octave::mach_info::float_format from_fmt,
+                            octave::mach_info::float_format to_fmt
+                            = octave::mach_info::native_float_format ());
 
 extern OCTAVE_API void
 read_doubles (std::istream& is, double *data, save_type type,
-              octave_idx_type len, bool swap, oct_mach_info::float_format fmt);
+              octave_idx_type len, bool swap, octave::mach_info::float_format fmt);
 
 extern OCTAVE_API void
 write_doubles (std::ostream& os, const double *data, save_type type,
                octave_idx_type len);
 
 extern OCTAVE_API void
 read_floats (std::istream& is, float *data, save_type type,
-             octave_idx_type len, bool swap, oct_mach_info::float_format fmt);
+             octave_idx_type len, bool swap, octave::mach_info::float_format fmt);
 
 extern OCTAVE_API void
 write_floats (std::ostream& os, const float *data, save_type type,
               octave_idx_type len);
 
 template <typename T>
 inline bool
 is_equivalent_type (oct_data_conv::data_type)
diff --git a/liboctave/util/lo-ieee.cc b/liboctave/util/lo-ieee.cc
--- a/liboctave/util/lo-ieee.cc
+++ b/liboctave/util/lo-ieee.cc
@@ -219,32 +219,32 @@ int
 
 void
 octave_ieee_init (void)
 {
   bool initialized = false;
 
   if (! initialized)
     {
-      oct_mach_info::float_format ff = oct_mach_info::native_float_format ();
+      octave::mach_info::float_format ff = octave::mach_info::native_float_format ();
 
       switch (ff)
         {
-        case oct_mach_info::flt_fmt_ieee_big_endian:
-        case oct_mach_info::flt_fmt_ieee_little_endian:
+        case octave::mach_info::flt_fmt_ieee_big_endian:
+        case octave::mach_info::flt_fmt_ieee_little_endian:
           {
             lo_nan = std::numeric_limits<double>::quiet_NaN ();
             lo_inf = std::numeric_limits<double>::infinity ();
 
             lo_float_nan = std::numeric_limits<float>::quiet_NaN ();
             lo_float_inf = std::numeric_limits<float>::infinity ();
 
             // The following is patterned after code in R.
 
-            if (ff == oct_mach_info::flt_fmt_ieee_big_endian)
+            if (ff == octave::mach_info::flt_fmt_ieee_big_endian)
               {
                 lo_ieee_hw = 0;
                 lo_ieee_lw = 1;
               }
             else
               {
                 lo_ieee_hw = 1;
                 lo_ieee_lw = 0;
