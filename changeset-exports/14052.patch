# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1323903255 18000
#      Wed Dec 14 17:54:15 2011 -0500
# Node ID 024a050fc1473c3a657c1ba7fe9f71c0264d13f5
# Parent  29e9eb59f9174ebdcfd143e65f692169849be53b
# Parent  f07f7dd0d4dff450b480351ac9628735086f41f8
maint: periodic merge of stable to default

diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -644,17 +644,17 @@ OCTAVE_IEEE754_DATA_FORMAT
 
 OCTAVE_CXX_COMPLEX_SETTERS
 OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS
 
 ### Check for the QHull library
 
 OCTAVE_CHECK_LIBRARY(qhull, QHull,
   [Qhull library not found -- this will result in loss of functionality of some geometry functions.],
-  [qhull/qhull_a.h], [qh_qhull], [], [],
+  [qhull/libqhull.h libqhull.h qhull/qhull.h qhull.h], [qh_qhull], [], [],
   [warn_qhull=
    OCTAVE_CHECK_QHULL_VERSION
    OCTAVE_CHECK_QHULL_OK([TEXINFO_QHULL="@set HAVE_QHULL"
      AC_DEFINE(HAVE_QHULL, 1, [Define if QHull is available.])], [
      warn_qhull="Qhull library found, but seems not to work properly -- this will result in loss of functionality of some geometry functions.  Please try recompiling the library with -fno-strict-aliasing."])])
 
 ### Check for pcre regex library.
 
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1054,17 +1054,17 @@ endfunction
 @end group
 @end example
 
 @noindent
 will produce a very quick countdown from '3' to 'Blast Off' as the
 lines "@code{disp(2);}" and "@code{disp(1);}" won't be executed.
 
 The block comment markers must appear alone as the only characters on a line
-(excepting whitespace) in order to to be parsed correctly.
+(excepting whitespace) in order to be parsed correctly.
 
 @node Comments and the Help System
 @subsection Comments and the Help System
 @cindex documenting functions
 @cindex documenting user scripts
 @cindex help, user-defined functions
 
 The @code{help} command (@pxref{Getting Help}) is able to find the first
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -369,17 +369,18 @@ in.call1
 @end example
 
 @node Creating Structures
 @subsection Creating Structures
 @cindex dynamic naming
 
 Besides the index operator ".", Octave can use dynamic naming "(var)" or the
 @code{struct} function to create structures.  Dynamic naming uses the string
-value of a variable as the field name.  For example,
+value of a variable as the field name.  For example:
+
 @example
 @group
 a = "field2";
 x.a = 1;
 x.(a) = 2;
 x
      @result{} x =
         @{
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -66,17 +66,17 @@ hg commit -m "make Octave the coolest so
 hg export -o ../cool.diff tip
                              # export the changeset to a diff
                              # file
 # send ../cool.diff via email
 @end group
 @end example
 
 You may want to get familiar with Mercurial queues to manage your
-changesets. Here is a slightly more complex example using Mercurial
+changesets.  Here is a slightly more complex example using Mercurial
 queues, where work on two unrelated changesets is done in parallel and
 one of the changesets is updated after discussion on the maintainers
 mailing list:
 
 @example
 hg qnew nasty_bug            # create a new patch
 # change sources@dots{}
 hg qref                      # save the changes into the patch
@@ -149,17 +149,17 @@ several parts of one file, you should en
 following the GNU coding standards on changelogs, like the following
 example:
 
 @example
 @group
 look for methods before constructors
 
 * symtab.cc (symbol_table::fcn_info::fcn_info_rep::find):
-Look for class methods before constructors, contrary to Matlab
+Look for class methods before constructors, contrary to @sc{matlab}
 documentation.
 
 * test/ctor-vs-method: New directory of test classes.
 * test/test_ctor_vs_method.m: New file.
 * test/Makefile.am: Include ctor-vs-method/module.mk.
 (FCN_FILES): Include test_ctor_vs_method.m in the list.
 @end group
 @end example
diff --git a/doc/interpreter/debug.txi b/doc/interpreter/debug.txi
--- a/doc/interpreter/debug.txi
+++ b/doc/interpreter/debug.txi
@@ -185,65 +185,64 @@ the commands @code{dbstep}.
 
 @DOCSTRING(dbdown)
 
 @node Profiling
 @section Profiling
 @cindex profiler
 @cindex code profiling
 
-Octave supports profiling of code execution on a per-function level. If
+Octave supports profiling of code execution on a per-function level.  If
 profiling is enabled, each call to a function (supporting built-ins,
 operators, functions in oct- and mex-files, user-defined functions in
 Octave code and anonymous functions) is recorded while running Octave
-code. After that, this data can aid in analyzing the code behavior, and
+code.  After that, this data can aid in analyzing the code behavior, and
 is in particular helpful for finding ``hot spots'' in the code which use
 up a lot of computation time and are the best targets to spend
 optimization efforts on.
 
 The main command for profiling is @code{profile}, which can be used to
 start or stop the profiler and also to query collected data afterwards.
 The data is returned in an Octave data structure which can then be
 examined or further processed by other routines or tools.
 
 @DOCSTRING(profile)
 
 An easy way to get an overview over the collected data is
-@code{profshow}. This function takes the profiler data returned by
+@code{profshow}.  This function takes the profiler data returned by
 @code{profile} as input and prints a flat profile, for instance:
 
 @example
 @group
  Function Attr     Time (s)        Calls
 ----------------------------------------
    >myfib    R        2.195        13529
 binary <=             0.061        13529
  binary -             0.050        13528
  binary +             0.026         6764
 @end group
 @end example
 
 This shows that most of the run time was spent executing the function
 @samp{myfib}, and some minor proportion evaluating the listed binary
-operators. Furthermore, it is shown how often the function was called
+operators.  Furthermore, it is shown how often the function was called
 and the profiler also records that it is recursive.
 
 @DOCSTRING(profshow)
 
 @DOCSTRING(profexplore)
 
 @node Profiler Example
 @section Profiler Example
 
-Below, we will give a short example of a profiler session. See also
+Below, we will give a short example of a profiler session.  See also
 @ref{Profiling} for the documentation of the profiler functions in
-detail. Consider the code:
+detail.  Consider the code:
 
 @example
-@group
 global N A;
 
 N = 300;
 A = rand (N, N);
 
 function xt = timesteps (steps, x0, expM)
   global N;
 
@@ -269,34 +268,33 @@ endfunction
 
 function fib = bar (N)
   if (N <= 2)
     fib = 1;
   else
     fib = bar (N - 1) + bar (N - 2);
   endif
 endfunction
-@end group
 @end example
 
 If we execute the two main functions, we get:
 
 @example
 @group
 tic; foo; toc;
 @result{} Elapsed time is 2.37338 seconds.
 
 tic; bar (20); toc;
 @result{} Elapsed time is 2.04952 seconds.
 @end group
 @end example
 
 But this does not give much information about where this time is spent;
 for instance, whether the single call to @code{expm} is more expensive
-or the recursive time-stepping itself. To get a more detailed picture,
+or the recursive time-stepping itself.  To get a more detailed picture,
 we can use the profiler.
 
 @example
 @group
 profile on;
 foo;
 profile off;
 
@@ -321,96 +319,98 @@ This prints a table like:
   34      norm             0.011            1
   40  binary -             0.004          101
   33   balance             0.003            1
 @end group
 @end example
 
 The entries are the individual functions which have been executed (only
 the 10 most important ones), together with some information for each of
-them. The entries like @samp{binary *} denote operators, while other
-entries are ordinary functions. They include both built-ins like
-@code{expm} and our own routines (for instance @code{timesteps}). From
+them.  The entries like @samp{binary *} denote operators, while other
+entries are ordinary functions.  They include both built-ins like
+@code{expm} and our own routines (for instance @code{timesteps}).  From
 this profile, we can immediately deduce that @code{expm} uses up the
 largest proportion of the processing time, even though it is only called
-once. The second expensive operation is the matrix-vector product in the
-routine @code{timesteps}. @footnote{We only know it is the binary
+once.  The second expensive operation is the matrix-vector product in the
+routine @code{timesteps}.  @footnote{We only know it is the binary
 multiplication operator, but fortunately this operator appears only at
 one place in the code and thus we know which occurrence takes so much
-time. If there were multiple places, we would have to use the
+time.  If there were multiple places, we would have to use the
 hierarchical profile to find out the exact place which uses up the time
 which is not covered in this example.}
 
 Timing, however, is not the only information available from the profile.
 The attribute column shows us that @code{timesteps} calls itself
-recursively. This may not be that remarkable in this example (since it's
-clear anyway), but could be helpful in a more complex setting. As to the
+recursively.  This may not be that remarkable in this example (since it's
+clear anyway), but could be helpful in a more complex setting.  As to the
 question of why is there a @samp{binary \} in the output, we can easily
-shed some light on that too. Note that @code{data} is a structure array
+shed some light on that too.  Note that @code{data} is a structure array
 (@ref{Structure Arrays}) which contains the field @code{FunctionTable}.
-This stores the raw data for the profile shown. The number in the first
+This stores the raw data for the profile shown.  The number in the first
 column of the table gives the index under which the shown function can
-be found there. Looking up @code{data.FunctionTable(41)} gives:
+be found there.  Looking up @code{data.FunctionTable(41)} gives:
 
 @example
 @group
   scalar structure containing the fields:
 
     FunctionName = binary \
     TotalTime =  0.18765
     NumCalls =  1
     IsRecursive = 0
     Parents =  7
     Children = [](1x0)
 @end group
 @end example
 
 Here we see the information from the table again, but have additional
-fields @code{Parents} and @code{Children}. Those are both arrays, which
+fields @code{Parents} and @code{Children}.  Those are both arrays, which
 contain the indices of functions which have directly called the function
 in question (which is entry 7, @code{expm}, in this case) or been called
-by it (no functions). Hence, the backslash operator has been used
+by it (no functions).  Hence, the backslash operator has been used
 internally by @code{expm}.
 
-Now let's take a look at @code{bar}. For this, we start a fresh
+Now let's take a look at @code{bar}.  For this, we start a fresh
 profiling session (@code{profile on} does this; the old data is removed
 before the profiler is restarted):
 
 @example
 @group
 profile on;
 bar (20);
 profile off;
 
 profshow (profile ('info'));
 @end group
 @end example
 
 This gives:
 
 @example
+@group
    #            Function Attr     Time (s)        Calls
 -------------------------------------------------------
    1                 bar    R        2.091        13529
    2           binary <=             0.062        13529
    3            binary -             0.042        13528
    4            binary +             0.023         6764
    5             profile             0.000            1
    8               false             0.000            1
    6              nargin             0.000            1
    7           binary !=             0.000            1
    9 __profiler_enable__             0.000            1
+@end group
 @end example
 
-Unsurprisingly, @code{bar} is also recursive. It has been called 13,529
+Unsurprisingly, @code{bar} is also recursive.  It has been called 13,529
 times in the course of recursively calculating the Fibonacci number in a
 suboptimal way, and most of the time was spent in @code{bar} itself.
 
 Finally, let's say we want to profile the execution of both @code{foo}
-and @code{bar} together. Since we already have the run-time data
+and @code{bar} together.  Since we already have the run-time data
 collected for @code{bar}, we can restart the profiler without clearing
 the existing data and collect the missing statistics about @code{foo}.
 This is done by:
 
 @example
 @group
 profile resume;
 foo;
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -50,158 +50,247 @@ combinations of these with various opera
 @opindex :
 
 An @dfn{index expression} allows you to reference or extract selected
 elements of a matrix or vector.
 
 Indices may be scalars, vectors, ranges, or the special operator
 @samp{:}, which may be used to select entire rows or columns.
 
-Vectors are indexed using a single index expression.  Matrices may be
-indexed using one or two indices.  When using a single index
-expression, the elements of the matrix are taken in column-first order;
-the dimensions of the output match those of the index expression.  For
-example,
+Vectors are indexed using a single index expression.  Matrices (2-D)
+and higher multi-dimensional arrays are indexed using either one index
+or @math{N} indices where @math{N} is the dimension of the array.
+When using a single index expression to index 2-D or higher data the
+elements of the array are taken in column-first order (like Fortran).
+
+The output from indexing assumes the dimensions of the index
+expression.  For example:
 
 @example
 @group
-a(2)       # a scalar
-a(1:2)     # a row vector
-a([1; 2])  # a column vector
+a(2)       # result is a scalar
+a(1:2)     # result is a row vector
+a([1; 2])  # result is a column vector
 @end group
 @end example
 
 As a special case, when a colon is used as a single index, the output
-is a column vector containing all the elements of the vector or matrix.
-For example:
+is a column vector containing all the elements of the vector or
+matrix.  For example:
 
 @example
-a(:)       # a column vector
+@group
+a(:)       # result is a column vector
+a(:)'      # result is a row vector
+@end group
 @end example
 
+The above two code idioms are often used in place of @code{reshape}
+when a simple vector, rather than an arbitrarily sized array, is
+needed.
+
 Given the matrix
 
 @example
 a = [1, 2; 3, 4]
 @end example
 
 @noindent
-all of the following expressions are equivalent
+all of the following expressions are equivalent and select the first
+row of the matrix.
 
 @example
 @group
-a(1, [1, 2])
-a(1, 1:2)
-a(1, :)
+a(1, [1, 2])  # row 1, columns 1 and 2
+a(1, 1:2)     # row 1, columns in range 1-2
+a(1, :)       # row 1, all columns
+@end group
+@end example
+
+@cindex @code{end}, indexing
+@cindex :end
+
+In index expressions the keyword @code{end} automatically refers to
+the last entry for a particular dimension.  This magic index can also
+be used in ranges and typically eliminates the needs to call
+@code{size} or @code{length} to gather array bounds before indexing.
+For example:
+
+@example
+@group
+a = [1, 2, 3, 4];
+
+a(1:end/2)        # first half of a => [1, 2]
+a(end + 1) = 5;   # append element 
+a(end) = [];      # delete element 
+a(1:2:end)        # odd elements of a => [1, 3]
+a(2:2:end)        # even elements of a => [2, 4]
+a(end:-1:1)       # reversal of a => [4, 3, 2 , 1]
 @end group
 @end example
 
-@noindent
-and select the first row of the matrix.
+@menu
+* Advanced Indexing::
+@end menu
+
+@node Advanced Indexing
+@subsection Advanced Indexing
+
+An array with @samp{n} dimensions can be indexed using @samp{m}
+indices.  More generally, the set of index tuples determining the
+result is formed by the Cartesian product of the index vectors (or
+ranges or scalars).
+
+For the ordinary and most common case, @w{@code{m == n}}, and each
+index corresponds to its respective dimension.  If @w{@code{m < n}}
+and every index is less than the size of the array in the
+@math{i^{th}} dimension, @code{m(i) < n(i)}, then the index expression
+is padded with trailing singleton dimensions (@code{[ones (m-n, 1)]}).
+If @w{@code{m < n}} but one of the indices @code{m(i)} is outside the
+size of the current array, then the last @w{@code{n-m+1}} dimensions
+are folded into a single dimension with an extent equal to the product
+of extents of the original dimensions.  This is easiest to understand
+with an example.
 
-In general, an array with @samp{n} dimensions can be indexed using @samp{m}
-indices.  If @code{n == m}, each index corresponds to its respective dimension.
-The set of index tuples determining the result is formed by the Cartesian
-product of the index vectors (or ranges or scalars).  If @code{n < m}, then the
-array is padded by trailing singleton dimensions.  If @code{n > m}, the last
-@code{n-m+1} dimensions are folded into a single dimension with extent equal to
-product of extents of the original dimensions.
+@example
+a = reshape (1:8, 2, 2, 2)  # Create 3-D array
+a =
+
+ans(:,:,1) =
+
+   1   3
+   2   4
+
+ans(:,:,2) =
+
+   5   7
+   6   8
 
-@c FIXED -- sections on variable prefer_zero_one_indexing were removed
+a(2,1,2);   # Case (m == n): ans = 6
+a(2,1);     # Case (m < n), idx within array:
+            # equivalent to a(2,1,1), ans = 2
+a(2,4);     # Case (m < n), idx outside array:
+            # Dimension 2 & 3 folded into new dimension of size 2x2 = 4
+            # Select 2nd row, 4th element of [2, 4, 6, 8], ans = 8
+@end example
 
-Indexing a scalar with a vector of ones can be used to create a
-vector the same size as the index vector, with each element equal to
-the value of the original scalar.  For example, the following statements
+One advanced use of indexing is to create arrays filled with a single
+value.  This can be done by using an index of ones on a scalar value.
+The result is an object with the dimensions of the index expression
+and every element equal to the original scalar.  For example, the
+following statements
 
 @example
 @group
 a = 13;
 a(ones (1, 4))
 @end group
 @end example
 
 @noindent
 produce a vector whose four elements are all equal to 13.
 
-Similarly, indexing a scalar with two vectors of ones can be used to
-create a matrix.  For example the following statements
+Similarly, by indexing a scalar with two vectors of ones it is
+possible to create a matrix.  The following statements
 
 @example
 @group
 a = 13;
 a(ones (1, 2), ones (1, 3))
 @end group
 @end example
 
 @noindent
-create a 2 by 3 matrix with all elements equal to 13.
+create a 2x3 matrix with all elements equal to 13.
 
 The last example could also be written as
 
 @example
 @group
-13 (ones (2, 3))
+13(ones (2, 3))
 @end group
 @end example
 
-It should be, noted that @code{ones (1, n)} (a row vector of ones) results in a
-range (with zero increment), and is therefore more efficient when used in index
-expression than other forms of @dfn{ones}.  In particular, when @samp{r} is a
-row vector, the expressions
+It is more efficient to use indexing rather than the code construction
+@code{scalar * ones (N, M, @dots{})} because it avoids the unnecessary
+multiplication operation.  Moreover, multiplication may not be
+defined for the object to be replicated whereas indexing an array is
+always defined.  The following code shows how to create a 2x3 cell
+array from a base unit which is not itself a scalar.
+
+@example
+@group
+@{"Hello"@}(ones (2, 3))
+@end group
+@end example
+
+It should be, noted that @code{ones (1, n)} (a row vector of ones)
+results in a range (with zero increment).  A range is stored
+internally as a starting value, increment, end value, and total number
+of values; hence, it is more efficient for storage than a vector or
+matrix of ones whenever the number of elements is greater than 4.  In
+particular, when @samp{r} is a row vector, the expressions
 
 @example
   r(ones (1, n), :)
 @end example
 
 @example
   r(ones (n, 1), :)
 @end example
 
 @noindent
-will produce identical results, but the first one will be significantly
-faster, at least for @samp{r} and @samp{n} large enough.  The reason is that
-in the first case the index is kept in a compressed form, which allows Octave
-to choose a more efficient algorithm to handle the expression.
+will produce identical results, but the first one will be
+significantly faster, at least for @samp{r} and @samp{n} large enough.
+In the first case the index is held in compressed form as a range
+which allows Octave to choose a more efficient algorithm to handle the
+expression.
 
-In general, for an user unaware of these subtleties, it is best to use
-the function @dfn{repmat} for spreading arrays into bigger ones.
+A general recommendation, for a user unaware of these subtleties, is
+to use the function @code{repmat} for replicating smaller arrays into
+bigger ones.
 
-It is also possible to create a matrix with different values.  The
-following example creates a 10 dimensional row vector @math{a} containing
-the values
+A second use of indexing is to speed up code.  Indexing is a fast
+operation and judicious use of it can reduce the requirement for
+looping over individual array elements which is a slow operation.
+
+Consider the following example which creates a 10-element row vector
+@math{a} containing the values
 @tex
 $a_i = \sqrt{i}$.
 @end tex
 @ifnottex
 a(i) = sqrt(i).
 @end ifnottex
 
 @example
 @group
 for i = 1:10
   a(i) = sqrt (i);
 endfor
 @end group
 @end example
 
 @noindent
-Note that it is quite inefficient to create a vector using a loop like
-the one shown in the example above.  In this particular case, it would
-have been much more efficient to use the expression
+It is quite inefficient to create a vector using a loop like this.  In
+this case, it would have been much more efficient to use the
+expression
 
 @example
 a = sqrt (1:10);
 @end example
 
 @noindent
-thus avoiding the loop entirely.  In cases where a loop is still
-required, or a number of values must be combined to form a larger
-matrix, it is generally much faster to set the size of the matrix first,
-and then insert elements using indexing commands.  For example, given a
-matrix @code{a},
+which avoids the loop entirely.
+
+In cases where a loop cannot be avoided, or a number of values must be
+combined to form a larger matrix, it is generally faster to set the
+size of the matrix first (pre-allocate storage), and then insert
+elements using indexing commands.  For example, given a matrix
+@code{a},
 
 @example
 @group
 [nr, nc] = size (a);
 x = zeros (nr, n * nc);
 for i = 1:n
   x(:,(i-1)*nc+1:i*nc) = a;
 endfor
@@ -216,18 +305,18 @@ is considerably faster than
 x = a;
 for i = 1:n-1
   x = [x, a];
 endfor
 @end group
 @end example
 
 @noindent
-particularly for large matrices because Octave does not have to
-repeatedly resize the result.
+because Octave does not have to repeatedly resize the intermediate
+result.
 
 @DOCSTRING(sub2ind)
 
 @DOCSTRING(ind2sub)
 
 @DOCSTRING(isindex)
 
 @DOCSTRING(allow_noninteger_range_as_index)
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -285,18 +285,18 @@ endfunction
 
 In this particular case, the two values could have been returned as
 elements of a single array, but that is not always possible or
 convenient.  The values to be returned may not have compatible
 dimensions, and it is often desirable to give the individual return
 values distinct names.
 
 It is possible to use the @code{nthargout} function to obtain only some
-of the return values or several at once in a cell array. @ref{Cell Array
-Objects}
+of the return values or several at once in a cell array.
+@ref{Cell Array Objects}
 
 @DOCSTRING(nthargout)
 
 In addition to setting @code{nargin} each time a function is called,
 Octave also automatically initializes @code{nargout} to the number of
 values that are expected to be returned.  This allows you to write
 functions that behave differently depending on the number of values that
 the user of the function has requested.  The implicit assignment to the
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -77,17 +77,17 @@ about building Octave with this option.
 Enable bounds checking for indexing operators in the internal array
 classes.  This option is primarily used for debugging Octave.  Building
 Octave with this option has a negative impact on performance and is not
 recommended for general use.
 
 @item --disable-docs
 Disable building all forms of the documentation (Info, PDF, HTML).  The
 default is to build documentation, but your system will need functioning
-Texinfo and Tex installs for this to succeed.
+Texinfo and @TeX{} installs for this to succeed.
 
 @item --enable-float-truncate
 This option allows for truncation of intermediate floating point results
 in calculations.  It is only necessary for certain platforms.
 
 @item --enable-readline
 Use the readline library to provide for editing of the command line in
 terminal environments.  This option is on by default.
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -557,17 +557,19 @@ The description follows on succeeding li
 
 In a function description, the name of the function being described
 appears first.  It is followed on the same line by a list of parameters.
 The names used for the parameters are also used in the body of the
 description.
 
 Here is a description of an imaginary function @code{foo}:
 
-@deftypefn {Function} {} foo (@var{x}, @var{y}, @dots{})
+@deftypefn  {Function} {} foo (@var{x})
+@deftypefnx {Function} {} foo (@var{x}, @var{y})
+@deftypefnx {Function} {} foo (@var{x}, @var{y}, @dots{})
 The function @code{foo} subtracts @var{x} from @var{y}, then adds the
 remaining arguments to the result.  If @var{y} is not supplied, then the
 number 19 is used by default.
 
 @example
 @group
 foo (1, [3, 5], 3, 9)
      @result{} [ 14, 16 ]
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -577,32 +577,32 @@ Print an integer as an unsigned octal nu
 Conversions}, for details.
 
 @item @samp{%u}
 Print an integer as an unsigned decimal number.  @xref{Integer
 Conversions}, for details.
 
 @item @samp{%x}, @samp{%X}
 Print an integer as an unsigned hexadecimal number.  @samp{%x} uses
-lower-case letters and @samp{%X} uses upper-case.  @xref{Integer
+lowercase letters and @samp{%X} uses uppercase.  @xref{Integer
 Conversions}, for details.
 
 @item @samp{%f}
 Print a floating-point number in normal (fixed-point) notation.
 @xref{Floating-Point Conversions}, for details.
 
 @item @samp{%e}, @samp{%E}
 Print a floating-point number in exponential notation.  @samp{%e} uses
-lower-case letters and @samp{%E} uses upper-case.  @xref{Floating-Point
+lowercase letters and @samp{%E} uses uppercase.  @xref{Floating-Point
 Conversions}, for details.
 
 @item @samp{%g}, @samp{%G}
 Print a floating-point number in either normal (fixed-point) or
 exponential notation, whichever is more appropriate for its magnitude.
-@samp{%g} uses lower-case letters and @samp{%G} uses upper-case.
+@samp{%g} uses lowercase letters and @samp{%G} uses uppercase.
 @xref{Floating-Point Conversions}, for details.
 
 @item @samp{%c}
 Print a single character.  @xref{Other Output Conversions}.
 
 @item @samp{%s}
 Print a string.  @xref{Other Output Conversions}.
 
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -378,16 +378,20 @@ Expressions
 * Calling Functions::           
 * Arithmetic Ops::              
 * Comparison Ops::              
 * Boolean Expressions::         
 * Assignment Ops::              
 * Increment Ops::               
 * Operator Precedence::         
 
+Index Expressions
+
+* Advanced Indexing::           
+
 Calling Functions
 
 * Call by Value::               
 * Recursion::                   
 
 Boolean Expressions
 
 * Element-by-element Boolean Operators::  
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -201,17 +201,17 @@ package source files.
 This is an optional file describing the functions provided by the
 package.  If this file is not given then one with be created
 automatically from the functions in the package and the
 @code{Categories} keyword in the @file{DESCRIPTION} file.
 @xref{The INDEX File}, for details on this file.
 
 @item package/NEWS
 This is an optional file describing all user-visible changes worth
-mentioning. As this file increases on size, old entries can be moved
+mentioning.  As this file increases on size, old entries can be moved
 into @file{package/ONEWS}.
 
 @item package/ONEWS
 This is an optional file describing old entries from the @file{NEWS} file.
 
 @anchor{doc-PKG_ADD}
 @item package/PKG_ADD
 An optional file that includes commands that are run when the package
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -29,233 +29,261 @@ and demonstration code in the source cod
 * Demonstration Functions::
 @end menu
 
 @node Test Functions
 @section Test Functions
 
 @DOCSTRING(test)
 
-@code{test} scans the named script file looking for lines which
-start with @code{%!}.  The prefix is stripped off and the rest of the
-line is processed through the Octave interpreter.  If the code
+@code{test} scans the named script file looking for lines which start
+with the identifier @samp{%!}.  The prefix is stripped off and the rest
+of the line is processed through the Octave interpreter.  If the code
 generates an error, then the test is said to fail.
 
 Since @code{eval()} will stop at the first error it encounters, you must
 divide your tests up into blocks, with anything in a separate
 block evaluated separately.  Blocks are introduced by the keyword
-@code{test} immediately following the @code{%!}.  For example:
+@code{test} immediately following @samp{%!}.  For example:
 
 @example
 @group
-   %!test error ("this test fails!");
-   %!test "test doesn't fail. it doesn't generate an error";
+%!test error ("this test fails!");
+%!test "test doesn't fail. it doesn't generate an error";
 @end group
 @end example
 
 When a test fails, you will see something like:
 
 @example
 @group
-     ***** test error ('this test fails!')
-   !!!!! test failed
-   this test fails!
+  ***** test error ("this test fails!")
+!!!!! test failed
+this test fails!
 @end group
 @end example
 
 Generally, to test if something works, you want to assert that it
 produces a correct value.  A real test might look something like
 
 @example
 @group
-   %!test
-   %! @var{a} = [1, 2, 3; 4, 5, 6]; B = [1; 2];
-   %! expect = [ @var{a} ; 2*@var{a} ];
-   %! get = kron (@var{b}, @var{a});
-   %! if (any(size(expect) != size(get)))
-   %!    error ("wrong size: expected %d,%d but got %d,%d",
-   %!           size(expect), size(get));
-   %! elseif (any(any(expect!=get)))
-   %!    error ("didn't get what was expected.");
-   %! endif
+%!test
+%! @var{a} = [1, 2, 3; 4, 5, 6]; B = [1; 2];
+%! expect = [ @var{a} ; 2*@var{a} ];
+%! get = kron (@var{b}, @var{a});
+%! if (any (size (expect) != size (get)))
+%!   error ("wrong size: expected %d,%d but got %d,%d",
+%!          size(expect), size(get));
+%! elseif (any (any (expect != get)))
+%!   error ("didn't get what was expected.");
+%! endif
 @end group
 @end example
 
 To make the process easier, use the @code{assert} function.  For example,
 with @code{assert} the previous test is reduced to:
 
 @example
 @group
-   %!test
-   %! @var{a} = [1, 2, 3; 4, 5, 6]; @var{b} = [1; 2];
-   %! assert (kron (@var{b}, @var{a}), [ @var{a}; 2*@var{a} ]);
+%!test
+%! @var{a} = [1, 2, 3; 4, 5, 6]; @var{b} = [1; 2];
+%! assert (kron (@var{b}, @var{a}), [ @var{a}; 2*@var{a} ]);
 @end group
 @end example
 
 @code{assert} can accept a tolerance so that you can compare results
 absolutely or relatively.  For example, the following all succeed:
 
 @example
 @group
-   %!test assert (1+eps, 1, 2*eps)          # absolute error
-   %!test assert (100+100*eps, 100, -2*eps) # relative error
+%!test assert (1+eps, 1, 2*eps)          # absolute error
+%!test assert (100+100*eps, 100, -2*eps) # relative error
 @end group
 @end example
 
 You can also do the comparison yourself, but still have assert
 generate the error:
 
 @example
 @group
-   %!test assert (isempty([]))
-   %!test assert ([ 1,2; 3,4 ] > 0)
+%!test assert (isempty ([]))
+%!test assert ([1, 2; 3, 4] > 0)
 @end group
 @end example
 
 Because @code{assert} is so frequently used alone in a test block, there
 is a shorthand form:
 
 @example
-   %!assert (@dots{})
+%!assert (@dots{})
 @end example
 
 @noindent
 which is equivalent to:
 
 @example
-   %!test assert (@dots{})
+%!test assert (@dots{})
 @end example
 
+Occasionally a block of tests will depend on having optional
+functionality in Octave.  Before testing such blocks the availability of
+the required functionality must be checked.  A @code{%!testif HAVE_XXX}
+block will only be run if Octave was compiled with functionality
+@samp{HAVE_XXX}.  For example, the sparse single value decomposition,
+@code{svds()}, depends on having the @sc{arpack} library.  All of the tests
+for @code{svds} begin with
+
+@example
+%!testif HAVE_ARPACK
+@end example
+
+@noindent
+Review @file{config.h} or @code{octave_config_info ("DEFS")} to see some
+of the possible values to check.
+
 Sometimes during development there is a test that should work but is
 known to fail.  You still want to leave the test in because when the
 final code is ready the test should pass, but you may not be able to
 fix it immediately.  To avoid unnecessary bug reports for these known
 failures, mark the block with @code{xtest} rather than @code{test}:
 
 @example
 @group
-   %!xtest assert (1==0)
-   %!xtest fail ('success=1','error'))
+%!xtest assert (1==0)
+%!xtest fail ("success=1", "error")
 @end group
 @end example
 
-Another use of @code{xtest} is for statistical tests which should
-pass most of the time but are known to fail occasionally.
+@noindent
+In this case, the test will run and any failure will be reported.
+However, testing is not aborted and subsequent test blocks will be
+processed normally.  Another use of @code{xtest} is for statistical
+tests which should pass most of the time but are known to fail
+occasionally.
 
 Each block is evaluated in its own function environment, which means
 that variables defined in one block are not automatically shared
 with other blocks.  If you do want to share variables, then you
 must declare them as @code{shared} before you use them.  For example, the
 following declares the variable @var{a}, gives it an initial value (default
-is empty), then uses it in several subsequent tests.
+is empty), and then uses it in several subsequent tests.
 
 @example
 @group
-   %!shared @var{a}
-   %! @var{a} = [1, 2, 3; 4, 5, 6];
-   %!assert (kron ([1; 2], @var{a}), [ @var{a}; 2*@var{a} ]);
-   %!assert (kron ([1, 2], @var{a}), [ @var{a}, 2*@var{a} ]);
-   %!assert (kron ([1,2; 3,4], @var{a}), [ @var{a},2*@var{a}; 3*@var{a},4*@var{a} ]);
+%!shared @var{a}
+%! @var{a} = [1, 2, 3; 4, 5, 6];
+%!assert (kron ([1; 2], @var{a}), [ @var{a}; 2*@var{a} ]);
+%!assert (kron ([1, 2], @var{a}), [ @var{a}, 2*@var{a} ]);
+%!assert (kron ([1,2; 3,4], @var{a}), [ @var{a},2*@var{a}; 3*@var{a},4*@var{a} ]);
 @end group
 @end example
 
 You can share several variables at the same time:
 
 @example
-   %!shared @var{a}, @var{b}
+%!shared @var{a}, @var{b}
 @end example
 
 You can also share test functions:
 
 @example
 @group
-   %!function @var{a} = fn (@var{b})
-   %!  @var{a} = 2*@var{b};
-   %!endfunction
-   %!assert (@var{fn}(2), 4);
+%!function @var{a} = fn (@var{b})
+%!  @var{a} = 2*@var{b};
+%!endfunction
+%!assert (fn(2), 4);
 @end group
 @end example
 
 Note that all previous variables and values are lost when a new 
 shared block is declared.
 
 Error and warning blocks are like test blocks, but they only succeed 
 if the code generates an error.  You can check the text of the error
 is correct using an optional regular expression @code{<pattern>}.  
 For example:
 
 @example
-   %!error <passes!> error('this test passes!');
+%!error <passes!> error ("this test passes!");
 @end example
 
 If the code doesn't generate an error, the test fails.  For example:
 
 @example
-   %!error "this is an error because it succeeds.";
+%!error "this is an error because it succeeds.";
 @end example
 
 @noindent
 produces
 
 @example
 @group
-   ***** error "this is an error because it succeeds.";
-   !!!!! test failed: no error
+  ***** error "this is an error because it succeeds.";
+!!!!! test failed: no error
 @end group
 @end example
 
 It is important to automate the tests as much as possible, however
 some tests require user interaction.  These can be isolated into
 demo blocks, which if you are in batch mode, are only run when 
-called with @code{demo} or @code{verbose}.  The code is displayed before
-it is executed.  For example,
+called with @code{demo} or the @code{verbose} option to @code{test}.
+The code is displayed before it is executed.  For example,
 
 @example
 @group
-   %!demo
-   %! @var{t}=[0:0.01:2*pi]; @var{x}=sin(@var{t});
-   %! plot(@var{t},@var{x});
-   %! you should now see a sine wave in your figure window
+%!demo
+%! @var{t} = [0:0.01:2*pi]; @var{x} = sin (@var{t});
+%! plot (@var{t}, @var{x});
+%! # you should now see a sine wave in your figure window
 @end group
 @end example
 
 @noindent
 produces
 
 @example
 @group
-   > @var{t}=[0:0.01:2*pi]; @var{x}=sin(@var{t});
-   > plot(@var{t},@var{x});
-   > you should now see a sine wave in your figure window
-   Press <enter> to continue: 
+funcname example 1:
+ @var{t} = [0:0.01:2*pi]; @var{x} = sin (@var{t});
+ plot (@var{t}, @var{x});
+ # you should now see a sine wave in your figure window
+
+Press <enter> to continue: 
 @end group
 @end example
 
 Note that demo blocks cannot use any shared variables.  This is so
 that they can be executed by themselves, ignoring all other tests.
 
 If you want to temporarily disable a test block, put @code{#} in place
 of the block type.  This creates a comment block which is echoed
-in the log file, but is not executed.  For example:
+in the log file but not executed.  For example:
 
 @example
 @group
-   %!#demo
-   %! @var{t}=[0:0.01:2*pi]; @var{x}=sin(@var{t});
-   %! plot(@var{t},@var{x});
-   %! you should now see a sine wave in your figure window
+%!#demo
+%! @var{t} = [0:0.01:2*pi]; @var{x} = sin (@var{t});
+%! plot (@var{t}, @var{x});
+%! # you should now see a sine wave in your figure window
 @end group
 @end example
 
-Block type summary:
+@subsubheading Block type summary:
 
 @table @code
 @item %!test
 check that entire block is correct
 
+@item %!testif HAVE_XXX
+check block only if Octave was compiled with feature HAVE_XXX.
+
+@item %!xtest
+check block, report a test failure but do not abort testing.
+
 @item %!error
 check for correct error message
 
 @item %!warning
 check for correct warning message
 
 @item %!demo
 demo only executes in interactive mode
@@ -272,57 +300,53 @@ define a function for use in multiple te
 @item %!endfunction
 close a function definition
 
 @item %!assert (x, y, tol)
 shorthand for @code{%!test assert (x, y, tol)}
 @end table
 
 You can also create test scripts for builtins and your own C++
-functions.  Just put a file of the function name on your path without
-any extension and it will be picked up by the test procedure.  You
-can even embed tests directly in your C++ code:
+functions.  To do so put a file with the bare function name (no .m
+extension) in a directory in the load path and it will be discovered by
+the @code{test} function.  Alternatively, you can embed tests directly in your
+C++ code:
 
 @example
 @group
-   #if 0
-   %!test disp('this is a test')
-   #endif
+#if 0
+%!test disp ("this is a test")
+#endif
 @end group
 @end example
 
 @noindent
 or
 
 @example
 @group
-   /*
-   %!test disp('this is a test')
-   */
+/*
+%!test disp ("this is a test")
+*/
 @end group
 @end example
 
 @noindent
-but then the code will have to be on the load path and the user 
-will have to remember to type test('name.cc').  Conversely, you
-can separate the tests from normal Octave script files by putting
-them in plain files with no extension rather than in script files.
-@c DO I WANT TO INCLUDE THE EDITOR SPECIFIC STATEMENT BELOW???
-@c Don't forget to tell emacs that the plain text file you are using
-@c is actually octave code, using something like:
-@c   -*-octave-*-
+However, in this case the raw source code will need to be on the load
+path and the user will have to remember to type
+@code{test ("funcname.cc")}.
 
 @DOCSTRING(assert)
 
 @DOCSTRING(fail)
 
 @node Demonstration Functions
 @section Demonstration Functions
 
 @DOCSTRING(demo)
 
+@DOCSTRING(example)
+
 @DOCSTRING(rundemos)
 
 @DOCSTRING(runtests)
 
-@DOCSTRING(example)
-
 @DOCSTRING(speed)
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -931,34 +931,75 @@ AC_DEFUN([OCTAVE_HDF5_HAS_ENFORCED_16_AP
 ])
 dnl
 dnl Check for the QHull version.
 dnl
 AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION],
   [AC_CACHE_CHECK([for qh_version in $QHULL_LIBS],
     octave_cv_lib_qhull_version,  [
       AC_LINK_IFELSE([AC_LANG_PROGRAM([[
-#include <qhull/qhull_a.h>
+#include <stdio.h>
+#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+# if defined (HAVE_QHULL_LIBQHULL_H)
+#  include <qhull/libqhull.h>
+# else
+#  include <qhull/qhull.h>
+# endif
+# include <qhull/qset.h>
+# include <qhull/geom.h>
+# include <qhull/poly.h>
+# include <qhull/io.h>
+#elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
+# if defined (HAVE_LIBQHULL_H)
+#  include <libqhull.h>
+# else
+#  include <qhull.h>
+# endif
+# include <qset.h>
+# include <geom.h>
+# include <poly.h>
+# include <io.h>
+#endif
 ]], [[
 const char *tmp = qh_version;
 ]])], [octave_cv_lib_qhull_version=yes], [octave_cv_lib_qhull_version=no])])
   if test "$octave_cv_lib_qhull_version" = no; then
     AC_DEFINE(NEED_QHULL_VERSION, 1,
       [Define if the QHull library needs a qh_version variable defined.])
   fi
 ])
 dnl
 dnl Check whether QHull works (does not crash)
 dnl
 AC_DEFUN([OCTAVE_CHECK_QHULL_OK],
   [AC_CACHE_CHECK([whether the qhull library works],
     octave_cv_lib_qhull_ok, [
       AC_RUN_IFELSE([AC_LANG_PROGRAM([[
 #include <stdio.h>
-#include <qhull/qhull.h>
+#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+# if defined (HAVE_QHULL_LIBQHULL_H)
+#  include <qhull/libqhull.h>
+# else
+#  include <qhull/qhull.h>
+# endif
+# include <qhull/qset.h>
+# include <qhull/geom.h>
+# include <qhull/poly.h>
+# include <qhull/io.h>
+#elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
+# if defined (HAVE_LIBQHULL_H)
+#  include <libqhull.h>
+# else
+#  include <qhull.h>
+# endif
+# include <qset.h>
+# include <geom.h>
+# include <poly.h>
+# include <io.h>
+#endif
 #ifdef NEED_QHULL_VERSION
 char *qh_version = "version";
 #endif
 ]], [[
 int dim = 2;
 int n = 4;
 coordT points[8] = { -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5 };
 boolT ismalloc = 0;
diff --git a/scripts/general/iscolumn.m b/scripts/general/iscolumn.m
--- a/scripts/general/iscolumn.m
+++ b/scripts/general/iscolumn.m
@@ -30,31 +30,27 @@ function retval = iscolumn (x)
     print_usage ();
   endif
 
   sz = size (x);
   retval = (ndims (x) == 2 && (sz(2) == 1));
 
 endfunction
 
-%!assert(iscolumn ([1, 2, 3]), false);
-%!assert(iscolumn ([1; 2; 3]));
-%!assert(iscolumn (1));
-%!assert(iscolumn ([]), false);
-%!assert(iscolumn ([1, 2; 3, 4]), false);
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((iscolumn ("t")));
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert(!(iscolumn ("test")));
+%!assert (iscolumn ([1, 2, 3]), false)
+%!assert (iscolumn ([1; 2; 3]))
+%!assert (iscolumn (1))
+%!assert (iscolumn ([]), false)
+%!assert (iscolumn ([1, 2; 3, 4]), false)
 
-%!assert(!(iscolumn (["test"; "ing"])));
+%!assert (iscolumn ("t"))
+%!assert (iscolumn ("test"), false)
+%!assert (iscolumn (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
-%! assert((iscolumn (s)));
+%! assert (iscolumn (s));
 
 %% Test input validation
-%!error iscolumn ();
-%!error iscolumn ([1, 2], 2);
+%!error iscolumn ()
+%!error iscolumn ([1, 2], 2)
 
diff --git a/scripts/general/isrow.m b/scripts/general/isrow.m
--- a/scripts/general/isrow.m
+++ b/scripts/general/isrow.m
@@ -30,31 +30,27 @@ function retval = isrow (x)
     print_usage ();
   endif
 
   sz = size (x);
   retval = (ndims (x) == 2 && (sz(1) == 1));
 
 endfunction
 
-%!assert(isrow ([1, 2, 3]));
-%!assert(isrow ([1; 2; 3]), false);
-%!assert(isrow (1));
-%!assert(isrow ([]), false);
-%!assert(isrow ([1, 2; 3, 4]), false);
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isrow ("t")));
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isrow ("test")));
+%!assert (isrow ([1, 2, 3]))
+%!assert (isrow ([1; 2; 3]), false)
+%!assert (isrow (1))
+%!assert (isrow ([]), false)
+%!assert (isrow ([1, 2; 3, 4]), false)
 
-%!assert(!(isrow (["test"; "ing"])));
+%!assert (isrow ("t"))
+%!assert (isrow ("test"))
+%!assert (isrow (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
-%! assert((isrow (s)));
+%! assert (isrow (s));
 
 %% Test input validation
-%!error isrow ();
-%!error isrow ([1, 2], 2);
+%!error isrow ()
+%!error isrow ([1, 2], 2)
 
diff --git a/scripts/general/isscalar.m b/scripts/general/isscalar.m
--- a/scripts/general/isscalar.m
+++ b/scripts/general/isscalar.m
@@ -29,28 +29,26 @@ function retval = isscalar (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   retval = numel (x) == 1;
 
 endfunction
 
-%!assert(isscalar (1));
-%!assert(!(isscalar ([1, 2])));
-%!assert(!(isscalar ([])));
-%!assert(!(isscalar ([1, 2; 3, 4])));
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isscalar ("t")));
+%!assert (isscalar (1))
+%!assert (isscalar ([1, 2]), false)
+%!assert (isscalar ([]), false)
+%!assert (isscalar ([1, 2; 3, 4]), false)
 
-%!assert(!(isscalar ("test")));
-%!assert(!(isscalar (["test"; "ing"])));
+%!assert (isscalar ("t"))
+%!assert (isscalar ("test"), false)
+%!assert (isscalar (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
-%! assert((isscalar (s)));
+%! assert (isscalar (s));
 
 %% Test input validation
-%!error isscalar ();
-%!error isscalar (1, 2);
+%!error isscalar ()
+%!error isscalar (1, 2)
 
diff --git a/scripts/general/isvector.m b/scripts/general/isvector.m
--- a/scripts/general/isvector.m
+++ b/scripts/general/isvector.m
@@ -32,31 +32,26 @@ function retval = isvector (x)
     print_usage ();
   endif
 
   sz = size (x);
   retval = (ndims (x) == 2 && (sz(1) == 1 || sz(2) == 1));
 
 endfunction
 
-%!assert(isvector (1));
-%!assert(isvector ([1; 2; 3]));
-%!assert(!(isvector ([])));
-%!assert(!(isvector ([1, 2; 3, 4])));
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isvector ("t")));
+%!assert (isvector (1))
+%!assert (isvector ([1; 2; 3]))
+%!assert (isvector ([]), false)
+%!assert (isvector ([1, 2; 3, 4]), false)
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isvector ("test")));
-
-%!assert(!(isvector (["test"; "ing"])));
+%!assert (isvector ("t"))
+%!assert (isvector ("test"))
+%!assert (isvector (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
-%! assert((isvector (s)));
+%! assert (isvector (s));
 
 %% Test input validation
-%!error isvector ();
-%!error isvector ([1, 2], 2);
+%!error isvector ()
+%!error isvector ([1, 2], 2)
 
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polyarea (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} polyarea (@var{x}, @var{y}, @var{dim})
 ##
-## Determines area of a polygon by triangle method.  The variables
+## Determine area of a polygon by triangle method.  The variables
 ## @var{x} and @var{y} define the vertex pairs, and must therefore have
 ## the same shape.  They can be either vectors or arrays.  If they are
 ## arrays then the columns of @var{x} and @var{y} are treated separately
 ## and an area returned for each.
 ##
 ## If the optional @var{dim} argument is given, then @code{polyarea}
 ## works along this dimension of the arrays @var{x} and @var{y}.
 ##
diff --git a/scripts/miscellaneous/debug.m b/scripts/miscellaneous/debug.m
--- a/scripts/miscellaneous/debug.m
+++ b/scripts/miscellaneous/debug.m
@@ -13,74 +13,79 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} debug ()
-## Summary of the debugging commands.  The debugging commands that are
-## available in Octave are
+## Summary of debugging commands.  For more information on each command
+## and available options use @code{help CMD}.
+## 
+## The debugging commands available in Octave are
 ##
 ## @table @code
-## @item keyboard
-## Force entry into debug mode.
-##
 ## @item dbstop
 ## Add a breakpoint.
 ##
 ## @item dbclear
 ## Remove a breakpoint.
 ##
 ## @item dbstatus
 ## List all breakpoints.
 ##
+## @item dbwhere
+## Report the current file and line number where execution is stopped.
+##
+## @item dbtype
+## List the function where execution is currently stopped, enumerating
+## the line numbers.
+##
+## @item  dbstep
+## @itemx dbnext
+## Execute one or more lines of code and re-enter debug mode.
+##
 ## @item dbcont
-## Continue execution from the debug prompt.
+## Continue normal code execution from the debug prompt.
+##
+## @item dbquit
+## Quit debugging mode immediately and return to the main prompt.
 ##
 ## @item dbstack
 ## Print a backtrace of the execution stack.
 ##
-## @item dbstep
-## Execute one or more lines and re-enter debug mode
-##
-## @item dbtype
-## List the function where execution is currently stopped, enumerating
-## the lines.
-##
 ## @item dbup
-## The workspace up the execution stack.
+## Move up the execution stack.
 ##
 ## @item dbdown
-## The workspace down the execution stack.
+## Move down the execution stack.
 ##
-## @item dbquit
-## Quit debugging mode and return to the main prompt.
+## @item keyboard
+## Force entry into debug mode from an m-file.
 ##
 ## @item debug_on_error
-## Function to query or set whether to enter debug mode in case Octave
-## encounters an error.
+## Configure whether Octave enters debug mode when it encounters an error.
 ##
 ## @item debug_on_warning
-## Function to query or set whether to enter debug mode in case Octave
-## encounters a warning.
+## Configure whether Octave enters debug mode when it encounters a warning.
 ##
 ## @item debug_on_interrupt
-## Function to query or set whether to enter debug mode in case Octave
-## encounters an interupt.
+## Configure whether Octave enters debug mode when it encounters an interrupt.
 ##
+## @item isdebugmode
+## Return true if in debug mode.
 ## @end table
 ##
 ## @noindent
-## when Octave encounters a breakpoint or other reason to enter debug
+## When Octave encounters a breakpoint, or other reason to enter debug
 ## mode, the prompt changes to @code{"debug>"}.  The workspace of the function
 ## where the breakpoint was encountered becomes available and any Octave
-## command that works within that workspace may be executed.
+## command that is valid in that workspace context may be executed.
 ##
-## @seealso{dbstop, dbclear, dbstatus, dbcont, dbstack, dbstep, dbtype,
-## dbup, dbdown, dbquit, debug_on_error, debug_on_warning,
-## debug_on_interrupt}
+## @seealso{dbstop, dbclear, dbstatus, dbwhere, dbtype, dbcont, dbquit,
+##          dbstack, dbup, dbdown, keyboard, debug_on_error, debug_on_warning,
+##          debug_on_interrupt, isdebugmode}
 ## @end deftypefn
 
 function debug ()
   help ("debug");
 endfunction
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontour (@var{f})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezcontour (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontour (@dots{})
 ##
-## Plots the contour lines of a function.  @var{f} is a string, inline function
+## Plot the contour lines of a function.  @var{f} is a string, inline function
 ## or function handle with two arguments defining the function.  By default the
 ## plot is over the domain @code{-2*pi < @var{x} < 2*pi} and @code{-2*pi <
 ## @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontourf (@var{f})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezcontourf (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontourf (@dots{})
 ##
-## Plots the filled contour lines of a function.  @var{f} is a string, inline
+## Plot the filled contour lines of a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} ezmesh (@var{f})
 ## @deftypefnx {Function File} {} ezmesh (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezmesh (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmesh (@dots{})
 ##
-## Plots the mesh defined by a function.  @var{f} is a string, inline
+## Plot the mesh defined by a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} ezmeshc (@var{f})
 ## @deftypefnx {Function File} {} ezmeshc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezmeshc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmeshc (@dots{})
 ##
-## Plots the mesh and contour lines defined by a function.  @var{f} is a string,
+## Plot the mesh and contour lines defined by a function.  @var{f} is a string,
 ## inline function or function handle with two arguments defining the function.
 ## By default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezplot (@var{f})
 ## @deftypefnx {Function File} {} ezplot (@var{fx}, @var{fy})
 ## @deftypefnx {Function File} {} ezplot (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezplot (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezplot (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezplot (@dots{})
 ##
-## Plots in two-dimensions the curve defined by @var{f}.  The function
+## Plot the curve defined by @var{f} in two dimensions.  The function
 ## @var{f} may be a string, inline function or function handle and can
 ## have either one or two variables.  If @var{f} has one variable, then
 ## the function is plotted over the domain @code{-2*pi < @var{x} < 2*pi}
 ## with 500 points.
 ##
 ## If @var{f} has two variables then @code{@var{f}(@var{x},@var{y}) = 0}
 ## is calculated over the meshed domain @code{-2*pi < @var{x} | @var{y}
 ## < 2*pi} with 60 by 60 in the mesh.  For example:
diff --git a/scripts/plot/ezplot3.m b/scripts/plot/ezplot3.m
--- a/scripts/plot/ezplot3.m
+++ b/scripts/plot/ezplot3.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezplot3 (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezplot3 (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezplot3 (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezplot3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezplot3 (@dots{})
 ##
-## Plots in three-dimensions the curve defined parametrically.
+## Plot a parametrically defined curve in three dimensions.
 ## @var{fx}, @var{fy}, and @var{fz} are strings, inline functions
 ## or function handles with one arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi}
 ## with 60 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of @var{t}.  @var{n} is a scalar defining the number of points to use.
 ##
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/ezpolar.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezpolar (@var{f})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezpolar (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezpolar (@dots{})
 ##
-## Plots in polar plot defined by a function.  The function @var{f} is either
+## Plot a function in polar coordinates.  The function @var{f} is either
 ## a string, inline function or function handle with one arguments defining
 ## the function.  By default the plot is over the domain @code{0 < @var{x} <
 ## 2*pi} with 60 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{t}.  @var{n} is a scalar defining the number of points to
 ## use.
 ##
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} ezsurf (@var{f})
 ## @deftypefnx {Function File} {} ezsurf (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezsurf (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurf (@dots{})
 ##
-## Plots the surface defined by a function.  @var{f} is a string, inline
+## Plot the surface defined by a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} ezsurfc (@var{f})
 ## @deftypefnx {Function File} {} ezsurfc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezsurfc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurfc (@dots{})
 ##
-## Plots the surface and contour lines defined by a function.  @var{f} is a
+## Plot the surface and contour lines defined by a function.  @var{f} is a
 ## string, inline function or function handle with two arguments defining the
 ## function.  By default the plot is over the domain @code{-2*pi < @var{x} <
 ## 2*pi} and @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -30,18 +30,21 @@
 ## @end deftypefn
 
 function retval = graphics_toolkit (name, hlist = [])
 
   if (nargin > 2)
     print_usage ();
   endif
 
+  if (nargout > 0 || nargin == 0)
+    retval = get (0, "defaultfigure__graphics_toolkit__");
+  endif
+
   if (nargin == 0)
-    retval = get (0, "defaultfigure__graphics_toolkit__");
     return;
   elseif (nargin == 1)
     if (! ischar (name))
       error ("graphics_toolkit: invalid graphics toolkit NAME");
     endif
   elseif (nargin == 2)
     ## Swap input arguments
     [hlist, name] = deal (name, hlist);
@@ -60,26 +63,33 @@ function retval = graphics_toolkit (name
   endif
 
   if (isempty (hlist))
     set (0, "defaultfigure__graphics_toolkit__", name);
   else
     set (hlist, "__graphics_toolkit__", name);
   endif
 
-  if (isargout (1))
-    retval = name;
-  endif
-
 endfunction
 
 
 %!testif HAVE_FLTK
 %! unwind_protect
 %!   hf = figure ("visible", "off"); 
 %!   toolkit = graphics_toolkit ();
 %!   assert (get (0, "defaultfigure__graphics_toolkit__"), toolkit);
 %!   graphics_toolkit (hf, "fltk"); 
 %!   assert (get (hf, "__graphics_toolkit__"), "fltk");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
+%!testif HAVE_FLTK
+%!  old_toolkit = graphics_toolkit ();
+%!  switch old_toolkit
+%!    case {"gnuplot"}
+%!      new_toolkit = "fltk";
+%!    otherwise
+%!      new_toolkit = "gnuplot";
+%!  endswitch
+%!  assert (graphics_toolkit (new_toolkit), old_toolkit)
+%!  assert (graphics_toolkit (old_toolkit), new_toolkit)
+
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -29,17 +29,17 @@
 ## correspond to different @var{x} values and rows of @var{z} correspond
 ## to different @var{y} values.
 ##
 ## The color of the mesh is derived from the @code{colormap}
 ## and the value of @var{z}.  Optionally the color of the mesh can be
 ## specified independent of @var{z}, by adding a fourth matrix, @var{c}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
-## suface object.
+## surface object.
 ## @seealso{colormap, contour, meshgrid, surf}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = mesh (varargin)
 
   newplot ();
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -236,51 +236,61 @@ function [u, s, v, flag] = svds (A, k, s
 
     if (nargout > 3)
       flag = norm (A*v - u*s, 1) > root2 * opts.tol * norm (A, 1);
     endif
   endif
 
 endfunction
 
-%!shared n, k, A, u, s, v, opts
+%!shared n, k, A, u, s, v, opts, rand_state, randn_state
 %! n = 100;
 %! k = 7;
-%! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
-%! [u,s,v] = svd(full(A));
-%! s = diag(s);
-%! [~, idx] = sort(abs(s));
+%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
+%! [u,s,v] = svd (full (A));
+%! s = diag (s);
+%! [~, idx] = sort (abs(s));
 %! s = s(idx);
-%! u = u(:,idx);
-%! v = v(:,idx);
-%! old_state1 = randn ("state");
-%! restore_state1 = onCleanup (@() randn ("state", old_state1));
-%! old_state2 = rand ("state");
-%! restore_state2 = onCleanup (@() rand ("state", old_state2));
-%! randn ('state', 42);      % Initialize to make normest function reproducible
-%! rand ('state', 42);
+%! u = u(:, idx);
+%! v = v(:, idx);
+%! randn_state = randn ("state");
+%! rand_state = rand ("state");
+%! randn ("state", 42);      % Initialize to make normest function reproducible
+%! rand ("state", 42);
 %! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector
 %!                         % to guarantee reproducible results
+%!
 %!test
-%! [u2,s2,v2,flag] = svds(A,k);
-%! s2 = diag(s2);
-%! assert(flag,!1);
-%! assert(s2, s(end:-1:end-k+1), 1e-10);
+%! [u2,s2,v2,flag] = svds (A,k);
+%! s2 = diag (s2);
+%! assert (flag, !1);
+%! assert (s2, s(end:-1:end-k+1), 1e-10);
+%!
 %!testif HAVE_UMFPACK
-%! [u2,s2,v2,flag] = svds(A,k,0,opts);
-%! s2 = diag(s2);
-%! assert(flag,!1);
-%! assert(s2, s(k:-1:1), 1e-10);
+%! [u2,s2,v2,flag] = svds (A,k,0,opts);
+%! s2 = diag (s2);
+%! assert (flag, !1);
+%! assert (s2, s(k:-1:1), 1e-10);
+%!
 %!testif HAVE_UMFPACK
 %! idx = floor(n/2);
 %! % Don't put sigma right on a singular value or there are convergence issues
 %! sigma = 0.99*s(idx) + 0.01*s(idx+1);
-%! [u2,s2,v2,flag] = svds(A,k,sigma,opts);
-%! s2 = diag(s2);
-%! assert(flag,!1);
-%! assert(s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10);
+%! [u2,s2,v2,flag] = svds (A,k,sigma,opts);
+%! s2 = diag (s2);
+%! assert (flag, !1);
+%! assert (s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10);
+%!
 %!test
-%! [u2,s2,v2,flag] = svds(zeros (10), k);
-%! assert (isequal(u2, eye (10, k)) && isequal (s2, zeros(k)) && isequal (v2, eye(10, 7)));
+%! [u2,s2,v2,flag] = svds (zeros (10), k);
+%! assert (u2, eye (10, k));
+%! assert (s2, zeros (k));
+%! assert (v2, eye (10, 7));
+%!
 %!test
 %! s = svds (speye (10));
 %! assert (s, ones (6, 1), 2*eps);
 
+%!test
+%! ## Restore random number generator seeds at end of tests
+%! rand ("state", rand_state);
+%! randn ("state", randn_state);
+
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} assert (@var{cond})
 ## @deftypefnx {Function File} {} assert (@var{cond}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{observed}, @var{expected})
 ## @deftypefnx {Function File} {} assert (@var{observed}, @var{expected}, @var{tol})
 ##
-## Produces an error if the condition is not met.  @code{assert} can be
+## Produce an error if the condition is not met.  @code{assert} can be
 ## called in three different ways.
 ##
 ## @table @code
 ## @item assert (@var{cond})
 ## @itemx assert (@var{cond}, @var{errmsg}, @dots{})
 ## @itemx assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## Called with a single argument @var{cond}, @code{assert} produces an
 ## error if @var{cond} is zero.  If called with a single argument a
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -78,25 +78,27 @@ function [code_r, idx_r] = example (name
     for i = 1:length (doidx)
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       printf ("%s example %d:%s\n\n", name, doidx(i), block);
     endfor
   endif
 
 endfunction
 
+
 %!## warning: don't modify the demos without modifying the tests!
 %!demo
 %! example ('example');
 %!demo
 %! t=0:0.01:2*pi; x = sin(t);
 %! plot (t,x)
 
 %!assert (example('example',1), "\n example ('example');");
 %!test
 %! [code, idx] = example ('example');
 %! assert (code, ...
 %!         "\n example ('example');\n t=0:0.01:2*pi; x = sin(t);\n plot (t,x)")
 %! assert (idx, [1, 23, 63]);
 
 %% Test input validation
-%!error example;
-%!error example('example', 3, 5)
+%!error example
+%!error example ('example', 3, 5)
+
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -45,37 +45,34 @@ along with Octave; see the file COPYING.
 #include <iostream>
 #include <string>
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
-#ifdef HAVE_QHULL
-extern "C" {
-#include <qhull/qhull_a.h>
-}
-
-#ifdef NEED_QHULL_VERSION
+#if defined (HAVE_QHULL)
+# include "oct-qhull.h"
+# if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__delaunayn__.oct 2007-08-21";
-#endif
+# endif
 #endif
 
 DEFUN_DLD (__delaunayn__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{T} =} __delaunayn__ (@var{pts})\n\
 @deftypefnx {Loadable Function} {@var{T} =} __delaunayn__ (@var{pts}, @var{options})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
   octave_value_list retval;
 
-#ifdef HAVE_QHULL
+#if defined (HAVE_QHULL)
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -40,39 +40,36 @@ qhull command
 
 #include "lo-ieee.h"
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
-#ifdef HAVE_QHULL
-extern "C" {
-#include <qhull/qhull_a.h>
-}
-
-#ifdef NEED_QHULL_VERSION
+#if defined (HAVE_QHULL)
+# include "oct-qhull.h"
+# if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__voronoi__.oct 2007-07-24";
-#endif
+# endif
 #endif
 
 DEFUN_DLD (__voronoi__, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   std::string caller = args(0).string_value ();
 
-#ifdef HAVE_QHULL
+#if defined (HAVE_QHULL)
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
   if (nargin < 2 || nargin > 3)
     {
       print_usage ();
       return retval;
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #define AMD_NAME(name) amd ## name
 #endif
 
 DEFUN_DLD (amd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} amd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} amd (@var{S}, @var{opts})\n\
 \n\
-Returns the approximate minimum degree permutation of a matrix.  This\n\
+Return the approximate minimum degree permutation of a matrix.  This\n\
 permutation such that the Cholesky@tie{}factorization of @code{@var{S}\n\
 (@var{p}, @var{p})} tends to be sparser than the Cholesky@tie{}factorization\n\
 of @var{S} itself.  @code{amd} is typically faster than @code{symamd} but\n\
 serves a similar purpose.\n\
 \n\
 The optional parameter @var{opts} is a structure that controls the\n\
 behavior of @code{amd}.  The fields of the structure are\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -124,18 +124,19 @@ Called with either a sparse or full matr
 @ifnottex\n\
 \n\
 @example\n\
 @var{L} * @var{L}' = @var{A}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
-For full matrices, if the 'lower' flag is set only the lower triangular part of the matrix \
-is used for the factorization, otherwise the upper triangular part is used.\n\
+For full matrices, if the 'lower' flag is set only the lower triangular part\n\
+of the matrix is used for the factorization, otherwise the upper triangular\n\
+part is used.\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -642,17 +642,17 @@ Ng, Oak Ridge National Laboratory.  (see
 }
 
 DEFUN_DLD (etree, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
-Returns the elimination tree for the matrix @var{S}.  By default @var{S}\n\
+Return the elimination tree for the matrix @var{S}.  By default @var{S}\n\
 is assumed to be symmetric and the symmetric elimination tree is\n\
 returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
 'sym' or 'col', for symmetric or column elimination tree respectively\n\
 \n\
 Called with a second argument, @code{etree} also returns the postorder\n\
 permutations on the tree.\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/config-module.awk b/src/DLD-FUNCTIONS/config-module.awk
--- a/src/DLD-FUNCTIONS/config-module.awk
+++ b/src/DLD-FUNCTIONS/config-module.awk
@@ -2,17 +2,18 @@ BEGIN {
   FS = "|";
   nfiles = 0;
 
   print "## DO NOT EDIT -- generated from module-files by config-module.awk";
   print ""
   print "EXTRA_DIST += \\"
   print "  DLD-FUNCTIONS/config-module.sh \\"
   print "  DLD-FUNCTIONS/config-module.awk \\"
-  print "  DLD-FUNCTIONS/module-files"
+  print "  DLD-FUNCTIONS/module-files \\"
+  print "  DLD-FUNCTIONS/oct-qhull.h"
   print ""
 }
 /^#.*/ { next; }
 {
   nfiles++;
   files[nfiles] = $1;
   cppflags[nfiles] = $2;
   ldflags[nfiles] = $3;
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -36,25 +36,22 @@ 2006-05-01 Tom Holroyd
 #include <sstream>
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "parse.h"
 
-#ifdef HAVE_QHULL
-extern "C" {
-#include <qhull/qhull_a.h>
-}
-
-# ifdef NEED_QHULL_VERSION
+#if defined (HAVE_QHULL)
+# include "oct-qhull.h"
+# if defined (NEED_QHULL_VERSION)
 char qh_version[] = "convhulln.oct 2007-07-24";
 # endif
-#endif /* HAVE_QHULL */
+#endif
 
 DEFUN_DLD (convhulln, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{h} =} convhulln (@var{pts})\n\
 @deftypefnx {Loadable Function} {@var{h} =} convhulln (@var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
 Compute the convex hull of the set of points @var{pts} which is a matrix\n\
 of size [n, dim] containing n points in a space of dimension dim.\n\
@@ -80,17 +77,17 @@ default arguments in @var{options}.  Use
 \n\
 If the second output @var{v} is requested the volume of the enclosing\n\
 convex hull is calculated.\n\n\
 @seealso{convhull, delaunayn, voronoin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-#ifdef HAVE_QHULL
+#if defined (HAVE_QHULL)
 
   int nargin = args.length ();
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
diff --git a/src/DLD-FUNCTIONS/oct-qhull.h b/src/DLD-FUNCTIONS/oct-qhull.h
new file mode 100644
--- /dev/null
+++ b/src/DLD-FUNCTIONS/oct-qhull.h
@@ -0,0 +1,54 @@
+/*
+
+Copyright (C) 2011 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_oct_qhull_h)
+#define octave_oct_qhull_h 1
+
+#include <cstdio>
+
+extern "C" {
+
+#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+# if defined (HAVE_QHULL_LIBQHULL_H)
+#  include <qhull/libqhull.h>
+# else
+#  include <qhull/qhull.h>
+# endif
+# include <qhull/qset.h>
+# include <qhull/geom.h>
+# include <qhull/poly.h>
+# include <qhull/io.h>
+#elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
+# if defined (HAVE_LIBQHULL_H)
+#  include <libqhull.h>
+# else
+#  include <qhull.h>
+# endif
+# include <qset.h>
+# include <geom.h>
+# include <poly.h>
+# include <io.h>
+#endif
+
+}
+
+#endif
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -1019,19 +1019,19 @@ D 50 p1284, 1994.\n\
 */
 
 DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} unique entries, sampled without\n\
-replacement from @code{1:@var{n}}. The complexity is O(@var{n}) in\n\
+replacement from @code{1:@var{n}}.  The complexity is O(@var{n}) in\n\
 memory and O(@var{m}) in time, unless @var{m} < @var{n}/5, in which case\n\
-O(@var{m}) memory is used as well. The randomization is performed using\n\
+O(@var{m}) memory is used as well.  The randomization is performed using\n\
 rand(). All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
 
 #ifdef USE_UNORDERED_MAP_WITH_TR1
 using std::tr1::unordered_map;
 #else
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -303,17 +303,17 @@ bp_table::do_add_breakpoint (const std::
                     {
                       bp_set.insert (fname);
                     }
                 }
             }
         }
     }
   else
-    error ("add_breakpoint: unable to find the function requested\n");
+    error ("add_breakpoint: unable to find the requested function\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
 int
@@ -358,17 +358,17 @@ bp_table::do_remove_breakpoint (const st
                     bp_set.erase (it);
 
                 }
 
               retval = results.length ();
             }
         }
       else
-        error ("remove_breakpoint: unable to find the function requested\n");
+        error ("remove_breakpoint: unable to find the requested function\n");
     }
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
@@ -398,17 +398,17 @@ bp_table::do_remove_all_breakpoints_in_f
           bp_set_iterator it = bp_set.find (fname);
           if (it != bp_set.end ())
             bp_set.erase (it);
 
         }
     }
   else if (! silent)
     error ("remove_all_breakpoint_in_file: "
-           "unable to find the function requested\n");
+           "unable to find the requested function\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 void
 bp_table::do_remove_all_breakpoints (void)
@@ -499,30 +499,41 @@ intmap_to_ov (const bp_table::intmap& li
 
   retval.resize (dim_vector (1, idx));
 
   return retval;
 }
 
 DEFUN (dbstop, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{rline} =} dbstop (@var{func}, @var{line}, @dots{})\n\
-Set a breakpoint in a function\n\
-@table @code\n\
+@deftypefn  {Loadable Function} {@var{rline} =} dbstop (\"@var{func}\")\n\
+@deftypefnx {Loadable Function} {@var{rline} =} dbstop (\"@var{func}\", @var{line}, @dots{})\n\
+Set a breakpoint in function @var{func}.\n\
+\n\
+Arguments are\n\
+\n\
+@table @var\n\
 @item func\n\
-String representing the function name.  When already in debug\n\
+Function name as a string variable.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 \n\
 @item line\n\
-Line number you would like the breakpoint to be set on.  Multiple\n\
-lines might be given as separate arguments or as a vector.\n\
+Line number where the breakpoint should be set.  Multiple\n\
+lines may be given as separate arguments or as a vector.\n\
 @end table\n\
 \n\
-The rline returned is the real line that the breakpoint was set at.\n\
-@seealso{dbclear, dbstatus, dbstep}\n\
+When called with a single argument @var{func}, the breakpoint\n\
+is set at the first executable line in the named function.\n\
+\n\
+The optional output @var{rline} is the real line number where the\n\
+breakpoint was set.  This can differ from specified line if\n\
+the line is not executable.  For example, if a breakpoint attempted on a\n\
+blank line then Octave will set the real breakpoint at the\n\
+next executable line.\n\
+@seealso{dbclear, dbstatus, dbstep, debug_on_error, debug_on_warning, debug_on_interrupt}\n\
 @end deftypefn")
 {
   bp_table::intmap retval;
   std::string symbol_name;
   bp_table::intmap lines;
 
   parse_dbfunction_params ("dbstop", args, symbol_name, lines);
 
@@ -532,29 +543,36 @@ The rline returned is the real line that
   if (! error_state)
     retval = bp_table::add_breakpoint (symbol_name, lines);
 
   return intmap_to_ov (retval);
 }
 
 DEFUN (dbclear, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} dbclear (@var{func}, @var{line}, @dots{})\n\
-Delete a breakpoint in a function\n\
-@table @code\n\
+@deftypefn  {Loadable Function} {} dbclear (\"@var{func}\")\n\
+@deftypefnx {Loadable Function} {} dbclear (\"@var{func}\", @var{line}, @dots{})\n\
+Delete a breakpoint in the function @var{func}.\n\
+\n\
+Arguments are\n\
+\n\
+@table @var\n\
 @item func\n\
-String representing the function name.  When already in debug\n\
+Function name as a string variable.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 \n\
 @item line\n\
-Line number where you would like to remove the breakpoint.  Multiple\n\
-lines might be given as separate arguments or as a vector.\n\
+Line number from which to remove a breakpoint.  Multiple\n\
+lines may be given as separate arguments or as a vector.\n\
 @end table\n\
-No checking is done to make sure that the line you requested is really\n\
-a breakpoint.  If you get the wrong line nothing will happen.\n\
+\n\
+When called without a line number specification all breakpoints\n\
+in the named function are cleared.\n\
+\n\
+If the requested line is not a breakpoint no action is performed.\n\
 @seealso{dbstop, dbstatus, dbwhere}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string symbol_name = "";
   bp_table::intmap lines;
 
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
@@ -562,36 +580,53 @@ a breakpoint.  If you get the wrong line
   if (! error_state)
     bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {lst =} dbstatus (@var{func})\n\
-Return a vector containing the lines on which a function has\n\
-breakpoints set.\n\
-@table @code\n\
-@item func\n\
-String representing the function name.  When already in debug\n\
-mode this should be left out.\n\
+@deftypefn  {Loadable Function} {} dbstatus ()\n\
+@deftypefnx {Loadable Function} {@var{brk_list} =} dbstatus ()\n\
+@deftypefnx {Loadable Function} {@var{brk_list} =} dbstatus (\"@var{func}\")\n\
+Report the location of active breakpoints.\n\
+\n\
+When called with no input or output arguments, print the list of\n\
+all functions with breakpoints and the line numbers where those\n\
+breakpoints are set.\n\
+If a function name @var{func} is specified then only report breakpoints\n\
+for the named function.\n\
+\n\
+The optional return argument @var{brk_list} is a struct array with the\n\
+following fields.\n\
+\n\
+@table @asis\n\
+@item name\n\
+The name of the function with a breakpoint.\n\
+\n\
+@item file\n\
+The name of the m-file where the function code is located.\n\
+\n\
+@item line\n\
+A line number, or vector of line numbers, with a breakpoint.\n\
 @end table\n\
+\n\
 @seealso{dbclear, dbwhere}\n\
 @end deftypefn")
 {
   octave_map retval;
   int nargin = args.length ();
   octave_value_list fcn_list;
   bp_table::fname_line_map bp_list;
   std::string symbol_name;
 
   if (nargin != 0 && nargin != 1)
     {
-      error ("dbstatus: only zero or one arguements accepted\n");
+      error ("dbstatus: only zero or one arguments accepted\n");
       return octave_value ();
     }
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           symbol_name = args(0).string_value ();
@@ -658,18 +693,19 @@ mode this should be left out.\n\
 
       return octave_value (retval);
     }
 }
 
 DEFUN (dbwhere, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbwhere ()\n\
-Show where we are in the code\n\
-@seealso{dbclear, dbstatus, dbstop}\n\
+In debugging mode, report the current file and line number where\n\
+execution is stopped.\n\
+@seealso{dbstatus, dbcont, dbstep, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_user_code *dbg_fcn = get_user_code ();
 
   if (dbg_fcn)
     {
@@ -699,17 +735,17 @@ Show where we are in the code\n\
               if (! line.empty ())
                 octave_stdout << l << ": " << line << std::endl;
             }
         }
       else
         octave_stdout << " <unknown line>" << std::endl;
     }
   else
-    error ("dbwhere: must be inside of a user function to use dbwhere\n");
+    error ("dbwhere: must be inside a user function to use dbwhere\n");
 
   return retval;
 }
 
 // Copied and modified from the do_type command in help.cc
 // Maybe we could share some code?
 void
 do_dbtype (std::ostream& os, const std::string& name, int start, int end)
@@ -749,19 +785,27 @@ do_dbtype (std::ostream& os, const std::
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} dbtype ()\n\
-List script file with line numbers.\n\
-@seealso{dbclear, dbstatus, dbstop}\n\
+@deftypefn  {Loadable Function} {} dbtype ()\n\
+@deftypefnx {Loadable Function} {} dbtype (\"startl:endl\")\n\
+@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\")\n\
+@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\", \"startl:endl\")\n\
+When in debugging mode and called with no arguments, list the script file\n\
+being debugged with line numbers.  An optional range specification,\n\
+specified as a string, can be used to list only a portion of the file.\n\
+\n\
+When called with the name of a function, list that script file\n\
+with line numbers.\n\
+@seealso{dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_user_code *dbg_fcn;
 
   int nargin = args.length ();
   string_vector argv = args.make_argv ("dbtype");
 
@@ -770,17 +814,17 @@ List script file with line numbers.\n\
       switch (nargin)
         {
         case 0: // dbtype
           dbg_fcn = get_user_code ();
 
           if (dbg_fcn)
             do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
           else
-            error ("dbtype: must be in a user function to give no arguments to dbtype\n");
+            error ("dbtype: must be inside a user function to give no arguments to dbtype\n");
           break;
 
         case 1: // (dbtype func) || (dbtype start:end)
           dbg_fcn = get_user_code (argv[1]);
 
           if (dbg_fcn)
             do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
           else
@@ -882,17 +926,17 @@ do_dbstack (const octave_value_list& arg
           n = atoi (s_arg.c_str ());
         }
       else
         n = args(0).int_value ();
 
       if (n > 0)
         nskip = n;
       else
-        error ("dbstack: expecting N to be a nonnegative integer");
+        error ("dbstack: N must be a non-negative integer");
     }
 
   if (! error_state)
     {
       octave_map stk = octave_call_stack::backtrace (nskip, curr_frame);
 
       if (nargout == 0)
         {
@@ -955,20 +999,48 @@ do_dbstack (const octave_value_list& arg
 void
 show_octave_dbstack (void)
 {
   do_dbstack (octave_value_list (), 0, std::cerr);
 }
 
 DEFUN (dbstack, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{stack}, @var{idx}]} dbstack (@var{n})\n\
-Print or return current stack information.  With optional argument\n\
-@var{n}, omit the @var{n} innermost stack frames.\n\
-@seealso{dbclear, dbstatus, dbstop}\n\
+@deftypefn  {Loadable Function} {} dbstack ()\n\
+@deftypefnx {Loadable Function} {} dbstack (@var{n})\n\
+@deftypefnx {Loadable Function} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
+Display or return current debugging function stack information.\n\
+With optional argument @var{n}, omit the @var{n} innermost stack frames.\n\
+\n\
+The optional return argument @var{stack} is a struct array with the\n\
+following fields:\n\
+\n\
+@table @asis\n\
+@item file\n\
+The name of the m-file where the function code is located.\n\
+\n\
+@item name\n\
+The name of the function with a breakpoint.\n\
+\n\
+@item line\n\
+The line number of an active breakpoint.\n\
+\n\
+@item column\n\
+The column number of the line where the breakpoint begins.\n\
+\n\
+@item scope\n\
+Undocumented.\n\
+\n\
+@item context\n\
+Undocumented.\n\
+@end table\n\
+\n\
+The return argument @var{idx} specifies which element of the @var{stack}\n\
+struct array is currently active.\n\
+@seealso{dbup, dbdown, dbwhere, dbstatus}\n\
 @end deftypefn")
 {
   return do_dbstack (args, nargout, octave_stdout);
 }
 
 static void
 do_dbupdown (const octave_value_list& args, const std::string& who)
 {
@@ -999,56 +1071,59 @@ do_dbupdown (const octave_value_list& ar
 }
 
 DEFUN (dbup, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} dbup\n\
 @deftypefnx {Loadable Function} {} dbup (@var{n})\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move up one frame.\n\
-@seealso{dbstack}\n\
+@seealso{dbstack, dbdown}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbup");
 
   return retval;
 }
 
 DEFUN (dbdown, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} dbdown\n\
 @deftypefnx {Loadable Function} {} dbdown (@var{n})\n\
 In debugging mode, move down the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move down one frame.\n\
-@seealso{dbstack}\n\
+@seealso{dbstack, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbdown");
 
   return retval;
 }
 
 DEFUN (dbstep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dbstep\n\
 @deftypefnx {Command} {} dbstep @var{n}\n\
 @deftypefnx {Command} {} dbstep in\n\
 @deftypefnx {Command} {} dbstep out\n\
+@deftypefnx {Command} {} dbnext @dots{}\n\
 In debugging mode, execute the next @var{n} lines of code.\n\
-If @var{n} is omitted , execute the next single line of code.\n\
-If the next line of code is itself\n\
-defined in terms of an m-file remain in the existing function.\n\
+If @var{n} is omitted, execute the next single line of code.\n\
+If the next line of code is itself defined in terms of an m-file remain in\n\
+the existing function.\n\
 \n\
 Using @code{dbstep in} will cause execution of the next line to step into\n\
 any m-files defined on the next line.  Using @code{dbstep out} will cause\n\
 execution to continue until the current function returns.\n\
+\n\
+@code{dbnext} is an alias for @code{dbstep}.\n\
 @seealso{dbcont, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       int nargin = args.length ();
 
       if (nargin > 1)
@@ -1084,17 +1159,17 @@ execution to continue until the current 
                           tree_evaluator::dbstep_flag = n;
                         }
                       else
                         error ("dbstep: invalid argument");
                     }
                 }
             }
           else
-            error ("dbstep: expecting character string as argument");
+            error ("dbstep: input argument must be a character string");
         }
       else
         {
           Vdebugging = false;
 
           tree_evaluator::dbstep_flag = 1;
         }
     }
@@ -1104,17 +1179,17 @@ execution to continue until the current 
   return octave_value_list ();
 }
 
 DEFALIAS (dbnext, dbstep);
 
 DEFUN (dbcont, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbcont\n\
-In debugging mode, quit debugging mode and continue execution.\n\
+Leave command-line debugging mode and continue code execution normally.\n\
 @seealso{dbstep, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () == 0)
         {
           Vdebugging = false;
@@ -1128,18 +1203,19 @@ In debugging mode, quit debugging mode a
     error ("dbcont: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (dbquit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbquit\n\
-In debugging mode, quit debugging mode and return to the top level.\n\
-@seealso{dbstep, dbcont}\n\
+Quit debugging mode immediately without further code execution and\n\
+return to the Octave prompt.\n\
+@seealso{dbcont, dbstep}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () == 0)
         {
           Vdebugging = false;
 
@@ -1154,18 +1230,18 @@ In debugging mode, quit debugging mode a
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (isdebugmode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} isdebugmode ()\n\
-Return true if debug mode is on, otherwise false.\n\
-@seealso{dbstack, dbclear, dbstop, dbstatus}\n\
+Return true if in debugging mode, otherwise false.\n\
+@seealso{dbwhere, dbstack, dbstatus}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = Vdebugging;
   else
     print_usage ();
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -547,17 +547,18 @@ check_state (const std::string& state)
     return 1;
   else if (state == "error")
     return 2;
   else
     return -1;
 }
 
 // For given warning ID, return 0 if warnings are disabled, 1 if
-// enabled, and 2 if this ID should be an error instead of a warning.
+// enabled, and 2 if the given ID should be an error instead of a
+// warning.
 
 int
 warning_enabled (const std::string& id)
 {
   int retval = 0;
 
   int all_state = -1;
   int id_state = -1;
@@ -593,18 +594,19 @@ warning_enabled (const std::string& id)
                 id_found = true;
             }
 
           if (all_found && id_found)
             break;
         }
     }
 
+  // If "all" is not present, assume warnings are enabled.
   if (all_state == -1)
-    panic_impossible ();
+    all_state = 1;
 
   if (all_state == 0)
     {
       if (id_state >= 0)
         retval = id_state;
     }
   else if (all_state == 1)
     {
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1560,17 +1560,17 @@ The command\n\
 \n\
 @example\n\
 save -binary data a b*\n\
 @end example\n\
 \n\
 @noindent\n\
 saves the variable @samp{a} and all variables beginning with @samp{b} to\n\
 the file @file{data} in Octave's binary format.\n\
-@seealso{load, default_save_options, dlmread, csvread, fread}\n\
+@seealso{load, default_save_options, save_header_format_string, dlmread, csvread, fread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length ();
 
   string_vector argv = args.make_argv ();
 
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -664,17 +664,17 @@ variable value is restored when exiting 
 }
 
 /*
 %!test
 %! x = 0:10;
 %! save = allow_noninteger_range_as_index ();
 %! warn_state = warning ("query", "Octave:noninteger-range-as-index");
 %! unwind_protect
-%!   save = allow_noninteger_range_as_index (false);
+%!   allow_noninteger_range_as_index (false);
 %!   fail ('x(2.1:5)');
 %!   assert (x(2:5), 1:4);
 %!   allow_noninteger_range_as_index (true);
 %!   warning ("off", "Octave:noninteger-range-as-index");
 %!   assert (x(2.49:5), 1:3);
 %!   assert (x(2.5:5), 2:4);
 %!   assert (x(2.51:5), 2:4);
 %! unwind_protect_cleanup
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -316,17 +316,17 @@ octave_pager_stream::stream (void)
 {
   return instance_ok () ? *instance : std::cout;
 }
 
 void
 octave_pager_stream::flush_current_contents_to_diary (void)
 {
   if (instance_ok ())
-    instance->flush_current_contents_to_diary ();
+    instance->do_flush_current_contents_to_diary ();
 }
 
 void
 octave_pager_stream::set_diary_skip (void)
 {
   if (instance_ok ())
     instance->do_set_diary_skip ();
 }
@@ -635,17 +635,17 @@ terminal window in characters (rows and 
   size(1) = command_editor::terminal_cols ();
 
   return octave_value (size);
 }
 
 DEFUN (page_output_immediately, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} page_output_immediately ()\n\
-@deftypefnx {Built-in Function} {@var{val} =} page_output_immediately (@var{new_val})\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} page_output_immediately (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} page_output_immediately (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave sends\n\
 output to the pager as soon as it is available.  Otherwise, Octave\n\
 buffers its output and waits until just before the prompt is printed to\n\
 flush it to the pager.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -68,17 +68,17 @@ static const char *former_built_in_varia
   "beep_on_error",
   "completion_append_char",
   "crash_dumps_octave_core",
   "current_script_file_name",
   "debug_on_error",
   "debug_on_interrupt",
   "debug_on_warning",
   "debug_symtab_lookups",
-  "default_save_format",
+  "default_save_options",
   "echo_executing_commands",
   "fixed_point_format",
   "gnuplot_binary",
   "gnuplot_command_axes",
   "gnuplot_command_end",
   "gnuplot_command_plot",
   "gnuplot_command_replot",
   "gnuplot_command_splot",
