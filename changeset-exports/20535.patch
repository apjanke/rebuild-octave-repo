# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1443730699 14400
#      Thu Oct 01 16:18:19 2015 -0400
# Node ID b70cc4bd8109b0f7784874a5f13e32ec1f3786da
# Parent  fcb792acab9b2bbfc011e7b2687c80831254d0ae
begin removal of global error_state variable

* gripes.h, gripes.cc (gripe_library_execution_error): Delete.

* error.cc (warning_state): Delete unused variable.
(reset_error_handler): Don't set warning_state or error_state.
(debug_or_throw_exception): New static function.
(verror): Don't check error_state.
(vmessage): Call debug_or_throw_exception instead of setting
error_state.
(error_1, error_2): Combine into single function, error_1 that prints
error message and ultimately calls debug_or_throw_exception.
(verror, verror_with_cfn, verror_with_id_cfn): Call error_1.  Don't
check or set warning_state.
(error): Don't check error_state.
(Flasterror, Flasterr): Adapt to not using error_state.
(interpreter_try): Don't unwind_protect error_state.

* NEWS: Update.
* doc/interpreter/external.txi: Explain octave_execution_exception
instead of error_state for matrix addition example.

* jit-typeinfo.cc (octave_jit_gripe_nan_to_logical_conversion,
octave_jit_ginvalid_index, octave_jit_gindex_range,
octave_jit_paren_scalar, octave_jit_paren_scalar_subsasgn):
Don't catch octave_execution_exception.

* cellfun.cc (Fcellfun): Use exceptions instead of error_state.
* ls-mat-ascii.cc (save_mat_ascii_data): Likewise.
* mex.cc (mexCallMATLAB, mexEvalString): Likewise.
* variables.cc (safe_symbol_lookup): Likewise.

* svd.cc (Fsvd): Eliminate use of error_state.
* __magick_read__.cc (read_file, write_file): Likewise.

* variables.cc (generate_struct_completions): Eliminate use of
obsolete warning_state variable.

* ov-builtin.cc (octave_builtin::do_multi_index_op): Don't catch
octave_execution_exception and call gripe_library_execution_error.

* ov-class.cc (octave_class::reconstruct_exemplar): Eliminate use of
error_state.  Catch possible octave_execution_exception in
do_multi_index_op.

* ov-mex-fcn.cc (octave_mex_function::do_multi_index_op): Eliminate
use of error_state.  Catch possible octave_execution_exception in
call_mex.

* ov-fcn-handle.cc (octave_fcn_binder::maybe_binder): Eliminate use of
error_state.

* ov-oncleanup.cc (octave_oncleanup::~octave_oncleanup): Eliminate use
of error_state.  Propagate possible octave_execution_exception from
do_multi_index_op.

* ov.cc (octave_value::assign, do_binary_op, do_unary_op,
octave_value::do_non_const_unary_op): Don't catch
octave_execution_exception here.

* oct-parse.in.yy (octave_base_parser::finish_colon_expression,
octave_base_parser::finish_array_list): Eliminate use of warning_state
and error_state.
(Feval, Fevalin): Use exceptions instead of error_state.

* pt-eval.cc, pt-eval.h (tree_evaluator::unwind_protect_exception):
New static variable.
* (tree_evaluator::visit_statement): Don't catch
octave_execution_exception here.
(tree_evaluator::visit_try_catch_command,
tree_evaluator::do_unwind_protect_cleanup): Eliminate use of error_state.
(tree_evaluator::visit_unwind_protect_command): Use
unwind_protect_exception to track whether an exception has occurred in
the try block.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -66,16 +66,22 @@ Summary of important user-visible change
       default_save_options    java_new
       gen_doc_cache           java_unsigned_conversion
       interp1q                javafields
       isequalwithequalnans    javamethods
       java_convert_matrix     re_read_readline_init_file
       java_debug              read_readline_init_file
       java_invoke             saving_history
 
+ ** The global error_state variable in Octave's C++ API has been
+    deprecated and will be removed in a future version.  Now the error
+    and print_usage functions throw an exception
+    (octave_execution_error) after displaying the error message.  This
+    makes the error and print_usage functions in C++ work more like the
+    corresponding functions in the scripting language.
 
 Summary of important user-visible changes for version 4.0:
 ---------------------------------------------------------
 
  ** A graphical user interface is now the default when running Octave
     interactively.  The start-up option --no-gui will run the familiar
     command line interface, and still allows use of the GUI dialogs and
     qt plotting toolkit.  The option --no-gui-libs runs a minimalist
diff --git a/doc/interpreter/external.txi b/doc/interpreter/external.txi
--- a/doc/interpreter/external.txi
+++ b/doc/interpreter/external.txi
@@ -358,22 +358,25 @@ The typical way to extract a matrix or a
 @example
 @EXAMPLEFILE(addtwomatrices.cc)
 @end example
 
 To avoid segmentation faults causing Octave to abort this function
 explicitly checks that there are sufficient arguments available before
 accessing these arguments.  It then obtains two multi-dimensional arrays
 of type @code{NDArray} and adds these together.  Note that the array_value
-method is called without using the @code{is_matrix_type} type, and instead the
-error_state is checked before returning @code{A + B}.  The reason to
+method is called without using the @code{is_matrix_type} type.  If an
+error occurs when attempting to extract the value, Octave will print a
+message and throw an exception.  The reason to
 prefer this is that the arguments might be a type that is not an
 @code{NDArray}, but it would make sense to convert it to one.  The
 @code{array_value} method allows this conversion to be performed
-transparently if possible, and sets @code{error_state} if it is not.
+transparently if possible.  If you need to catch errors like this and
+perform some kind of cleanup or other operation, you can catch the
+@code{octave_execution_error} exception.
 
 @code{A + B}, operating on two @code{NDArray}'s returns an
 @code{NDArray}, which is cast to an @code{octave_value} on the return
 from the function.  An example of the use of this demonstration function is
 
 @example
 @group
 addtwomatrices (ones (2, 2), eye (2, 2))
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -65,50 +65,48 @@ along with Octave; see the file COPYING.
 
 static octave_value_list
 get_output_list (octave_idx_type count, octave_idx_type nargout,
                  const octave_value_list& inputlist,
                  octave_value& func,
                  octave_value& error_handler)
 {
   octave_value_list tmp;
+
+  bool execution_error = false;
+
   try
     {
       tmp = func.do_multi_index_op (nargout, inputlist);
     }
-  catch (octave_execution_exception)
+  catch (const octave_execution_exception&)
     {
       if (error_handler.is_defined ())
-        error_state = 1;
+        execution_error = true;
+      else
+        octave_throw_execution_exception ();
     }
 
-  if (error_state)
+  if (execution_error)
     {
       if (error_handler.is_defined ())
         {
           octave_scalar_map msg;
           msg.assign ("identifier", last_error_id ());
           msg.assign ("message", last_error_message ());
           msg.assign ("index",
                       static_cast<double> (count
                                            + static_cast<octave_idx_type>(1)));
 
           octave_value_list errlist = inputlist;
           errlist.prepend (msg);
 
           buffer_error_messages--;
 
-          error_state = 0;
-
           tmp = error_handler.do_multi_index_op (nargout, errlist);
-
-          buffer_error_messages++;
-
-          if (error_state)
-            tmp.clear ();
         }
       else
         tmp.clear ();
     }
 
   return tmp;
 }
 
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -88,48 +88,35 @@ static std::string Vlast_error_id;
 
 // The last file in which an error occured
 static octave_map Vlast_error_stack;
 
 // Current error state.
 //
 // Valid values:
 //
-//   -2: an error has occurred, but don't print any messages.
-//   -1: an error has occurred, we are printing a traceback
 //    0: no error
 //    1: an error has occurred
 //
 int error_state = 0;
 
-// Current warning state.
-//
-//  Valid values:
-//
-//    0: no warning
-//    1: a warning has occurred
-//
-int warning_state = 0;
-
 // Tell the error handler whether to print messages, or just store
 // them for later.  Used for handling errors in eval() and
 // the 'unwind_protect' statement.
 int buffer_error_messages = 0;
 
 // TRUE means error messages are turned off.
 bool discard_error_messages = false;
 
 // TRUE means warning messages are turned off.
 bool discard_warning_messages = false;
 
 void
 reset_error_handler (void)
 {
-  error_state = 0;
-  warning_state = 0;
   buffer_error_messages = 0;
   discard_error_messages = false;
 }
 
 static void
 initialize_warning_options (const std::string& state)
 {
   octave_scalar_map initw;
@@ -141,16 +128,36 @@ initialize_warning_options (const std::s
 }
 
 static octave_map
 initialize_last_error_stack (void)
 {
   return octave_call_stack::empty_backtrace ();
 }
 
+static void
+debug_or_throw_exception (void)
+{
+  if ((interactive || forced_interactive)
+      && Vdebug_on_error && octave_call_stack::caller_user_code ())
+    {
+      unwind_protect frame;
+      frame.protect_var (Vdebug_on_error);
+      Vdebug_on_error = false;
+
+      tree_evaluator::debug_mode = true;
+
+      tree_evaluator::current_frame = octave_call_stack::current_frame ();
+
+      do_keyboard (octave_value_list ());
+    }
+  else
+    octave_throw_execution_exception ();
+}
+
 // Warning messages are never buffered.
 
 static void
 vwarning (const char *name, const char *id, const char *fmt, va_list args)
 {
   if (discard_warning_messages)
     return;
 
@@ -199,17 +206,17 @@ verror (bool save_last_error, std::ostre
   //        message, not the traceback information.
 
   std::ostringstream output_buf;
 
   octave_vformat (output_buf, fmt, args);
 
   std::string base_msg = output_buf.str ();
 
-  bool to_beep_or_not_to_beep_p = Vbeep_on_error && ! error_state;
+  bool to_beep_or_not_to_beep_p = Vbeep_on_error;
 
   std::string msg_string;
 
   if (to_beep_or_not_to_beep_p)
     msg_string = "\a";
 
   if (name)
     msg_string += std::string (name) + ": ";
@@ -233,17 +240,17 @@ verror (bool save_last_error, std::ostre
                   msg_string += cfn + ' ';
                 }
             }
         }
     }
 
   msg_string += base_msg + "\n";
 
-  if (! error_state && save_last_error)
+  if (save_last_error)
     {
       // This is the first error in a possible series.
 
       Vlast_error_id = id;
       Vlast_error_message = base_msg;
 
       octave_user_code *fcn = octave_call_stack::caller_user_code ();
 
@@ -327,58 +334,16 @@ pr_where (const char *who)
       int line = elt.line ();
       int column = elt.column ();
 
       pr_where_1 ("    %s at line %d column %d\n",
                   fcn_name.c_str (), line, column);
     }
 }
 
-// Note that we don't actually print any message if the error string
-// is just "" or "\n".  This allows error ("") and error ("\n") to
-// just set the error state.
-
-static void
-error_1 (std::ostream& os, const char *name, const char *id,
-         const char *fmt, va_list args, bool with_cfn = false)
-{
-  if (error_state != -2)
-    {
-      if (fmt && *fmt)
-        {
-          size_t len = strlen (fmt);
-
-          if (len > 0)
-            {
-              if (fmt[len - 1] == '\n')
-                {
-                  if (len > 1)
-                    {
-                      // Strip newline before issuing error
-                      std::string tmp_fmt (fmt, len - 1);
-                      verror (true, os, name, id, tmp_fmt.c_str (),
-                              args, with_cfn);
-                    }
-
-                  error_state = -2;
-                }
-              else
-                {
-                  verror (true, os, name, id, fmt, args, with_cfn);
-
-                  if (! error_state)
-                    error_state = 1;
-                }
-            }
-        }
-      else
-        panic ("error_1: invalid format");
-    }
-}
-
 void
 vmessage (const char *name, const char *fmt, va_list args)
 {
   verror (false, std::cerr, name, "", fmt, args);
 }
 
 void
 message (const char *name, const char *fmt, ...)
@@ -404,17 +369,18 @@ message_with_id (const char *name, const
   vmessage_with_id (name, id, fmt, args);
   va_end (args);
 }
 
 void
 usage_1 (const char *id, const char *fmt, va_list args)
 {
   verror (true, std::cerr, "usage", id, fmt, args);
-  error_state = -1;
+
+  debug_or_throw_exception ();
 }
 
 void
 vusage (const char *fmt, va_list args)
 {
   usage_1 ("", fmt, args);
 }
 
@@ -438,92 +404,104 @@ usage_with_id (const char *id, const cha
 {
   va_list args;
   va_start (args, fmt);
   vusage_with_id (id, fmt, args);
   va_end (args);
 }
 
 static void
-error_2 (const char *id, const char *fmt, va_list args, bool with_cfn = false)
+error_1 (std::ostream& os, const char *name, const char *id,
+         const char *fmt, va_list args, bool with_cfn = false)
 {
-  int init_state = error_state;
-
-  error_1 (std::cerr, "error", id, fmt, args, with_cfn);
-
-  bool in_user_code = octave_call_stack::caller_user_code () != 0;
-
-  if (error_state != -2 && in_user_code && ! discard_error_messages)
-    pr_where ("error");
-
-  if (interactive && Vdebug_on_error && init_state == 0 && in_user_code)
+  if (fmt)
     {
-      unwind_protect frame;
-      frame.protect_var (Vdebug_on_error);
-      Vdebug_on_error = false;
-
-      error_state = 0;
+      if (*fmt)
+        {
+          size_t len = strlen (fmt);
 
-      tree_evaluator::debug_mode = true;
+          if (len > 0)
+            {
+              if (fmt[len - 1] == '\n')
+                {
+                  if (len > 1)
+                    {
+                      char *tmp_fmt = strsave (fmt);
+                      tmp_fmt[len - 1] = '\0';
+                      verror (true, os, name, id, tmp_fmt, args, with_cfn);
+                      delete [] tmp_fmt;
+                    }
+                }
+              else
+                {
+                  verror (true, os, name, id, fmt, args, with_cfn);
 
-      tree_evaluator::current_frame = octave_call_stack::current_frame ();
+                  bool in_user_code = octave_call_stack::caller_user_code () != 0;
 
-      do_keyboard (octave_value_list ());
+                  if (in_user_code && ! discard_error_messages)
+                    pr_where ("error");
+                }
+            }
+        }
     }
+  else
+    panic ("error_1: invalid format");
+
+  debug_or_throw_exception ();
 }
 
 void
 verror (const char *fmt, va_list args)
 {
-  error_2 ("", fmt, args);
+  error_1 (std::cerr, "error", "", fmt, args);
 }
 
 void
 error (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror (fmt, args);
   va_end (args);
 }
 
 void
 verror_with_cfn (const char *fmt, va_list args)
 {
-  error_2 ("", fmt, args, true);
+  error_1 (std::cerr, "error", "", fmt, args, true);
 }
 
 void
 error_with_cfn (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror_with_cfn (fmt, args);
   va_end (args);
 }
 
 void
 verror_with_id (const char *id, const char *fmt, va_list args)
 {
-  error_2 (id, fmt, args);
+  error_1 (std::cerr, "error", id, fmt, args);
 }
 
 void
 error_with_id (const char *id, const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror_with_id (id, fmt, args);
   va_end (args);
 }
 
 void
 verror_with_id_cfn (const char *id, const char *fmt, va_list args)
 {
-  error_2 (id, fmt, args, true);
+  error_1 (std::cerr, "error", id, fmt, args, true);
 }
 
 void
 error_with_id_cfn (const char *id, const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror_with_id_cfn (id, fmt, args);
@@ -627,17 +605,17 @@ static void
 warning_1 (const char *id, const char *fmt, va_list args)
 {
   int warn_opt = warning_enabled (id);
 
   if (warn_opt == 2)
     {
       // Handle this warning as an error.
 
-      error_2 (id, fmt, args);
+      error_1 (std::cerr, "error", id, fmt, args);
     }
   else if (warn_opt == 1)
     {
       bool fmt_suppresses_backtrace = false;
       size_t fmt_len = fmt ? strlen (fmt) : 0;
       fmt_suppresses_backtrace = (fmt_len > 0 && fmt[fmt_len-1] == '\n');
 
       if (fmt_suppresses_backtrace && fmt_len > 1)
@@ -646,24 +624,21 @@ warning_1 (const char *id, const char *f
           std::string tmp_fmt (fmt, fmt_len - 1);
           vwarning ("warning", id, tmp_fmt.c_str (), args);
         }
       else
         vwarning ("warning", id, fmt, args);
 
       bool in_user_code = octave_call_stack::caller_user_code () != 0;
 
-
       if (! fmt_suppresses_backtrace && in_user_code
-          && Vbacktrace_on_warning && ! warning_state
+          && Vbacktrace_on_warning
           && ! discard_warning_messages)
         pr_where ("warning");
 
-      warning_state = 1;
-
       if ((interactive || forced_interactive)
           && Vdebug_on_warning && in_user_code)
         {
           unwind_protect frame;
           frame.protect_var (Vdebug_on_warning);
           Vdebug_on_warning = false;
 
           tree_evaluator::debug_mode = true;
@@ -855,130 +830,127 @@ error.  Typically @var{err} is returned 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
   else
     {
       const octave_scalar_map err = args(0).scalar_map_value ();
 
-      if (! error_state)
+      if (err.contains ("message") && err.contains ("identifier"))
         {
-          if (err.contains ("message") && err.contains ("identifier"))
-            {
-              std::string msg = err.contents ("message").string_value ();
-              std::string id = err.contents ("identifier").string_value ();
-              int len = msg.length ();
-
-              std::string file;
-              std::string nm;
-              int l = -1;
-              int c = -1;
-
-              octave_map err_stack = initialize_last_error_stack ();
-
-              if (err.contains ("stack"))
-                {
-                  err_stack = err.contents ("stack").map_value ();
+          std::string msg = err.contents ("message").string_value ();
+          std::string id = err.contents ("identifier").string_value ();
+          int len = msg.length ();
 
-                  if (err_stack.numel () > 0)
-                    {
-                      if (err_stack.contains ("file"))
-                        file = err_stack.contents ("file")(0).string_value ();
-
-                      if (err_stack.contains ("name"))
-                        nm = err_stack.contents ("name")(0).string_value ();
+          std::string file;
+          std::string nm;
+          int l = -1;
+          int c = -1;
 
-                      if (err_stack.contains ("line"))
-                        l = err_stack.contents ("line")(0).nint_value ();
+          octave_map err_stack = initialize_last_error_stack ();
 
-                      if (err_stack.contains ("column"))
-                        c = err_stack.contents ("column")(0).nint_value ();
-                    }
-                }
+          if (err.contains ("stack"))
+            {
+              err_stack = err.contents ("stack").map_value ();
 
-              // Ugh.
-              char *tmp_msg = strsave (msg.c_str ());
-              if (tmp_msg[len-1] == '\n')
+              if (err_stack.numel () > 0)
                 {
-                  if (len > 1)
-                    {
-                      tmp_msg[len - 1] = '\0';
-                      rethrow_error (id.c_str (), "%s\n", tmp_msg);
-                    }
+                  if (err_stack.contains ("file"))
+                    file = err_stack.contents ("file")(0).string_value ();
+
+                  if (err_stack.contains ("name"))
+                    nm = err_stack.contents ("name")(0).string_value ();
+
+                  if (err_stack.contains ("line"))
+                    l = err_stack.contents ("line")(0).nint_value ();
+
+                  if (err_stack.contains ("column"))
+                    c = err_stack.contents ("column")(0).nint_value ();
                 }
-              else
-                rethrow_error (id.c_str (), "%s", tmp_msg);
-              delete [] tmp_msg;
+            }
 
-              // FIXME: is this the right thing to do for Vlast_error_stack?
-              //        Should it be saved and restored with unwind_protect?
-
-              Vlast_error_stack = err_stack;
+          // Ugh.
+          char *tmp_msg = strsave (msg.c_str ());
+          if (tmp_msg[len-1] == '\n')
+            {
+              if (len > 1)
+                {
+                  tmp_msg[len - 1] = '\0';
+                  rethrow_error (id.c_str (), "%s\n", tmp_msg);
+                }
+            }
+          else
+            rethrow_error (id.c_str (), "%s", tmp_msg);
+          delete [] tmp_msg;
 
-              if (err.contains ("stack"))
+          // FIXME: is this the right thing to do for Vlast_error_stack?
+          //        Should it be saved and restored with unwind_protect?
+
+          Vlast_error_stack = err_stack;
+
+          if (err.contains ("stack"))
+            {
+              if (file.empty ())
                 {
-                  if (file.empty ())
+                  if (nm.empty ())
                     {
-                      if (nm.empty ())
+                      if (l > 0)
                         {
-                          if (l > 0)
-                            {
-                              if (c > 0)
-                                pr_where_1 ("error: near line %d, column %d",
-                                            l, c);
-                              else
-                                pr_where_1 ("error: near line %d", l);
-                            }
-                        }
-                      else
-                        {
-                          if (l > 0)
-                            {
-                              if (c > 0)
-                                pr_where_1 ("error: called from '%s' near line %d, column %d",
-                                            nm.c_str (), l, c);
-                              else
-                                pr_where_1 ("error: called from '%d' near line %d",
-                                            nm.c_str (), l);
-                            }
+                          if (c > 0)
+                            pr_where_1 ("error: near line %d, column %d",
+                                        l, c);
+                          else
+                            pr_where_1 ("error: near line %d", l);
                         }
                     }
                   else
                     {
-                      if (nm.empty ())
+                      if (l > 0)
                         {
-                          if (l > 0)
-                            {
-                              if (c > 0)
-                                pr_where_1 ("error: in file %s near line %d, column %d",
-                                            file.c_str (), l, c);
-                              else
-                                pr_where_1 ("error: in file %s near line %d",
-                                            file.c_str (), l);
-                            }
+                          if (c > 0)
+                            pr_where_1 ("error: called from '%s' near line %d, column %d",
+                                        nm.c_str (), l, c);
+                          else
+                            pr_where_1 ("error: called from '%d' near line %d",
+                                        nm.c_str (), l);
                         }
-                      else
+                    }
+                }
+              else
+                {
+                  if (nm.empty ())
+                    {
+                      if (l > 0)
                         {
-                          if (l > 0)
-                            {
-                              if (c > 0)
-                                pr_where_1 ("error: called from '%s' in file %s near line %d, column %d",
-                                            nm.c_str (), file.c_str (), l, c);
-                              else
-                                pr_where_1 ("error: called from '%d' in file %s near line %d",
-                                            nm.c_str (), file.c_str (), l);
-                            }
+                          if (c > 0)
+                            pr_where_1 ("error: in file %s near line %d, column %d",
+                                        file.c_str (), l, c);
+                          else
+                            pr_where_1 ("error: in file %s near line %d",
+                                        file.c_str (), l);
+                        }
+                    }
+                  else
+                    {
+                      if (l > 0)
+                        {
+                          if (c > 0)
+                            pr_where_1 ("error: called from '%s' in file %s near line %d, column %d",
+                                        nm.c_str (), file.c_str (), l, c);
+                          else
+                            pr_where_1 ("error: called from '%d' in file %s near line %d",
+                                        nm.c_str (), file.c_str (), l);
                         }
                     }
                 }
             }
-          else
-            error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
         }
+      else
+        error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
     }
   return retval;
 }
 
 // Determine whether the first argument to error or warning function
 // should be handled as the message identifier or as the format string.
 
 static bool
@@ -993,41 +965,38 @@ maybe_extract_message_id (const std::str
   int nargin = args.length ();
 
   bool have_fmt = nargin > 1;
 
   if (nargin > 0)
     {
       std::string arg1 = args(0).string_value ();
 
-      if (! error_state)
+      // For compatibility with Matlab, an identifier must contain
+      // ':', but not at the beginning or the end, and it must not
+      // contain '%' (even if it is not a valid conversion
+      // operator) or whitespace.
+
+      if (arg1.find_first_of ("% \f\n\r\t\v") == std::string::npos
+          && arg1.find (':') != std::string::npos
+          && arg1[0] != ':'
+          && arg1[arg1.length ()-1] != ':')
         {
-          // For compatibility with Matlab, an identifier must contain
-          // ':', but not at the beginning or the end, and it must not
-          // contain '%' (even if it is not a valid conversion
-          // operator) or whitespace.
-
-          if (arg1.find_first_of ("% \f\n\r\t\v") == std::string::npos
-              && arg1.find (':') != std::string::npos
-              && arg1[0] != ':'
-              && arg1[arg1.length ()-1] != ':')
+          if (nargin > 1)
             {
-              if (nargin > 1)
-                {
-                  id = arg1;
+              id = arg1;
 
-                  nargs.resize (nargin-1);
+              nargs.resize (nargin-1);
 
-                  for (int i = 1; i < nargin; i++)
-                    nargs(i-1) = args(i);
-                }
-              else
-                nargs(0) = "call to " + caller
-                           + " with message identifier requires message";
+              for (int i = 1; i < nargin; i++)
+                nargs(i-1) = args(i);
             }
+          else
+            nargs(0) = "call to " + caller
+              + " with message identifier requires message";
         }
     }
 
   return have_fmt;
 }
 
 DEFUN (error, args, ,
        "-*- texinfo -*-\n\
@@ -1162,22 +1131,17 @@ disable escape sequence expansion use a 
                 id = c.string_value ();
             }
 
           // FIXME: also need to handle "stack" field in error structure,
           //        but that will require some more significant surgery on
           //        handle_message, error_with_id, etc.
         }
       else
-        {
-          have_fmt = maybe_extract_message_id ("error", args, nargs, id);
-
-          if (error_state)
-            return retval;
-        }
+        have_fmt = maybe_extract_message_id ("error", args, nargs, id);
 
       handle_message (error_with_id, id.c_str (), "unspecified error",
                       nargs, have_fmt);
     }
 
   return retval;
 }
 
@@ -1191,16 +1155,18 @@ warning_query (const std::string& id_arg
   if (id == "last")
     id = Vlast_warning_id;
 
   Cell ident = warning_options.contents ("identifier");
   Cell state = warning_options.contents ("state");
 
   octave_idx_type nel = ident.numel ();
 
+  assert (nel != 0);
+
   bool found = false;
 
   std::string val;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       if (ident(i).string_value () == id)
         {
@@ -1218,23 +1184,24 @@ warning_query (const std::string& id_arg
             {
               val = state(i).string_value ();
               found = true;
               break;
             }
         }
     }
 
-  if (found)
-    {
-      retval.assign ("identifier", id);
-      retval.assign ("state", val);
-    }
-  else
-    error ("warning: unable to find default warning state!");
+  // The warning state "all" is always supposed to remain in the list,
+  // so we should always find a state, either explicitly or by using the
+  // state for "all".
+
+  assert (found);
+
+  retval.assign ("identifier", id);
+  retval.assign ("state", val);
 
   return retval;
 }
 
 static std::string
 default_warning_state (void)
 {
   std::string retval = "on";
@@ -1809,21 +1776,16 @@ unspecified fields are initialized with 
 If @code{lasterror} is called with the argument @qcode{\"reset\"}, all\n\
 fields are set to their default values.\n\
 @seealso{lasterr, error, lastwarn}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
-  unwind_protect frame;
-
-  frame.protect_var (error_state);
-  error_state = 0;
-
   if (nargin < 2)
     {
       octave_scalar_map err;
 
       err.assign ("message", Vlast_error_message);
       err.assign ("identifier", Vlast_error_id);
 
       err.assign ("stack", octave_value (Vlast_error_stack));
@@ -1848,93 +1810,89 @@ fields are set to their default values.\
               octave_scalar_map new_err_stack;
               std::string new_error_message;
               std::string new_error_id;
               std::string new_error_file;
               std::string new_error_name;
               int new_error_line = -1;
               int new_error_column = -1;
 
-              if (! error_state && new_err.contains ("message"))
+              if (new_err.contains ("message"))
                 {
                   const std::string tmp =
                     new_err.getfield ("message").string_value ();
                   new_error_message = tmp;
                 }
 
-              if (! error_state && new_err.contains ("identifier"))
+              if (new_err.contains ("identifier"))
                 {
                   const std::string tmp =
                     new_err.getfield ("identifier").string_value ();
                   new_error_id = tmp;
                 }
 
-              if (! error_state && new_err.contains ("stack"))
+              if (new_err.contains ("stack"))
                 {
                   new_err_stack =
                     new_err.getfield ("stack").scalar_map_value ();
 
-                  if (! error_state && new_err_stack.contains ("file"))
+                  if (new_err_stack.contains ("file"))
                     {
                       const std::string tmp =
                         new_err_stack.getfield ("file").string_value ();
                       new_error_file = tmp;
                     }
 
-                  if (! error_state && new_err_stack.contains ("name"))
+                  if (new_err_stack.contains ("name"))
                     {
                       const std::string tmp =
                         new_err_stack.getfield ("name").string_value ();
                       new_error_name = tmp;
                     }
 
-                  if (! error_state && new_err_stack.contains ("line"))
+                  if (new_err_stack.contains ("line"))
                     {
                       const int tmp =
                         new_err_stack.getfield ("line").nint_value ();
                       new_error_line = tmp;
                     }
 
-                  if (! error_state && new_err_stack.contains ("column"))
+                  if (new_err_stack.contains ("column"))
                     {
                       const int tmp =
                         new_err_stack.getfield ("column").nint_value ();
                       new_error_column = tmp;
                     }
                 }
 
-              if (! error_state)
-                {
-                  Vlast_error_message = new_error_message;
-                  Vlast_error_id = new_error_id;
+              Vlast_error_message = new_error_message;
+              Vlast_error_id = new_error_id;
 
-                  if (new_err.contains ("stack"))
-                    {
-                      new_err_stack.setfield ("file", new_error_file);
-                      new_err_stack.setfield ("name", new_error_name);
-                      new_err_stack.setfield ("line", new_error_line);
-                      new_err_stack.setfield ("column", new_error_column);
-                      Vlast_error_stack = new_err_stack;
-                    }
-                  else
-                    {
-                      // No stack field.  Fill it in with backtrace info.
-                      octave_idx_type curr_frame = -1;
+              if (new_err.contains ("stack"))
+                {
+                  new_err_stack.setfield ("file", new_error_file);
+                  new_err_stack.setfield ("name", new_error_name);
+                  new_err_stack.setfield ("line", new_error_line);
+                  new_err_stack.setfield ("column", new_error_column);
+                  Vlast_error_stack = new_err_stack;
+                }
+              else
+                {
+                  // No stack field.  Fill it in with backtrace info.
+                  octave_idx_type curr_frame = -1;
 
-                      Vlast_error_stack
-                        = octave_call_stack::backtrace (0, curr_frame);
-                    }
+                  Vlast_error_stack
+                    = octave_call_stack::backtrace (0, curr_frame);
                 }
             }
           else
             error ("lasterror: argument must be a structure or a string");
         }
 
-      if (! error_state)
-        retval = err;
+      retval = err;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lasterr, args, nargout,
@@ -1950,46 +1908,36 @@ message identifier.\n\
 With one argument, set the last error message to @var{msg}.\n\
 \n\
 With two arguments, also set the last message identifier.\n\
 @seealso{lasterror, error, lastwarn}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  unwind_protect frame;
-
-  frame.protect_var (error_state);
-  error_state = 0;
-
   int argc = args.length () + 1;
 
   if (argc < 4)
     {
       string_vector argv = args.make_argv ("lasterr");
 
-      if (! error_state)
-        {
-          std::string prev_error_id = Vlast_error_id;
-          std::string prev_error_message = Vlast_error_message;
+      std::string prev_error_id = Vlast_error_id;
+      std::string prev_error_message = Vlast_error_message;
 
-          if (argc > 2)
-            Vlast_error_id = argv(2);
+      if (argc > 2)
+        Vlast_error_id = argv(2);
 
-          if (argc > 1)
-            Vlast_error_message = argv(1);
+      if (argc > 1)
+        Vlast_error_message = argv(1);
 
-          if (argc == 1 || nargout > 0)
-            {
-              retval(1) = prev_error_id;
-              retval(0) = prev_error_message;
-            }
+      if (argc == 1 || nargout > 0)
+        {
+          retval(1) = prev_error_id;
+          retval(0) = prev_error_message;
         }
-      else
-        error ("lasterr: all arguments must be strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lastwarn, args, nargout,
@@ -2011,36 +1959,30 @@ With two arguments, also set the last me
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   if (argc < 4)
     {
       string_vector argv = args.make_argv ("lastwarn");
 
-      if (! error_state)
-        {
-          std::string prev_warning_id = Vlast_warning_id;
-          std::string prev_warning_message = Vlast_warning_message;
+      std::string prev_warning_id = Vlast_warning_id;
+      std::string prev_warning_message = Vlast_warning_message;
 
-          if (argc > 2)
-            Vlast_warning_id = argv(2);
+      if (argc > 2)
+        Vlast_warning_id = argv(2);
 
-          if (argc > 1)
-            Vlast_warning_message = argv(1);
+      if (argc > 1)
+        Vlast_warning_message = argv(1);
 
-          if (argc == 1 || nargout > 0)
-            {
-              warning_state = 0;
-              retval(1) = prev_warning_id;
-              retval(0) = prev_warning_message;
-            }
+      if (argc == 1 || nargout > 0)
+        {
+          retval(1) = prev_warning_id;
+          retval(0) = prev_warning_message;
         }
-      else
-        error ("lastwarn: all arguments must be strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /* FIXME: Deprecated in 4.0 and scheduled for removal in 4.4 */
@@ -2159,17 +2101,16 @@ std::string
 last_warning_id (void)
 {
   return Vlast_warning_id;
 }
 
 void
 interpreter_try (unwind_protect& frame)
 {
-  frame.protect_var (error_state);
   frame.protect_var (buffer_error_messages);
   frame.protect_var (Vdebug_on_error);
   frame.protect_var (Vdebug_on_warning);
 
   buffer_error_messages++;
   Vdebug_on_error = false;
   Vdebug_on_warning = false;
 }
diff --git a/libinterp/corefcn/gripes.cc b/libinterp/corefcn/gripes.cc
--- a/libinterp/corefcn/gripes.cc
+++ b/libinterp/corefcn/gripes.cc
@@ -200,25 +200,16 @@ gripe_divide_by_zero (void)
 void
 gripe_logical_conversion (void)
 {
   warning_with_id ("Octave:logical-conversion",
                    "value not equal to 1 or 0 converted to logical 1");
 }
 
 void
-gripe_library_execution_error (void)
-{
-  octave_exception_state = octave_no_exception;
-
-  if (! error_state)
-    error ("caught execution error in library function");
-}
-
-void
 gripe_invalid_inquiry_subscript (void)
 {
   error ("invalid dimension inquiry of a non-existent value");
 }
 
 void
 gripe_indexed_cs_list (void)
 {
diff --git a/libinterp/corefcn/gripes.h b/libinterp/corefcn/gripes.h
--- a/libinterp/corefcn/gripes.h
+++ b/libinterp/corefcn/gripes.h
@@ -109,19 +109,16 @@ gripe_implicit_conversion (const std::st
 
 extern OCTINTERP_API void
 gripe_divide_by_zero (void);
 
 extern OCTINTERP_API void
 gripe_logical_conversion (void);
 
 extern OCTINTERP_API void
-gripe_library_execution_error (void);
-
-extern OCTINTERP_API void
 gripe_invalid_inquiry_subscript (void);
 
 extern OCTINTERP_API void
 gripe_indexed_cs_list (void);
 
 extern OCTINTERP_API void
 gripe_nonbraced_cs_list_assignment (void);
 
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -210,51 +210,30 @@ octave_jit_cast_any_complex (Complex c)
     return new octave_scalar (c.real ());
   else
     return new octave_complex (c);
 }
 
 extern "C" void
 octave_jit_gripe_nan_to_logical_conversion (void)
 {
-  try
-    {
-      gripe_nan_to_logical_conversion ();
-    }
-  catch (const octave_execution_exception&)
-    {
-      gripe_library_execution_error ();
-    }
+  gripe_nan_to_logical_conversion ();
 }
 
 extern "C" void
 octave_jit_ginvalid_index (void)
 {
-  try
-    {
-      gripe_invalid_index ();
-    }
-  catch (const octave_execution_exception&)
-    {
-      gripe_library_execution_error ();
-    }
+  gripe_invalid_index ();
 }
 
 extern "C" void
 octave_jit_gindex_range (int nd, int dim, octave_idx_type iext,
                          octave_idx_type ext)
 {
-  try
-    {
-      gripe_index_out_of_range (nd, dim, iext, ext);
-    }
-  catch (const octave_execution_exception&)
-    {
-      gripe_library_execution_error ();
-    }
+  gripe_index_out_of_range (nd, dim, iext, ext);
 }
 
 extern "C" jit_matrix
 octave_jit_paren_subsasgn_impl (jit_matrix *mat, octave_idx_type index,
                                 double value)
 {
   NDArray *array = mat->array;
   if (array->numel () < index)
@@ -276,51 +255,38 @@ make_indices (double *indices, octave_id
     result(i) = idx_vector (indices[i]);
 }
 
 extern "C" double
 octave_jit_paren_scalar (jit_matrix *mat, double *indicies,
                          octave_idx_type idx_count)
 {
   // FIXME: Replace this with a more optimal version
-  try
-    {
-      Array<idx_vector> idx;
-      make_indices (indicies, idx_count, idx);
+  Array<idx_vector> idx;
+  make_indices (indicies, idx_count, idx);
 
-      Array<double> ret = mat->array->index (idx);
-      return ret.xelem (0);
-    }
-  catch (const octave_execution_exception&)
-    {
-      gripe_library_execution_error ();
-      return 0;
-    }
+  Array<double> ret = mat->array->index (idx);
+
+  return ret.xelem (0);
 }
 
 extern "C" jit_matrix
 octave_jit_paren_scalar_subsasgn (jit_matrix *mat, double *indices,
                                   octave_idx_type idx_count, double value)
 {
   // FIXME: Replace this with a more optimal version
   jit_matrix ret;
-  try
-    {
-      Array<idx_vector> idx;
-      make_indices (indices, idx_count, idx);
+
+  Array<idx_vector> idx;
+  make_indices (indices, idx_count, idx);
 
-      Matrix temp (1, 1);
-      temp.xelem(0) = value;
-      mat->array->assign (idx, temp);
-      ret.update (mat->array);
-    }
-  catch (const octave_execution_exception&)
-    {
-      gripe_library_execution_error ();
-    }
+  Matrix temp (1, 1);
+  temp.xelem(0) = value;
+  mat->array->assign (idx, temp);
+  ret.update (mat->array);
 
   return ret;
 }
 
 extern "C" jit_matrix
 octave_jit_paren_subsasgn_matrix_range (jit_matrix *mat, jit_range *index,
                                         double value)
 {
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -86,22 +86,20 @@ load_path::dir_info::update (void)
                 }
               else
                 {
                   // We haven't seen this directory before.
 
                   initialize ();
                 }
             }
-          catch (octave_execution_exception)
+          catch (const octave_execution_exception&)
             {
               // Skip updating if we don't know where we are, but
               // don't treat it as an error.
-
-              error_state = 0;
             }
         }
       else if (fs.mtime () + fs.time_resolution () > dir_time_last_checked)
         initialize ();
     }
   else
     {
       std::string msg = fs.error ();
@@ -154,17 +152,17 @@ load_path::dir_info::initialize (void)
           std::string abs_name = octave_env::make_absolute (dir_name);
 
           // FIXME: nothing is ever removed from this cache of
           // directory information, so there could be some resource
           // problems.  Perhaps it should be pruned from time to time.
 
           abs_dir_cache[abs_name] = *this;
         }
-      catch (octave_execution_exception)
+      catch (const octave_execution_exception&)
         {
           // Skip updating if we don't know where we are.
         }
     }
   else
     {
       std::string msg = fs.error ();
       warning ("load_path: %s: %s", dir_name.c_str (), msg.c_str ());
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -364,25 +364,28 @@ bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val,
                      int precision, bool tabs)
 {
   bool success = true;
 
   if (val.is_complex_type ())
     warning ("save: omitting imaginary part for ASCII file");
 
-  Matrix m = val.matrix_value (true);
+  Matrix m;
 
-  if (error_state)
+  try
+    {
+      m = val.matrix_value (true);
+    }
+  catch (const octave_execution_exception&)
     {
       success = false;
+    }
 
-      error_state = 0;
-    }
-  else
+  if (success)
     {
       long old_precision = os.precision ();
 
       os.precision (precision);
 
       std::ios::fmtflags oflags
         = os.flags (static_cast<std::ios::fmtflags> (std::ios::scientific));
 
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3100,19 +3100,30 @@ mexCallMATLAB (int nargout, mxArray *arg
   // handling is implemented.  longjmp() only clears the stack, so any
   // class which allocates data on the heap is going to leak.
 
   args.resize (nargin);
 
   for (int i = 0; i < nargin; i++)
     args(i) = mxArray::as_octave_value (argin[i]);
 
-  octave_value_list retval = feval (fname, args, nargout);
-
-  if (error_state && mex_context->trap_feval_error == 0)
+  bool execution_error = false;
+
+  octave_value_list retval;
+
+  try
+    {
+      retval = feval (fname, args, nargout);
+    }
+  catch (const octave_execution_exception&)
+    {
+      execution_error = true;
+    }
+
+  if (execution_error && mex_context->trap_feval_error == 0)
     {
       // FIXME: is this the correct way to clean up?  abort() is
       // going to trigger a long jump, so the normal class destructors
       // will not be called.  Hopefully this will reduce things to a
       // tiny leak.  Maybe create a new octave memory tracer type
       // which prints a friendly message every time it is
       // created/copied/deleted to check this.
 
@@ -3133,23 +3144,17 @@ mexCallMATLAB (int nargout, mxArray *arg
       // that matrix memory is allocated by new[] and mxArray memory
       // is allocated by malloc().
       argout[i] = mex_context->make_value (retval (i));
     }
 
   while (num_to_copy < nargout)
     argout[num_to_copy++] = 0;
 
-  if (error_state)
-    {
-      error_state = 0;
-      return 1;
-    }
-  else
-    return 0;
+  return execution_error ? 1 : 0;
 }
 
 void
 mexSetTrapFlag (int flag)
 {
   if (mex_context)
     mex_context->trap_feval_error = flag;
 }
@@ -3158,24 +3163,29 @@ int
 mexEvalString (const char *s)
 {
   int retval = 0;
 
   int parse_status;
 
   octave_value_list ret;
 
-  ret = eval_string (s, false, parse_status, 0);
-
-  if (parse_status || error_state)
+  bool execution_error = false;
+
+  try
     {
-      error_state = 0;
-
-      retval = 1;
+      ret = eval_string (s, false, parse_status, 0);
     }
+  catch (const octave_execution_exception&)
+    {
+      execution_error = true;
+    }
+
+  if (parse_status || execution_error)
+    retval = 1;
 
   return retval;
 }
 
 void
 mexErrMsgTxt (const char *s)
 {
   if (s && strlen (s) > 0)
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -1176,17 +1176,17 @@ using std::unordered_map;
           double *rvec = r.fortran_vec ();
 
           octave_idx_type idx_len = short_shuffle ? m : n;
           Array<octave_idx_type> idx;
           try
             {
               idx = Array<octave_idx_type> (dim_vector (1, idx_len));
             }
-          catch (std::bad_alloc)
+          catch (const std::bad_alloc&)
             {
               // Looks like n is too big and short_shuffle is false.
               // Let's try again, but this time with the alternative.
               idx_len = m;
               short_shuffle = true;
               idx = Array<octave_idx_type> (dim_vector (1, idx_len));
             }
 
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -124,31 +124,25 @@ decomposition, eliminating the unnecessa
 @seealso{svd_driver, svds, eig, lu, chol, hess, qr, qz}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout == 2 || nargout > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (arg.ndims () != 2)
-    {
-      error ("svd: A must be a 2-D matrix");
-      return retval;
-    }
+    error ("svd: A must be a 2-D matrix");
 
   bool isfloat = arg.is_single_type ();
 
   SVD::type type = ((nargout == 0 || nargout == 1)
                     ? SVD::sigma_only
                     : (nargin == 2) ? SVD::economy : SVD::std);
 
   SVD::driver driver = static_cast<SVD::driver> (Vsvd_driver);
@@ -159,170 +153,139 @@ decomposition, eliminating the unnecessa
         {
           switch (type)
             {
             case SVD::std:
               retval(2) = FloatDiagMatrix (nc, nc, 1.0f);
               retval(1) = FloatMatrix (nr, nc);
               retval(0) = FloatDiagMatrix (nr, nr, 1.0f);
               break;
+
             case SVD::economy:
               retval(2) = FloatDiagMatrix (0, nc, 1.0f);
               retval(1) = FloatMatrix (0, 0);
               retval(0) = FloatDiagMatrix (nr, 0, 1.0f);
               break;
-          case SVD::sigma_only: default:
+
+            case SVD::sigma_only: default:
               retval(0) = FloatMatrix (0, 1);
               break;
             }
         }
       else
         {
           switch (type)
             {
             case SVD::std:
               retval(2) = DiagMatrix (nc, nc, 1.0);
               retval(1) = Matrix (nr, nc);
               retval(0) = DiagMatrix (nr, nr, 1.0);
               break;
+
             case SVD::economy:
               retval(2) = DiagMatrix (0, nc, 1.0);
               retval(1) = Matrix (0, 0);
               retval(0) = DiagMatrix (nr, 0, 1.0);
               break;
-          case SVD::sigma_only: default:
+
+            case SVD::sigma_only: default:
               retval(0) = Matrix (0, 1);
               break;
             }
         }
     }
   else
     {
       if (isfloat)
         {
           if (arg.is_real_type ())
             {
               FloatMatrix tmp = arg.float_matrix_value ();
 
-              if (! error_state)
-                {
-                  if (tmp.any_element_is_inf_or_nan ())
-                    {
-                      error ("svd: cannot take SVD of matrix containing Inf or NaN values");
-                      return retval;
-                    }
+              if (tmp.any_element_is_inf_or_nan ())
+                error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
-                  FloatSVD result (tmp, type, driver);
+              FloatSVD result (tmp, type, driver);
+
+              FloatDiagMatrix sigma = result.singular_values ();
 
-                  FloatDiagMatrix sigma = result.singular_values ();
-
-                  if (nargout == 0 || nargout == 1)
-                    {
-                      retval(0) = sigma.extract_diag ();
-                    }
-                  else
-                    {
-                      retval(2) = result.right_singular_matrix ();
-                      retval(1) = sigma;
-                      retval(0) = result.left_singular_matrix ();
-                    }
+              if (nargout == 0 || nargout == 1)
+                retval(0) = sigma.extract_diag ();
+              else
+                {
+                  retval(2) = result.right_singular_matrix ();
+                  retval(1) = sigma;
+                  retval(0) = result.left_singular_matrix ();
                 }
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
-              if (! error_state)
-                {
-                  if (ctmp.any_element_is_inf_or_nan ())
-                    {
-                      error ("svd: cannot take SVD of matrix containing Inf or NaN values");
-                      return retval;
-                    }
+              if (ctmp.any_element_is_inf_or_nan ())
+                error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
-                  FloatComplexSVD result (ctmp, type, driver);
+              FloatComplexSVD result (ctmp, type, driver);
+
+              FloatDiagMatrix sigma = result.singular_values ();
 
-                  FloatDiagMatrix sigma = result.singular_values ();
-
-                  if (nargout == 0 || nargout == 1)
-                    {
-                      retval(0) = sigma.extract_diag ();
-                    }
-                  else
-                    {
-                      retval(2) = result.right_singular_matrix ();
-                      retval(1) = sigma;
-                      retval(0) = result.left_singular_matrix ();
-                    }
+              if (nargout == 0 || nargout == 1)
+                retval(0) = sigma.extract_diag ();
+              else
+                {
+                  retval(2) = result.right_singular_matrix ();
+                  retval(1) = sigma;
+                  retval(0) = result.left_singular_matrix ();
                 }
             }
         }
       else
         {
           if (arg.is_real_type ())
             {
               Matrix tmp = arg.matrix_value ();
 
-              if (! error_state)
-                {
-                  if (tmp.any_element_is_inf_or_nan ())
-                    {
-                      error ("svd: cannot take SVD of matrix containing Inf or NaN values");
-                      return retval;
-                    }
+              if (tmp.any_element_is_inf_or_nan ())
+                error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
-                  SVD result (tmp, type, driver);
+              SVD result (tmp, type, driver);
+
+              DiagMatrix sigma = result.singular_values ();
 
-                  DiagMatrix sigma = result.singular_values ();
-
-                  if (nargout == 0 || nargout == 1)
-                    {
-                      retval(0) = sigma.extract_diag ();
-                    }
-                  else
-                    {
-                      retval(2) = result.right_singular_matrix ();
-                      retval(1) = sigma;
-                      retval(0) = result.left_singular_matrix ();
-                    }
+              if (nargout == 0 || nargout == 1)
+                retval(0) = sigma.extract_diag ();
+              else
+                {
+                  retval(2) = result.right_singular_matrix ();
+                  retval(1) = sigma;
+                  retval(0) = result.left_singular_matrix ();
                 }
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix ctmp = arg.complex_matrix_value ();
 
-              if (! error_state)
-                {
-                  if (ctmp.any_element_is_inf_or_nan ())
-                    {
-                      error ("svd: cannot take SVD of matrix containing Inf or NaN values");
-                      return retval;
-                    }
+              if (ctmp.any_element_is_inf_or_nan ())
+                error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
-                  ComplexSVD result (ctmp, type, driver);
+              ComplexSVD result (ctmp, type, driver);
+
+              DiagMatrix sigma = result.singular_values ();
 
-                  DiagMatrix sigma = result.singular_values ();
-
-                  if (nargout == 0 || nargout == 1)
-                    {
-                      retval(0) = sigma.extract_diag ();
-                    }
-                  else
-                    {
-                      retval(2) = result.right_singular_matrix ();
-                      retval(1) = sigma;
-                      retval(0) = result.left_singular_matrix ();
-                    }
+              if (nargout == 0 || nargout == 1)
+                retval(0) = sigma.extract_diag ();
+              else
+                {
+                  retval(2) = result.right_singular_matrix ();
+                  retval(1) = sigma;
+                  retval(0) = result.left_singular_matrix ();
                 }
             }
           else
-            {
-              gripe_wrong_type_arg ("svd", arg);
-              return retval;
-            }
+            gripe_wrong_type_arg ("svd", arg);
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (svd ([1, 2; 2, 1]), [3; 1], sqrt (eps))
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -646,30 +646,28 @@ main_loop (void)
                       else
                         command_editor::increment_current_command_number ();
                     }
                 }
               else if (parser.lexer.end_of_input)
                 break;
             }
         }
-      catch (octave_interrupt_exception)
+      catch (const octave_interrupt_exception&)
         {
           recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
             return exit_status;
         }
-      catch (octave_execution_exception)
+      catch (const octave_execution_exception&)
         {
           recover_from_exception ();
-          std::cerr << "error: unhandled execution exception -- trying to return to prompt"
-                    << std::endl;
         }
-      catch (std::bad_alloc)
+      catch (const std::bad_alloc&)
         {
           recover_from_exception ();
           std::cerr << "error: out of memory -- trying to return to prompt"
                     << std::endl;
         }
     }
   while (retval == 0);
 
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -512,18 +512,15 @@ private:
           frame.protect_var (Vdebug_on_error); \
           frame.protect_var (Vdebug_on_warning); \
  \
           Vdebug_on_error = false; \
           Vdebug_on_warning = false; \
  \
           F ARGS; \
         } \
-      OCTAVE_IGNORE_EXCEPTION (octave_interrupt_exception) \
-      OCTAVE_IGNORE_EXCEPTION (octave_execution_exception) \
-      OCTAVE_IGNORE_EXCEPTION (std::bad_alloc) \
- \
-      if (error_state) \
-        error_state = 0; \
+      OCTAVE_IGNORE_EXCEPTION (const octave_interrupt_exception&) \
+      OCTAVE_IGNORE_EXCEPTION (const octave_execution_exception&) \
+      OCTAVE_IGNORE_EXCEPTION (const std::bad_alloc&) \
     } \
   while (0)
 
 #endif
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1468,17 +1468,17 @@ character @nospell{\"@xbackslashchar{}0\
               if (nargin == 2)
                 retval = idx.extent (n) <= n;
               else
                 retval = true;
             }
           else
             retval = false;
         }
-      catch (octave_execution_exception)
+      catch (const octave_execution_exception&)
         {
           retval = false;
         }
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -263,17 +263,16 @@ generate_struct_completions (const std::
 
       if (is_variable (base_name))
         {
           int parse_status;
 
           unwind_protect frame;
 
           frame.protect_var (error_state);
-          frame.protect_var (warning_state);
 
           frame.protect_var (discard_error_messages);
           frame.protect_var (discard_warning_messages);
 
           discard_error_messages = true;
           discard_warning_messages = true;
 
           octave_value tmp = eval_string (prefix, true, parse_status);
@@ -372,19 +371,24 @@ isglobal (\"x\")\n\
 static octave_value
 safe_symbol_lookup (const std::string& symbol_name)
 {
   octave_value retval;
 
   unwind_protect frame;
   interpreter_try (frame);
 
-  retval = symbol_table::find (symbol_name);
-
-  error_state = 0;
+  try
+    {
+      retval = symbol_table::find (symbol_name);
+    }
+  catch (const octave_execution_exception&)
+    {
+      // Ignore errors.
+    }
 
   return retval;
 }
 
 int
 symbol_exist (const std::string& name, const std::string& type)
 {
   if (is_keyword (name))
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -686,17 +686,16 @@ read_file (const std::string& filename, 
     }
   catch (Magick::Warning& w)
     {
       warning ("Magick++ warning: %s", w.what ());
     }
   catch (Magick::Exception& e)
     {
       error ("Magick++ exception: %s", e.what ());
-      error_state = 1;
     }
 }
 
 static void
 maybe_initialize_magick (void)
 {
   static bool initialized = false;
 
@@ -1377,17 +1376,16 @@ write_file (const std::string& filename,
     }
   catch (Magick::ErrorCoder& e)
     {
       warning ("Magick++ coder error: %s", e.what ());
     }
   catch (Magick::Exception& e)
     {
       error ("Magick++ exception: %s", e.what ());
-      error_state = 1;
     }
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map}, @var{options})\n\
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -119,39 +119,32 @@ octave_builtin::do_multi_index_op (int n
       frame.add_fcn (octave_call_stack::pop);
 
       if (lvalue_list || curr_lvalue_list)
         {
           frame.protect_var (curr_lvalue_list);
           curr_lvalue_list = lvalue_list;
         }
 
-      try
-        {
-          BEGIN_PROFILER_BLOCK (octave_builtin)
+      BEGIN_PROFILER_BLOCK (octave_builtin)
 
-          retval = (*f) (args, nargout);
-          // Do not allow null values to be returned from functions.
-          // FIXME: perhaps true builtins should be allowed?
-          retval.make_storable_values ();
-          // Fix the case of a single undefined value.
-          // This happens when a compiled function uses
-          //   octave_value retval;
-          // instead of
-          //   octave_value_list retval;
-          // the idiom is very common, so we solve that here.
-          if (retval.length () == 1 && retval.xelem (0).is_undefined ())
-            retval.clear ();
+        retval = (*f) (args, nargout);
+      // Do not allow null values to be returned from functions.
+      // FIXME: perhaps true builtins should be allowed?
+      retval.make_storable_values ();
+      // Fix the case of a single undefined value.
+      // This happens when a compiled function uses
+      //   octave_value retval;
+      // instead of
+      //   octave_value_list retval;
+      // the idiom is very common, so we solve that here.
+      if (retval.length () == 1 && retval.xelem (0).is_undefined ())
+        retval.clear ();
 
-          END_PROFILER_BLOCK
-        }
-      catch (octave_execution_exception)
-        {
-          gripe_library_execution_error ();
-        }
+      END_PROFILER_BLOCK
     }
 
   return retval;
 }
 
 jit_type *
 octave_builtin::to_jit (void) const
 {
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1167,23 +1167,31 @@ octave_class::reconstruct_exemplar (void
       if (have_ctor)
         {
           unwind_protect frame;
 
           // Simulate try/catch.
 
           interpreter_try (frame);
 
-          octave_value_list result
-            = ctor.do_multi_index_op (1, octave_value_list ());
+          bool execution_error = false;
+
+          octave_value_list result;
 
-          if (! error_state && result.length () == 1)
+          try
+            {
+              result = ctor.do_multi_index_op (1, octave_value_list ());
+            }
+          catch (const octave_execution_exception&)
+            {
+              execution_error = true;
+            }
+
+          if (! execution_error && result.length () == 1)
             retval = true;
-
-          error_state = false;
         }
       else
         warning ("no constructor for class %s", c_name.c_str ());
     }
 
   return retval;
 }
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -2078,18 +2078,28 @@ octave_fcn_binder::maybe_binder (const o
                       if (symbol_table::get_dispatch (head_name).size () > 0)
                         bad = true;
                       else
                         {
                           // Simulate try/catch.
                           unwind_protect frame;
                           interpreter_try (frame);
 
-                          root_val = make_fcn_handle (head_name);
-                          if (error_state)
+                          bool execution_error = false;
+
+                          try
+                            {
+                              root_val = make_fcn_handle (head_name);
+                            }
+                          catch (const octave_execution_exception&)
+                            {
+                              execution_error = true;
+                            }
+
+                          if (execution_error)
                             bad = true;
                         }
                     }
                 }
 
               if (! bad)
                 {
                   // Stash proper name tags.
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -140,24 +140,17 @@ octave_mex_function::do_multi_index_op (
   else
     {
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
       frame.add_fcn (octave_call_stack::pop);
 
-      try
-        {
-          BEGIN_PROFILER_BLOCK (octave_mex_function)
-
-          retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
+      BEGIN_PROFILER_BLOCK (octave_mex_function)
 
-          END_PROFILER_BLOCK
-        }
-      catch (octave_execution_exception)
-        {
-          gripe_library_execution_error ();
-        }
+        retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
+
+      END_PROFILER_BLOCK
     }
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -73,39 +73,36 @@ octave_oncleanup::~octave_oncleanup (voi
   // Clear interrupts.
   frame.protect_var (octave_interrupt_state);
   octave_interrupt_state = 0;
 
   // Disallow quit().
   frame.protect_var (quit_allowed);
   quit_allowed = false;
 
-  // Clear errors.
-  frame.protect_var (error_state);
-  error_state = 0;
-
   try
     {
       // Run the actual code.
       fcn.do_multi_index_op (0, octave_value_list ());
     }
-  catch (octave_interrupt_exception)
+  catch (const octave_interrupt_exception&)
     {
       // Swallow the interrupt.
       warning ("onCleanup: interrupt occured in cleanup action");
     }
+  catch (const octave_execution_exception&)
+    {
+      // Propagate the error.
+      throw;
+    }
   catch (...) // Yes, the black hole. We're in a d-tor.
     {
       // This shouldn't happen, in theory.
       error ("onCleanup: internal error: unhandled exception in cleanup action");
     }
-
-  // FIXME: can this happen now?
-  if (error_state)
-    frame.discard_first ();
 }
 
 octave_scalar_map
 octave_oncleanup::scalar_map_value (void) const
 {
   octave_scalar_map retval;
   retval.setfield ("task", fcn);
   return retval;
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1485,26 +1485,19 @@ octave_value::assign (assign_op op, cons
           int tthis = this->type_id ();
           int trhs = rhs.type_id ();
 
           f = octave_value_typeinfo::lookup_assign_op (op, tthis, trhs);
         }
 
       if (f)
         {
-          try
-            {
-              f (*rep, octave_value_list (), *rhs.rep);
-              // Usually unnecessary, but may be needed (complex arrays).
-              maybe_mutate ();
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
+          f (*rep, octave_value_list (), *rhs.rep);
+          // Usually unnecessary, but may be needed (complex arrays).
+          maybe_mutate ();
         }
       else
         {
 
           binary_op binop = op_eq_to_binary_op (op);
 
           if (! error_state)
             {
@@ -1988,48 +1981,32 @@ do_binary_op (octave_value::binary_op op
       || t1 == octave_classdef::static_type_id ()
       || t2 == octave_classdef::static_type_id ())
     {
       octave_value_typeinfo::binary_class_op_fcn f
         = octave_value_typeinfo::lookup_binary_class_op (op);
 
       if (f)
         {
-          try
-            {
-              retval = f (v1, v2);
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
+          retval = f (v1, v2);
         }
       else
         gripe_binary_op (octave_value::binary_op_as_string (op),
                          v1.class_name (), v2.class_name ());
     }
   else
     {
       // FIXME: we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::binary_op_fcn f
         = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
       if (f)
-        {
-          try
-            {
-              retval = f (*v1.rep, *v2.rep);
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
-        }
+        retval = f (*v1.rep, *v2.rep);
       else
         {
           octave_value tv1;
           octave_base_value::type_conv_info cf1 =
             v1.numeric_conversion_function ();
 
           octave_value tv2;
           octave_base_value::type_conv_info cf2 =
@@ -2138,26 +2115,17 @@ do_binary_op (octave_value::binary_op op
                     }
                 }
 
               if (cf1 || cf2)
                 {
                   f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
                   if (f)
-                    {
-                      try
-                        {
-                          retval = f (*tv1.rep, *tv2.rep);
-                        }
-                      catch (octave_execution_exception)
-                        {
-                          gripe_library_execution_error ();
-                        }
-                    }
+                    retval = f (*tv1.rep, *tv2.rep);
                   else
                     gripe_binary_op (octave_value::binary_op_as_string (op),
                                      v1.type_name (), v2.type_name ());
                 }
               else
                 gripe_binary_op (octave_value::binary_op_as_string (op),
                                  v1.type_name (), v2.type_name ());
             }
@@ -2246,45 +2214,27 @@ do_binary_op (octave_value::compound_bin
       || t2 == octave_class::static_type_id ()
       || t1 == octave_classdef::static_type_id ()
       || t2 == octave_classdef::static_type_id ())
     {
       octave_value_typeinfo::binary_class_op_fcn f
         = octave_value_typeinfo::lookup_binary_class_op (op);
 
       if (f)
-        {
-          try
-            {
-              retval = f (v1, v2);
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
-        }
+        retval = f (v1, v2);
       else
         retval = decompose_binary_op (op, v1, v2);
     }
   else
     {
       octave_value_typeinfo::binary_op_fcn f
         = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
       if (f)
-        {
-          try
-            {
-              retval = f (*v1.rep, *v2.rep);
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
-        }
+        retval = f (*v1.rep, *v2.rep);
       else
         retval = decompose_binary_op (op, v1, v2);
     }
 
   return retval;
 }
 
 static void
@@ -2311,26 +2261,17 @@ do_cat_op (const octave_value& v1, const
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
   octave_value_typeinfo::cat_op_fcn f
     = octave_value_typeinfo::lookup_cat_op (t1, t2);
 
   if (f)
-    {
-      try
-        {
-          retval = f (*v1.rep, *v2.rep, ra_idx);
-        }
-      catch (octave_execution_exception)
-        {
-          gripe_library_execution_error ();
-        }
-    }
+    retval = f (*v1.rep, *v2.rep, ra_idx);
   else
     {
       octave_value tv1;
       octave_base_value::type_conv_info cf1 = v1.numeric_conversion_function ();
 
       octave_value tv2;
       octave_base_value::type_conv_info cf2 = v2.numeric_conversion_function ();
 
@@ -2516,49 +2457,31 @@ do_unary_op (octave_value::unary_op op, 
 
   if (t == octave_class::static_type_id ()
       || t == octave_classdef::static_type_id ())
     {
       octave_value_typeinfo::unary_class_op_fcn f
         = octave_value_typeinfo::lookup_unary_class_op (op);
 
       if (f)
-        {
-          try
-            {
-              retval = f (v);
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
-        }
+        retval = f (v);
       else
         gripe_unary_op (octave_value::unary_op_as_string (op),
                         v.class_name ());
     }
   else
     {
       // FIXME: we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::unary_op_fcn f
         = octave_value_typeinfo::lookup_unary_op (op, t);
 
       if (f)
-        {
-          try
-            {
-              retval = f (*v.rep);
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
-        }
+        retval = f (*v.rep);
       else
         {
           octave_value tv;
           octave_base_value::type_conv_fcn cf
             = v.numeric_conversion_function ();
 
           if (cf)
             {
@@ -2610,24 +2533,17 @@ octave_value::do_non_const_unary_op (una
 
       octave_value_typeinfo::non_const_unary_op_fcn f
         = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
 
       if (f)
         {
           make_unique ();
 
-          try
-            {
-              f (*rep);
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
+          f (*rep);
         }
       else
         {
           octave_base_value::type_conv_fcn cf = numeric_conversion_function ();
 
           if (cf)
             {
               octave_base_value *tmp = cf (*rep);
@@ -2638,24 +2554,17 @@ octave_value::do_non_const_unary_op (una
                   rep = tmp;
 
                   t = type_id ();
 
                   f = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
 
                   if (f)
                     {
-                      try
-                        {
-                          f (*rep);
-                        }
-                      catch (octave_execution_exception)
-                        {
-                          gripe_library_execution_error ();
-                        }
+                      f (*rep);
 
                       if (old_rep && --old_rep->count == 0)
                         delete old_rep;
                     }
                   else
                     {
                       if (old_rep)
                         {
@@ -2685,26 +2594,17 @@ octave_value::do_non_const_unary_op (una
 
       octave_value_typeinfo::non_const_unary_op_fcn f = 0;
 
       // Only attempt to operate in-place if this variable is unshared.
       if (rep->count == 1)
         f = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
 
       if (f)
-        {
-          try
-            {
-              f (*rep);
-            }
-          catch (octave_execution_exception)
-            {
-              gripe_library_execution_error ();
-            }
-        }
+        f (*rep);
       else
         *this = do_unary_op (op, *this);
     }
 
   return *this;
 }
 
 octave_value&
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -274,24 +274,24 @@ safe_source_file (const std::string& fil
                   const std::string& context = std::string (),
                   bool verbose = false, bool require_file = true,
                   const std::string& warn_for = std::string ())
 {
   try
     {
       source_file (file_name, context, verbose, require_file, warn_for);
     }
-  catch (octave_interrupt_exception)
+  catch (const octave_interrupt_exception&)
     {
       recover_from_exception ();
       octave_stdout << "\n";
       if (quitting_gracefully)
         clean_up_and_exit (exit_status);
     }
-  catch (octave_execution_exception)
+  catch (const octave_execution_exception&)
     {
       recover_from_exception ();
       gripe_safe_source_exception (file_name, "unhandled execution exception");
     }
 }
 
 // Initialize by reading startup files.
 
@@ -389,24 +389,24 @@ execute_eval_option_code (const std::str
   interactive = false;
 
   int parse_status = 0;
 
   try
     {
       eval_string (code, false, parse_status, 0);
     }
-  catch (octave_interrupt_exception)
+  catch (const octave_interrupt_exception&)
     {
       recover_from_exception ();
       octave_stdout << "\n";
       if (quitting_gracefully)
         clean_up_and_exit (exit_status);
     }
-  catch (octave_execution_exception)
+  catch (const octave_execution_exception&)
     {
       recover_from_exception ();
       std::cerr << "error: unhandled execution exception -- eval failed"
                 << std::endl;
     }
 
   return parse_status;
 }
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -2242,17 +2242,16 @@ octave_base_parser::maybe_warn_variable_
 tree_expression *
 octave_base_parser::finish_colon_expression (tree_colon_expression *e)
 {
   tree_expression *retval = e;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
-  frame.protect_var (warning_state);
 
   frame.protect_var (discard_error_messages);
   frame.protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   tree_expression *base = e->base ();
@@ -2263,17 +2262,17 @@ octave_base_parser::finish_colon_express
     {
       if (limit)
         {
           if (base->is_constant () && limit->is_constant ()
               && (! incr || (incr && incr->is_constant ())))
             {
               octave_value tmp = e->rvalue1 ();
 
-              if (! (error_state || warning_state))
+              if (! error_state)
                 {
                   tree_constant *tc_retval
                     = new tree_constant (tmp, base->line (), base->column ());
 
                   std::ostringstream buf;
 
                   tree_print_code tpc (buf);
 
@@ -3795,29 +3794,28 @@ octave_base_parser::validate_matrix_for_
 tree_expression *
 octave_base_parser::finish_array_list (tree_array_list *array_list)
 {
   tree_expression *retval = array_list;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
-  frame.protect_var (warning_state);
 
   frame.protect_var (discard_error_messages);
   frame.protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   if (array_list->all_elements_are_constant ())
     {
       octave_value tmp = array_list->rvalue1 ();
 
-      if (! (error_state || warning_state))
+      if (! error_state)
         {
           tree_constant *tc_retval
             = new tree_constant (tmp, array_list->line (),
                                  array_list->column ());
 
           std::ostringstream buf;
 
           tree_print_code tpc (buf);
@@ -4994,35 +4992,51 @@ the security considerations that the eva
       if (nargin > 1)
         {
           frame.protect_var (buffer_error_messages);
           buffer_error_messages++;
         }
 
       int parse_status = 0;
 
-      octave_value_list tmp = eval_string (args(0), nargout > 0,
-                                           parse_status, nargout);
-
-      if (nargin > 1 && (parse_status != 0 || error_state))
+      bool execution_error = false;
+
+      octave_value_list tmp;
+
+      try
         {
-          error_state = 0;
-
+          tmp = eval_string (args(0), nargout > 0, parse_status, nargout);
+        }
+      catch (const octave_execution_exception&)
+        {
+          execution_error = true;
+        }
+
+      if (nargin > 1 && (parse_status != 0 || execution_error))
+        {
           // Set up for letting the user print any messages from
           // errors that occurred in the first part of this eval().
 
           buffer_error_messages--;
 
           tmp = eval_string (args(1), nargout > 0, parse_status, nargout);
 
           if (nargout > 0)
             retval = tmp;
         }
-      else if (nargout > 0)
-        retval = tmp;
+      else
+        {
+          if (nargout > 0)
+            retval = tmp;
+
+          // FIXME: we should really be rethrowing whatever exception occurred,
+          // not just throwing an execution exception.
+          if (execution_error)
+            octave_throw_execution_exception ();
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -5151,36 +5165,53 @@ Like @code{eval}, except that the expres
               if (nargin > 2)
                 {
                   frame.protect_var (buffer_error_messages);
                   buffer_error_messages++;
                 }
 
               int parse_status = 0;
 
-              octave_value_list tmp = eval_string (args(1), nargout > 0,
-                                                   parse_status, nargout);
-
-              if (nargout > 0)
-                retval = tmp;
-
-              if (nargin > 2 && (parse_status != 0 || error_state))
+              bool execution_error = false;
+
+              octave_value_list tmp;
+
+              try
                 {
-                  error_state = 0;
-
+                  tmp = eval_string (args(1), nargout > 0,
+                                     parse_status, nargout);
+                }
+              catch (const octave_execution_exception&)
+                {
+                  execution_error = true;
+                }
+
+              if (nargin > 2 && (parse_status != 0 || execution_error))
+                {
                   // Set up for letting the user print any messages from
                   // errors that occurred in the first part of this eval().
 
                   buffer_error_messages--;
 
                   tmp = eval_string (args(2), nargout > 0,
                                      parse_status, nargout);
 
                   retval = (nargout > 0) ? tmp : octave_value_list ();
                 }
+              else
+                {
+                  if (nargout > 0)
+                    retval = tmp;
+
+                  // FIXME: we should really be rethrowing whatever
+                  // exception occurred, not just throwing an
+                  // execution exception.
+                  if (execution_error)
+                    octave_throw_execution_exception ();
+                }
             }
         }
       else
         error ("evalin: CONTEXT must be a string");
     }
   else
     print_usage ();
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -54,16 +54,18 @@ tree_evaluator *current_evaluator = &std
 int tree_evaluator::dbstep_flag = 0;
 
 size_t tree_evaluator::current_frame = 0;
 
 bool tree_evaluator::debug_mode = false;
 
 bool tree_evaluator::quiet_breakpoint_flag = false;
 
+bool tree_evaluator::unwind_protect_exception = false;
+
 tree_evaluator::stmt_list_type tree_evaluator::statement_context
   = tree_evaluator::other;
 
 bool tree_evaluator::in_loop_command = false;
 
 // Maximum nesting level for functions, scripts, or sourced files called
 // recursively.
 int Vmax_recursion_depth = 256;
@@ -746,21 +748,17 @@ tree_evaluator::visit_statement (tree_st
               if (do_bind_ans && ! (error_state || tmp_result.is_undefined ()))
                 bind_ans (tmp_result, expr->print_result ()
                           && statement_printing_enabled ());
 
               //              if (tmp_result.is_defined ())
               //                result_values(0) = tmp_result;
             }
         }
-      catch (octave_execution_exception)
-        {
-          gripe_library_execution_error ();
-        }
-      catch (std::bad_alloc)
+      catch (const std::bad_alloc&)
         {
           // FIXME: We want to use error_with_id here so that we set
           // the error state, give users control over this error
           // message, and so that we set the error_state appropriately
           // so we'll get stack trace info when appropriate.  But
           // error_with_id will require some memory allocations.  Is
           // there anything we can do to make those more likely to
           // succeed?
@@ -897,76 +895,69 @@ tree_evaluator::visit_try_catch_command 
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
   // The catch code is *not* added to unwind_protect stack; it doesn't need
   // to be run on interrupts.
 
   tree_statement_list *try_code = cmd.body ();
 
+  bool execution_error = false;
+  
   if (try_code)
     {
-      try_code->accept (*this);
+      try
+        {
+          try_code->accept (*this);
+        }
+      catch (const octave_execution_exception&)
+        {
+          execution_error = true;
+        }
     }
 
-  if (error_state)
+  if (execution_error)
     {
-      error_state = 0;
-
       if (catch_code)
         {
           // Set up for letting the user print any messages from errors that
           // occurred in the body of the try_catch statement.
 
           buffer_error_messages--;
 
           tree_identifier *expr_id = cmd.identifier ();
           octave_lvalue ult;
 
           if (expr_id)
             {
+              ult = expr_id->lvalue ();
 
               octave_scalar_map err;
 
-              ult = expr_id->lvalue ();
-
-              if (error_state)
-                return;
-
               err.assign ("message", last_error_message ());
               err.assign ("identifier", last_error_id ());
               err.assign ("stack", last_error_stack ());
 
-              if (! error_state)
-                ult.assign (octave_value::op_asn_eq, err);
-
+              ult.assign (octave_value::op_asn_eq, err);
             }
 
           if (catch_code)
             catch_code->accept (*this);
         }
     }
 }
 
 void
 tree_evaluator::do_unwind_protect_cleanup_code (tree_statement_list *list)
 {
   unwind_protect frame;
 
   frame.protect_var (octave_interrupt_state);
   octave_interrupt_state = 0;
 
-  // We want to run the cleanup code without error_state being set,
-  // but we need to restore its value, so that any errors encountered
-  // in the first part of the unwind_protect are not completely
-  // ignored.
-
-  frame.protect_var (error_state);
-  error_state = 0;
-
   // We want to preserve the last location info for possible
   // backtracking.
   frame.add_fcn (octave_call_stack::set_line,
                  octave_call_stack::current_line ());
   frame.add_fcn (octave_call_stack::set_column,
                  octave_call_stack::current_column ());
 
   // Similarly, if we have seen a return or break statement, allow all
@@ -975,18 +966,27 @@ tree_evaluator::do_unwind_protect_cleanu
   // only occur in loops.
 
   frame.protect_var (tree_return_command::returning);
   tree_return_command::returning = 0;
 
   frame.protect_var (tree_break_command::breaking);
   tree_break_command::breaking = 0;
 
-  if (list)
-    list->accept (*this);
+  bool execution_error_in_cleanup = false;
+
+  try
+    {
+      if (list)
+        list->accept (*this);
+    }
+  catch (const octave_execution_exception&)
+    {
+      execution_error_in_cleanup = true;
+    }
 
   // The unwind_protects are popped off the stack in the reverse of
   // the order they are pushed on.
 
   // FIXME: these statements say that if we see a break or
   // return statement in the cleanup block, that we want to use the
   // new value of the breaking or returning flag instead of restoring
   // the previous value.  Is that the right thing to do?  I think so.
@@ -1006,54 +1006,65 @@ tree_evaluator::do_unwind_protect_cleanu
   //
   // If we reset the value of the breaking flag, both the returning
   // flag and the breaking flag will be set, and we shouldn't have
   // both.  So, use the most recent one.  If there is no return or
   // break in the cleanup block, the values should be reset to
   // whatever they were when the cleanup block was entered.
 
   if (tree_break_command::breaking || tree_return_command::returning)
-    {
-      frame.discard (2);
-    }
+    frame.discard (2);
   else
-    {
-      frame.run (2);
-    }
+    frame.run (2);
 
-  // We don't want to ignore errors that occur in the cleanup code, so
-  // if an error is encountered there, leave error_state alone.
-  // Otherwise, set it back to what it was before.
+  // We don't want to ignore errors that occur in the cleanup code,
+  // so if an error is encountered there, rethrow the exception.
+  // Otherwise, rethrow any exception that might have occurred in the
+  // unwind_protect block.
 
-  if (error_state)
+  if (execution_error_in_cleanup)
     frame.discard (2);
   else
     frame.run (2);
 
   frame.run ();
+
+  // FIXME: we should really be rethrowing whatever exception occurred,
+  // not just throwing an execution exception.
+  if (unwind_protect_exception || execution_error_in_cleanup)
+    {
+      unwind_protect_exception = false;
+
+      octave_throw_execution_exception ();
+    }
 }
 
 void
 tree_evaluator::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
 {
   tree_statement_list *cleanup_code = cmd.cleanup ();
 
   tree_statement_list *unwind_protect_code = cmd.body ();
 
   if (unwind_protect_code)
     {
+      unwind_protect_exception = false;
+
       try
         {
           unwind_protect_code->accept (*this);
         }
-      catch (...)
+      catch (const octave_execution_exception&)
         {
+          unwind_protect_exception = true;
+
           // Run the cleanup code on exceptions, so that it is run even in case
           // of interrupt or out-of-memory.
           do_unwind_protect_cleanup_code (cleanup_code);
+
           // FIXME: should error_state be checked here?
           // We want to rethrow the exception, even if error_state is set, so
           // that interrupts continue.
           throw;
         }
 
       do_unwind_protect_cleanup_code (cleanup_code);
     }
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -148,16 +148,18 @@ public:
 
   // The number of the stack frame we are currently debugging.
   static size_t current_frame;
 
   static bool debug_mode;
 
   static bool quiet_breakpoint_flag;
 
+  static bool unwind_protect_exception;
+
   // Possible types of evaluation contexts.
   enum stmt_list_type
   {
     function,  // function body
     script,    // script file
     other      // command-line input or eval string
   };
 
diff --git a/liboctave/cruft/misc/quit.h b/liboctave/cruft/misc/quit.h
--- a/liboctave/cruft/misc/quit.h
+++ b/liboctave/cruft/misc/quit.h
@@ -190,28 +190,28 @@ inline void octave_quit (void)
   sig_atomic_t saved_octave_interrupt_immediately = octave_interrupt_immediately; \
  \
   try \
     { \
       octave_interrupt_immediately = 0;
 
 #define END_INTERRUPT_WITH_EXCEPTIONS \
     } \
-  catch (octave_interrupt_exception) \
+  catch (const octave_interrupt_exception&) \
     { \
       octave_interrupt_immediately = saved_octave_interrupt_immediately; \
       octave_jump_to_enclosing_context (); \
     } \
-  catch (octave_execution_exception) \
+  catch (const octave_execution_exception&) \
     { \
       octave_interrupt_immediately = saved_octave_interrupt_immediately; \
       octave_exception_state = octave_exec_exception; \
       octave_jump_to_enclosing_context (); \
     } \
-  catch (std::bad_alloc) \
+  catch (const std::bad_alloc&) \
     { \
       octave_interrupt_immediately = saved_octave_interrupt_immediately; \
       octave_exception_state = octave_alloc_exception; \
       octave_jump_to_enclosing_context (); \
     } \
  \
   octave_interrupt_immediately = saved_octave_interrupt_immediately
 #endif
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -1663,17 +1663,17 @@ command_editor::do_decode_prompt_string 
 
             case 'w':
             case 'W':
               {
                 try
                   {
                     temp = octave_env::get_current_directory ();
                   }
-                catch (octave_execution_exception)
+                catch (const octave_execution_exception&)
                   {
                     temp = "";
                   }
 
                 std::string home_dir = octave_env::get_home_directory ();
 
                 if (c == 'W' && (home_dir.empty () || temp != home_dir))
                   {
