# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1424974024 18000
#      Thu Feb 26 13:07:04 2015 -0500
# Node ID 17d647821d6124f7ae022a12197dcd38059ea1d7
# Parent  09ed6f7538dddc5e630b1d5badccfc84fffdae89
maint: More cleanup of C++ code to follow Octave coding conventions.

* gl-select.cc, betainc.cc, bitfcns.cc, bsxfun.cc, gl-render.cc,
graphics.cc, load-save.cc, ls-mat-ascii.cc, ls-mat5.cc, lu.cc,
oct-stream.cc, symtab.cc, variables.cc, __eigs__.cc,
__magick_read__.cc, chol.cc, ov-base-sparse.cc, ov-class.cc,
ov-classdef.cc, ov-fcn-inline.cc, ov-perm.cc, ov.cc, CMatrix.cc,
CSparse.cc, MSparse.cc, MatrixType.cc, MatrixType.h, dMatrix.cc,
dSparse.cc, fCMatrix.cc, fMatrix.cc, eigs-base.cc, lo-sysdep.cc,
kpse.cc: Break long lines before && and ||.

diff --git a/libgui/graphics/gl-select.cc b/libgui/graphics/gl-select.cc
--- a/libgui/graphics/gl-select.cc
+++ b/libgui/graphics/gl-select.cc
@@ -87,18 +87,18 @@ opengl_selector::select (const graphics_
       GLuint current_name = 0xffffffff;
 
       for (int i = 0, j = 0; i < hits && j < BUFFER_SIZE-3; i++)
         {
           GLuint n = select_buffer[j++],
                  minZ = select_buffer[j++];
 
           j++; // skip maxZ
-          if (((flags & select_last) == 0 && (minZ <= current_minZ)) ||
-              ((flags & select_last) != 0 && (minZ >= current_minZ)))
+          if (((flags & select_last) == 0 && (minZ <= current_minZ))
+              || ((flags & select_last) != 0 && (minZ >= current_minZ)))
             {
               bool candidate = true;
               GLuint name =
                 select_buffer[std::min (j + n, GLuint (BUFFER_SIZE)) - 1];
 
               if ((flags & select_ignore_hittest) == 0)
                 {
                   graphics_object go = object_map[name];
diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -69,18 +69,18 @@ compatible dimensions.\n\
 
   if (nargin == 3)
     {
       octave_value x_arg = args(0);
       octave_value a_arg = args(1);
       octave_value b_arg = args(2);
 
       // FIXME: Can we make a template version of the duplicated code below
-      if (x_arg.is_single_type () || a_arg.is_single_type () ||
-          b_arg.is_single_type ())
+      if (x_arg.is_single_type () || a_arg.is_single_type ()
+          || b_arg.is_single_type ())
         {
           if (x_arg.is_scalar_type ())
             {
               float x = x_arg.float_value ();
 
               if (a_arg.is_scalar_type ())
                 {
                   float a = a_arg.float_value ();
@@ -446,18 +446,18 @@ Compute the inverse of the incomplete Be
                 }
             }
         }
 
       // FIXME: It would be better to have an algorithm for betaincinv which
       // accepted float inputs and returned float outputs.  As it is, we do
       // extra work to calculate betaincinv to double precision and then throw
       // that precision away.
-      if (x_arg.is_single_type () || a_arg.is_single_type () ||
-          b_arg.is_single_type ())
+      if (x_arg.is_single_type () || a_arg.is_single_type ()
+          || b_arg.is_single_type ())
         {
           retval = Array<float> (retval.array_value ());
         }
     }
   else
     print_usage ();
 
   return retval;
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -126,52 +126,60 @@ bitopx (const std::string& fname, const 
     return bitopxx (std::bit_and<T>(), fname, x, y);
   if (fname == "bitor")
     return bitopxx (std::bit_or<T>(), fname, x, y);
 
   //else (fname == "bitxor")
   return bitopxx (std::bit_xor<T>(), fname, x, y);
 }
 
+static inline int
+bitop_arg_is_int (const octave_value& arg)
+{
+  return (arg.class_name () != octave_scalar::static_class_name ()
+          && arg.class_name () != octave_float_scalar::static_class_name ()
+          && arg.class_name () != octave_bool::static_class_name ());
+}
+
+static inline int
+bitop_arg_is_bool (const octave_value& arg)
+{
+  return arg.class_name () == octave_bool::static_class_name ();
+}
+
+static inline int
+bitop_arg_is_float (const octave_value& arg)
+{
+  return arg.class_name () == octave_float_scalar::static_class_name ();
+}
+
 octave_value
 bitop (const std::string& fname, const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      if ((args(0).class_name () == octave_scalar::static_class_name ())
-          || (args(0).class_name () == octave_float_scalar::static_class_name ())
-          || (args(0).class_name () == octave_bool::static_class_name ())
-          || (args(1).class_name () == octave_scalar::static_class_name ())
-          || (args(1).class_name () == octave_float_scalar::static_class_name ())
-          || (args(1).class_name () == octave_bool::static_class_name ()))
+      if (args(0).class_name () == octave_scalar::static_class_name ()
+          || args(0).class_name () == octave_float_scalar::static_class_name ()
+          || args(0).class_name () == octave_bool::static_class_name ()
+          || args(1).class_name () == octave_scalar::static_class_name ()
+          || args(1).class_name () == octave_float_scalar::static_class_name ()
+          || args(1).class_name () == octave_bool::static_class_name ())
         {
-          bool arg0_is_int = (args(0).class_name () !=
-                              octave_scalar::static_class_name () &&
-                              args(0).class_name () !=
-                              octave_float_scalar::static_class_name () &&
-                              args(0).class_name () !=
-                              octave_bool::static_class_name ());
-          bool arg1_is_int = (args(1).class_name () !=
-                              octave_scalar::static_class_name () &&
-                              args(1).class_name () !=
-                              octave_float_scalar::static_class_name () &&
-                              args(1).class_name () !=
-                              octave_bool::static_class_name ());
-          bool arg0_is_bool = args(0).class_name () ==
-                              octave_bool::static_class_name ();
-          bool arg1_is_bool = args(1).class_name () ==
-                              octave_bool::static_class_name ();
-          bool arg0_is_float = args(0).class_name () ==
-                               octave_float_scalar::static_class_name ();
-          bool arg1_is_float = args(1).class_name () ==
-                               octave_float_scalar::static_class_name ();
+          bool arg0_is_int = bitop_arg_is_int (args(0));
+          bool arg1_is_int = bitop_arg_is_int (args(1));
+
+          bool arg0_is_bool = bitop_arg_is_bool (args(0));
+          bool arg1_is_bool = bitop_arg_is_bool (args(1));
+
+          bool arg0_is_float = bitop_arg_is_float (args(0));
+          bool arg1_is_float = bitop_arg_is_float (args(1));
 
           if (! (arg0_is_int || arg1_is_int))
             {
               if (arg0_is_bool && arg1_is_bool)
                 {
                   boolNDArray x (args(0).bool_array_value ());
                   boolNDArray y (args(1).bool_array_value ());
                   if (! error_state)
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -531,18 +531,18 @@ dimensionality as the other array.\n\
                                   C = C.resize (dvc);
                                 }
                             }
                         }
                       else
                         {
                           update_index (ra_idx, dvc, i);
 
-                          if (have_FloatNDArray ||
-                              have_FloatComplexNDArray)
+                          if (have_FloatNDArray
+                              || have_FloatComplexNDArray)
                             {
                               if (! tmp(0).is_float_type ())
                                 {
                                   if (have_FloatNDArray)
                                     {
                                       have_FloatNDArray = false;
                                       C = result_FloatNDArray;
                                     }
@@ -550,18 +550,18 @@ dimensionality as the other array.\n\
                                     {
                                       have_FloatComplexNDArray = false;
                                       C = result_FloatComplexNDArray;
                                     }
                                   C = do_cat_op (C, tmp(0), ra_idx);
                                 }
                               else if (tmp(0).is_double_type ())
                                 {
-                                  if (tmp(0).is_complex_type () &&
-                                      have_FloatNDArray)
+                                  if (tmp(0).is_complex_type ()
+                                      && have_FloatNDArray)
                                     {
                                       result_ComplexNDArray =
                                         ComplexNDArray (result_FloatNDArray);
                                       result_ComplexNDArray.insert
                                         (tmp(0).complex_array_value (), ra_idx);
                                       have_FloatComplexNDArray = false;
                                       have_ComplexNDArray = true;
                                     }
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1570,19 +1570,19 @@ opengl_renderer::draw_line (const line::
         }
 
       set_linewidth (0.5);
       set_linestyle ("-");
     }
 
   set_clipping (false);
 
-  if (! props.marker_is ("none") &&
-      ! (props.markeredgecolor_is ("none")
-         && props.markerfacecolor_is ("none")))
+  if (! props.marker_is ("none")
+      && ! (props.markeredgecolor_is ("none")
+            && props.markerfacecolor_is ("none")))
     {
       Matrix lc, fc;
 
       if (props.markeredgecolor_is ("auto"))
         lc = props.get_color_rgb ();
       else if (! props.markeredgecolor_is ("none"))
         lc = props.get_markeredgecolor_rgb ();
 
@@ -2131,19 +2131,19 @@ opengl_renderer::draw_surface (const sur
             glDisable (GL_LIGHTING);
         }
       else
         {
           // FIXME: implement transparency
         }
     }
 
-  if (! props.marker_is ("none") &&
-      ! (props.markeredgecolor_is ("none")
-         && props.markerfacecolor_is ("none")))
+  if (! props.marker_is ("none")
+      && ! (props.markeredgecolor_is ("none")
+            && props.markerfacecolor_is ("none")))
     {
       // FIXME: check how transparency should be handled in markers
       // FIXME: check what to do with marker facecolor set to auto
       //        and facecolor set to none.
 
       bool do_edge = ! props.markeredgecolor_is ("none");
       bool do_face = ! props.markerfacecolor_is ("none");
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -2801,19 +2801,19 @@ xreset_default_properties (graphics_hand
 
   // Reset defaults
   for (property_list::pval_map_const_iterator it = factory_pval.begin ();
        it != factory_pval.end (); it++)
     {
       std::string pname = it->first;
 
       // Don't reset internal properties and handle_properties
-      if (! obj.has_readonly_property (pname) &&
-          pname.find ("__") != 0 && pname.find ("current") != 0 &&
-          pname != "uicontextmenu" && pname != "parent")
+      if (! obj.has_readonly_property (pname)
+          && pname.find ("__") != 0 && pname.find ("current") != 0
+          && pname != "uicontextmenu" && pname != "parent")
         {
           // Store *mode prop/val in order to set them last
           if (pname.find ("mode") == (pname.length () - 4))
             pval[pname] = it->second;
           else
             obj.set (pname, it->second);
         }
     }
@@ -3217,18 +3217,18 @@ base_graphics_object::values_as_string (
 
   if (valid_object ())
     {
       octave_map m = get ().map_value ();
       graphics_object obj = gh_manager::get_object (get_handle ());
 
       for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
         {
-          if (pa->first != "children" &&
-              ! obj.has_readonly_property (pa->first))
+          if (pa->first != "children"
+              && ! obj.has_readonly_property (pa->first))
             {
               property p = get_properties ().get_property (pa->first);
 
               if (p.ok () && ! p.is_hidden ())
                 {
                   retval += "\n\t" + std::string (pa->first) + ":  ";
                   if (p.is_radio ())
                     retval += p.values_as_string ();
@@ -7370,20 +7370,20 @@ axes::update_axis_limits (const std::str
 
   xproperties.update_transform ();
 
 }
 
 void
 axes::update_axis_limits (const std::string& axis_type)
 {
-  if ((updating_axis_limits.find (get_handle ().value ()) !=
-       updating_axis_limits.end ()) ||
-      (updating_aspectratios.find (get_handle ().value ()) !=
-       updating_aspectratios.end ()))
+  if ((updating_axis_limits.find (get_handle ().value ())
+       != updating_axis_limits.end ())
+      || (updating_aspectratios.find (get_handle ().value ())
+          != updating_aspectratios.end ()))
     return;
 
   Matrix kids = xproperties.get_children ();
 
   double min_val = octave_Inf;
   double max_val = -octave_Inf;
   double min_pos = octave_Inf;
   double max_neg = -octave_Inf;
@@ -8077,26 +8077,26 @@ text::properties::update_text_extent (vo
   /* The bbox is relative to the text's position.
      We'll leave it that way, because get_position () does not return
      valid results when the text is first constructed.
      Conversion to proper coordinates is performed in get_extent. */
   set_extent (bbox);
 
 #endif
 
-  if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel") ||
-      autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
+  if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel")
+      || autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
     update_autopos ("sync");
 }
 
 void
 text::properties::request_autopos (void)
 {
-  if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel") ||
-      autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
+  if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel")
+      || autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
     update_autopos (get_autopos_tag ());
 }
 
 void
 text::properties::update_units (void)
 {
   if (! units_is ("data"))
     {
@@ -8171,18 +8171,18 @@ patch::properties::update_fvc (void)
     return;
 
   Matrix xd = get_xdata ().matrix_value ();
   Matrix yd = get_ydata ().matrix_value ();
   Matrix zd = get_zdata ().matrix_value ();
   NDArray cd = get_cdata ().array_value ();
 
   bad_data_msg = std::string ();
-  if (xd.dims () != yd.dims () ||
-      (xd.dims () != zd.dims () && ! zd.is_empty ()))
+  if (xd.dims () != yd.dims ()
+      || (xd.dims () != zd.dims () && ! zd.is_empty ()))
     {
       bad_data_msg = "x/y/zdata should have the same dimensions";
       return;
     }
 
   // Faces and Vertices
   dim_vector dv;
   bool is3D = false;
@@ -11229,18 +11229,18 @@ dellistener (gcf, \"position\", c);\n\
                 {
                   graphics_object go = gh_manager::get_object (gh);
 
                   if (args.length () == 2)
                     go.delete_property_listener (pname, octave_value (),
                                                  POSTSET);
                   else
                     {
-                      if (args(2).is_string () &&
-                          args(2).string_value () == "persistent")
+                      if (args(2).is_string ()
+                          && args(2).string_value () == "persistent")
                         {
                           go.delete_property_listener (pname, octave_value (),
                                                        PERSISTENT);
                           go.delete_property_listener (pname, octave_value (),
                                                        POSTSET);
                         }
                       else
                         go.delete_property_listener (pname, args(2), POSTSET);
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -210,18 +210,18 @@ read_binary_file_header (std::istream& i
 #ifdef HAVE_ZLIB
 static bool
 check_gzip_magic (const std::string& fname)
 {
   bool retval = false;
   std::ifstream file (fname.c_str ());
   OCTAVE_LOCAL_BUFFER (unsigned char, magic, 2);
 
-  if (file.read (reinterpret_cast<char *> (magic), 2) && magic[0] == 0x1f &&
-      magic[1] == 0x8b)
+  if (file.read (reinterpret_cast<char *> (magic), 2) && magic[0] == 0x1f
+      && magic[1] == 0x8b)
     retval = true;
 
   file.close ();
   return retval;
 }
 #endif
 
 static load_save_format
@@ -1708,18 +1708,18 @@ the file @file{data} in Octave's binary 
         {
           // FIXME: It should be possible to append to HDF5 files.
           if (append)
             {
               error ("save: appending to HDF5 files is not implemented");
               return retval;
             }
 
-          bool write_header_info = ! (append &&
-                                      H5Fis_hdf5 (fname.c_str ()) > 0);
+          bool write_header_info
+            = ! (append && H5Fis_hdf5 (fname.c_str ()) > 0);
 
           hdf5_ofstream hdf5_file (fname.c_str (), mode);
 
           if (hdf5_file.file_id != -1)
             {
               save_vars (argv, i, argc, hdf5_file, format,
                          save_as_floats, write_header_info);
 
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -167,18 +167,18 @@ get_lines_and_columns (std::istream& is,
                       nc = 0;
 
                       goto done;
                     }
                 }
 
               beg = buf.find_first_not_of (", \t", end);
 
-              if (beg == std::string::npos || (buf[beg] == '\r' &&
-                                               beg == buf.length () - 1))
+              if (beg == std::string::npos
+                  || (buf[beg] == '\r' && beg == buf.length () - 1))
                 {
                   // We had a line with trailing spaces and
                   // ending with a CRLF, so this should look like EOL,
                   // not a new colum.
                   break;
                 }
             }
           else
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -627,18 +627,18 @@ read_mat5_binary_element (std::istream& 
       tc = Matrix ();
       return retval;
     }
 
   pos = is.tellg ();
 
   // array flags subelement
   int32_t len;
-  if (read_mat5_tag (is, swap, type, len, is_small_data_element) ||
-      type != miUINT32 || len != 8 || is_small_data_element)
+  if (read_mat5_tag (is, swap, type, len, is_small_data_element)
+      || type != miUINT32 || len != 8 || is_small_data_element)
     {
       error ("load: invalid array flags subelement");
       goto early_read_error;
     }
 
   int32_t flags;
   read_int (is, swap, flags);
 
@@ -654,18 +654,18 @@ read_mat5_binary_element (std::istream& 
   read_int (is, swap, tmp_nzmax);   // max number of nonzero in sparse
   nzmax = tmp_nzmax;
 
   // dimensions array subelement
   if (arrayclass != MAT_FILE_WORKSPACE_CLASS)
     {
       int32_t dim_len;
 
-      if (read_mat5_tag (is, swap, type, dim_len, is_small_data_element) ||
-          type != miINT32)
+      if (read_mat5_tag (is, swap, type, dim_len, is_small_data_element)
+          || type != miINT32)
         {
           error ("load: invalid dimensions array subelement");
           goto early_read_error;
         }
 
       int ndims = dim_len / 4;
       if (ndims == 1)
         {
@@ -690,17 +690,18 @@ read_mat5_binary_element (std::istream& 
   else
     {
       // Why did mathworks decide to not have dims for a workspace!!!
       dims.resize (2);
       dims(0) = 1;
       dims(1) = 1;
     }
 
-  if (read_mat5_tag (is, swap, type, len, is_small_data_element) || !INT8(type))
+  if (read_mat5_tag (is, swap, type, len, is_small_data_element)
+      || ! INT8(type))
     {
       error ("load: invalid array name subelement");
       goto early_read_error;
     }
 
   {
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
@@ -909,19 +910,19 @@ read_mat5_binary_element (std::istream& 
             if (fpath.length () == 0)
               // We have a builtin function
               tc = make_fcn_handle (fname);
             else
               {
                 std::string mroot =
                   m0.contents ("matlabroot").string_value ();
 
-                if ((fpath.length () >= mroot.length ()) &&
-                    fpath.substr (0, mroot.length ()) == mroot &&
-                    OCTAVE_EXEC_PREFIX != mroot)
+                if ((fpath.length () >= mroot.length ())
+                    && fpath.substr (0, mroot.length ()) == mroot
+                    && OCTAVE_EXEC_PREFIX != mroot)
                   {
                     // If fpath starts with matlabroot, and matlabroot
                     // doesn't equal octave_config_info ("exec_prefix")
                     // then the function points to a version of Octave
                     // or Matlab other than the running version. In that
                     // case we replace with the same function in the
                     // running version of Octave?
 
@@ -1092,17 +1093,17 @@ read_mat5_binary_element (std::istream& 
         int n_fields = 2;
         string_vector field (n_fields);
 
         for (int i = 0; i < n_fields; i++)
           {
             int32_t fn_type;
             int32_t fn_len;
             if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element)
-                || !INT8(fn_type))
+                || ! INT8(fn_type))
               {
                 error ("load: invalid field name subelement");
                 goto data_read_error;
               }
 
             OCTAVE_LOCAL_BUFFER (char, elname, fn_len + 1);
 
             std::streampos tmp_pos = is.tellg ();
@@ -1153,18 +1154,18 @@ read_mat5_binary_element (std::istream& 
         tc = m;
       }
       break;
 
     case MAT_FILE_OBJECT_CLASS:
       {
         isclass = true;
 
-        if (read_mat5_tag (is, swap, type, len, is_small_data_element) ||
-            !INT8(type))
+        if (read_mat5_tag (is, swap, type, len, is_small_data_element)
+            || ! INT8(type))
           {
             error ("load: invalid class name");
             goto skip_ahead;
           }
 
         {
           OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
@@ -1206,17 +1207,17 @@ read_mat5_binary_element (std::istream& 
           goto data_read_error;
 
         if (swap)
           swap_bytes<4> (&field_name_length);
 
         // field name subelement.  The length of this subelement tells
         // us how many fields there are.
         if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element)
-            || !INT8(fn_type))
+            || ! INT8(fn_type))
           {
             error ("load: invalid field name subelement");
             goto data_read_error;
           }
 
         octave_idx_type n_fields = fn_len/field_name_length;
 
         if (n_fields > 0)
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -588,18 +588,18 @@ information.\n\
 static
 bool check_lu_dims (const octave_value& l, const octave_value& u,
                     const octave_value& p)
 {
   octave_idx_type m = l.rows ();
   octave_idx_type k = u.rows ();
   octave_idx_type n = u.columns ();
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
-          && k == std::min (m, n) &&
-          (p.is_undefined () || p.rows () == m));
+          && k == std::min (m, n)
+          && (p.is_undefined () || p.rows () == m));
 }
 
 DEFUN (luupdate, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 Given an LU@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{L}*@var{U}}, @var{L}@tie{}lower unit trapezoidal and\n\
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -4221,25 +4221,28 @@ octave_stream_list::do_insert (octave_st
 {
   // Insert item with key corresponding to file-descriptor.
 
   int stream_number;
 
   if ((stream_number = os.file_number ()) == -1)
     return stream_number;
 
-  // Should we test for "(list.find (stream_number) != list.end ()) &&
-  // list[stream_number].is_open ()" and respond with "error
-  // ("internal error: ...")"? It should not happen except for some
-  // bug or if the user has opened a stream with an interpreted
-  // command, but closed it directly with a system call in an
-  // oct-file; then the kernel knows the fd is free, but Octave does
-  // not know. If it happens, it should not do harm here to simply
-  // overwrite this entry, although the wrong entry might have done
-  // harm before.
+  // Should we test for
+  //
+  //  (list.find (stream_number) != list.end ()
+  //   && list[stream_number].is_open ())
+  //
+  // and respond with "error ("internal error: ...")"?  It should not
+  // happen except for some bug or if the user has opened a stream with
+  // an interpreted command, but closed it directly with a system call
+  // in an oct-file; then the kernel knows the fd is free, but Octave
+  // does not know.  If it happens, it should not do harm here to simply
+  // overwrite this entry, although the wrong entry might have done harm
+  // before.
 
   if (list.size () < list.max_size ())
     list[stream_number] = os;
   else
     {
       stream_number = -1;
       error ("could not create file id");
     }
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -239,20 +239,22 @@ out_of_date_check (octave_value& functio
 
                   std::string file;
                   std::string dir_name;
 
                   if (check_relative)
                     {
                       int nm_len = nm.length ();
 
-                      if (octave_env::absolute_pathname (nm) &&
-                          ((nm_len > 4 && (nm.substr (nm_len-4) == ".oct"
-                                           || nm.substr (nm_len-4) == ".mex"))
-                           || (nm_len > 2 && nm.substr (nm_len-2) == ".m")))
+                      if (octave_env::absolute_pathname (nm)
+                          && ((nm_len > 4
+                               && (nm.substr (nm_len-4) == ".oct"
+                                   || nm.substr (nm_len-4) == ".mex"))
+                              || (nm_len > 2
+                                  && nm.substr (nm_len-2) == ".m")))
                         file = nm;
                       else
                         {
                           // We don't want to make this an absolute name,
                           // because load_fcn_file looks at the name to
                           // decide whether it came from a relative lookup.
 
                           if (! dispatch_type.empty ())
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -275,18 +275,18 @@ generate_struct_completions (const std::
 
           discard_error_messages = true;
           discard_warning_messages = true;
 
           octave_value tmp = eval_string (prefix, true, parse_status);
 
           frame.run ();
 
-          if (tmp.is_defined () &&
-              (tmp.is_map () || tmp.is_java () || tmp.is_classdef_object ()))
+          if (tmp.is_defined ()
+              && (tmp.is_map () || tmp.is_java () || tmp.is_classdef_object ()))
             names = tmp.map_keys ();
         }
     }
 
   return names;
 }
 
 // FIXME: this will have to be much smarter to work "correctly".
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -265,18 +265,18 @@ Undocumented internal function.\n\
               amm = (args(0).matrix_value ());
             }
         }
 
     }
 
   // Note hold off reading B till later to avoid issues of double
   // copies of the matrix if B is full/real while A is complex.
-  if (!error_state && nargin > 1 + arg_offset &&
-      !(args(1 + arg_offset).is_real_scalar ()))
+  if (! error_state && nargin > 1 + arg_offset
+      && ! (args(1 + arg_offset).is_real_scalar ()))
     {
       if (args(1+arg_offset).is_complex_type ())
         {
           b_arg = 1+arg_offset;
           have_b = true;
           b_is_complex = true;
           arg_offset++;
         }
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -795,18 +795,18 @@ use @code{imread}.\n\
   // to cover the different types of images which would lead to a lot of
   // copy and paste.
   {
     const unsigned int nRows = imvec[frameidx(0)].rows ();
     const unsigned int nCols = imvec[frameidx(0)].columns ();
     const octave_idx_type n = frameidx.nelem ();
     for (octave_idx_type frame = 0; frame < n; frame++)
       {
-        if (nRows != imvec[frameidx(frame)].rows () ||
-            nCols != imvec[frameidx(frame)].columns ())
+        if (nRows != imvec[frameidx(frame)].rows ()
+            || nCols != imvec[frameidx(frame)].columns ())
           {
             error ("imread: all frames must have the same size but frame %i is different",
                    frameidx(frame) +1);
             return output;
           }
       }
   }
 
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -1266,18 +1266,18 @@ triangular, return the Cholesky@tie{}fac
       octave_idx_type i = argi.scalar_value ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n)
         {
           if (j > 0 && j <= n+1 && i > 0 && i <= n+1)
             {
 
-              if (argr.is_single_type () && argi.is_single_type () &&
-                  argj.is_single_type ())
+              if (argr.is_single_type () && argi.is_single_type ()
+                  && argj.is_single_type ())
                 {
                   if (argr.is_real_type ())
                     {
                       // real case
                       FloatMatrix R = argr.float_matrix_value ();
 
                       FloatCHOL fact;
                       fact.set (R);
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -406,19 +406,19 @@ template <class T>
 bool
 octave_base_sparse<T>::load_ascii (std::istream& is)
 {
   octave_idx_type nz = 0;
   octave_idx_type nr = 0;
   octave_idx_type nc = 0;
   bool success = true;
 
-  if (extract_keyword (is, "nnz", nz, true) &&
-      extract_keyword (is, "rows", nr, true) &&
-      extract_keyword (is, "columns", nc, true))
+  if (extract_keyword (is, "nnz", nz, true)
+      && extract_keyword (is, "rows", nr, true)
+      && extract_keyword (is, "columns", nc, true))
     {
       T tmp (nr, nc, nz);
 
       is >> tmp;
 
       if (!is)
         {
           error ("load: failed to load matrix constant");
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1992,20 +1992,20 @@ belongs to.\n\
       return retval;
     }
 
   boolNDArray matches (cls.dims (), false);
   const octave_idx_type n = cls.numel ();
   for (octave_idx_type idx = 0; idx < n; idx++)
     {
       const std::string cl = cls(idx);
-      if ((cl == "float"   && obj.is_float_type   ()) ||
-          (cl == "integer" && obj.is_integer_type ()) ||
-          (cl == "numeric" && obj.is_numeric_type ()) ||
-          obj.class_name () == cl || obj.is_instance_of (cl))
+      if ((cl == "float"   && obj.is_float_type   ())
+          || (cl == "integer" && obj.is_integer_type ())
+          || (cl == "numeric" && obj.is_numeric_type ())
+          || obj.class_name () == cl || obj.is_instance_of (cl))
         matches(idx) = true;
     }
   return octave_value (matches);
 }
 
 /*
 %!assert (isa ("char", "float"), false)
 %!assert (isa (logical (1), "float"), false)
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -275,22 +275,21 @@ static cdef_class
 get_class_context (std::string& name, bool& in_constructor)
 {
   cdef_class cls;
 
   octave_function* fcn = octave_call_stack::current ();
 
   in_constructor = false;
 
-  if (fcn &&
-      (fcn->is_class_method ()
-       || fcn->is_classdef_constructor ()
-       || fcn->is_anonymous_function_of_class ()
-       || (fcn->is_private_function ()
-           && ! fcn->dispatch_class ().empty ())))
+  if (fcn && (fcn->is_class_method ()
+              || fcn->is_classdef_constructor ()
+              || fcn->is_anonymous_function_of_class ()
+              || (fcn->is_private_function ()
+                  && ! fcn->dispatch_class ().empty ())))
     {
       cls = lookup_class (fcn->dispatch_class ());
       if (! error_state)
         {
           name = fcn->name ();
           in_constructor = fcn->is_classdef_constructor ();
         }
     }
@@ -3621,18 +3620,18 @@ cdef_package::cdef_package_rep::meta_sub
                       if (! error_state)
                         {
                           // NOTE: the case where the package query is the last
                           // part of this subsref index is handled in the parse
                           // tree, because there is some logic to handle magic
                           // "end" that makes it impossible to execute the
                           // function call at this stage.
 
-                          if (type.size () > 1 &&
-                              ! fcn->is_postfix_index_handled (type[1]))
+                          if (type.size () > 1
+                              && ! fcn->is_postfix_index_handled (type[1]))
                             {
                               octave_value_list tmp_args;
 
                               retval = o.do_multi_index_op (nargout,
                                                             tmp_args);
                             }
                           else
                             retval(0) = o;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -754,21 +754,21 @@ functions from strings is through the us
 
                       for (int j = 0; j < fargs.length (); j++)
                         if (tmp_arg == fargs (j))
                           {
                             have_arg = true;
                             break;
                           }
 
-                      if (! have_arg && tmp_arg != "i" && tmp_arg != "j" &&
-                          tmp_arg != "NaN" && tmp_arg != "nan" &&
-                          tmp_arg != "Inf" && tmp_arg != "inf" &&
-                          tmp_arg != "NA" && tmp_arg != "pi" &&
-                          tmp_arg != "e" && tmp_arg != "eps")
+                      if (! have_arg && tmp_arg != "i" && tmp_arg != "j"
+                          && tmp_arg != "NaN" && tmp_arg != "nan"
+                          && tmp_arg != "Inf" && tmp_arg != "inf"
+                          && tmp_arg != "NA" && tmp_arg != "pi"
+                          && tmp_arg != "e" && tmp_arg != "eps")
                         fargs.append (tmp_arg);
 
                       tmp_arg = std::string ();
                       is_arg = false;
                     }
                 }
 
               // Sort the arguments into ascii order.
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -107,21 +107,18 @@ octave_perm_matrix::do_index_op (const o
               this->count++;
             }
         }
     }
 
   // if error_state is set, we've already griped.
   if (! error_state && ! retval.is_defined ())
     {
-      if (nidx == 2 && ! resize_ok &&
-          idx0.is_scalar () && idx1.is_scalar ())
-        {
-          retval = matrix.checkelem (idx0(0), idx1(0));
-        }
+      if (nidx == 2 && ! resize_ok && idx0.is_scalar () && idx1.is_scalar ())
+        retval = matrix.checkelem (idx0(0), idx1(0));
       else
         retval = to_dense ().do_index_op (idx, resize_ok);
     }
 
   return retval;
 }
 
 bool
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2031,18 +2031,19 @@ do_binary_op (octave_value::binary_op op
           octave_base_value::type_conv_info cf1 =
             v1.numeric_conversion_function ();
 
           octave_value tv2;
           octave_base_value::type_conv_info cf2 =
             v2.numeric_conversion_function ();
 
           // Try biased (one-sided) conversions first.
-          if (cf2.type_id () >= 0 &&
-              octave_value_typeinfo::lookup_binary_op (op, t1, cf2.type_id ()))
+          if (cf2.type_id () >= 0
+              && octave_value_typeinfo::lookup_binary_op (op, t1,
+                                                          cf2.type_id ()))
             cf1 = 0;
           else if (cf1.type_id () >= 0
                    && octave_value_typeinfo::lookup_binary_op (op,
                                                                cf1.type_id (),
                                                                t2))
             cf2 = 0;
 
           if (cf1)
@@ -2092,20 +2093,20 @@ do_binary_op (octave_value::binary_op op
 
               cf2 = tv2.numeric_demotion_function ();
 
               // Try biased (one-sided) conversions first.
               if (cf2.type_id () >= 0
                   && octave_value_typeinfo::lookup_binary_op (op, t1,
                                                               cf2.type_id ()))
                 cf1 = 0;
-              else if (cf1.type_id () >= 0 &&
-                       octave_value_typeinfo::lookup_binary_op (op,
-                                                                cf1.type_id (),
-                                                                t2))
+              else if (cf1.type_id () >= 0
+                       && octave_value_typeinfo::lookup_binary_op (op,
+                                                                   cf1.type_id (),
+                                                                   t2))
                 cf2 = 0;
 
               if (cf1)
                 {
                   octave_base_value *tmp = cf1 (*tv1.rep);
 
                   if (tmp)
                     {
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1933,18 +1933,17 @@ ComplexMatrix::utsolve (MatrixType &matt
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               (*current_liboctave_error_handler)
@@ -2029,18 +2028,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               (*current_liboctave_error_handler)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -767,18 +767,17 @@ SparseComplexMatrix::dinverse (MatrixTyp
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           if (typ == MatrixType::Permuted_Diagonal)
             retval = transpose ();
           else
             retval = *this;
 
           // Force make_unique to be called
           Complex *v = retval.data ();
@@ -822,18 +821,18 @@ SparseComplexMatrix::tinverse (MatrixTyp
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper
+          || typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
 
           if (calccond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
@@ -897,18 +896,18 @@ SparseComplexMatrix::tinverse (MatrixTyp
                           else if (rpX > rpU)
                             colUp++;
                           else
                             {
                               v -= retval.xdata (colXp) * data (colUp);
                               colXp++;
                               colUp++;
                             }
-                        } while ((rpX<j) && (rpU<j) &&
-                                 (colXp<cx) && (colUp<nz));
+                        }
+                      while (rpX < j && rpU < j && colXp < cx && colUp < nz);
 
 
                       // get A(m,m)
                       if (typ == MatrixType::Upper)
                         colUp = cidx (j+1) - 1;
                       else
                         colUp = cidx (j);
                       Complex pivot = data (colUp);
@@ -1308,18 +1307,17 @@ SparseComplexMatrix::dsolve (MatrixType 
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           retval.resize (nc, b.cols (), Complex (0.,0.));
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
@@ -1370,18 +1368,17 @@ SparseComplexMatrix::dsolve (MatrixType 
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
@@ -1462,18 +1459,17 @@ SparseComplexMatrix::dsolve (MatrixType 
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           retval.resize (nc, b.cols (), Complex (0.,0.));
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
@@ -1524,18 +1520,17 @@ SparseComplexMatrix::dsolve (MatrixType 
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
@@ -1616,18 +1611,17 @@ SparseComplexMatrix::utsolve (MatrixType
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           if (calc_cond)
             {
@@ -1656,18 +1650,18 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k ||
-                              data (cidx (kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k
+                              || data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (kidx);
@@ -1732,18 +1726,18 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k ||
-                              data (cidx (k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k
+                              || data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
@@ -1848,18 +1842,17 @@ SparseComplexMatrix::utsolve (MatrixType
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -1897,18 +1890,18 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k ||
-                              data (cidx (kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k
+                              || data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (kidx);
@@ -1994,18 +1987,18 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k ||
-                              data (cidx (k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k
+                              || data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
@@ -2131,18 +2124,17 @@ SparseComplexMatrix::utsolve (MatrixType
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           if (calc_cond)
             {
@@ -2171,18 +2163,18 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k ||
-                              data (cidx (kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k
+                              || data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (kidx);
@@ -2247,18 +2239,18 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k ||
-                              data (cidx (k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k
+                              || data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
@@ -2363,18 +2355,17 @@ SparseComplexMatrix::utsolve (MatrixType
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -2412,18 +2403,18 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k ||
-                              data (cidx (kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k
+                              || data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (kidx);
@@ -2509,18 +2500,18 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nr-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k ||
-                              data (cidx (k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k
+                              || data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
@@ -2647,18 +2638,17 @@ SparseComplexMatrix::ltsolve (MatrixType
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           if (calc_cond)
             {
@@ -2784,18 +2774,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k ||
-                              data (cidx (k)) == 0.)
+                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
@@ -2900,18 +2889,17 @@ SparseComplexMatrix::ltsolve (MatrixType
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -3064,18 +3052,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k ||
-                              data (cidx (k)) == 0.)
+                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
@@ -3203,18 +3190,17 @@ SparseComplexMatrix::ltsolve (MatrixType
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           if (calc_cond)
             {
@@ -3342,18 +3328,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k ||
-                              data (cidx (k)) == 0.)
+                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
@@ -3459,18 +3444,17 @@ SparseComplexMatrix::ltsolve (MatrixType
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -3623,18 +3607,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k ||
-                              data (cidx (k)) == 0.)
+                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
@@ -3915,18 +3898,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       // Note can't treat symmetric case as there is no dpttrf function
-      if (typ == MatrixType::Tridiagonal ||
-          typ == MatrixType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal
+          || typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4212,18 +4195,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       // Note can't treat symmetric case as there is no dpttrf function
-      if (typ == MatrixType::Tridiagonal ||
-          typ == MatrixType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal
+          || typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5535,18 +5518,18 @@ SparseComplexMatrix::factorize (octave_i
       UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (status == UMFPACK_WARNING_singular_matrix ||
-          rcond_plus_one == 1.0 || xisnan (rcond))
+      if (status == UMFPACK_WARNING_singular_matrix
+          || rcond_plus_one == 1.0 || xisnan (rcond))
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
@@ -6574,18 +6557,18 @@ SparseComplexMatrix::fsolve (MatrixType 
                   retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               rcond = Info (UMFPACK_RCOND);
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (status == UMFPACK_WARNING_singular_matrix ||
-                  rcond_plus_one == 1.0 || xisnan (rcond))
+              if (status == UMFPACK_WARNING_singular_matrix
+                  || rcond_plus_one == 1.0 || xisnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     sing_handler (rcond);
                   else
                     gripe_singular_matrix (rcond);
                 }
@@ -6646,18 +6629,18 @@ SparseComplexMatrix::solve (MatrixType &
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal ||
-           typ == MatrixType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal
+           || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
@@ -6714,18 +6697,18 @@ SparseComplexMatrix::solve (MatrixType &
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal ||
-           typ == MatrixType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal
+           || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
@@ -6782,18 +6765,18 @@ SparseComplexMatrix::solve (MatrixType &
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal ||
-           typ == MatrixType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal
+           || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
@@ -6851,18 +6834,18 @@ SparseComplexMatrix::solve (MatrixType &
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal ||
-           typ == MatrixType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal
+           || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
@@ -7640,31 +7623,30 @@ min (const SparseComplexMatrix& a, const
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
-              if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   Complex tmp = xmin (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   Complex tmp = xmin (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
@@ -7758,31 +7740,30 @@ max (const SparseComplexMatrix& a, const
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
-              if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   Complex tmp = xmax (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   Complex tmp = xmax (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -66,27 +66,26 @@ plus_or_minus (MSparse<T>& a, const MSpa
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
-              if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   r.ridx (jx) = a.ridx (ja);
                   r.data (jx) = op (a.data (ja), 0.);
                   jx++;
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   r.ridx (jx) = b.ridx (jb);
                   r.data (jx) = op (0., b.data (jb));
                   jx++;
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
@@ -338,27 +337,26 @@ plus_or_minus (const MSparse<T>& a, cons
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
-              if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   r.ridx (jx) = a.ridx (ja);
                   r.data (jx) = op (a.data (ja), 0.);
                   jx++;
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   r.ridx (jx) = b.ridx (jb);
                   r.data (jx) = op (0.,  b.data (jb));
                   jx++;
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
@@ -460,23 +458,22 @@ product (const MSparse<T>& a, const MSpa
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
-              if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   ja++; ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   jb++; jb_lt_max= jb < jb_max;
                 }
               else
                 {
                   if ((a.data (ja) * b.data (jb)) != 0.)
                     {
                       r.data (jx) = a.data (ja) * b.data (jb);
@@ -579,24 +576,23 @@ quotient (const MSparse<T>& a, const MSp
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
-              if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   r.elem (a.ridx (ja),i) = a.data (ja) / Zero;
                   ja++; ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   r.elem (b.ridx (jb),i) = Zero / b.data (jb);
                   jb++; jb_lt_max= jb < jb_max;
                 }
               else
                 {
                   r.elem (a.ridx (ja),i) = a.data (ja) / b.data (jb);
                   ja++; ja_lt_max= ja < ja_max;
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -273,18 +273,18 @@ MatrixType::MatrixType (const SparseMatr
 
           for (octave_idx_type j = 0; j < i; j++)
             found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
             found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
-              if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
-                  ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
+              if ((a.cidx (j+1) > a.cidx (j) + 1)
+                  || ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
               found[a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
@@ -377,18 +377,18 @@ MatrixType::MatrixType (const SparseMatr
             perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 {
-                  if ((a.cidx (j+1) - a.cidx (j)) > 0 &&
-                      (a.ridx (a.cidx (j+1)-1) == i))
+                  if ((a.cidx (j+1) - a.cidx (j)) > 0
+                      && (a.ridx (a.cidx (j+1)-1) == i))
                     {
                       perm[i] = j;
                       found = true;
                       break;
                     }
                 }
 
               if (!found)
@@ -469,33 +469,33 @@ MatrixType::MatrixType (const SparseMatr
               nperm = 0;
             }
         }
 
       // FIXME: Disable lower under-determined and upper over-determined
       //        problems as being detected, and force to treat as singular
       //        as this seems to cause issues.
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-           && nrows > ncols) ||
-          ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-           && nrows < ncols))
+           && nrows > ncols)
+          || ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+              && nrows < ncols))
         {
-          if (typ == MatrixType::Permuted_Upper ||
-              typ == MatrixType::Permuted_Lower)
+          if (typ == MatrixType::Permuted_Upper
+              || typ == MatrixType::Permuted_Lower)
             delete [] perm;
           nperm = 0;
           typ = MatrixType::Rectangular;
         }
 
       if (typ == MatrixType::Full && ncols != nrows)
         typ = MatrixType::Rectangular;
 
-      if (maybe_hermitian && (typ == MatrixType::Full ||
-                              typ == MatrixType::Tridiagonal ||
-                              typ == MatrixType::Banded))
+      if (maybe_hermitian && (typ == MatrixType::Full
+                              || typ == MatrixType::Tridiagonal
+                              || typ == MatrixType::Banded))
         {
           bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
@@ -591,18 +591,18 @@ MatrixType::MatrixType (const SparseComp
 
           for (octave_idx_type j = 0; j < i; j++)
             found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
             found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
-              if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
-                  ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
+              if ((a.cidx (j+1) > a.cidx (j) + 1)
+                  || ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
               found[a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
@@ -695,18 +695,18 @@ MatrixType::MatrixType (const SparseComp
             perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 {
-                  if ((a.cidx (j+1) - a.cidx (j)) > 0 &&
-                      (a.ridx (a.cidx (j+1)-1) == i))
+                  if ((a.cidx (j+1) - a.cidx (j)) > 0
+                      && (a.ridx (a.cidx (j+1)-1) == i))
                     {
                       perm[i] = j;
                       found = true;
                       break;
                     }
                 }
 
               if (!found)
@@ -787,33 +787,33 @@ MatrixType::MatrixType (const SparseComp
               nperm = 0;
             }
         }
 
       // FIXME: Disable lower under-determined and upper over-determined
       //        problems as being detected, and force to treat as singular
       //        as this seems to cause issues.
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-           && nrows > ncols) ||
-          ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-           && nrows < ncols))
+           && nrows > ncols)
+          || ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
+              && nrows < ncols))
         {
-          if (typ == MatrixType::Permuted_Upper ||
-              typ == MatrixType::Permuted_Lower)
+          if (typ == MatrixType::Permuted_Upper
+              || typ == MatrixType::Permuted_Lower)
             delete [] perm;
           nperm = 0;
           typ = MatrixType::Rectangular;
         }
 
       if (typ == MatrixType::Full && ncols != nrows)
         typ = MatrixType::Rectangular;
 
-      if (maybe_hermitian && (typ == MatrixType::Full ||
-                              typ == MatrixType::Tridiagonal ||
-                              typ == MatrixType::Banded))
+      if (maybe_hermitian && (typ == MatrixType::Full
+                              || typ == MatrixType::Tridiagonal
+                              || typ == MatrixType::Banded))
         {
           bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
@@ -885,18 +885,18 @@ MatrixType::MatrixType (const matrix_typ
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type np,
                         const octave_idx_type *p, bool _full)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
-  if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower) &&
-      np > 0 && p != 0)
+  if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower)
+      && np > 0 && p != 0)
     {
       typ = t;
       nperm = np;
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = p[i];
     }
   else
@@ -960,25 +960,24 @@ MatrixType::operator = (const MatrixType
 }
 
 int
 MatrixType::type (bool quiet)
 {
   if (typ != MatrixType::Unknown
       && (full || sp_bandden == octave_sparse_params::get_bandden ()))
     {
-      if (!quiet &&
-          octave_sparse_params::get_key ("spumoni") != 0.)
+      if (!quiet && octave_sparse_params::get_key ("spumoni") != 0.)
         warn_cached ();
 
       return typ;
     }
 
-  if (typ != MatrixType::Unknown &&
-      octave_sparse_params::get_key ("spumoni") != 0.)
+  if (typ != MatrixType::Unknown
+      && octave_sparse_params::get_key ("spumoni") != 0.)
     (*current_liboctave_warning_with_id_handler)
       ("Octave:matrix-type-info", "invalidating matrix type");
 
   typ = MatrixType::Unknown;
 
   return typ;
 }
 
@@ -1203,41 +1202,39 @@ MatrixType::info () const
         (*current_liboctave_warning_with_id_handler)
           ("Octave:matrix-type-info", "full matrix");
     }
 }
 
 void
 MatrixType::mark_as_symmetric (void)
 {
-  if (typ == MatrixType::Tridiagonal ||
-      typ == MatrixType::Tridiagonal_Hermitian)
+  if (typ == MatrixType::Tridiagonal
+      || typ == MatrixType::Tridiagonal_Hermitian)
     typ = MatrixType::Tridiagonal_Hermitian;
-  else if (typ == MatrixType::Banded ||
-           typ == MatrixType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     typ = MatrixType::Banded_Hermitian;
-  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian ||
-           typ == MatrixType::Unknown)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian
+           || typ == MatrixType::Unknown)
     typ = MatrixType::Hermitian;
   else
     (*current_liboctave_error_handler)
       ("Can not mark current matrix type as symmetric");
 }
 
 void
 MatrixType::mark_as_unsymmetric (void)
 {
-  if (typ == MatrixType::Tridiagonal ||
-      typ == MatrixType::Tridiagonal_Hermitian)
+  if (typ == MatrixType::Tridiagonal
+      || typ == MatrixType::Tridiagonal_Hermitian)
     typ = MatrixType::Tridiagonal;
-  else if (typ == MatrixType::Banded ||
-           typ == MatrixType::Banded_Hermitian)
+  else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     typ = MatrixType::Banded;
-  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian ||
-           typ == MatrixType::Unknown)
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian
+           || typ == MatrixType::Unknown)
     typ = MatrixType::Full;
 }
 
 void
 MatrixType::mark_as_permuted (const octave_idx_type np,
                               const octave_idx_type *p)
 {
   nperm = np;
diff --git a/liboctave/array/MatrixType.h b/liboctave/array/MatrixType.h
--- a/liboctave/array/MatrixType.h
+++ b/liboctave/array/MatrixType.h
@@ -116,18 +116,18 @@ public:
   bool is_banded (void)
   { return (typ == Banded || typ == Banded_Hermitian); }
 
   bool is_tridiagonal (void) const
   { return (typ == Tridiagonal || typ == Tridiagonal_Hermitian); }
 
   bool is_hermitian (void) const
   {
-    return (typ == Banded_Hermitian || typ == Tridiagonal_Hermitian ||
-            typ == Hermitian);
+    return (typ == Banded_Hermitian || typ == Tridiagonal_Hermitian
+            || typ == Hermitian);
   }
 
   bool is_rectangular (void) const { return (typ == Rectangular); }
 
   bool is_known (void) const { return (typ != Unknown); }
 
   bool is_unknown (void) const { return (typ == Unknown); }
 
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1572,18 +1572,17 @@ Matrix::utsolve (MatrixType &mattype, co
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               (*current_liboctave_error_handler)
@@ -1667,18 +1666,17 @@ Matrix::ltsolve (MatrixType &mattype, co
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               (*current_liboctave_error_handler)
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -777,27 +777,27 @@ atan2 (const SparseMatrix& x, const Spar
 
               octave_idx_type  jb = y.cidx (i);
               octave_idx_type  jb_max = y.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max)
                 {
                   octave_quit ();
-                  if ((! jb_lt_max) ||
-                      (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
+                  if ((! jb_lt_max)
+                      || (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
                     {
                       r.ridx (jx) = x.ridx (ja);
                       r.data (jx) = atan2 (x.data (ja), 0.);
                       jx++;
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
-                  else if ((! ja_lt_max) ||
-                           (jb_lt_max && (y.ridx (jb) < x.ridx (ja))))
+                  else if ((! ja_lt_max)
+                           || (jb_lt_max && (y.ridx (jb) < x.ridx (ja))))
                     {
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
                       double tmp = atan2 (x.data (ja), y.data (jb));
                       if (tmp != 0.)
@@ -862,18 +862,17 @@ SparseMatrix::dinverse (MatrixType &matt
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           if (typ == MatrixType::Permuted_Diagonal)
             retval = transpose ();
           else
             retval = *this;
 
           // Force make_unique to be called
           double *v = retval.data ();
@@ -917,18 +916,18 @@ SparseMatrix::tinverse (MatrixType &matt
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper
+          || typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
 
           if (calccond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
@@ -992,18 +991,18 @@ SparseMatrix::tinverse (MatrixType &matt
                           else if (rpX > rpU)
                             colUp++;
                           else
                             {
                               v -= retval.xdata (colXp) * data (colUp);
                               colXp++;
                               colUp++;
                             }
-                        } while ((rpX<j) && (rpU<j) &&
-                                 (colXp<cx) && (colUp<nz));
+                        }
+                      while (rpX < j && rpU < j && colXp < cx && colUp < nz);
 
                       // get A(m,m)
                       if (typ == MatrixType::Upper)
                         colUp = cidx (j+1) - 1;
                       else
                         colUp = cidx (j);
                       double pivot = data (colUp);
                       if (pivot == 0. || ridx (colUp) != j)
@@ -1394,18 +1393,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           retval.resize (nc, b.cols (), 0.);
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
@@ -1455,18 +1453,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseMatrix (nc, b_nc, b_nz);
 
           retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
@@ -1546,18 +1543,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           retval.resize (nc, b.cols (), 0);
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
@@ -1607,18 +1603,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal ||
-          typ == MatrixType::Permuted_Diagonal)
+      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
@@ -1699,18 +1694,17 @@ SparseMatrix::utsolve (MatrixType &matty
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           if (calc_cond)
             {
@@ -1739,18 +1733,18 @@ SparseMatrix::utsolve (MatrixType &matty
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k ||
-                              data (cidx (kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k
+                              || data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           double tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (kidx);
@@ -1815,18 +1809,18 @@ SparseMatrix::utsolve (MatrixType &matty
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k ||
-                              data (cidx (k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k
+                              || data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           double tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
@@ -1930,18 +1924,17 @@ SparseMatrix::utsolve (MatrixType &matty
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -1979,18 +1972,18 @@ SparseMatrix::utsolve (MatrixType &matty
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k ||
-                              data (cidx (kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k
+                              || data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           double tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (kidx);
@@ -2076,18 +2069,18 @@ SparseMatrix::utsolve (MatrixType &matty
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k ||
-                              data (cidx (k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k
+                              || data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           double tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
@@ -2213,18 +2206,17 @@ SparseMatrix::utsolve (MatrixType &matty
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           if (calc_cond)
             {
@@ -2253,18 +2245,18 @@ SparseMatrix::utsolve (MatrixType &matty
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (cwork[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k ||
-                              data (cidx (kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k
+                              || data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx (kidx);
@@ -2330,18 +2322,18 @@ SparseMatrix::utsolve (MatrixType &matty
                     cwork[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k ||
-                              data (cidx (k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k
+                              || data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = cwork[k] / data (cidx (k+1)-1);
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
@@ -2447,18 +2439,17 @@ SparseMatrix::utsolve (MatrixType &matty
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -2496,18 +2487,18 @@ SparseMatrix::utsolve (MatrixType &matty
                     cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (cwork[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k ||
-                              data (cidx (kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k
+                              || data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx (kidx);
@@ -2594,18 +2585,18 @@ SparseMatrix::utsolve (MatrixType &matty
                     cwork[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k ||
-                              data (cidx (k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k
+                              || data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = cwork[k] / data (cidx (k+1)-1);
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
@@ -2733,18 +2724,17 @@ SparseMatrix::ltsolve (MatrixType &matty
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           if (calc_cond)
             {
@@ -2871,18 +2861,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k ||
-                              data (cidx (k)) == 0.)
+                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           double tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1;
@@ -2989,18 +2978,17 @@ SparseMatrix::ltsolve (MatrixType &matty
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -3153,18 +3141,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k ||
-                              data (cidx (k)) == 0.)
+                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           double tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
@@ -3292,18 +3279,17 @@ SparseMatrix::ltsolve (MatrixType &matty
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           if (calc_cond)
             {
@@ -3431,18 +3417,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                     cwork[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k ||
-                              data (cidx (k)) == 0.)
+                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = cwork[k] / data (cidx (k));
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
@@ -3549,18 +3534,17 @@ SparseMatrix::ltsolve (MatrixType &matty
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -3714,18 +3698,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                     cwork[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k ||
-                              data (cidx (k)) == 0.)
+                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
                           Complex tmp = cwork[k] / data (cidx (k));
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
@@ -4006,18 +3989,18 @@ SparseMatrix::trisolve (MatrixType &matt
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       // Note can't treat symmetric case as there is no dpttrf function
-      if (typ == MatrixType::Tridiagonal ||
-          typ == MatrixType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal
+          || typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4302,18 +4285,18 @@ SparseMatrix::trisolve (MatrixType &matt
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       // Note can't treat symmetric case as there is no dpttrf function
-      if (typ == MatrixType::Tridiagonal ||
-          typ == MatrixType::Tridiagonal_Hermitian)
+      if (typ == MatrixType::Tridiagonal
+          || typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5728,18 +5711,18 @@ SparseMatrix::factorize (octave_idx_type
       UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (status == UMFPACK_WARNING_singular_matrix ||
-          rcond_plus_one == 1.0 || xisnan (rcond))
+      if (status == UMFPACK_WARNING_singular_matrix
+          || rcond_plus_one == 1.0 || xisnan (rcond))
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
@@ -6786,18 +6769,18 @@ SparseMatrix::solve (MatrixType &mattype
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal ||
-           typ == MatrixType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal
+           || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return Matrix ();
     }
@@ -6854,18 +6837,18 @@ SparseMatrix::solve (MatrixType &mattype
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal ||
-           typ == MatrixType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal
+           || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseMatrix ();
     }
@@ -6922,18 +6905,18 @@ SparseMatrix::solve (MatrixType &mattype
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal ||
-           typ == MatrixType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal
+           || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
@@ -6990,18 +6973,18 @@ SparseMatrix::solve (MatrixType &mattype
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal ||
-           typ == MatrixType::Tridiagonal_Hermitian)
+  else if (typ == MatrixType::Tridiagonal
+           || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
@@ -7749,31 +7732,30 @@ min (const SparseMatrix& a, const Sparse
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
-              if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   double tmp = xmin (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   double tmp = xmin (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
@@ -7900,31 +7882,30 @@ max (const SparseMatrix& a, const Sparse
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
-              if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+              if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   double tmp = xmax (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if ((! ja_lt_max) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
+              else if ((! ja_lt_max)
+                       || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   double tmp = xmax (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1937,18 +1937,17 @@ FloatComplexMatrix::utsolve (MatrixType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               (*current_liboctave_error_handler)
@@ -2033,18 +2032,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               (*current_liboctave_error_handler)
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1584,18 +1584,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Upper ||
-          typ == MatrixType::Upper)
+      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               (*current_liboctave_error_handler)
@@ -1681,18 +1680,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Lower ||
-          typ == MatrixType::Lower)
+      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               (*current_liboctave_error_handler)
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -497,18 +497,18 @@ LuAminusSigmaB (const SparseMatrix &m, c
     }
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
-      if (U.xcidx (j+1) > U.xcidx (j) &&
-          U.xridx (U.xcidx (j+1)-1) == j)
+      if (U.xcidx (j+1) > U.xcidx (j)
+          && U.xridx (U.xcidx (j+1)-1) == j)
         d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
@@ -661,18 +661,18 @@ LuAminusSigmaB (const SparseComplexMatri
     }
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
-      if (U.xcidx (j+1) > U.xcidx (j) &&
-          U.xridx (U.xcidx (j+1)-1) == j)
+      if (U.xcidx (j+1) > U.xcidx (j)
+          && U.xridx (U.xcidx (j+1)-1) == j)
         d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
@@ -841,30 +841,30 @@ EigsRealSymmetricMatrix (const M& m, con
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 ||
-                  bidx >= n || D_NINT (bidx) != bidx)
+              if (checked(bidx) || bidx < 0 || bidx >= n
+                  || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
-  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
-      typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-      typ != "SI")
+  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
+      && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
+      && typ != "SI")
     {
       (*current_liboctave_error_handler)
         ("eigs: unrecognized sigma value");
       return -1;
     }
 
   if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
     {
@@ -1164,18 +1164,18 @@ EigsRealSymmetricMatrixShift (const M& m
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 ||
-                  bidx >= n || D_NINT (bidx) != bidx)
+              if (checked(bidx) || bidx < 0 || bidx >= n
+                  || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
@@ -1460,19 +1460,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (! have_sigma)
     {
-      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
-          typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-          typ != "SI")
+      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
+          && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
+          && typ != "SI")
         (*current_liboctave_error_handler)
           ("eigs: unrecognized sigma value");
 
       if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
         {
           (*current_liboctave_error_handler)
             ("eigs: invalid sigma value for real symmetric problem");
           return -1;
@@ -1755,30 +1755,30 @@ EigsRealNonSymmetricMatrix (const M& m, 
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 ||
-                  bidx >= n || D_NINT (bidx) != bidx)
+              if (checked(bidx) || bidx < 0 || bidx >= n
+                  || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
-  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
-      typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-      typ != "SI")
+  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
+      && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
+      && typ != "SI")
     {
       (*current_liboctave_error_handler)
         ("eigs: unrecognized sigma value");
       return -1;
     }
 
   if (typ == "LA" || typ == "SA" || typ == "BE")
     {
@@ -2127,18 +2127,18 @@ EigsRealNonSymmetricMatrixShift (const M
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 ||
-                  bidx >= n || D_NINT (bidx) != bidx)
+              if (checked(bidx) || bidx < 0 || bidx >= n
+                  || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
@@ -2478,19 +2478,19 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
 
   if (! have_sigma)
     {
-      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
-          typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-          typ != "SI")
+      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
+          && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
+          && typ != "SI")
         (*current_liboctave_error_handler)
           ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
         {
           (*current_liboctave_error_handler)
             ("eigs: invalid sigma value for unsymmetric problem");
           return -1;
@@ -2823,30 +2823,30 @@ EigsComplexNonSymmetricMatrix (const M& 
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 ||
-                  bidx >= n || D_NINT (bidx) != bidx)
+              if (checked(bidx) || bidx < 0 || bidx >= n
+                  || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
-  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
-      typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-      typ != "SI")
+  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
+      && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
+      && typ != "SI")
     {
       (*current_liboctave_error_handler)
         ("eigs: unrecognized sigma value");
       return -1;
     }
 
   if (typ == "LA" || typ == "SA" || typ == "BE")
     {
@@ -3147,18 +3147,18 @@ EigsComplexNonSymmetricMatrixShift (cons
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 ||
-                  bidx >= n || D_NINT (bidx) != bidx)
+              if (checked(bidx) || bidx < 0 || bidx >= n
+                  || D_NINT (bidx) != bidx)
                 {
                   (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
@@ -3451,19 +3451,19 @@ EigsComplexNonSymmetricFunc (EigsComplex
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (! have_sigma)
     {
-      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
-          typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
-          typ != "SI")
+      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
+          && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
+          && typ != "SI")
         (*current_liboctave_error_handler)
           ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
         {
           (*current_liboctave_error_handler)
             ("eigs: invalid sigma value for complex problem");
           return -1;
diff --git a/liboctave/system/lo-sysdep.cc b/liboctave/system/lo-sysdep.cc
--- a/liboctave/system/lo-sysdep.cc
+++ b/liboctave/system/lo-sysdep.cc
@@ -94,26 +94,28 @@ octave_popen2 (const std::string& cmd, c
   HANDLE hProcess = GetCurrentProcess ();
   HANDLE childRead, childWrite, parentRead, parentWrite;
   DWORD pipeMode;
 
   ZeroMemory (&pi, sizeof (pi));
   ZeroMemory (&si, sizeof (si));
   si.cb = sizeof (si);
 
-  if (! CreatePipe (&childRead, &parentWrite, 0, 0) ||
-      ! DuplicateHandle (hProcess, childRead, hProcess, &childRead, 0, TRUE,
-                         DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
+  if (! CreatePipe (&childRead, &parentWrite, 0, 0)
+      || ! DuplicateHandle (hProcess, childRead, hProcess, &childRead,
+                            0, TRUE,
+                            DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
     {
       msg = "popen2: pipe creation failed";
       return -1;
     }
-  if (! CreatePipe (&parentRead, &childWrite, 0, 0) ||
-      ! DuplicateHandle (hProcess, childWrite, hProcess, &childWrite, 0, TRUE,
-                         DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
+  if (! CreatePipe (&parentRead, &childWrite, 0, 0)
+      || ! DuplicateHandle (hProcess, childWrite, hProcess, &childWrite,
+                            0, TRUE,
+                            DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
     {
       msg = "popen2: pipe creation failed";
       return -1;
     }
   if (! sync_mode)
     {
       pipeMode = PIPE_NOWAIT;
       SetNamedPipeHandleState (parentRead, &pipeMode, 0, 0);
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -1653,20 +1653,20 @@ brace_gobbler (const std::string& text, 
           continue;
         }
 
       if (c == satisfy && !level && !quoted)
         {
           /* We ignore an open brace surrounded by whitespace, and also
              an open brace followed immediately by a close brace, that
              was preceded with whitespace.  */
-          if (c == '{' &&
-              ((i == 0 || brace_whitespace (text[i-1])) &&
-               (i+1 < text_len &&
-                (brace_whitespace (text[i+1]) || text[i+1] == '}'))))
+          if (c == '{'
+              && ((i == 0 || brace_whitespace (text[i-1]))
+                  && (i+1 < text_len
+                      && (brace_whitespace (text[i+1]) || text[i+1] == '}'))))
             continue;
           /* If this is being compiled as part of bash, ignore the '{'
              in a '${ }' construct */
           if ((c != '{') || i == 0 || (text[i-1] != '$'))
             break;
         }
 
       if (c == '{')
