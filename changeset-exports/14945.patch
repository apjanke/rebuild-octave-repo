# HG changeset patch
# User Max Brister <max@2bass.com>
# Date 1339212717 18000
#      Fri Jun 08 22:31:57 2012 -0500
# Node ID 591aeec5c5200c20c260ea340afedb3815f61aef
# Parent  c0a5ab3b92786fe64f50944874c991ef84caa6c5
Remove uneeded error checks

diff --git a/src/pt-jit.cc b/src/pt-jit.cc
--- a/src/pt-jit.cc
+++ b/src/pt-jit.cc
@@ -351,49 +351,49 @@ jit_typeinfo::jit_typeinfo (llvm::Module
       llvm::APInt op_int(sizeof (octave_value::binary_op), op,
                          std::numeric_limits<octave_value::binary_op>::is_signed);
       llvm::Value *op_as_llvm = llvm::ConstantInt::get (binary_op_type, op_int);
       llvm::Value *ret = builder.CreateCall3 (any_binary,
                                                  op_as_llvm,
                                                  fn->arg_begin (),
                                                  ++fn->arg_begin ());
       builder.CreateRet (ret);
-      binary_ops[op].add_overload (fn, true, true, any, any, any);
+      binary_ops[op].add_overload (fn, true, any, any, any);
     }
 
   llvm::Type *void_t = llvm::Type::getVoidTy (context);
 
   // grab any
   fn = create_function ("octave_jit_grab_any", any, any);
                         
   engine->addGlobalMapping (fn, reinterpret_cast<void*>(&octave_jit_grab_any));
-  grab_fn.add_overload (fn, false, false, any, any);
+  grab_fn.add_overload (fn, false, any, any);
   grab_fn.stash_name ("grab");
 
   // grab scalar
   fn = create_identity (scalar);
-  grab_fn.add_overload (fn, false, false, scalar, scalar);
+  grab_fn.add_overload (fn, false, scalar, scalar);
 
   // grab index
   fn = create_identity (index);
-  grab_fn.add_overload (fn, false, false, index, index);
+  grab_fn.add_overload (fn, false, index, index);
 
   // release any
   fn = create_function ("octave_jit_release_any", void_t, any->to_llvm ());
   engine->addGlobalMapping (fn, reinterpret_cast<void*>(&octave_jit_release_any));
-  release_fn.add_overload (fn, false, false, 0, any);
+  release_fn.add_overload (fn, false, 0, any);
   release_fn.stash_name ("release");
 
   // release scalar
   fn = create_identity (scalar);
-  release_fn.add_overload (fn, false, false, 0, scalar);
+  release_fn.add_overload (fn, false, 0, scalar);
 
   // release index
   fn = create_identity (index);
-  release_fn.add_overload (fn, false, false, 0, index);
+  release_fn.add_overload (fn, false, 0, index);
 
   // now for binary scalar operations
   // FIXME: Finish all operations
   add_binary_op (scalar, octave_value::op_add, llvm::Instruction::FAdd);
   add_binary_op (scalar, octave_value::op_sub, llvm::Instruction::FSub);
   add_binary_op (scalar, octave_value::op_mul, llvm::Instruction::FMul);
   add_binary_op (scalar, octave_value::op_el_mul, llvm::Instruction::FMul);
 
@@ -423,33 +423,33 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     builder.SetInsertPoint (warn_block);
     builder.CreateCall (gripe_div0);
     builder.CreateBr (normal_block);
 
     builder.SetInsertPoint (normal_block);
     llvm::Value *ret = builder.CreateFDiv (fn->arg_begin (), ++fn->arg_begin ());
     builder.CreateRet (ret);
 
-    jit_function::overload ol (fn, true, true, scalar, scalar, scalar);
+    jit_function::overload ol (fn, true, scalar, scalar, scalar);
     binary_ops[octave_value::op_div].add_overload (ol);
     binary_ops[octave_value::op_el_div].add_overload (ol);
   }
   llvm::verifyFunction (*fn);
 
   // ldiv is the same as div with the operators reversed
   llvm::Function *div = fn;
   fn = create_function ("octave_jit_ldiv_scalar_scalar", scalar, scalar, scalar);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
     llvm::Value *ret = builder.CreateCall2 (div, ++fn->arg_begin (),
                                             fn->arg_begin ());
     builder.CreateRet (ret);
 
-    jit_function::overload ol (fn, true, true, scalar, scalar, scalar);
+    jit_function::overload ol (fn, true, scalar, scalar, scalar);
     binary_ops[octave_value::op_ldiv].add_overload (ol);
     binary_ops[octave_value::op_el_ldiv].add_overload (ol);
   }
   llvm::verifyFunction (*fn);
 
   // now for binary index operators
   add_binary_op (index, octave_value::op_add, llvm::Instruction::Add);
 
@@ -464,33 +464,33 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   fn = create_function ("octave_jit_for_range_init", index, range);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
     llvm::Value *zero = llvm::ConstantInt::get (index_t, 0);
     builder.CreateRet (zero);
   }
   llvm::verifyFunction (*fn);
-  for_init_fn.add_overload (fn, false, false, index, range);
+  for_init_fn.add_overload (fn, false, index, range);
 
   // bounds check for for loop
   for_check_fn.stash_name ("for_check");
 
   fn = create_function ("octave_jit_for_range_check", boolean, range, index);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
     llvm::Value *nelem
       = builder.CreateExtractValue (fn->arg_begin (), 3);
     llvm::Value *idx = ++fn->arg_begin ();
     llvm::Value *ret = builder.CreateICmpULT (idx, nelem);
     builder.CreateRet (ret);
   }
   llvm::verifyFunction (*fn);
-  for_check_fn.add_overload (fn, false, false, boolean, range, index);
+  for_check_fn.add_overload (fn, false, boolean, range, index);
 
   // index variabe for for loop
   for_index_fn.stash_name ("for_index");
 
   fn = create_function ("octave_jit_for_range_idx", scalar, range, index);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
@@ -500,17 +500,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     llvm::Value *base = builder.CreateExtractValue (rng, 0);
     llvm::Value *inc = builder.CreateExtractValue (rng, 2);
 
     llvm::Value *ret = builder.CreateFMul (didx, inc);
     ret = builder.CreateFAdd (base, ret);
     builder.CreateRet (ret);
   }
   llvm::verifyFunction (*fn);
-  for_index_fn.add_overload (fn, false, false, scalar, range, index);
+  for_index_fn.add_overload (fn, false, scalar, range, index);
 
   // logically true
   logically_true_fn.stash_name ("logically_true");
 
   llvm::Function *gripe_nantl = create_function ("octave_jit_gripe_nan_to_logical_conversion", void_t);
   engine->addGlobalMapping (gripe_nantl, reinterpret_cast<void *> (&octave_jit_gripe_nan_to_logical_conversion));
                             
 
@@ -529,24 +529,24 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     builder.CreateBr (normal_block);
     builder.SetInsertPoint (normal_block);
 
     llvm::Value *zero = llvm::ConstantFP::get (dbl, 0);
     llvm::Value *ret = builder.CreateFCmpONE (fn->arg_begin (), zero);
     builder.CreateRet (ret);
   }
   llvm::verifyFunction (*fn);
-  logically_true_fn.add_overload (fn, true, false, boolean, scalar);
+  logically_true_fn.add_overload (fn, true, boolean, scalar);
 
   fn = create_function ("octave_logically_true_bool", boolean, boolean);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   builder.CreateRet (fn->arg_begin ());
   llvm::verifyFunction (*fn);
-  logically_true_fn.add_overload (fn, false, false, boolean, boolean);
+  logically_true_fn.add_overload (fn, false, boolean, boolean);
 
   // make_range
   // FIXME: May be benificial to implement all in LLVM
   make_range_fn.stash_name ("make_range");
   llvm::Function *compute_nelem
     = create_function ("octave_jit_compute_nelem", index, scalar, scalar, scalar);
   engine->addGlobalMapping (compute_nelem,
                             reinterpret_cast<void*> (&octave_jit_compute_nelem));
@@ -567,53 +567,53 @@ jit_typeinfo::jit_typeinfo (llvm::Module
                                                   izero, NULL);
     rng = builder.CreateInsertValue (rng, base, 0);
     rng = builder.CreateInsertValue (rng, limit, 1);
     rng = builder.CreateInsertValue (rng, inc, 2);
     rng = builder.CreateInsertValue (rng, nelem, 3);
     builder.CreateRet (rng);
   }
   llvm::verifyFunction (*fn);
-  make_range_fn.add_overload (fn, false, false, range, scalar, scalar, scalar);
+  make_range_fn.add_overload (fn, false, range, scalar, scalar, scalar);
 
   casts[any->type_id ()].stash_name ("(any)");
   casts[scalar->type_id ()].stash_name ("(scalar)");
 
   // cast any <- scalar
   fn = create_function ("octave_jit_cast_any_scalar", any, scalar);
   engine->addGlobalMapping (fn, reinterpret_cast<void*> (&octave_jit_cast_any_scalar));
-  casts[any->type_id ()].add_overload (fn, false, false, any, scalar);
+  casts[any->type_id ()].add_overload (fn, false, any, scalar);
 
   // cast scalar <- any
   fn = create_function ("octave_jit_cast_scalar_any", scalar, any);
   engine->addGlobalMapping (fn, reinterpret_cast<void*> (&octave_jit_cast_scalar_any));
-  casts[scalar->type_id ()].add_overload (fn, false, false, scalar, any);
+  casts[scalar->type_id ()].add_overload (fn, false, scalar, any);
 
   // cast any <- any
   fn = create_identity (any);
-  casts[any->type_id ()].add_overload (fn, false, false, any, any);
+  casts[any->type_id ()].add_overload (fn, false, any, any);
 
   // cast scalar <- scalar
   fn = create_identity (scalar);
-  casts[scalar->type_id ()].add_overload (fn, false, false, scalar, scalar);
+  casts[scalar->type_id ()].add_overload (fn, false, scalar, scalar);
 }
 
 void
 jit_typeinfo::add_print (jit_type *ty, void *call)
 {
   std::stringstream name;
   name << "octave_jit_print_" << ty->name ();
 
   llvm::Type *void_t = llvm::Type::getVoidTy (context);
   llvm::Function *fn = create_function (name.str (), void_t,
                                         llvm::Type::getInt8PtrTy (context),
                                         ty->to_llvm ());
   engine->addGlobalMapping (fn, call);
 
-  jit_function::overload ol (fn, false, true, 0, string, ty);
+  jit_function::overload ol (fn, false, 0, string, ty);
   print_fn.add_overload (ol);
 }
 
 // FIXME: cp between add_binary_op, add_binary_icmp, and add_binary_fcmp
 void
 jit_typeinfo::add_binary_op (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
@@ -626,17 +626,17 @@ jit_typeinfo::add_binary_op (jit_type *t
   builder.SetInsertPoint (block);
   llvm::Instruction::BinaryOps temp
     = static_cast<llvm::Instruction::BinaryOps>(llvm_op);
   llvm::Value *ret = builder.CreateBinOp (temp, fn->arg_begin (),
                                           ++fn->arg_begin ());
   builder.CreateRet (ret);
   llvm::verifyFunction (*fn);
 
-  jit_function::overload ol(fn, false, false, ty, ty, ty);
+  jit_function::overload ol(fn, false, ty, ty, ty);
   binary_ops[op].add_overload (ol);
 }
 
 void
 jit_typeinfo::add_binary_icmp (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
@@ -648,17 +648,17 @@ jit_typeinfo::add_binary_icmp (jit_type 
   builder.SetInsertPoint (block);
   llvm::CmpInst::Predicate temp
     = static_cast<llvm::CmpInst::Predicate>(llvm_op);
   llvm::Value *ret = builder.CreateICmp (temp, fn->arg_begin (),
                                          ++fn->arg_begin ());
   builder.CreateRet (ret);
   llvm::verifyFunction (*fn);
 
-  jit_function::overload ol (fn, false, false, boolean, ty, ty);
+  jit_function::overload ol (fn, false, boolean, ty, ty);
   binary_ops[op].add_overload (ol);
 }
 
 void
 jit_typeinfo::add_binary_fcmp (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
@@ -670,17 +670,17 @@ jit_typeinfo::add_binary_fcmp (jit_type 
   builder.SetInsertPoint (block);
   llvm::CmpInst::Predicate temp
     = static_cast<llvm::CmpInst::Predicate>(llvm_op);
   llvm::Value *ret = builder.CreateFCmp (temp, fn->arg_begin (),
                                          ++fn->arg_begin ());
   builder.CreateRet (ret);
   llvm::verifyFunction (*fn);
 
-  jit_function::overload ol (fn, false, false, boolean, ty, ty);
+  jit_function::overload ol (fn, false, boolean, ty, ty);
   binary_ops[op].add_overload (ol);
 }
 
 llvm::Function *
 jit_typeinfo::create_function (const llvm::Twine& name, llvm::Type *ret,
                                const std::vector<llvm::Type *>& args)
 {
   llvm::FunctionType *ft = llvm::FunctionType::get (ret, args, false);
@@ -782,16 +782,17 @@ operator<< (std::ostream& os, const jit_
 }
 
 // -------------------- jit_instruction --------------------
 void
 jit_instruction::remove (void)
 {
   if (mparent)
     mparent->remove (mlocation);
+  resize_arguments (0);
 }
 
 llvm::BasicBlock *
 jit_instruction::parent_llvm (void) const
 {
   return mparent->to_llvm ();
 }
 
@@ -873,22 +874,21 @@ jit_block::prepend_after_phi (jit_instru
           insert_before (iter, instr);
           return instr;
         }
     }
 
   return append (instr);
 }
 
-jit_instruction *
-jit_block::append (jit_instruction *instr)
+void
+jit_block::internal_append (jit_instruction *instr)
 {
   instructions.push_back (instr);
   instr->stash_parent (this, --instructions.end ());
-  return instr;
 }
 
 jit_instruction *
 jit_block::insert_before (iterator loc, jit_instruction *instr)
 {
   iterator iloc = instructions.insert (loc, instr);
   instr->stash_parent (this, iloc);
   return instr;
@@ -912,46 +912,46 @@ jit_block::terminator (void) const
   jit_instruction *last = instructions.back ();
   return dynamic_cast<jit_terminator *> (last);
 }
 
 jit_block *
 jit_block::pred (size_t idx) const
 {
   // FIXME: Make this O(1)
-  
-  // here we get the use in backwards order. This means we preserve phi
-  // information when new blocks are added
   assert (idx < use_count ());
   jit_use *use;
-  size_t real_idx = use_count () - idx - 1;
   size_t i;
-  for (use = first_use (), i = 0; use && i < real_idx; ++i,
-         use = use->next ());
-    
+  for (use = first_use (), i = 0; use && i < idx; ++i, use = use->next ());
   return use->user_parent ();
 }
 
+bool
+jit_block::branch_alive (jit_block *asucc) const
+{
+  return terminator ()->alive (asucc);
+}
+
 size_t
 jit_block::pred_index (jit_block *apred) const
 {
   for (size_t i = 0; i < pred_count (); ++i)
     if (pred (i) == apred)
       return i;
 
   fail ("No such predecessor");
 }
 
 void
-jit_block::create_merge (llvm::Function *inside, size_t pred_idx)
+jit_block::create_merge (llvm::Function *inside, jit_block *apred)
 {
   mpred_llvm.resize (pred_count ());
 
-  jit_block *ipred = pred (pred_idx);
-  if (! mpred_llvm[pred_idx] && ipred->pred_count () > 1)
+  size_t pred_idx = pred_index (apred);
+  if (! mpred_llvm[pred_idx] && apred->pred_count () > 1)
     {
       llvm::BasicBlock *amerge;
       amerge = llvm::BasicBlock::Create (context, "phi_merge", inside,
                                          to_llvm ());
           
       // fix the predecessor jump if it has been created
       jit_terminator *jterm = pred_terminator (pred_idx);
       if (jterm->has_llvm ())
@@ -1117,30 +1117,109 @@ jit_block::idom_intersect (jit_block *b)
 
       while (j->id () > i->id ())
         j = j->idom;
     }
 
   return i;
 }
 
-// -------------------- jit_call --------------------
+// -------------------- jit_phi --------------------
 bool
-jit_call::dead (void) const
+jit_phi::prune (void)
 {
-  return ! has_side_effects () && use_count () == 0;
+  jit_block *p = parent ();
+  size_t new_idx = 0;
+  for (size_t i = 0; i < argument_count (); ++i)
+    {
+      jit_block *inc = incomming (i);
+      if (inc->branch_alive (p))
+        {
+          if (new_idx != i)
+            {
+              stash_argument (new_idx, argument (i));
+              mincomming[new_idx] = mincomming[i];
+            }
+
+          ++new_idx;
+        }
+    }
+
+  if (new_idx != argument_count ())
+    {
+      resize_arguments (new_idx);
+      mincomming.resize (new_idx);
+    }
+
+  assert (argument_count () > 0);
+  if (argument_count () == 1)
+    {
+      replace_with (argument (0));
+      return true;
+    }
+
+  return false;
 }
 
 bool
-jit_call::almost_dead (void) const
+jit_phi::infer (void)
+{
+  jit_block *p = parent ();
+  if (! p->alive ())
+    return false;
+
+  jit_type *infered = 0;
+  for (size_t i = 0; i < argument_count (); ++i)
+    {
+      jit_block *inc = mincomming[i];
+      if (inc->branch_alive (p))
+        infered = jit_typeinfo::join (infered, argument_type (i));
+    }
+  
+  if (infered != type ())
+    {
+      stash_type (infered);
+      return true;
+    }
+
+  return false;
+}
+
+// -------------------- jit_terminator --------------------
+bool
+jit_terminator::alive (const jit_block *asucessor) const
 {
-  return ! has_side_effects () && use_count () <= 1;
+  size_t scount = sucessor_count ();
+  for (size_t i = 0; i < scount; ++i)
+    if (sucessor (i) == asucessor)
+      return malive[i];
+
+  panic_impossible ();
 }
 
 bool
+jit_terminator::infer (void)
+{
+  if (! parent ()->alive ())
+    return false;
+
+  bool changed = false;
+  for (size_t i = 0; i < malive.size (); ++i)
+    if (! malive[i] && check_alive (i))
+      {
+        changed = true;
+        malive[i] = true;
+        sucessor (i)->mark_alive ();
+      }
+
+  return changed;
+}
+
+// -------------------- jit_call --------------------
+bool
 jit_call::infer (void)
 {
   // FIXME: explain algorithm
   for (size_t i = 0; i < argument_count (); ++i)
     {
       already_infered[i] = argument_type (i);
       if (! already_infered[i])
         return false;
@@ -1168,16 +1247,17 @@ jit_call::infer (void)
 jit_convert::jit_convert (llvm::Module *module, tree &tee)
   : iterator_count (0), breaking (false)
 {
   jit_instruction::reset_ids ();
 
   entry_block = create<jit_block> ("body");
   final_block = create<jit_block> ("final");
   blocks.push_back (entry_block);
+  entry_block->mark_alive ();
   block = entry_block;
   visit (tee);
 
   // FIXME: Remove if we no longer only compile loops
   assert (! breaking);
   assert (breaks.empty ());
   assert (continues.empty ());
 
@@ -1202,19 +1282,27 @@ jit_convert::jit_convert (llvm::Module *
 
   // FIXME: Describe algorithm here
   while (worklist.size ())
     {
       jit_instruction *next = worklist.front ();
       worklist.pop_front ();
 
       if (next->infer ())
-        append_users (next);
+        {
+          // terminators need to be handles specially
+          if (jit_terminator *term = dynamic_cast<jit_terminator *> (next))
+            append_users_term (term);
+          else
+            append_users (next);
+        }
     }
 
+  remove_dead ();
+
   place_releases ();
 
 #ifdef OCTAVE_JIT_DEBUG
   std::cout << "-------------------- Compiling tree --------------------\n";
   std::cout << tee.str_print_code () << std::endl;
   print_blocks ("octave jit ir");
 #endif
 
@@ -1265,22 +1353,23 @@ jit_convert::visit_binary_expression (tr
 
   tree_expression *lhs = be.lhs ();
   jit_value *lhsv = visit (lhs);
 
   tree_expression *rhs = be.rhs ();
   jit_value *rhsv = visit (rhs);
 
   const jit_function& fn = jit_typeinfo::binary_op (be.op_type ());
-  result = block->append (create<jit_call> (fn, lhsv, rhsv));
-
-  jit_block *normal = create<jit_block> (block->name () + "a");
-  block->append (create<jit_check_error> (normal, final_block));
+  jit_call *call = block->append (create<jit_call> (fn, lhsv, rhsv));
+
+  jit_block *normal = create<jit_block> (block->name ());
+  block->append (create<jit_check_error> (call, normal, final_block));
   blocks.push_back (normal);
   block = normal;
+  result = call;
 }
 
 void
 jit_convert::visit_break_command (tree_break_command&)
 {
   breaks.push_back (block);
   breaking = true;
 }
@@ -1519,22 +1608,22 @@ jit_convert::visit_if_command_list (tree
 
       if (i) // the first block is prev_block, so it has already been added
         blocks.push_back (entry_blocks[i]);
 
       if (! tic->is_else_clause ())
         {
           tree_expression *expr = tic->condition ();
           jit_value *cond = visit (expr);
-          jit_instruction *check = create<jit_call> (&jit_typeinfo::logically_true, cond);
+          jit_call *check = create<jit_call> (&jit_typeinfo::logically_true, cond);
           block->append (check);
 
-          jit_block *next = create<jit_block> (block->name () + "a");
+          jit_block *next = create<jit_block> (block->name ());
           blocks.push_back (next);
-          block->append (create<jit_check_error> (next, final_block));
+          block->append (create<jit_check_error> (check, next, final_block));
           block = next;
 
           jit_block *body = create<jit_block> (i == 0 ? "if_body" : "ifelse_body");
           blocks.push_back (body);
 
           jit_instruction *br = create<jit_cond_break> (check, body,
                                                         entry_blocks[i + 1]);
           block->append (br);
@@ -1801,16 +1890,34 @@ jit_convert::visit (tree& tee)
   tee.accept (*this);
 
   jit_value *ret = result;
   result = 0;
   return ret;
 }
 
 void
+jit_convert::append_users_term (jit_terminator *term)
+{
+  for (size_t i = 0; i < term->sucessor_count (); ++i)
+    {
+      if (term->alive (i))
+        {
+          jit_block *succ = term->sucessor (i);
+          for (jit_block::iterator iter = succ->begin (); iter != succ->end ()
+                 && isa<jit_phi> (*iter); ++iter)
+            worklist.push_back (*iter);
+
+          if (succ->terminator ())
+            worklist.push_back (succ->terminator ());
+        }
+    }
+}
+
+void
 jit_convert::merge_blocks (void)
 {
   for (block_list::iterator iter = blocks.begin (); iter != blocks.end ();
        ++iter)
     {
       jit_block *b = *iter;
       jit_block *merged = b->maybe_merge ();
 
@@ -1898,40 +2005,83 @@ jit_convert::do_construct_ssa (jit_block
 
       instr->push_variable ();
     }
 
   // finish phi nodes of sucessors
   for (size_t i = 0; i < block.succ_count (); ++i)
     {
       jit_block *finish = block.succ (i);
-      size_t pred_idx = finish->pred_index (&block);
 
       for (jit_block::iterator iter = finish->begin (); iter != finish->end ()
              && isa<jit_phi> (*iter);)
         {
           jit_phi *phi = dynamic_cast<jit_phi *> (*iter);
           jit_variable *var = phi->dest ();
           if (var->has_top ())
             {
-              phi->stash_argument (pred_idx, var->top ());
+              phi->add_incomming (&block, var->top ());
               ++iter;
             }
           else
             {
               // temporaries may have extranious phi nodes which can be removed
               assert (! phi->use_count ());
               assert (var->name ().size () && var->name ()[0] == '#');
               iter = finish->remove (iter);
             }
         }
     }
 }
 
 void
+jit_convert::remove_dead ()
+{
+  block_list::iterator biter;
+  for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+    {
+      jit_block *b = *biter;
+      if (b->alive ())
+        {
+          for (jit_block::iterator iter = b->begin (); iter != b->end ()
+                 && isa<jit_phi> (*iter);)
+            {
+              jit_phi *phi = static_cast<jit_phi *> (*iter);
+              if (phi->prune ())
+                iter = b->remove (iter);
+              else
+                ++iter;
+            }
+        }
+    }
+
+  for (biter = blocks.begin (); biter != blocks.end ();)
+    {
+      jit_block *b = *biter;
+      if (b->alive ())
+        {
+          // FIXME: A special case for jit_check_error, if we generalize to
+          // we will need to change!
+          jit_terminator *term = b->terminator ();
+          if (term && term->sucessor_count () == 2 && ! term->alive (1))
+            {
+              jit_block *succ = term->sucessor (0);
+              term->remove ();
+              jit_break *abreak = b->append (create<jit_break> (succ));
+              abreak->infer ();
+            }
+
+          ++biter;
+        }
+      else
+        biter = blocks.erase (biter);
+    }
+}
+
+void
 jit_convert::place_releases (void)
 {
   release_placer placer (*this);
   entry_block->visit_dom (placer, &jit_block::pop_all);
 }
 
 void
 jit_convert::finish_breaks (jit_block *dest, const block_list& lst)
@@ -2051,19 +2201,19 @@ jit_convert::convert_llvm::convert (llvm
       function->eraseFromParent ();
       throw;
     }
 
   return function;
 }
 
 void
-jit_convert::convert_llvm::finish_phi (jit_instruction *phi)
+jit_convert::convert_llvm::finish_phi (jit_instruction *aphi)
 {
-  jit_block *pblock = phi->parent ();
+  jit_phi *phi = static_cast<jit_phi *> (aphi);
   llvm::PHINode *llvm_phi = llvm::cast<llvm::PHINode> (phi->to_llvm ());
 
   bool can_remove = ! phi->use_count ();
   if (! can_remove && llvm_phi->hasOneUse () && phi->use_count () == 1)
     {
       jit_instruction *user = phi->first_use ()->user ();
       can_remove = isa<jit_call> (user); // must be a remove
     }
@@ -2081,17 +2231,17 @@ jit_convert::convert_llvm::finish_phi (j
       llvm_phi->eraseFromParent ();
       phi->stash_llvm (0);
 
       for (size_t i = 0; i < phi->argument_count (); ++i)
         {
           jit_value *arg = phi->argument (i);
           if (arg->has_llvm () && phi->argument_type (i) != phi->type ())
             {
-              llvm::BasicBlock *pred = pblock->pred_llvm (i);
+              llvm::BasicBlock *pred = phi->incomming_llvm (i);
               builder.SetInsertPoint (--pred->end ());
               const jit_function::overload& ol
                 = jit_typeinfo::get_release (phi->argument_type (i));
               if (! ol.function)
                 {
                   std::stringstream ss;
                   ss << "No release for phi(" << i << "): ";
                   phi->print (ss);
@@ -2101,17 +2251,17 @@ jit_convert::convert_llvm::finish_phi (j
               builder.CreateCall (ol.function, phi->argument_llvm (i));
             }
         }
     }
   else
     {
       for (size_t i = 0; i < phi->argument_count (); ++i)
         {
-          llvm::BasicBlock *pred = pblock->pred_llvm (i);
+          llvm::BasicBlock *pred = phi->incomming_llvm (i);
           if (phi->argument_type (i) == phi->type ())
             llvm_phi->addIncoming (phi->argument_llvm (i), pred);
           else
             {
               // add cast right before pred terminator
               builder.SetInsertPoint (--pred->end ());
 
               const jit_function::overload& ol
@@ -2244,17 +2394,17 @@ jit_convert::convert_llvm::visit (jit_ph
   llvm::PHINode *node = llvm::PHINode::Create (phi.type_llvm (),
                                                phi.argument_count ());
   builder.Insert (node);
   phi.stash_llvm (node);
 
   jit_block *parent = phi.parent ();
   for (size_t i = 0; i < phi.argument_count (); ++i)
     if (phi.argument_type (i) != phi.type ())
-      parent->create_merge (function, i);
+      parent->create_merge (function, phi.incomming (i));
 }
 
 void
 jit_convert::convert_llvm::visit (jit_variable&)
 {
   fail ("ERROR: SSA construction should remove all variables");
 }
 
diff --git a/src/pt-jit.h b/src/pt-jit.h
--- a/src/pt-jit.h
+++ b/src/pt-jit.h
@@ -167,71 +167,69 @@ std::ostream& jit_print (std::ostream& o
 // and code generation.
 class
 jit_function
 {
 public:
   struct
   overload
   {
-    overload (void) : function (0), can_error (true), result (0) {}
+    overload (void) : function (0), can_error (false), result (0) {}
 
-    overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0) :
-      function (f), can_error (e), side_effects (s), result (r), arguments (1)
+    overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0) :
+      function (f), can_error (e), result (r), arguments (1)
     {
       arguments[0] = arg0;
     }
 
-    overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0,
-              jit_type *arg1) : function (f), can_error (e), side_effects (s),
+    overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0,
+              jit_type *arg1) : function (f), can_error (e),
                                 result (r), arguments (2)
     {
       arguments[0] = arg0;
       arguments[1] = arg1;
     }
 
-    overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0,
+    overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0,
               jit_type *arg1, jit_type *arg2) : function (f), can_error (e),
-                                                side_effects (s), result (r),
-                                                arguments (3)
+                                                result (r), arguments (3)
     {
       arguments[0] = arg0;
       arguments[1] = arg1;
       arguments[2] = arg2;
     }
 
     llvm::Function *function;
     bool can_error;
-    bool side_effects;
     jit_type *result;
     std::vector<jit_type*> arguments;
   };
 
   void add_overload (const overload& func)
   {
     add_overload (func, func.arguments);
   }
 
-  void add_overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0)
+  void add_overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0)
   {
-    overload ol (f, e, s, r, arg0);
+    overload ol (f, e, r, arg0);
     add_overload (ol);
   }
 
-  void add_overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0,
+  void add_overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0,
                      jit_type *arg1)
   {
-    overload ol (f, e, s, r, arg0, arg1);
+    overload ol (f, e, r, arg0, arg1);
     add_overload (ol);
   }
 
-  void add_overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0,
+  void add_overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0,
                      jit_type *arg1, jit_type *arg2)
   {
-    overload ol (f, e, s, r, arg0, arg1, arg2);
+    overload ol (f, e, r, arg0, arg1, arg2);
     add_overload (ol);
   }
 
   void add_overload (const overload& func,
                      const std::vector<jit_type*>& args);
 
   const overload& get_overload (const std::vector<jit_type *>& types) const;
 
@@ -593,18 +591,18 @@ jit_const_range;
 class jit_ir_walker;
 class jit_use;
 
 class
 jit_value
 {
   friend class jit_use;
 public:
-  jit_value (void) : llvm_value (0), ty (0), use_head (0), myuse_count (0),
-                     mlast_use (0) {}
+  jit_value (void) : llvm_value (0), ty (0), use_head (0), use_tail (0),
+                     myuse_count (0), mlast_use (0) {}
 
   virtual ~jit_value (void);
 
   // replace all uses with
   void replace_with (jit_value *value);
 
   jit_type *type (void) const { return ty; }
 
@@ -657,27 +655,28 @@ public:
   }
 
   void stash_llvm (llvm::Value *compiled)
   {
     llvm_value = compiled;
   }
 
 protected:
-  std::ostream& print_indent (std::ostream& os, size_t indent) const
+  std::ostream& print_indent (std::ostream& os, size_t indent = 0) const
   {
     for (size_t i = 0; i < indent * 8; ++i)
       os << " ";
     return os;
   }
 
   llvm::Value *llvm_value;
 private:
   jit_type *ty;
   jit_use *use_head;
+  jit_use *use_tail;
   size_t myuse_count;
   jit_instruction *mlast_use;
 };
 
 std::ostream& operator<< (std::ostream& os, const jit_value& value);
 
 class
 jit_use
@@ -716,21 +715,23 @@ public:
     remove ();
 
     mvalue = avalue;
 
     if (mvalue)
       {
         if (mvalue->use_head)
           {
-            mvalue->use_head->mprev = this;
-            mnext = mvalue->use_head;
+            mvalue->use_tail->mnext = this;
+            mprev = mvalue->use_tail;
           }
+        else
+          mvalue->use_head = this;
         
-        mvalue->use_head = this;
+        mvalue->use_tail = this;
         ++mvalue->myuse_count;
       }
 
     mindex = aindex;
     muser = auser;
   }
 
   jit_use *next (void) const { return mnext; }
@@ -739,16 +740,19 @@ public:
 private:
   void remove (void)
   {
     if (mvalue)
       {
         if (this == mvalue->use_head)
             mvalue->use_head = mnext;
 
+        if (this == mvalue->use_tail)
+          mvalue->use_tail = mprev;
+
         if (mprev)
           mprev->mnext = mnext;
 
         if (mnext)
           mnext->mprev = mprev;
 
         mnext = mprev = 0;
         --mvalue->myuse_count;
@@ -869,20 +873,16 @@ public:
       for (size_t i = old; i < acount; ++i)
         stash_argument (i, adefault);
   }
 
   // argument types which have been infered already
   const std::vector<jit_type *>& argument_types (void) const
   { return already_infered; }
 
-  virtual bool dead (void) const { return false; }
-
-  virtual bool almost_dead (void) const { return false; }
-
   virtual void push_variable (void) {}
 
   virtual void pop_variable (void) {}
 
   virtual bool infer (void) { return false; }
 
   void remove (void);
 
@@ -938,17 +938,17 @@ public:
 
   jit_const (PASS_T avalue) : mvalue (avalue)
   {
     stash_type (EXTRACT_T ());
   }
 
   PASS_T value (void) const { return mvalue; }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent);
     jit_print (os, type ()) << ": ";
     if (QUOTE)
       os << "\"";
     os << mvalue;
     if (QUOTE)
       os << "\"";
@@ -967,36 +967,48 @@ public:
   typedef std::list<jit_instruction *> instruction_list;
   typedef instruction_list::iterator iterator;
   typedef instruction_list::const_iterator const_iterator;
 
   typedef std::set<jit_block *> df_set;
   typedef df_set::const_iterator df_iterator;
 
   jit_block (const std::string& aname) : mvisit_count (0), mid (NO_ID), idom (0),
-                                         mname (aname), mdead (false)
+                                         mname (aname), mdead (false),
+                                         malive (false)
   {}
 
-  virtual bool dead (void) const { return mdead; }
+  // if a block is alive, then it might be visited during execution
+  bool alive (void) const { return malive; }
+
+  void mark_alive (void) { malive = true; }
+
+  // dead blocks have already been removed from the CFG
+  bool dead (void) const { return mdead; }
 
   void mark_dead (void) { mdead = true; }
 
   // If we can merge with a sucessor, do so and return the now empty block
   jit_block *maybe_merge ();
 
   // merge another block into this block, leaving the merge block empty
   void merge (jit_block& merge);
 
   const std::string& name (void) const { return mname; }
 
   jit_instruction *prepend (jit_instruction *instr);
 
   jit_instruction *prepend_after_phi (jit_instruction *instr);
 
-  jit_instruction *append (jit_instruction *instr);
+  template <typename T>
+  T *append (T *instr)
+  {
+    internal_append (instr);
+    return instr;
+  }
 
   jit_instruction *insert_before (iterator loc, jit_instruction *instr);
 
   jit_instruction *insert_after (iterator loc, jit_instruction *instr);
 
   iterator remove (iterator iter)
   {
     jit_instruction *instr = *iter;
@@ -1009,16 +1021,19 @@ public:
 
   jit_block *pred (size_t idx) const;
 
   jit_terminator *pred_terminator (size_t idx) const
   {
     return pred (idx)->terminator ();
   }
 
+  // is the jump from pred alive?
+  bool branch_alive (jit_block *asucc) const;
+
   std::ostream& print_pred (std::ostream& os, size_t idx) const
   {
     return pred (idx)->short_print (os);
   }
 
   // takes into account for the addition of phi merges
   llvm::BasicBlock *pred_llvm (size_t idx) const
   {
@@ -1031,17 +1046,17 @@ public:
   llvm::BasicBlock *pred_llvm (jit_block *apred) const
   {
     return pred_llvm (pred_index (apred));
   }
 
   size_t pred_index (jit_block *apred) const;
 
   // create llvm phi merge blocks for all predecessors (if required)
-  void create_merge (llvm::Function *inside, size_t pred_idx);
+  void create_merge (llvm::Function *inside, jit_block *apred);
 
   size_t pred_count (void) const { return use_count (); }
 
   jit_block *succ (size_t i) const;
 
   size_t succ_count (void) const;
 
   iterator begin (void) { return instructions.begin (); }
@@ -1117,17 +1132,17 @@ public:
   void visit_dom (func_type0 inorder, func_type1 postorder)
   {
     do_visit_dom (mvisit_count, inorder, postorder);
   }
 
   // call pop_varaible on all instructions
   void pop_all (void);
 
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent);
     short_print (os) << ":        %pred = ";
     for (size_t i = 0; i < pred_count (); ++i)
       {
         print_pred (os, i);
         if (i + 1 < pred_count ())
           os << ", ";
@@ -1152,16 +1167,18 @@ public:
       os << mid;
     return os;
   }
 
   llvm::BasicBlock *to_llvm (void) const;
 
   JIT_VALUE_ACCEPT (block)
 private:
+  void internal_append (jit_instruction *instr);
+
   void compute_df (size_t visit_count);
 
   bool update_idom (size_t visit_count);
 
   void create_dom_tree (size_t visit_count);
 
   jit_block *idom_intersect (jit_block *b);
 
@@ -1173,16 +1190,17 @@ private:
   size_t mid;
   jit_block *idom;
   df_set mdf;
   std::vector<jit_block *> dom_succ;
   std::string mname;
   instruction_list instructions;
   mutable std::vector<llvm::BasicBlock *> mpred_llvm;
   bool mdead;
+  bool malive;
 };
 
 // allow regular function pointers as well as pointers to members
 template <typename func_type>
 class jit_block_callback
 {
 public:
   jit_block_callback (func_type afunction) : function (afunction) {}
@@ -1278,17 +1296,17 @@ public:
     jit_use *use = first_use ();
     while (use)
       {
         result.insert (use->user_parent ());
         use = use->next ();
       }
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     return print_indent (os, indent) << mname;
   }
 
   JIT_VALUE_ACCEPT (variable)
 private:
   std::string mname;
   std::stack<jit_value *> value_stack;
@@ -1349,44 +1367,44 @@ private:
   jit_variable *mdest;
 };
 
 class
 jit_phi : public jit_assign_base
 {
 public:
   jit_phi (jit_variable *adest, size_t npred) : jit_assign_base (adest, npred)
-  {}
-
-  virtual bool dead (void) const
   {
-    return use_count () == 0;
+    mincomming.reserve (npred);
   }
 
-  virtual bool almost_dead (void) const
+  // removes arguments form dead incomming jumps
+  bool prune (void);
+
+  void add_incomming (jit_block *from, jit_value *value)
   {
-    return use_count () <= 1;
+    stash_argument (mincomming.size (), value);
+    mincomming.push_back (from);
   }
 
-  virtual bool infer (void)
+  jit_block *incomming (size_t i) const
   {
-    jit_type *infered = 0;
-    for (size_t i = 0; i < argument_count (); ++i)
-      infered = jit_typeinfo::join (infered, argument_type (i));
-
-    if (infered != type ())
-      {
-        stash_type (infered);
-        return true;
-      }
-
-    return false;
+    return mincomming[i];
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  llvm::BasicBlock *incomming_llvm (size_t i) const
+  {
+    jit_block *inc = incomming (i);
+    jit_block *p = parent ();
+    return p->pred_llvm (inc);
+  }
+
+  virtual bool infer (void);
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     std::stringstream ss;
     print_indent (ss, indent);
     short_print (ss) << " phi ";
     std::string ss_str = ss.str ();
     std::string indent_str (ss_str.size (), ' ');
     os << ss_str;
 
@@ -1412,118 +1430,129 @@ public:
     if (type ())
       jit_print (os, type ()) << ": ";
 
     dest ()->short_print (os);
     return os << "#" << id ();
   }
 
   JIT_VALUE_ACCEPT (phi);
+private:
+  std::vector<jit_block *> mincomming;
 };
 
 class
 jit_terminator : public jit_instruction
 {
 public:
-  jit_terminator (jit_value *arg0) : jit_instruction (arg0) {}
+  jit_terminator (size_t asucessor_count, jit_value *arg0)
+    : jit_instruction (arg0), malive (asucessor_count, false) {}
 
-  jit_terminator (jit_value *arg0, jit_value *arg1)
-    : jit_instruction (arg0, arg1) {}
+  jit_terminator (size_t asucessor_count, jit_value *arg0, jit_value *arg1)
+    : jit_instruction (arg0, arg1), malive (asucessor_count, false) {}
 
-  jit_terminator (jit_value *arg0, jit_value *arg1, jit_value *arg2)
-    : jit_instruction (arg0, arg1, arg2) {}
+  jit_terminator (size_t asucessor_count, jit_value *arg0, jit_value *arg1,
+                  jit_value *arg2)
+    : jit_instruction (arg0, arg1, arg2), malive (asucessor_count, false) {}
 
-  virtual jit_block *sucessor (size_t idx = 0) const = 0;
+  jit_block *sucessor (size_t idx = 0) const
+  {
+    return static_cast<jit_block *> (argument (idx));
+  }
 
   // return either our sucessors block directly, or the phi merge block
   // between us and our sucessor
   llvm::BasicBlock *sucessor_llvm (size_t idx = 0) const
   {
     jit_block *succ = sucessor (idx);
     llvm::BasicBlock *pllvm = parent_llvm ();
     llvm::BasicBlock *spred_llvm = succ->pred_llvm (parent ());
     llvm::BasicBlock *succ_llvm = succ->to_llvm ();
     return pllvm == spred_llvm ? succ_llvm : spred_llvm;
   }
 
   std::ostream& print_sucessor (std::ostream& os, size_t idx = 0) const
   {
+    if (alive (idx))
+      os << "[live] ";
+    else
+      os << "[dead] ";
+
     return sucessor (idx)->short_print (os);
   }
 
-  virtual size_t sucessor_count (void) const = 0;
+  // Check if the jump to sucessor is live
+  bool alive (const jit_block *asucessor) const;
+  bool alive (size_t idx) const { return malive[idx]; }
+
+  size_t sucessor_count (void) const { return malive.size (); }
+
+  virtual bool infer (void);
+protected:
+  virtual bool check_alive (size_t) const { return true; }
+private:
+  std::vector<bool> malive;
 };
 
 class
 jit_break : public jit_terminator
 {
 public:
-  jit_break (jit_block *succ) : jit_terminator (succ) {}
+  jit_break (jit_block *succ) : jit_terminator (1, succ) {}
 
-  jit_block *sucessor (size_t idx = 0) const
-  {
-    jit_value *arg = argument (idx);
-    return static_cast<jit_block *> (arg);
-  }
+  virtual size_t sucessor_count (void) const { return 1; }
 
-  size_t sucessor_count (void) const { return 1; }
-
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "break: ";
     return print_sucessor (os);
   }
 
   JIT_VALUE_ACCEPT (break)
 };
 
 class
 jit_cond_break : public jit_terminator
 {
 public:
   jit_cond_break (jit_value *c, jit_block *ctrue, jit_block *cfalse)
-    : jit_terminator (c, ctrue, cfalse) {}
+    : jit_terminator (2, ctrue, cfalse, c) {}
 
-  jit_value *cond (void) const { return argument (0); }
+  jit_value *cond (void) const { return argument (2); }
 
   std::ostream& print_cond (std::ostream& os) const
   {
     return cond ()->short_print (os);
   }
 
   llvm::Value *cond_llvm (void) const
   {
     return cond ()->to_llvm ();
   }
 
-  jit_block *sucessor (size_t idx) const
-  {
-    jit_value *arg = argument (idx + 1);
-    return static_cast<jit_block *> (arg);
-  }
+  virtual size_t sucessor_count (void) const { return 2; }
 
-  size_t sucessor_count (void) const { return 2; }
-
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "cond_break: ";
     print_cond (os) << ", ";
     print_sucessor (os, 0) << ", ";
     return print_sucessor (os, 1);
   }
 
   JIT_VALUE_ACCEPT (cond_break)
 };
 
 class
 jit_call : public jit_instruction
 {
 public:
   jit_call (const jit_function& afunction,
-            jit_value *arg0) : jit_instruction (arg0), mfunction (afunction) {}
+            jit_value *arg0) : jit_instruction (arg0), mfunction (afunction)
+  {}
 
   jit_call (const jit_function& (*afunction) (void),
             jit_value *arg0) : jit_instruction (arg0), mfunction (afunction ()) {}
 
   jit_call (const jit_function& afunction,
             jit_value *arg0, jit_value *arg1) : jit_instruction (arg0, arg1),
                                                 mfunction (afunction) {}
 
@@ -1537,79 +1566,78 @@ public:
 
   jit_call (const jit_function& (*afunction) (void),
             jit_value *arg0, jit_value *arg1, jit_value *arg2, jit_value *arg3)
     : jit_instruction (arg0, arg1, arg2, arg3), mfunction (afunction ()) {}
                                                 
 
   const jit_function& function (void) const { return mfunction; }
 
-  bool has_side_effects (void) const
+  bool can_error (void) const
   {
-    return overload ().side_effects;
+    return overload ().can_error;
   }
 
   const jit_function::overload& overload (void) const
   {
     return mfunction.get_overload (argument_types ());
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent);
 
     if (use_count ())
       short_print (os) << " = ";
     os << "call " << mfunction.name () << " (";
 
     for (size_t i = 0; i < argument_count (); ++i)
       {
         print_argument (os, i);
         if (i + 1 < argument_count ())
           os << ", ";
       }
     return os << ")";
   }
 
-  virtual bool dead (void) const;
-
-  virtual bool almost_dead (void) const;
-
   virtual bool infer (void);
 
   JIT_VALUE_ACCEPT (call)
 private:
   const jit_function& mfunction;
 };
 
 // FIXME: This is just ugly...
 // checks error_state, if error_state is false then goto the normal branche,
 // otherwise goto the error branch
 class
 jit_check_error : public jit_terminator
 {
 public:
-  jit_check_error (jit_block *normal, jit_block *error)
-    : jit_terminator (normal, error) {}
+  jit_check_error (jit_call *acheck_for, jit_block *normal, jit_block *error)
+    : jit_terminator (2, normal, error, acheck_for) {}
 
-  jit_block *sucessor (size_t idx) const
+  jit_call *check_for (void) const
   {
-    return static_cast<jit_block *> (argument (idx));
+    return static_cast<jit_call *> (argument (2));
   }
 
-  size_t sucessor_count (void) const { return 2; }
-
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
-    print_indent (os, indent) << "check_error: normal: ";
-    print_sucessor (os, 0) << " error: ";
+    print_indent (os, indent) << "error_check " << *check_for () << ", ";
+    print_sucessor (os, 0) << ", ";
     return print_sucessor (os, 1);
   }
 
   JIT_VALUE_ACCEPT (jit_check_error)
+protected:
+  virtual bool check_alive (size_t idx) const
+  {
+    return idx == 0 ? true : check_for ()->can_error ();
+  }
 };
 
 class
 jit_extract_argument : public jit_assign_base
 {
 public:
   jit_extract_argument (jit_type *atype, jit_variable *adest)
     : jit_assign_base (adest)
@@ -1622,17 +1650,17 @@ public:
     return dest ()->name ();
   }
 
   const jit_function::overload& overload (void) const
   {
     return jit_typeinfo::cast (type (), jit_typeinfo::get_any ());
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent);
 
     return short_print (os) << " = extract " << name ();
   }
 
   JIT_VALUE_ACCEPT (extract_argument)
 };
@@ -1665,17 +1693,17 @@ public:
     return result ()->type ();
   }
 
   llvm::Value *result_llvm (void) const
   {
     return result ()->to_llvm ();
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     jit_value *res = result ();
     print_indent (os, indent) << "store ";
     dest->short_print (os);
 
     if (! isa<jit_variable> (res))
       {
         os << " = ";
@@ -1901,29 +1929,33 @@ private:
   jit_value *visit (tree& tee);
 
   void append_users (jit_value *v)
   {
     for (jit_use *use = v->first_use (); use; use = use->next ())
       worklist.push_back (use->user ());
   }
 
+  void append_users_term (jit_terminator *term);
+
   void track_value (jit_value *value)
   {
     if (value->type ())
       constants.push_back (value);
     all_values.push_back (value);
   }
 
   void merge_blocks (void);
 
   void construct_ssa (void);
 
   static void do_construct_ssa (jit_block& block);
 
+  void remove_dead ();
+
   void place_releases (void);
 
   void print_blocks (const std::string& header)
   {
     std::cout << "-------------------- " << header << " --------------------\n";
     for (std::list<jit_block *>::iterator iter = blocks.begin ();
          iter != blocks.end (); ++iter)
       {
